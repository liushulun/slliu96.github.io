[{"title":"Billboard","url":"/post/billboard/","content":"<center>\n\n<p><a href=\"/categories/Android/\" title=\"@LINK\"><font color=EB6D39>Android 系列</font></a> &emsp;&emsp; <a href=\"/categories/Java/\" title=\"@LINK\"><font color=EB6D39>Java 系列</font></a> &emsp;&emsp; <a href=\"/categories/Algorithm/\" title=\"@LINK\"><font color=EB6D39>算法系列</font></a></p>\n</center>\n"},{"title":"Android-AIDL","url":"/post/android/android-aidl/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-AIDL\"><a href=\"#Android-AIDL\" class=\"headerlink\" title=\"Android-AIDL\"></a>Android-AIDL</h1>","categories":["Android"],"tags":["Android","AIDL"]},{"title":"Android-ANR","url":"/post/android/android-anr/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-ANR\"><a href=\"#Android-ANR\" class=\"headerlink\" title=\"Android-ANR\"></a>Android-ANR</h1><p>ANR（Application Not Responding）出现的原因有：</p>\n<p>（1）输入事件（如触摸和按键等）在 5s 内未响应。</p>\n<p>（2）BroadcastReceiver 在规定时间内（前台广播 10s，后台广播 60s）未执行完 <code>onReceive()</code>，因此在 <code>onReceive()</code> 中不要执行耗时操作。</p>\n<p>（3）Service 在规定时间内（前台服务 20s，后台服务 10s）未完成启动（<code>onCreate()</code>）。</p>\n<p>（4）ContentProvider 在 10s 内未完成启动（<code>onCreate()</code>）。</p>\n<p>发生 ANR 时，Android 会在 <code>/data/anr/</code> 下生成一个 <code>traces.txt</code>，可通过 Adb 命令导出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">adb pull data/anr/traces.txt</span></span><br></pre></td></tr></table></figure>\n\n<p>打开文本，找到对应的进程名，在下面查找发生 ANR 相关的类、方法。</p>\n<p>也有可能是 CPU 满负载、IO 阻塞、内存泄漏等等。</p>\n","categories":["Android"],"tags":["Android","ANR"]},{"title":"Android-应用架构","url":"/post/android/android-architecture/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-应用架构\"><a href=\"#Android-应用架构\" class=\"headerlink\" title=\"Android-应用架构\"></a>Android-应用架构</h1><p>App 架构的核心思想，主要就是为了降低 UI 逻辑和数据业务逻辑之间的耦合度。</p>\n<h3 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h3><p>MVC 即：Model - View - Controller 模式，Model 与 View、View 与 Controller、Controller 与 Model，都是单向直接通信，View 层负责 UI 逻辑，Model 层负责数据，Controller 负责替 View 层操作 Model 层，但由于 Android 中，Activity 通常会同时担任 View 层和 Controller 层，随着业务变得复杂，Activity 也会越来越臃肿，而且 Activity 与 Model 层交互时，相当于 View 层可以与 Model 层直接交互，没有完全解耦。</p>\n<h3 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h3><p>MVP 即：Model - View - Presenter 模式，Presenter 与 View、Presenter 与 Model 之间都是双向通信，而 Model 与 View 之间完全没有直接通信，从而彻底解耦。并且由于将 MVC 模式中的 Controller 完全解放成独立的 Presenter，也避免了 Activity 中逻辑代码过多的情况。</p>\n<ul>\n<li><p>MVP 模式的变种：Passive View</p>\n<p>Passive View 即：被动 View 层，是 MVP 模式最广泛的一个变种，其核心思想就是：View 层所需的数据，不是由其主动拉取 Presenter 获得的，而是被动地由 Presenter 推送的，在 Android 中，也就是 View 层开放自己被动接受数据的接口，Presenter 在转发 View 层请求数据的逻辑给 Model 后，由 Model 通过 Presenter 来主动调用 View 的接口来回传数据。</p>\n</li>\n</ul>\n<h3 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"MVVM模式\"></a>MVVM模式</h3><p>MVVM 即：Model - View - ViewModel 模式，View 仍然对应了 UI 层，Model 仍然是负责主要的数据处理，但一些和 View 层有关的属性及操作则放入了 ViewModel 中实现，其关键在于 DataBinding 技术，View 的变化和 ViewModel 的操作会双向同步，实际上是 Jetpack 框架替开发人员做了一些工作。</p>\n<ul>\n<li><p>DataBinding 原理</p>\n<p>DataBinding 会对布局文件中使用 <code>&lt;layout&gt;</code> 标签包裹的元素预处理，会为每个元素增加一个 <code>tag</code> 属性，然后将各个元素抽取出来生成一个名为 <code>xxxxx-layout.xml</code> 的文件（<code>xxxxx</code> 是原本 xml 布局文件的命名），文件中将原本的所有 View 标签，都转换成了 <code>&lt;Target id=&quot;xxx&quot; tag=&quot;yyy&quot; view=&quot;ZzzView&quot;&gt;</code> 的形式，其中根布局对应的 tag 是 <code>layout</code>，然后根据原布局文件和新生成的文件，生成一个继承自 <code>ViewDataBinding</code> 的类，并将布局文件中的元素，都根据类型和 id 创建成员变量。</p>\n</li>\n</ul>\n","categories":["Android"],"tags":["Android","架构","MVC","MVP","MVVM"]},{"title":"Android-Binder","url":"/post/android/android-binder/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Binder\"><a href=\"#Android-Binder\" class=\"headerlink\" title=\"Android-Binder\"></a>Android-Binder</h1><h2 id=\"1-Linux跨进程通信\"><a href=\"#1-Linux跨进程通信\" class=\"headerlink\" title=\"1. Linux跨进程通信\"></a>1. Linux跨进程通信</h2><h3 id=\"1-1-内核态与用户态\"><a href=\"#1-1-内核态与用户态\" class=\"headerlink\" title=\"1.1 内核态与用户态\"></a>1.1 内核态与用户态</h3><p>为了保障操作系统最基本的运行不受其他应用的影响，Linux 将内存分为内核空间和用户空间：</p>\n<ul>\n<li>内核空间可以调用所有系统资源、执行任何指令，执行内核代码时，CPU 特权等级处于最高的 0，此时 CPU 处于内核态。</li>\n<li>用户空间只支持简单运算，不能直接调用系统资源，执行用户代码时，CPU 特权等级处于最低的 3，此时 CPU 处于用户态。</li>\n</ul>\n<p>用户空间想要调用部分系统资源则必须通过 <code>SysCall</code> 向内核空间发送指令由内核空间完成。<code>SysCall</code> 可以理解为，内核空间向外暴露的接口，<code>SysCall</code> 预先定义了一套允许用户空间发送的指令，并根据这些指令执行具体的系统命令。</p>\n<p>用户空间可以借助 <code>SysCall</code> 向内核空间发送命令，如果多个用户空间之间需要通信，则需要借助内核空间完成交互。传统的 Linux 通信机制，例如 Socket 和管道，都是内核原生支持的，而 Binder 并不是 Linux 内核的一部分，而是通过 Linux 的动态可加载内核模块（Loadable Kernel Module, LKM）链接到 Linux 的内核中。LKM 允许独立编译但不允许独立运行，其运行时会被链接到内核作为内核的一部分运行于内核空间，因此用户空间不同进程之间就可以通过 Binder 通信。</p>\n<blockquote>\n<p>在与 ServiceManager 和 Binder 通信的过程中，Client 和 Service 会发送多条命令，其中 Client 发起的请求命令称为 BC（Binder Client）命令；Service 响应的命令称为 BR（Binder Reply）命令。</p>\n</blockquote>\n<h3 id=\"1-2-Linux中的驱动\"><a href=\"#1-2-Linux中的驱动\" class=\"headerlink\" title=\"1.2 Linux中的驱动\"></a>1.2 Linux中的驱动</h3><p>Linux 把硬件的读写抽象为文件 IO，而驱动就是对这个抽象的封装和实现。Linux 中有三种类型的驱动设备：字符设备、块设备、网络设备。</p>\n<ul>\n<li>字符设备是指能像字节流文件一样被访问的设备，对字符设备 IO 时，硬件也同时进行 IO。例如显示屏、键盘、串口、LCD、LED 等。<ul>\n<li>字符设备中有一个比较特殊的 misc 杂项设备，设备号为 10，可以自动生成设备节点。Binder 就属于 misc 杂项设备。</li>\n</ul>\n</li>\n<li>块设备是指通过传输数据块（一般为 512b 或 1k）来访问的设备，例如硬盘、SD 卡、U 盘、光盘等。</li>\n<li>网络设备是指能和其他主机交换数据的设备，例如网卡、蓝牙等。</li>\n</ul>\n<h3 id=\"1-3-Binder驱动\"><a href=\"#1-3-Binder驱动\" class=\"headerlink\" title=\"1.3 Binder驱动\"></a>1.3 Binder驱动</h3><p>Binder 驱动并没有真正建立硬件 IO，而是借助驱动的方式，通过内存映射 <code>mmap()</code> 实现进程间通信。</p>\n<p>跨进程无法直接通信的原因是，不同进程之间的内存不可见，因此两个进程无法直接操作另一个进程的内存。通常 Client 进程向 Service 进程请求通信时，需要先将 Client 的请求数据拷贝到内核区，然后再从内核区拷贝到 Service，造成两次数据拷贝，效率较低，因此 Binder 采用了内存映射 MemoryMap 的方式，仅用一次拷贝实现进程间通信：</p>\n<ul>\n<li>使用 Binder 进行进程间通信时，Binder 驱动在内核创建一个数据接收缓冲区，然后在内核开辟一块内核缓冲区，并建立两个缓冲区之间的映射关系、以及 Service 用户空间中一块内存地址与数据接收缓冲区的映射关系；相当于此时 Service 的一块用户内存直接映射到了内核中的数据接收缓冲区。</li>\n<li>将 Client 的数据拷贝到内核中的内核缓冲区，由于内核缓冲区与数据接收缓冲区存在映射关系，而数据接收缓冲区又与 Service 的一块用户内存存在映射关系，所以 Service 就能通过映射，直接操作内核缓冲区中来自 Client 拷贝的数据。</li>\n<li>当 Service 处理完毕，对 Client 响应时，就会重复上述过程，只不过这时反过来，请求时的 Client 变为了响应时的 Service，请求时的 Service 变为了响应时的 Client。</li>\n</ul>\n<hr>\n<h2 id=\"2-ServiceManager\"><a href=\"#2-ServiceManager\" class=\"headerlink\" title=\"2. ServiceManager\"></a>2. ServiceManager</h2><p>Android 基于 Linux 的系统，因此 Android 的系统运行也需要遵循 Linux 运行的基本原则。Linux 系统在启动时，第一启动的进程就是 <code>init.c</code>：</p>\n<p><img data-src=\"./linux_android_startup.png\" alt=\"Android 系统启动加载流程\" title=\"@ASSET\"></p>\n<ul>\n<li>启动 <code>init</code> 进程，进入 Linux 系统的第一步。</li>\n<li>启动各类基础服务，包括 Zygote 和 ServiceManager 等。<ul>\n<li>Zygote 启动 SystemService，SystemService 又会分裂出不同的系统服务，包括 ActviityManageService、PackageManageService 等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-ServiceManager启动\"><a href=\"#2-1-ServiceManager启动\" class=\"headerlink\" title=\"2.1 ServiceManager启动\"></a>2.1 ServiceManager启动</h3><p><img data-src=\"./service_manager_startup.jpeg\" alt=\"ServiceManager 启动流程\" title=\"@ASSET\"></p>\n<p>ServiceManager 启动后，在 main 函数中对 Binder 和 Binder 驱动做了初始化：</p>\n<ul>\n<li>调用 <code>binder_open()</code> 打开 Binder 驱动；<ul>\n<li>这一步还会在 Binder 内创建一个全局链表 <code>binder_procs</code>，并且将 ServiceManager 自己存入到第一个 <code>binder_proc</code> 节点，也即序号为 0。</li>\n<li>由于 ServiceManager 也是一个独立进程，所以其他 Service 和 ServiceManager 通信本身又涉及到进程间通信；</li>\n<li>因此 ServiceManager 存放在 <code>binder_procs</code> 的 0 号节点，Binder 自动为其创建一个 Binder 实体，这样任何 Service 都可以通过 0 号引用从 Binder 中获取到 ServiceManager。</li>\n</ul>\n</li>\n<li>调用 <code>binder_become_context_manager()</code> 设为 Binder 进程的守护进程；</li>\n<li>调用 <code>binder_loop</code> 开启 Binder 循环，Binder 循环会不断执行 <code>binder_parse()</code> 轮询 BR_XXX 命令。</li>\n</ul>\n<h3 id=\"2-2-ServiceManager注册和查找服务\"><a href=\"#2-2-ServiceManager注册和查找服务\" class=\"headerlink\" title=\"2.2 ServiceManager注册和查找服务\"></a>2.2 ServiceManager注册和查找服务</h3><p>ServiceManager 有两大主要功能：注册服务和查找服务。</p>\n<p><img data-src=\"./service_manager_work.jpeg\" alt=\"ServiceManager 工作流程\" title=\"@ASSET\"></p>\n<p>（1）Service 启动后通过 ServiceManager 注册服务 <code>do_add_service()</code>：</p>\n<ul>\n<li><p>ServiceManager 向 Binder 发送 BC_TRANSACTION 命令，携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入阻塞等待状态。</p>\n</li>\n<li><p>Binder 驱动收到命令后，向 ServiceManager 的 todo 队列中添加一条事务，事务的内容就是创建服务端进程 binder_node，并插入到 binder_procs 链表中。</p>\n</li>\n<li><p>Binder 处理完后，向 ServiceManager 发送 BR_TRANSACTION 命令，ServiceManager 收到后向已注册服务列表 svclist 中写入对应的信息 ServiceInfo，并发送 BR_REPLY 命令唤醒阻塞等待的线程。</p>\n</li>\n<li><p>每个 Service 启动时会创建一个 Binder 线程池，并向其中注册一个线程。Binder 线程池默认上线为 16 个，当 Client 调用 BinderService 处理事务时，都是通过添加到 Service 的线程池处理的：</p>\n<p><img data-src=\"./binder_process_thread.jpeg\" alt=\"Binder 进程中的线程池\" title=\"@ASSET\"></p>\n</li>\n</ul>\n<p>（2）其他进程通过 ServiceManager 查找服务 <code>do_find_service()</code>：</p>\n<ul>\n<li>ServiceManager 在 Java 层有一个 HashMap 的缓存，缓存了所有被获取过的 Service，如果命中了缓存就会直接返回。</li>\n<li>否则 ServiceManager 向 Binder 发送 BC_TRANSACTION 命令，携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入阻塞等待状态。</li>\n<li>Binder 驱动收到命令后，向 ServiceManager 发送 BC_TRANSACTION 命令，优先从已注册服务列表 svclist 中查找；<ul>\n<li>如果 serviceInfo 中存在则直接响应 BR_REPLY 并唤醒阻塞等待的线程。</li>\n<li>如果不存在，则向 binder_procs 链表中插入一条事务进行通信，事务执行后再返回响应。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/freekiteyu/article/details/70082302\" title=\"@LINK\">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制（作者：jeanboydev）</a></li>\n<li><a href=\"https://blog.csdn.net/AndroidStudyDay/article/details/93749470\" title=\"@LINK\">腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程（作者：动脑学院[David]）</a></li>\n<li><a href=\"https://blog.csdn.net/qq_27672101/article/details/108186072\" title=\"@LINK\">Binder死磕到底（一）：Linux进程通信和service manager进程（作者：诸神黄昏EX）</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/152237289\" title=\"@LINK\">说说你对 binder 驱动的了解？（作者：Sam Wang）</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Binder"]},{"title":"Android-Broadcast","url":"/post/android/android-broadcast/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-BroadcastReceiver\"><a href=\"#Android-BroadcastReceiver\" class=\"headerlink\" title=\"Android-BroadcastReceiver\"></a>Android-BroadcastReceiver</h1><p>BroadcastReceiver 本质上通过设置过滤来有选择地响应某些事件，例如网络状态的变化、锁屏的变化等等，其本身没有用户界面，但可以启动 Activity 或 Service，或使用 Notification 通知用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收广播后的响应</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-Broadcast的分类\"><a href=\"#1-Broadcast的分类\" class=\"headerlink\" title=\"1. Broadcast的分类\"></a>1. Broadcast的分类</h2><h3 id=\"1-1-静态和动态\"><a href=\"#1-1-静态和动态\" class=\"headerlink\" title=\"1.1 静态和动态\"></a>1.1 静态和动态</h3><p>静态和动态仅针对接收器 BroadcastReceiver，由注册方式决定。</p>\n<h4 id=\"1-1-1-静态Receiver\"><a href=\"#1-1-1-静态Receiver\" class=\"headerlink\" title=\"1.1.1 静态Receiver\"></a>1.1.1 静态Receiver</h4><p>在 Manifest 中静态声明注册的 BroadcastReceiver 就称为静态 Receiver。静态 Receiver 会随系统的启动而保持活跃，即使 App 未运行，只要接收到指定广播就会触发响应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-2-动态Receiver\"><a href=\"#1-1-2-动态Receiver\" class=\"headerlink\" title=\"1.1.2 动态Receiver\"></a>1.1.2 动态Receiver</h4><p>通过代码动态注册和销毁的 BroadcastReceiver 就称为动态 Receiver。动态 Receiver 只有在生命周期内才能接收广播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DemoReceiver demoReceiver = <span class=\"keyword\">new</span> DemoReceiver();</span><br><span class=\"line\"><span class=\"comment\">// 动态注册</span></span><br><span class=\"line\">registerReceiver(demoReceiver, <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 销毁广播接收器</span></span><br><span class=\"line\">unregisterReceiver(demoReceiver);</span><br></pre></td></tr></table></figure>\n\n<p><code>registerReceiver()</code> 和 <code>unregisterReceiver()</code> 都是 Context 中的方法，但需要注意的是，Register 和 Unregister 必须由同一个 Context 对象调用，例如：</p>\n<ul>\n<li>AActivity 注册的 Receiver，必须由 AActivity 反注册。</li>\n<li>AActivity 注册的 Receiver，由其他 Activity 或 Application 反注册会抛出异常。</li>\n<li>同理，Application 注册的 Receiver，由其他 Activity 反注册也会抛出异常。</li>\n</ul>\n<p>注册和反注册一定要确保成对调用，如果 Activity 注册 Receiver 后未主动销毁，会导致 Activity 退出后无法回收导致内存泄漏。</p>\n<blockquote>\n<p>动态注册的 Receiver <strong>只能接收「隐式」广播</strong>。</p>\n</blockquote>\n<h3 id=\"1-2-全局和本地\"><a href=\"#1-2-全局和本地\" class=\"headerlink\" title=\"1.2 全局和本地\"></a>1.2 全局和本地</h3><p>全局和本地同时针对 Broadcast 和 BroadcastReceiver，由 Broadcast 发送方式和 Receiver 的注册方式决定。</p>\n<h4 id=\"1-2-1-全局广播\"><a href=\"#1-2-1-全局广播\" class=\"headerlink\" title=\"1.2.1 全局广播\"></a>1.2.1 全局广播</h4><p>全局 Broadcast 可以被任意全局 Receiver 接收，即使 App 并未启动。</p>\n<ul>\n<li>静态注册的 Receiver，如果 <code>exported=true</code> 则为全局 Receiver，否则为本地 Receiver。</li>\n<li>通过 <code>Context#registerReceiver()</code> 注册的是全局 Receiver。</li>\n<li><code>Context#sendBroadcast()</code> 发送的是全局广播。</li>\n</ul>\n<p>全局 Receiver 通常应该设置 <code>permission</code> 属性，可以视为「密钥」，如果 <code>permission</code> 有值，则仅当广播的 <code>permission</code> 属性匹配成功时才会响应。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态 Receiver 设置 Permission：</span></span><br><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:permission=<span class=\"string\">&quot;PERMISSION_STR&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态 Receiver 设置 Permission：</span></span><br><span class=\"line\">context.reisterReceiver(receiver, intentFilter, permission, schedulerHandler);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-本地广播\"><a href=\"#1-2-2-本地广播\" class=\"headerlink\" title=\"1.2.2 本地广播\"></a>1.2.2 本地广播</h4><p>本地 Broadcast 通过 <code>LocalBroadcastManager</code> 发送，只能在应用程序内部传播。本地 Receiver 通过 <code>LocalBroadcastManager</code> 注册和反注册，也只能接收应用内部的 Broadcast。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 Context 获取 LocalBroadcastManager 实例对象</span></span><br><span class=\"line\">LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);</span><br><span class=\"line\"><span class=\"comment\">// 注册本地 Receiver</span></span><br><span class=\"line\">localBroadcastManager.registerReceiver(<span class=\"keyword\">new</span> DemoReceiver(), <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 发送本地 Broadcast</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本地 Broadcast 无法指定 <code>permission</code> 属性，本地注册的 Receiver 也无法过滤 <code>permission</code> 属性。</p>\n</blockquote>\n<h3 id=\"1-3-标准和有序\"><a href=\"#1-3-标准和有序\" class=\"headerlink\" title=\"1.3 标准和有序\"></a>1.3 标准和有序</h3><p>标准广播和有序广播仅针对 Broadcast，由发送方式决定。</p>\n<h4 id=\"1-3-1-标准Broadcast\"><a href=\"#1-3-1-标准Broadcast\" class=\"headerlink\" title=\"1.3.1 标准Broadcast\"></a>1.3.1 标准Broadcast</h4><p>标准 Broadcast 可以被所有类型符合的 Receiver 接收，且不能被拦截和修改。</p>\n<p>（1）发送「全局」标准 Broadcast：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不指定 Permission 的全局 Broadcast：</span></span><br><span class=\"line\">context.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 指定 Permission 的全局 Broadcast：</span></span><br><span class=\"line\">context.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>), <span class=\"string\">&quot;PERMISSION_STR&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（2）发送「本地」标准 Broadcast：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-2-有序Broadcast\"><a href=\"#1-3-2-有序Broadcast\" class=\"headerlink\" title=\"1.3.2 有序Broadcast\"></a>1.3.2 有序Broadcast</h4><p>只有全局 Broadcast 可以有序发送，按照 Receiver 的优先级（范围：-1000 ~ 1000）从高到低逐级传播，Receiver 可以修改广播数据、也可以终止广播事件。</p>\n<blockquote>\n<p>当 Priority 属性相等时，动态 Receiver 比静态 Receiver 优先。</p>\n</blockquote>\n<p>（1）设置静态 Receiver 的优先级：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter</span><br><span class=\"line\">        android:priority=<span class=\"string\">&quot;100&quot;</span>&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n\n<p>（2）设置动态 Receiver 的优先级：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>);</span><br><span class=\"line\">intentFilter.setPriority(<span class=\"number\">100</span>);</span><br><span class=\"line\">context.registerReceiver(<span class=\"keyword\">new</span> DemoReceiver(), intentFilter);</span><br></pre></td></tr></table></figure>\n\n<p>（3）发送「全局」有序 Broadcast（必须指定 <code>permission</code> 属性）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">context.sendOrderedBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>), <span class=\"string\">&quot;PERMISSION_STR&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本地 Broadcast 无法设置有序。</p>\n</blockquote>\n<p>如果 Receiver 需要消费掉有序 Broadcast，阻止其继续向更低优先级的 Receiver 传递，可以通过 <code>BroadcastReceiver#abortBroadcast()</code> 方法中断后续传递：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;DemoReceiver&quot;</span>, <span class=\"string\">&quot;--- onReceive ---&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该方法调用仅在收到的是有序 Broadcast 时有效。</span></span><br><span class=\"line\">    abortBroadcast();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 Receiver 想向后续优先级更低的 Receiver 传递一些信息，可以通过 <code>BroadcastReceiver#setResultExtras(Bundle)</code> 存入，由下一个 Receiver 通过 <code>BroadcastReceiver#getResultExtras(boolean)</code> 取出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HighPriorityReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存入当前高优先级 Receiver 的数据：</span></span><br><span class=\"line\">        setResultExtras(<span class=\"keyword\">new</span> Bundle());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LowPriorityReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取出上一个 Receiver 存入的数据</span></span><br><span class=\"line\">        <span class=\"comment\">// - 入参为 true 表示如果没有数据，会自动构造一个空 Map。</span></span><br><span class=\"line\">        <span class=\"comment\">// - 入参为 false 表示如果没有数据，会返回 null。</span></span><br><span class=\"line\">        Bundle lastData = getResultExtras(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-Broadcast的限制\"><a href=\"#2-Broadcast的限制\" class=\"headerlink\" title=\"2. Broadcast的限制\"></a>2. Broadcast的限制</h2><h3 id=\"2-1-耗时任务\"><a href=\"#2-1-耗时任务\" class=\"headerlink\" title=\"2.1 耗时任务\"></a>2.1 耗时任务</h3><p>BroadcastReceiver 的 <code>onReceive()</code> 默认运行在主进程的主线程，因此前台卡顿超过 10 秒、后台卡顿超过 60 秒就会抛出 ANR。但也不应该在 <code>onReceive()</code> 中开启子线程，因为 BroadcastReceiver 可能在 App 未启动的时候触发并启动进程，如果开启子线程，<code>onReceive()</code> 方法立即返回，则主线程及主进程可能会被退出，导致其子线程被中断，这种情况是不可预料的，因此不应该在 BroadcastReceiver 中通过子线程的方式处理耗时任务。</p>\n<p>BroadcastReceiver 通常作为一个通知者，在接收到特定的消息后，如果需要执行的耗时任务与 UI 有关，可以通过启动 Activity 的方式由 Activity 处理，如果与 UI 无关则可以通过启动 Service 的方式由 Service 处理，此时 App 进程被正常启动，Activity 或 Service 都将按照各自的生命周期执行，因此任务的处理是可预料的。</p>\n<h3 id=\"2-2-显式和隐式广播\"><a href=\"#2-2-显式和隐式广播\" class=\"headerlink\" title=\"2.2 显式和隐式广播\"></a>2.2 显式和隐式广播</h3><p>全局 BroadcastReceiver 在收到符合条件的 Broadcast 后，如果原本 App 未启动则会先启动 Application，但不会启动 Activity，此时 App 在最近任务不可见，且用户不可感知。所以高 API 对隐式广播做了限制，禁止通过隐式 Broadcast 唤起静态 Receiver，避免 App 偷偷互相拉起的情况。</p>\n<ul>\n<li>隐式广播：广播 Intent 仅指定 ActionName 属性。</li>\n<li>显式广播：广播 Intent 需要指定 <code>ComponentName</code> 属性，包含 Receiver 所在 App 的包名、以及 Receiver 的全路径。</li>\n</ul>\n<p>（1）App 内部发送的本地隐式 Broadcast 可以被其 App 内的任意 Receiver 接收。</p>\n<p>因为本地广播仅在当前 App 内传播，所以任意 Receiver 都可以接收来自其同一个 App 内部发送的「本地」隐式广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过隐式 Intent 发送本地 Broadcast，该 App 内所有对应 ActionName 的 Receiver 都可以收到：</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>（2）动态注册的 Receiver 只能接收隐式 Broadcast。</p>\n<p>在 Manifest 中注册的四大组件，App 安装时系统就能明确获取到对应的信息，因此通常跨 App 调用组件时，都需要采用显式调用的方式，系统会根据显示调用的信息搜索已经静态注册的组件。但四大组件中只有 BroadcastReceiver 可以动态注册，而动态注册的 Receiver 是不会被记录在 Manifest 中的，如果向其发送显式广播，系统将无法从已注册的组件信息中搜索到对应的 Receiver，因此动态 Receiver 只能接收隐式 Broadcast。</p>\n<p>（3）外部 App 发送的隐式 Broadcast 可以被动态 Receiver 接收。</p>\n<p>因为 Google 在高 API 版本对隐式 Broadcast 唤起的限制主要时避免 App 偷偷互相拉起，因此对于已经启动的 App，其 Receiver 被唤起并不会影响用户体验。而动态 Receiver 一定是在 App 运行时注册的，因此动态 Receiver 可以接收来自其他 App 发送的隐式广播。</p>\n<p>（4）外部 App 发送的隐式 Broadcast 无法被静态 Receiver 接收。</p>\n<p>由于静态 Receiver 在 App 未启动时也响应对符合条件的 Broadcast，并且会静默启动 Application，因此静态 Receiver 被禁止接收来自外部 App 发送的全局隐式 Broadcast。向其他 App 的 Receiver 发送全局 Broadcast 时，Receiver 必须指定 <code>exported=&quot;true&quot;</code>，且发送方必须采用显式 Intent 的方式，指定 Receiver 所在 App 的包名和 Receiver 全路径：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;DemoReceiver&quot;</span>, <span class=\"string\">&quot;--- onReceive ---&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接收方 App 必须设置 exported=true，permission 可选。</span></span><br><span class=\"line\">&lt;manifest <span class=\"keyword\">package</span>=<span class=\"string\">&quot;priv.luis&quot;</span>&gt;</span><br><span class=\"line\">    &lt;receiver</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">        android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方必须指定 Receiver 所在 App 的包名以及 Receiver 的全路径：</span></span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>);</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;priv.luis&quot;</span>, <span class=\"string\">&quot;priv.luis.DemoReceiver&quot;</span>));</span><br><span class=\"line\">content.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>查看日志即可发现，如果 Receiver 所在 App 原本未启动，则发送广播后会先启动 Application，然后触发 <code>onReceive()</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">D/OemNetd: setPidForPackage: packageName=priv.luis, pid=25234, pid=10408</span><br><span class=\"line\">I/ActivityManager: Start proc 25234:priv.luis/u0a408 <span class=\"keyword\">for</span> broadcast &#123;priv.luis/priv.luis.DemoReceiver&#125; <span class=\"built_in\">caller</span>=priv.luis.demosender</span><br><span class=\"line\">D/DemoReceiver: --- onReceive ---</span><br></pre></td></tr></table></figure>\n","categories":["Android"],"tags":["Android","四大组件","Broadcast","Receiver"]},{"title":"Android-ContentProvider","url":"/post/android/android-contentprovider/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-ContentProvider\"><a href=\"#Android-ContentProvider\" class=\"headerlink\" title=\"Android-ContentProvider\"></a>Android-ContentProvider</h1><p>ContentProvider 使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过 ContentResolver 类从该内容提供者中获取或存入数据。</p>\n<p>只有需要在多个应用程序间共享数据是才需要内容提供者，且必须存储在一个内容提供者中。好处是可以统一数据访问方式。例如通讯录数据被多个应用程序使用。</p>\n<p>ContentProvider 使用 URI（Universal Resource Identifier，统一资源定位符）来唯一标识其数据集，URI 以 <code>content://</code> 作为前缀。通常不会直接使用 ContentProvider 类的对象，大多数是通过 ContentResolver 对象实现对 ContentProvider 的操作。</p>\n<p>一个 ContentProvider 应该包括或重写如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;luis.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 匹配成功后返回的匹配码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MATCH_CODE = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于判断数据请求的 URI 是否匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UriMatcher uriMatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该 APP 用于共享的数据集</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoData demoData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据改变后通知该 URI</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri NOTIFY_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若匹配不成功则返回 NO_MATCH == -1</span></span><br><span class=\"line\">        uriMatcher = <span class=\"keyword\">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//添加预留需要匹配的 URI</span></span><br><span class=\"line\">        uriMatcher.addURI(AUTHORITY, <span class=\"string\">&quot;data&quot;</span>, MATCH_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        demoData = DemoData.getInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cursor <span class=\"title\">query</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String[] projection,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"meta\">@Nullable</span> String sortOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行数据的增删改查前先验证请求的 URI 和预留的 URI 是否匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            Cursor cursor = demoData.queryData();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getType</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">insert</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            demoData.insertData(values);</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> deleteCount = demoData.deleteData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> deleteCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> updateCount = demoData.updateData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> updateCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyChange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        getContext().getContentResolver().notifyChange(NOTIFY_URI, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他应用中使用 ContentResolver 获取数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ContentResolver contentResolver = getContentObserver();</span><br></pre></td></tr></table></figure>\n\n<p>非必须的可选功能：如果需要对 URI 指向的数据监听变化，则需要重写并注册 ContentObserver，并传入一个 Handler 以在数据发生变化时通过 Handler 通知主线程更新 UI：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler Handler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyContentObserver</span><span class=\"params\">(Handler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(handler);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange, uri);</span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.obj = uri;</span><br><span class=\"line\">        Handler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在需要接收数据的 ContentResolver 中注册该 ContentObserver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;luis.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri DATA_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\">contentResolver.registerContentObserver(DATA_URI, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DemoContentObserver(handler));</span><br></pre></td></tr></table></figure>\n\n<p>当需要对某个 ContentProvider 提供的数据增删改查时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">Cursor cursor = contentResolver.query(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; cursor.getCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cursor.moveToNext()) &#123;</span><br><span class=\"line\">        dataValue1 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column1&quot;</span>));</span><br><span class=\"line\">        dataValue2 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column2&quot;</span>));</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\">ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn1&quot;</span>, dataValue1);</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn2&quot;</span>, dataValue2);</span><br><span class=\"line\">......</span><br><span class=\"line\">contentResolver.insert(DATA_URI, contentValues);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\">contentResolver.delete(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，对一个 App 共享的数据集，通常是通过 ContentResolver 处理的，而 ContentProvider 更像是提供了一个可以处理数据的接口，其定义了入口 URI，调用增删改查时的具体逻辑，并返回数据处理的结果。</p>\n","categories":["Android"],"tags":["Android","四大组件","ContentProvider"]},{"title":"Android-设计模式","url":"/post/android/android-design_pattern/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-设计模式\"><a href=\"#Android-设计模式\" class=\"headerlink\" title=\"Android-设计模式\"></a>Android-设计模式</h1><h2 id=\"1-单例模式\"><a href=\"#1-单例模式\" class=\"headerlink\" title=\"1. 单例模式\"></a>1. 单例模式</h2><h3 id=\"1-1-饿汉式\"><a href=\"#1-1-饿汉式\" class=\"headerlink\" title=\"1.1 饿汉式\"></a>1.1 饿汉式</h3><p>饿汉式写法简单，线程安全，但没有懒加载的效果，如果没有使用过会浪费内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> singleton; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-懒汉式\"><a href=\"#1-2-懒汉式\" class=\"headerlink\" title=\"1.2 懒汉式\"></a>1.2 懒汉式</h3><p>懒汉式：懒加载，节约内存，但线程不安全</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> stati Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-线程安全的懒汉式\"><a href=\"#1-3-线程安全的懒汉式\" class=\"headerlink\" title=\"1.3 线程安全的懒汉式\"></a>1.3 线程安全的懒汉式</h3><p>线程安全的懒汉式：懒加载同时线程安全，但使用锁会造成不必要的同步开销，大部分情况下用不到同步</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> stati Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-双锁检测DCL\"><a href=\"#1-4-双锁检测DCL\" class=\"headerlink\" title=\"1.4 双锁检测DCL\"></a>1.4 双锁检测DCL</h3><p>双锁检测：懒加载，线程安全，效率高，但 volatile 影响一点性能，高并发下有一定的缺陷。volatile 关键字可以禁止代码重排序，所有的写（write）操作都将发生在读（read）操作之前，保证singleton是一定被初始化了的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == singleton) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == singleton) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-静态内部类\"><a href=\"#1-5-静态内部类\" class=\"headerlink\" title=\"1.5 静态内部类\"></a>1.5 静态内部类</h3><p>静态内部类：懒加载，线程安全，推荐使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//第一次调用getInstance方法时才加载SingletonHolder并初始化sInstance</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//静态内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton sInstance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2. 工厂模式\"></a>2. 工厂模式</h2><h3 id=\"2-1-简单工厂模式\"><a href=\"#2-1-简单工厂模式\" class=\"headerlink\" title=\"2.1 简单工厂模式\"></a>2.1 简单工厂模式</h3><p>（1）定义抽象产品类及公共接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）定义具体产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建工厂类，创建具体的产品</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Product <span class=\"title\">create</span><span class=\"params\">(String productName)</span> </span>&#123;</span><br><span class=\"line\">        Product product = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (productName) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;A&quot;</span>:</span><br><span class=\"line\">                product = <span class=\"keyword\">new</span> ProductA();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;B&quot;</span>:</span><br><span class=\"line\">                product = <span class=\"keyword\">new</span> ProductB();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-抽象工厂模式\"><a href=\"#2-2-抽象工厂模式\" class=\"headerlink\" title=\"2.2 抽象工厂模式\"></a>2.2 抽象工厂模式</h3><p>抽象工厂最复杂，假如有 <code>N</code> 种产品，<code>M</code> 个工厂实体，则一共会有 <code>N * M</code> 种产品实体。</p>\n<p>（1）创建抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CPU</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showCPU</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showMemory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showHD</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntelCPU</span> <span class=\"keyword\">extends</span> <span class=\"title\">CPU</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showCPU</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Intet CPU&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SamsungMemory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Memory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showMemory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;三星 内存&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WdHD</span> <span class=\"keyword\">extends</span> <span class=\"title\">HD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showHD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;西部数据 硬盘&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComputerFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> CPU <span class=\"title\">createCPU</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Memory <span class=\"title\">createMemory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> HD <span class=\"title\">createHD</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建工厂实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DellComputerFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComputerFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CPU <span class=\"title\">createCPU</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IntelCPU();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Memory <span class=\"title\">createMemory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SamsungMemory();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HD <span class=\"title\">createHD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WdHD();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-工厂方法模式\"><a href=\"#2-3-工厂方法模式\" class=\"headerlink\" title=\"2.3 工厂方法模式\"></a>2.3 工厂方法模式</h3><p>工厂方法模式可以看成是抽象工厂模式的一个特例，当抽象工厂中，只有一种产品时，就和工厂方法一样了。</p>\n<p>（1）创建抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Product <span class=\"title\">create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建工厂实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductA();<span class=\"comment\">//创建ProductA</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductB();<span class=\"comment\">//创建ProductB</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-建造者模式\"><a href=\"#3-建造者模式\" class=\"headerlink\" title=\"3. 建造者模式\"></a>3. 建造者模式</h2><p>（1）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCPU;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mMemory;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mHD;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCPU</span><span class=\"params\">(String CPU)</span> </span>&#123;</span><br><span class=\"line\">        mCPU = CPU;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(String memory)</span> </span>&#123;</span><br><span class=\"line\">        mMemory = memory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHD</span><span class=\"params\">(String HD)</span> </span>&#123;</span><br><span class=\"line\">        mHD = HD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建建造者抽象类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildCPU</span><span class=\"params\">(String cpu)</span></span>;<span class=\"comment\">//组装CPU</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMemory</span><span class=\"params\">(String memory)</span></span>;<span class=\"comment\">//组装内存</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildHD</span><span class=\"params\">(String hd)</span></span>;<span class=\"comment\">//组装硬盘</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Computer <span class=\"title\">create</span><span class=\"params\">()</span></span>;<span class=\"comment\">//返回组装好的电脑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建建造者实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建产品实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Computer mComputer = <span class=\"keyword\">new</span> Computer();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildCPU</span><span class=\"params\">(String cpu)</span> </span>&#123;<span class=\"comment\">//组装CPU</span></span><br><span class=\"line\">        mComputer.setCPU(cpu);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMemory</span><span class=\"params\">(String memory)</span> </span>&#123;<span class=\"comment\">//组装内存</span></span><br><span class=\"line\">        mComputer.setMemory(memory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildHD</span><span class=\"params\">(String hd)</span> </span>&#123;<span class=\"comment\">//组装硬盘</span></span><br><span class=\"line\">        mComputer.setHD(hd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Computer <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//返回组装好的电脑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mComputer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建指挥者实体类，用于控制建造者进行建造任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Director</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Builder mBuild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Director</span><span class=\"params\">(Builder build)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mBuild = build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//指挥装机人员组装电脑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Construct</span><span class=\"params\">(String cpu, String memory, String hd)</span> </span>&#123;</span><br><span class=\"line\">        mBuild.buildCPU(cpu);</span><br><span class=\"line\">        mBuild.buildMemory(memory);</span><br><span class=\"line\">        mBuild.buildHD(hd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-观察者模式\"><a href=\"#4-观察者模式\" class=\"headerlink\" title=\"4. 观察者模式\"></a>4. 观察者模式</h2><p><code>java.util.Observable</code>：抽象被观察者。</p>\n<ul>\n<li>需要继承并根据不同功能重写 <code>Observable</code>，表示被观察者。使用单例模式，由静态内部类管理一个实例，将构造方法私有化。</li>\n<li><code>Observable</code> 的实例（单例）对象也就是被观察者，在内部根据需要添加方法，方法内部调用 <code>setChanged()</code> 和 <code>notifyObservers(Object data)</code>。</li>\n<li>而被观察者需要通过调用 <code>Observable#addObserver(Object observer)</code> 来添加观察者。</li>\n<li><code>notifyObservers(Object data)</code> 方法内部会遍历所有添加给被观察者的观察者，并调用观察者的 <code>update(Observable observable, Object arg)</code> 方法，也即表示带着数据 <code>data</code> 通知所有观察者。</li>\n<li>因此充当观察者的类（添加给被观察者的类）需要实现 <code>Observe</code> 接口，重写 <code>update(Observable o, Object arg)</code> 方法，用 <code>instanceof</code> 判断参数 <code>observable</code> 到底是哪一个被观察者，然后用数据 <code>arg</code> 做相应的操作。</li>\n</ul>\n<p>（1）一个被观察者可以被多个观察者观察，也即给被观察者 <code>add</code> 多个观察者，并添加业务方法，当业务执行的时候，业务方法内部会通知所有被添加的观察者，所有被添加的观察者都会收到通知，但一个被观察者可以有多个业务，并不是每个观察者都需要用到每个业务，因此可以在不同业务的方法内的 <code>notifyObservers(Object data)</code> 中，传不同类型的数据 <code>data</code>，在观察者的 <code>update(Observable observable, Object arg)</code> 方法内，需要用 <code>instanceof</code> 判断数据 <code>arg</code> 的类型，来判断自己是否需要处理。</p>\n<p>（2）一个观察者可以观察多个被观察者，也就是多个被观察者调用 <code>Observable.addObserver()</code> 的时候，可以添加同一个观察者，因此当观察者的 <code>update(Observable observable, Object arg)</code> 方法被调用时，还要先用 <code>instanceof</code> 来判断参数 <code>observable</code> 到底是来自哪个被观察者，然后再用 <code>instanceof</code> 判断数据 <code>arg</code> 是由被观察者中哪个业务方法调用传递过来的，这样才能唯一确定一个业务逻辑。</p>\n<p>（3）接口回调与观察者模式的选择：回调是一对一的关系，只监听一个事件；观察者模式则是可以一对多也可以多对一，因此观察者模式的数据流图是网状结构，如果业务逻辑比较简单的时候，用回调反而能提升代码可读性以及降低开发复杂度。</p>\n<hr>\n<h2 id=\"5-中介者模式\"><a href=\"#5-中介者模式\" class=\"headerlink\" title=\"5. 中介者模式\"></a>5. 中介者模式</h2><p>当程序存在大量的类时，多个对象之间存在着依赖的关系，呈现出网状结构，那么程序的可读性和可维护性就变差了，并且修改一个类需要牵涉到其他类，不符合开闭原则。</p>\n<p>当多个类之间有复杂交互时，通过创建一个中介者类，用于处理其他类之间的交互问题，提高耦合但也提高了代码逻辑清晰度和可读性，在类和类交互时，也不需要针对不同的类定制专用的接口，只需要通过中介者提供的公用接口调用即可。</p>\n","categories":["Android"],"tags":["Android","设计模式"]},{"title":"Android-多线程","url":"/post/android/android-itc/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-多线程\"><a href=\"#Android-多线程\" class=\"headerlink\" title=\"Android-多线程\"></a>Android-多线程</h1><h2 id=\"1-线程池\"><a href=\"#1-线程池\" class=\"headerlink\" title=\"1. 线程池\"></a>1. 线程池</h2><p>线程池底层是通过HashSet维护的，可以确保不会出现一个线程的多个实例，并且集合无序，可以保持高效率。多余的任务用一个阻塞队列来管理，阻塞队列满了才会激活非核心线程。</p>\n<h3 id=\"1-1-线程池关键参数\"><a href=\"#1-1-线程池关键参数\" class=\"headerlink\" title=\"1.1 线程池关键参数\"></a>1.1 线程池关键参数</h3><ul>\n<li><p><code>corePoolSize</code> 线程池核心线程大小</p>\n<p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut</code>。这里的最小线程数量即是 <code>corePoolSize</code>。</p>\n</li>\n<li><p><code>maximumPoolSize</code> 线程池最大线程数量</p>\n<p>一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了则会创建一个新线程，然后从工作队列中的取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由 <code>maximunPoolSize</code> 来指定。</p>\n</li>\n<li><p><code>keepAliveTime</code> 空闲线程存活时间</p>\n<p>一个线程如果处于空闲状态，并且当前的线程数量大于 <code>corePoolSize</code> ，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由 <code>keepAliveTime</code> 来设定。</p>\n</li>\n<li><p><code>unit</code> 空间线程存活时间单位</p>\n<p><code>keepAliveTime</code> 的计量单位。</p>\n</li>\n<li><p><code>workQueue</code> 工作队列</p>\n<p>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。JDK 中提供了四种工作队列：</p>\n<ol>\n<li><p><code>ArrayBlockingQueue</code></p>\n<p> 基于数组的有界阻塞队列，按 FIFO 排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到 <code>corePoolSize</code> 后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到 <code>maxPoolSize</code>，则会执行拒绝策略。</p>\n</li>\n<li><p><code>LinkedBlockingQuene</code></p>\n<p> 基于链表的无界阻塞队列（其实最大容量为 <code>Interger.MAX</code>），按照 FIFO 排序。由于该队列的近似无界性，当线程池中线程数量达到 <code>corePoolSize</code> 后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到 <code>maxPoolSize</code> ，因此使用该工作队列时，参数 <code>maxPoolSize</code> 其实是不起作用的。</p>\n</li>\n<li><p><code>SynchronousQuene</code></p>\n<p> 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到 <code>maxPoolSize</code>，则执行拒绝策略。</p>\n</li>\n<li><p><code>PriorityBlockingQueue</code></p>\n<p> 具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n</li>\n</ol>\n</li>\n<li><p><code>threadFactory</code> 线程工厂</p>\n<p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为 <code>Daemon 线程</code> 等等</p>\n</li>\n<li><p><code>handler 拒绝策略</code></p>\n<p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，JDK 中提供了 4 种拒绝策略：</p>\n<ol>\n<li><p><code>CallerRunsPolicy</code></p>\n<p> 该策略下，在调用者线程中直接执行被拒绝任务的 <code>run()</code> 方法，除非线程池已经 Shutdown，则直接抛弃任务。</p>\n</li>\n<li><p><code>AbortPolicy</code></p>\n<p> 该策略下，直接丢弃任务，并抛出 <code>RejectedExecutionException</code> 异常。</p>\n</li>\n<li><p><code>DiscardPolicy</code></p>\n<p> 该策略下，直接丢弃任务，什么都不做。</p>\n</li>\n<li><p><code>DiscardOldestPolicy</code></p>\n<p> 该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列。</p>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-线程间通信ITC\"><a href=\"#2-线程间通信ITC\" class=\"headerlink\" title=\"2. 线程间通信ITC\"></a>2. 线程间通信ITC</h2><blockquote>\n<p>ITC, Inter Thread Communication</p>\n</blockquote>\n<p>（1）<code>runOnUiThread()</code></p>\n<p>直接将指定代码运行在主线程。</p>\n<p>（2）<code>View.post()</code></p>\n<p>（3）<code>AsyncTask</code></p>\n<p>在主线程中调用开启后台任务，然后通过继承自 <code>AsyncTask</code> 的类并重写 <code>doInBackground(Object[] objs)</code> 和 <code>onPostExecute(Object obj)</code> 分别指定后台任务以及任务执行完毕后的步骤。</p>\n<ul>\n<li><code>AsyncTask</code> 至少两个线程，最多有 <code>2 * CPU + 1</code>，核心线程数最少 2 个、最大 4 个，空闲线程存活时间 30 秒。</li>\n<li><code>AsyncTask</code> 内部维护了一个线程池和一个 <code>Handler</code>，所以有可能发生内存泄漏。</li>\n</ul>\n<p>（4）Handler</p>\n","categories":["Android"],"tags":["Android"]},{"title":"AndroidStudio打包JAR","url":"/post/android/android-jar/","content":"<span id=\"more\"></span>\n\n<h1 id=\"AndroidStudio打包JAR\"><a href=\"#AndroidStudio打包JAR\" class=\"headerlink\" title=\"AndroidStudio打包JAR\"></a>AndroidStudio打包JAR</h1><p>前言：做 Android 项目应该经常会用到一些符合自己习惯的工具类，但如果每次都重新写一遍或者复制粘贴既麻烦也不便于保存，所以通常会把一些特别常用的工具类（Log，自定义 View、自定义框架等）打包成 jar 或 aar（aar 除了必须的 class 代码，还会包含所有 res 下的资源文件，jar 仅包含 class 和 Manifests），打包成 aar 比较简单，所以本文仅记载如何打包成 jar 文件。</p>\n<hr>\n<h2 id=\"1-新建需要打包的项目\"><a href=\"#1-新建需要打包的项目\" class=\"headerlink\" title=\"1. 新建需要打包的项目\"></a>1. 新建需要打包的项目</h2><p>为了避免奇奇怪怪的因素影响正式项目，把需要打包的东西新建一个项目。我的工具类以 AndroidLogger 为例：</p>\n<p><img data-src=\"./new_project.png\" alt=\"新建项目\" title=\"@ASSET\"></p>\n<p>下一步，选择哪个平台都无所谓，但是在选择最低SDK版本这里，作为工具类，除非是高版本才有的特性（比如 ConstraintLayout），一般在应该设置的低一点以提高平时开发的通用性。本来我设置的是 <code>minimumSDK = 8</code> 结果出来个提示，大致意思是选择的版本太低了，然后一点点调高到 14 的时候消失，Api 14 对应的是 Android 4.0，对于市面上几乎全部的安卓手机而言应该都不止 4.0 了，索性就用 14 作为最低版本吧！</p>\n<p>再下一步，因为本例中所做的工具类是单纯的辅助 Debug，完全没有用到视图功能，所以我选择了 No Activity ，如果有用到的话还是按需要勾选对应的模板即可。</p>\n<p><img data-src=\"./select_template.png\" alt=\"选择模板\" title=\"@ASSET\"></p>\n<p>直接 Finish，创建了一个什么都没有的项目。然后在常规的项目目录下新建一个类写工具类的代码，这里以 <code>Logger</code> 为例：</p>\n<p><img data-src=\"./project_structure.png\" alt=\"项目结构\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"2-构建Library\"><a href=\"#2-构建Library\" class=\"headerlink\" title=\"2. 构建Library\"></a>2. 构建Library</h2><p>此时这个项目虽然除了这个类以外什么都没有，但是其本质还是一个 Android 项目，打包成 jar 之前需要先把项目改成 Library，然后再进行打包。这里需要改动 <code>build.gradle (Module: app)</code> 的两个地方：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首行把application改为library</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注释或删除defaultConfig中的applicationId字段</span></span><br><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">    <span class=\"comment\">// applicationId &quot;XXXXX&quot;</span></span><br><span class=\"line\">    minSdkVersion <span class=\"number\">14</span></span><br><span class=\"line\">    targetSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    versionCode <span class=\"number\">1</span></span><br><span class=\"line\">    versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\">    testInstrumentationRunner <span class=\"string\">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改完之后如下：</p>\n<p><img data-src=\"./edit_gradle.png\" alt=\"修改 Gradle\" title=\"@ASSET\"></p>\n<p>点击 <code>Sync Now</code> 同步 Gradle。完成之后再看一下项目文件夹的图标，已经变成了 Library！</p>\n<p><img data-src=\"./library_icon.png\" alt=\"Library 项目图标\" title=\"@ASSET\"></p>\n<p>然后把项目切换成 <code>Project</code> 视图模式：</p>\n<p><img data-src=\"./switch_view.png\" alt=\"切换项目视图\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"3-创建执行任务\"><a href=\"#3-创建执行任务\" class=\"headerlink\" title=\"3. 创建执行任务\"></a>3. 创建执行任务</h2><p>接下来需要再在 <code>build.gradle (Module: app)</code> 里面加上一段代码，加的位置在 <code>android&#123;&#125;</code> 里面，与 <code>defaultConfig&#123;&#125;</code> 和 <code>buildTypes&#123;&#125;</code> 同级的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">task <span class=\"title\">makeJar</span><span class=\"params\">(type: Copy)</span> </span>&#123;</span><br><span class=\"line\">    delete <span class=\"string\">&#x27;build/libs/logger.jar&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要打包的class文件的目录</span></span><br><span class=\"line\">    from(<span class=\"string\">&#x27;build/intermediates/intermediate-jars/debug/&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 打包完后输出jar文件的目录</span></span><br><span class=\"line\">    into(<span class=\"string\">&#x27;build/&#x27;</span>)</span><br><span class=\"line\">    include(<span class=\"string\">&#x27;classes.jar&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 后面的logger.jar自行命名</span></span><br><span class=\"line\">    rename (<span class=\"string\">&#x27;classes.jar&#x27;</span>, <span class=\"string\">&#x27;logger.jar&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img data-src=\"./gradle_add_script.png\" alt=\"Gradle 增加打包脚本\" title=\"@ASSET\"></p>\n<p>解释一下，基本上英文单词都已经表示了啥意思了，主要是说一下 <code>from</code> 里面的东西，老版本的打包脚本这个目录应该是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是老版本的目录</span></span><br><span class=\"line\">from(<span class=\"string\">&#x27;build/intermediates/bundle/debug/&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但是升级了之后 <code>intermediates</code> 文件夹下没有 <code>Bundle</code> 文件夹了，但是意外的发现执行完后会有 <code>intermediate-jars</code> 文件夹，一看名字就知道里面放的是 jar 包，点进去后发现确实如此，所以就改成了这个文件夹。这时大家可能会发现连 <code>intermediate-jars</code> 文件夹也没有啊！放心不是我在耍你们，到这一步为止还没有这个目录，需要等我们执行完Task之后才有。</p>\n<p>另外，<code>into</code> 目录也是可以自定的，你想输出到哪就写哪，但是最好选择一个已存在的目录，印象中以前在 <code>app\\build\\</code> 下有一个 <code>libs</code> 文件夹，现在发现没了不知道是不是自己记错了，所以干脆输出到 <code>build</code> 文件夹的根目录下了。<code>into</code> 这一步的路径和第一步 <code>delete</code> 的路径配合使用，只是为了防止目标文件夹里已经有了 jar 包导致写入失败而已。<code>rename</code> 就更简单了，只是需要注意 <code>classes.jar</code>这个不要改动。</p>\n<p>再点击 <code>Sync Now</code> 同步一下，等待同步完后 <code>Rebuild Project</code> 一下，然后打开 AndroidStudio 下面的一排工具栏处找到 <code>Terminal</code> 工具：</p>\n<p><img data-src=\"./open_inner_terminal.png\" alt=\"打开 AS 自带 Terminal\" title=\"@ASSET\"></p>\n<p>执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第 1 个命令</span></span><br><span class=\"line\">gradlew makeJar</span><br></pre></td></tr></table></figure>\n\n<p>注意这里是 <code>gradlew</code> 不是 <code>gradle</code> ，后面的 <code>makeJar</code> 与 <code>build.gradle (Module: app)</code> 中加的那段代码的。</p>\n<p>等待执行完后，再执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第 2 个命令</span></span><br><span class=\"line\">task makeJar</span><br></pre></td></tr></table></figure>\n\n<p>名称相同（可以自定义），然后回车运行，等他读条执行完毕，如果显示绿色的 <font color=#00ff00>BUILD SUCCESSFUL</font> 就说明成功了。</p>\n<p><img data-src=\"./terminal_successful.png\" alt=\"命令执行成功\" title=\"@ASSET\"></p>\n<p>再看一下 <code>build</code> 目录下，出现了 <code>Logger.jar</code>（没有的先折叠 <code>build</code> 目录再重新展开看看），成功打包！</p>\n<p><img data-src=\"./create_jar_successful.png\" alt=\"成功打包 jar\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"4-打包成功\"><a href=\"#4-打包成功\" class=\"headerlink\" title=\"4. 打包成功\"></a>4. 打包成功</h2><p>复制到硬盘上就能拿来用了，实测可以导入到其他工程中使用。说个题外话，如果好奇心比较重去看了一眼现在的 <code>intermediates</code> 目录下的文件，会发现依然没有 <code>intermediate-jars</code> 文件夹，也没有 <code>bundle</code> 文件夹，但是没所谓啦！反正已经获取到 jar 包了，如果强迫症非要看一眼 <code>intermediate-jars</code> 文件夹的话也不是没有办法，只需要在 <code>Terminal</code> 命令行中重新执行一次 <code>gradlew makeJar</code> 并成功构建后即可！完成以后再看 <code>build\\intermediates\\</code> 目录下就有啦！</p>\n<p><img data-src=\"./intermediate_jars_folder.png\" alt=\"intermediate-jars 目录\" title=\"@ASSET\"></p>\n<p>有这个强迫症的 <del>（比如我）</del>，得改！如果在第一次执行完之后没有输出 jar 的，也可以尝试再次执行。</p>\n","categories":["Android"],"tags":["Android","Jar","打包"]},{"title":"Android-Looper","url":"/post/android/android-looper/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Looper\"><a href=\"#Android-Looper\" class=\"headerlink\" title=\"Android-Looper\"></a>Android-Looper</h1><p>前言：本文是针对 Looper 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h2 id=\"1-Looper简介\"><a href=\"#1-Looper简介\" class=\"headerlink\" title=\"1. Looper简介\"></a>1. Looper简介</h2><p>首先看一下源码中对 Looper 的注释说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Class used to run a message loop for a thread.  Threads by default do</span></span><br><span class=\"line\"><span class=\"comment\">  * not have a message loop associated with them; to create one, call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #prepare&#125; in the thread that is to run the loop, and then</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop&#125; to have it process messages until the loop is stopped.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;Most interaction with a message loop is through the</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Handler&#125; class.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,</span></span><br><span class=\"line\"><span class=\"comment\">  * using the separation of &#123;<span class=\"doctag\">@link</span> #prepare&#125; and &#123;<span class=\"doctag\">@link</span> #loop&#125; to create an</span></span><br><span class=\"line\"><span class=\"comment\">  * initial Handler to communicate with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  *  class LooperThread extends Thread &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *      public Handler mHandler;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *      public void run() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.prepare();</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          mHandler = new Handler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *              public void handleMessage(Message msg) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *                  // process incoming messages here</span></span><br><span class=\"line\"><span class=\"comment\">  *              &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *          &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.loop();</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *  &#125;&lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Looper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * API Implementation Note:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * This class contains the code required to set up and manage an event loop</span></span><br><span class=\"line\"><span class=\"comment\">     * based on MessageQueue.  APIs that affect the state of the queue should be</span></span><br><span class=\"line\"><span class=\"comment\">     * defined on MessageQueue or Handler rather than on Looper itself.  For example,</span></span><br><span class=\"line\"><span class=\"comment\">     * idle handlers and sync barriers are defined on the queue whereas preparing the</span></span><br><span class=\"line\"><span class=\"comment\">     * thread, looping, and quitting are defined on the looper.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致翻译：</p>\n<p>（1）Looper 被 Thread 用于运行一个消息循环。一个线程默认不具有与之关联的消息循环（消息队列），如果想要为线程创建一个消息队列，在该线程中调用 <code>Looper.prepare()</code>，然后再调用 <code>Looper.loop()</code> 来启动消息处理循环，该循环将一直运行直到被终止。</p>\n<p>（2）大多数情况下，和消息循环的交互是通过 <code>Handler</code> 完成的。</p>\n<p>（3）以下代码是实现一个具有消息循环的线程的典型方式，通过分别调用 <code>prepare()</code> 和 <code>loop()</code> 来创建一个初始化的 <code>Handler</code> 并用于和 <code>Looper</code> 交互：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）Looper 类中包含某些代码，是需要通过 MessageQueue 来设置和管理事件循环的。影响消息队列的状态的 API 应该在 MessageQueue 或 Handler 中而不是在 Looper 本身定义，例如 <code>Idle Handler</code> 和同步障栅是在消息队列中定义的，而 Thread 的前期准备、消息循环、退出则是在 Looper 中完成的。</p>\n<p>以上内容可能涉及到 Handler 或 Message 的内容，可以通过系列对应的文章查阅。</p>\n<hr>\n<h2 id=\"2-Looper初始化和实例化\"><a href=\"#2-Looper初始化和实例化\" class=\"headerlink\" title=\"2. Looper初始化和实例化\"></a>2. Looper初始化和实例化</h2><p>Looper 类光是从名字就能看出来作用，通过之前对 Handler 的源码分析可以知道，Handler 构造时，可以手动传入一个 Looper 对象和处理消息的回调 Callback，用来与 Handler 绑定，此时这个 Handler 则会用来处理该 Looper 的消息队列中的消息，并且与该 Looper 处在同一线程，而默认构造方法则最终都调用了以下构造方法，并且内部给 Looper 传入了一个 <code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到默认情况下会调用 <code>Looper.myLooper()</code>，再查看一下这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Return the Looper object associated with the current thread.  Returns</span></span><br><span class=\"line\"><span class=\"comment\">  * null if the calling thread is not associated with a Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Looper <span class=\"title\">myLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadLocal.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法也就是从 <code>ThreadLocal</code> 中获取一个对象，ThreadLocal 的相关内容在系列文章中已有介绍，简单来说，首先需要向当前线程中 <code>set()</code> 一个对象，才能 <code>get()</code> 出来，并且 ThreadLocal 中存放的对象是和线程绑定的，不同线程只能 <code>get()</code> 到该线程自己 <code>set()</code> 进去的对象，再看一下这个 <code>sThreadLocal</code> 在一开始的声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>说明存取的都是 Looper 对象。Looper 其实有两个 <code>prepare()</code> 方法，一个无参，另一个就是以下这个有一个布尔类型参数的，但无参的 <code>prepare()</code> 最终也是调用的有参这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Initialize the current thread as a looper.</span></span><br><span class=\"line\"><span class=\"comment\">  * This gives you a chance to create handlers that then reference</span></span><br><span class=\"line\"><span class=\"comment\">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #quit()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Looper.prepare(boolean)</code> 方法中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里就清楚了，Looper 在调用 <code>prepare()</code> 方法后，会往对应的 ThreadLocal 中存放一个实例化的 Looper 对象，而 <code>Looper.myLooper()</code> 则是从 ThreadLocal 中取出这个对象，因此如果一个 Looper 没有先调用 <code>prepare()</code> 就直接使用会报错。但是为什么不直接通过 <code>new</code> 来生成实例对象呢？因为 Looper 的构造方法是私有的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这么设计的好处我个人理解为：① Looper、Handler、Thread 这些类都是由系统进行资源管理的，用户不应具有太大的修改权限，并且 Looper 类是 <code>final</code> 修饰的，也不允许用户继承重写。② Looper 必须和指定的线程绑定，指定调用 <code>prepare()</code> 方法可以强调这一特性。③ Looper 只能和一个线程绑定，使用 ThreadLocal 管理，采用 <code>new</code> 的方式可能会有多线程的问题。</p>\n<hr>\n<h2 id=\"3-Looper总结\"><a href=\"#3-Looper总结\" class=\"headerlink\" title=\"3. Looper总结\"></a>3. Looper总结</h2><p>其实到这里 Looper 的工作原理和流程就已经可以总结了：</p>\n<ol>\n<li>Looper 是一个消息循环。</li>\n<li>Looper 内有成员变量 MessageQueue，并通过它循环取出、派发消息进行事件处理。</li>\n<li>Looper 无法通过构造方法实例化，而是通过 <code>prepare()</code> 方法，并在内部调用了 <code>myLooper()</code> 方法来实例化一个 Looper 对象，且会和线程绑定，通过对应线程的 ThreadLocal 来存取。</li>\n<li>Looper 所在的线程决定了 Handler 处理消息时所在的线程。实例化 Handler 时，可以自行创建某线程的 Looper 实例化对象，并将其与 Handler 绑定，则 Handler 处理的消息即来自于 Looper 所在的线程。</li>\n<li>线程默认是不具有消息循环的，也即默认情况下一个 Thread 是不会维护 Looper 的，通过继承重写 Thread，并在其中调用 <code>Looper.prepare()</code> 来创建消息循环，再通过 <code>Looper.loop()</code> 来开启循环。</li>\n</ol>\n<p>但在实际开发中其实有些比较常见的问题：</p>\n<p>（1）平时用 Handler 处理消息时，并没有调用 <code>Looper.prepare()</code> 或通过其手动创建一个 Looper 对象，但依然可以正常处理消息。这是因为，Android 的主线程即 UI 线程，有一定的特殊性，整个 App 过程中仅允许存在一个 UI 线程，而 App 的主线程对应在 <code>ActivityThread.main()</code> 方法，其也是整个 App 的入口方法，在这个方法里面就生成了 Looper 的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure>\n\n<p>对应 Looper 中的源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Initialize the current thread as a looper, marking it as an</span></span><br><span class=\"line\"><span class=\"comment\">  * application&#x27;s main looper. The main looper for your application</span></span><br><span class=\"line\"><span class=\"comment\">  * is created by the Android environment, so you should never need</span></span><br><span class=\"line\"><span class=\"comment\">  * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然本质上仍然是通过 <code>prepare(boolean)</code> 方法生成了一个成员变量 <code>sMainLooper</code>，但是加了类锁，并且只允许创建一次，由于 App 运行期间，主线程一直存在，因此主线程的对应的 Looper 实例对象 <code>sMainLooper</code> 在 App 运行期间有且仅有一个，所以在主线程中使用 Handler 无需手动创建 Looper 实例对象以及显式调用 <code>prepare()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程中实例化 Handler</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(<span class=\"keyword\">new</span> Handler.Callback() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（2）即使在子线程中，也可以不显式调用 <code>prepare()</code> 方法，这时 Handler 的初始化方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是 <code>void handleMessage(Message)</code>和（1）中使用匿名 Callback 的 <code>boolean handleMessage(Message)</code> 不同。</p>\n</blockquote>\n<p>这里不需要显式调用 <code>prepare()</code> 的原因是给 Handler 传了一个 <code>Looper.getMainLooper()</code> 的参数，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Returns the application&#x27;s main looper, which lives in the main thread of the application.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Looper <span class=\"title\">getMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sMainLooper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到实际上就是返回了主线程的 <code>sMainLooper</code>，所以也不需要手动创建 Looper 实例对象。</p>\n<p>（3）利用 <strong>Handler 处理消息所在线程由其实例化时传入的 Looper 对象决定</strong> 这一特性，可以衍生出主线程和子线程之间交互的方式：</p>\n<ol>\n<li>子线程向主线程发送消息：在子线程实例化 Handler 时传入 <code>Looper.getMainLooper()</code> 参数。</li>\n<li>主线程向子线程发送消息：在主线程实例化 Handler 时传入一个在子线程中调用过 <code>prepare()</code> 方法已初始化的 Looper 对象。</li>\n</ol>\n<p>针对以上情形 ②，主线程开启子线程后向下执行，如果主线程发送消息的时间较早，可能子线程还没有完成对 Looper 的实例化，则会导致空指针异常，此时可以将子线程用 <code>HandlerThread</code> 类代替，实例化时传入一个 <code>String</code> 类型的线程标记名，HandlerThread 不能重写 <code>run()</code> 方法，当然也不需要显式调用 <code>prepare()</code> 和 <code>loop()</code>，通过 <code>HandlerThread.getLooper()</code> 即可获取 Looper 实例对象。</p>\n","categories":["Android"],"tags":["Android","Looper","源码"]},{"title":"Android-Message","url":"/post/android/android-message/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Message\"><a href=\"#Android-Message\" class=\"headerlink\" title=\"Android-Message\"></a>Android-Message</h1><h2 id=\"1-Message的种类\"><a href=\"#1-Message的种类\" class=\"headerlink\" title=\"1. Message的种类\"></a>1. Message的种类</h2><p>在 Android 中经常使用 Message 来发送一些“消息”，这个“消息”有自己的标识 <code>what</code>，有自己的两个通用参数 <code>arg1</code> 和 <code>arg2</code>，有自己的具体消息内容 <code>obj</code>，似乎消息就是一个通过标识传递数据的功能，但其实里面大有门道。</p>\n<p>在使用 Message 时，默认情况下越早发送的消息越早被处理，这是因为默认的消息即为同步消息，而实际上消息有三种：同步消息、异步消息、障栅消息：</p>\n<ol>\n<li>在默认情况下均为 <strong>同步消息</strong>，同步消息的意义即：除非指定 Message 的执行时间，否咋 Message 会以队列（FIFO，先进先出）的机制顺序处理消息。</li>\n<li>异步消息则不受顺序的限制，即使在同步消息阻塞的情况下，依然可以处理异步消息。</li>\n<li>障栅消息本身并不携带额外的数据，可以看成是一个阻塞器，它用于阻塞同步消息而对异步消息没有影响，可以看成是让异步消息优先执行的一个调节器。</li>\n</ol>\n<p>而消息是否同步，并不是由 Message 本身决定的，而是由处理消息的 Handler 决定的。</p>\n<hr>\n<h2 id=\"2-同步消息\"><a href=\"#2-同步消息\" class=\"headerlink\" title=\"2. 同步消息\"></a>2. 同步消息</h2><p>在默认初始化 Handler 时，不论是调用无参构造方法，还是传递 Looper 的构造方法，或者重写回调的构造方法，其实源码里都有这么一个内部调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内部调用了有布尔值的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略了其他几个带布尔值的构造方法，详细可查源码</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>这些带布尔值的内部构造方法，其布尔值含义都是一样的：<code>async</code>，是否异步。可以看到，当我们实例化 Handler 没有显式传入一个 <code>true</code> 作为参数时，默认调用的内部构造方法均使用了 <code>false</code> 作为参数，也即：<strong>默认情况下不使用异步</strong>。</p>\n<hr>\n<h2 id=\"3-异步消息\"><a href=\"#3-异步消息\" class=\"headerlink\" title=\"3. 异步消息\"></a>3. 异步消息</h2><p>如果需要使用异步消息，则需要实例化 Handler 时手动指定 <code>async</code> 参数。从源码可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于这 3 个可以指定 <code>async</code> 的构造方法，均添加了 <code>@hide</code> 或 <code>@UnsupportedAppUsage</code> 注解，因此只能通过反射才能手动构造。查看第二个方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释里面很清楚地写到，该方法使用当前线程的 Looper 来实例化 Handler。手动指定该方法的参数 <code>async = true</code>，即可使得该 Handler 所发送的消息均为 <strong>异步消息</strong>。</p>\n<hr>\n<h2 id=\"4-障栅消息\"><a href=\"#4-障栅消息\" class=\"headerlink\" title=\"4. 障栅消息\"></a>4. 障栅消息</h2><p>障栅消息的本质也只是一个 Message，但是其 <code>target</code> 为 <code>null</code>（其他消息不能设置为 <code>null</code>，否则会报异常），且 <code>arg1</code> 设置为一个从 0 开始每次自增 1 的 token，用于标识不同的障栅消息。前面已经介绍到，障栅消息的作用是阻塞添加到消息队列的时间比它晚的同步消息，因此障栅消息添加到队列时，会根据添加的时间 <code>when</code> 来插入到对应的消息位置。为了便于理解，这里把 <code>when</code> 比障栅消息小的最后一个消息（即障栅消息前一个）称为 LAST，把这个消息的下一个（即障栅消息后一个）称为 ONEMORE。</p>\n<p>（1）在 MessageQueue 中发送障栅消息的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其调用了另一个私有同名方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enqueue a new sync barrier token.</span></span><br><span class=\"line\">    <span class=\"comment\">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mNextBarrierToken 从 0 开始</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"comment\">// 障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 中间变量，用于记录比障栅消息早的最后一个消息（障栅消息的前一个）</span></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 当前第一条消息</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息比障栅消息更早，则不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 用 prev 记录当前消息 p</span></span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                <span class=\"comment\">// p 指向下一条消息</span></span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 循环完成后，会找出所有 when 比障栅消息更小的 Message</span></span><br><span class=\"line\">            <span class=\"comment\">// 且按照原顺序连接在单链表中，这些消息不会阻塞。</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时 LAST 即是 prev，而 p 则指向了 ONEMORE。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            <span class=\"comment\">// 说明循环进到了内部，也即障栅消息将位于 LAST 和 ONEMORE 的中间</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为 ONEMORE，即 p</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// LAST 的下一条为障栅消息</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明循环没有进入，也即障栅消息将位于消息队列的首位</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为原先消息队列的第一条消息</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// 消息队列的第一条消息变为障栅消息</span></span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并返回了一个 token，当一个障栅消息被加入到 MessageQueue 后，比障栅消息被添加的时间 <code>when</code> 更晚的同步消息将被阻塞，而异步消息不受影响，直到使用和返回值相同的 token 作为参数调用 <code>removeSyncBarrier(int token)</code> 将该障栅消息移除后，同步消息才恢复处理。</p>\n<p>从源码中可以得知，这一步其实只是把一个障栅消息插入到 MessageQueue 中，插入的位置是由障栅消息的 <code>when</code> 决定的，而障栅消息的 <code>when</code> 则是在公有无参 <code>postSyncBarrier()</code> 中，传入了一个 <code>SystemClock.uptimeMillis()</code>，因此障栅消息的添加无法自定义插入点，只能在代码中手动在想要阻塞的同步消息的前面执行 <code>postSyncBarrier()</code>。</p>\n<p>（2）接下来是移除障栅消息 <code>removeSyncBarrier(int token)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从消息队列的第一个元素开始</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"comment\">//遍历消息队列的所有元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有 p.targe == null 且 p.arg1 == token 的才是对应的障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是否需要唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明目标障栅消息不是第一个消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则将障栅消息的前一条消息的 next 指向障栅消息的下一条</span></span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 因为障栅消息之前有消息，还没有阻塞，所以不需要唤醒</span></span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果障栅消息是第一条消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则消息队列的第一条消息直接设置为障栅消息的下一条</span></span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息（原先障栅消息的下一条）为 null，说明消息队列中没有消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息的 target != null，说明</span></span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除障栅消息就比较简单了，就是遍历消息队列找到 <code>target == null</code> 且 token 对应的消息并移除即可，满足某些条件时还需要唤醒 native 层的消息队列。</p>\n","categories":["Android"],"tags":["Android","源码","Message","消息"]},{"title":"Android-内存优化","url":"/post/android/android-memory/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-内存优化\"><a href=\"#Android-内存优化\" class=\"headerlink\" title=\"Android-内存优化\"></a>Android-内存优化</h1><h1 id=\"内存泄漏和内存抖动\"><a href=\"#内存泄漏和内存抖动\" class=\"headerlink\" title=\"内存泄漏和内存抖动\"></a>内存泄漏和内存抖动</h1><h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>（1）内存泄漏的原因：</p>\n<ul>\n<li><p>Handler 发送的消息未被处理则会导致 MessageQueue 一直持有 Handler 和 Message 的引用，解决办法：创建静态内部 Handler 类继承自 Handler，并实例化该内部的 Handler，并且在 <code>onDestroy()</code> 方法中手动移除所有未处理的消息、或者使用进程唯一的 MainLooper 来实例化 Handler。</p>\n</li>\n<li><p>单例模式的生命周期通常和 App 一致，若其中传入了 Context，则会导致对应的 Context 无法被回收，此时可以改用 Application 的 Context。</p>\n</li>\n<li><p>使用 View、Context 等作为参数传递到外部对象中，由于 Context 和 View 对象很容易被回收，如果被外部对象持有，很可能会导致内存泄漏。可以使用弱引用 WeakReference。</p>\n</li>\n<li><p>非静态匿名内部类，例如一个非静态的 Runnable 对象，被用来实例化一个匿名 Thread 对象：<code>new Thread(runnable).start();</code>，由于该 Runnable 对象非静态，会自动持有其外部类的引用，则导致外部类无法被回收。可以通过把 Runnable 对象声明为 <code>static</code> 解决。</p>\n</li>\n<li><p>注册/反注册未成对使用，例如广播接收器，可以在 <code>onCreate()</code> 或 <code>onResume()</code> 中注册，在 <code>onDestroy()</code> 或 <code>onPause()</code> 中释放。</p>\n</li>\n<li><p>资源为关闭，例如 Cursor、File、Bitmap、视频等，通常内部实现了一些缓冲技术，并且可能还涉及到 Native 层，都需要手动关闭资源，否则会引起内存泄漏。</p>\n</li>\n<li><p>集合未及时清理，例如将一些 View、Context 等存入集合中导致无法回收，或是将集合声明为 <code>static</code>，都会导致内存泄漏。</p>\n</li>\n</ul>\n<p>（2）内存泄漏的检测：</p>\n<p>主要是引入 LeakCanary，然后在 Application 中初始化和安装，之后在设备上运行 App 即可在 LeakCanary 中自动检测。还有MAT、Lint等。</p>\n<ul>\n<li><p>LeakCanary原理</p>\n</li>\n<li><p>利用logging监听方法耗时，会不会让app增大延迟</p>\n</li>\n</ul>\n<p>通过Looper.setMessageLogging(Printer)来设置自己的Printer，Printer会在Looper处理一个事件的开始和结束输出Msg的相关信息。</p>\n<h2 id=\"内存抖动\"><a href=\"#内存抖动\" class=\"headerlink\" title=\"内存抖动\"></a>内存抖动</h2><p>内存抖动主要是短时间内有大量对象产生和销毁，伴随着频繁的 GC，占用大量 CPU 和 UI 线程资源，导致 App 卡顿。</p>\n<p>（1）内存抖动的原因：</p>\n<ul>\n<li><p>在循环中声明和创建对象，可以改为在外部创建对象，然后在循环内实例化。</p>\n</li>\n<li><p>频繁改变 <code>String</code> 对象，可以改为使用 <code>StringBuilder</code> 最后再转为 <code>String</code>。</p>\n</li>\n<li><p><code>View</code> 中的 <code>onDraw()</code> 方法会被频繁调用，应当尽量避免创建对象。</p>\n</li>\n<li><p>频繁使用的图片资源，或者复用几率较大的对象，可以建立缓存。</p>\n</li>\n</ul>\n<p>（2）内存抖动的检测和定位：</p>\n<p>使用 AndroidStudio 自带的工具 Android Profile，选择 Memory 栏，当出现 GC 时，会显示一个垃圾桶图标，如果 GC 出现的频繁，则很可能是内存抖动。</p>\n<p>使用 AndroidStudio 自带的工具：Tools - Android - Android Device Monitor，打开 App，在 Monitor 工具中选择 App 对应的进程，然后运行对应的功能后，选择 DDMS 工具，查看一个 .trace 文件，在“main”栏会显示具体的抖动，找到发生抖动（柱状图起伏很大的一段）放大后，对应的找到相关的方法（方法被调用时，调用者的方法序号小于其调用的方法的序号），根据实际情况追溯到对应的方法中去查看有没有可能导致内存抖动的代码并修改。</p>\n<hr>\n<h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1><p>（1）逻辑层</p>\n<p>尽可能消除或减少内存泄漏、内存抖动。</p>\n<p>（2）UI 层</p>\n<ul>\n<li><p>减少布局层级，可通过手机的“过渡绘制”和 AndroidStudio - Tools - Layout Inspector 查看。</p>\n</li>\n<li><p>使用 ViewStub 占位不常用资源。</p>\n</li>\n<li><p>使用简单的布局，例如在层级相同的前提下，使用 FrameLayout 或 LinearLayout 替代 RelativeLayout。</p>\n</li>\n<li><p>优化自定义 View 中的 <code>onDraw()</code>，避免复杂语句。</p>\n</li>\n</ul>\n<p>（3）应用层</p>\n<ul>\n<li><p>耗时操作异步处理。</p>\n</li>\n<li><p>复用资源本地缓存。</p>\n</li>\n<li><p>Bitmap 优化，例如读取信息时，设置 <code>BitmapFactory.Options.inJustDecodeBounds = true;</code>，则仅读取宽高而不将具体数据读入内存，当图片过大时，对图片进行压缩，缓存一份压缩后的图片，对需要显示大图的地方，使用 <code>BitmapRegionDecoder</code>，指定 Bitmap 的区域进行解码。</p>\n</li>\n</ul>\n<p>（4）代码层</p>\n<ul>\n<li><p>ListView、RecyclerView，使用 ViewHolder 复用布局。</p>\n</li>\n<li><p>减少枚举类。由于 JVM 使用 int 作为默认整型变量，因此在数据量大和非必要场景下，使用 int 替代 short、byte 反而性能更好。</p>\n</li>\n<li><p>使用 SparseArray 或 ArrayMap 代替简单的 HashMap 结构。</p>\n</li>\n</ul>\n<p>稀疏数组是针对替换 <code>HashMap&lt;Integer, Object&gt;</code> 的，其意义在于：如果一个 HashMap 里面存的数据很少，会浪费很多空闲的内存空间，因此可以使用一个压缩后的矩阵来表示。SparseArray 矩阵，分为上下两个部分，共三列。上部分只有第一行，从左到右三列分别是：原 HashMap 的行数、原 HashMap 的列数、原 HashMap 共使用了几个元素。下部分则分别记录了原 HashMap 中使用了的元素分别在原 HashMap 中的行下标、列下标、取值。</p>\n<p>ArrayMap使用两个数组来存放键值对，一个数组存放Key，另一个存放Value。</p>\n<p>如果Key确定是Int，可使用SparseArray，Long可使用LongSparseArray，其他使用ArrayMap，但数据量大时，还是使用HashMap，因为SparseArray和ArrayMap使用二分法，将计算后的Hash值按从小到大的顺序排列插入和读取。</p>\n<p>（5）启动优化</p>\n<p>利用window background快速展示一个界面给用户快速的心理预期，启动的过程，如第一个Activity的onCreate中避免繁重的初始化任务，IO、网络等耗时操作懒加载，减少布局嵌套等。</p>\n<p>（6）APK体积优化</p>\n<p>资源文件方面：使用webp代替传统jpg和png格式，单色背景或简单几何图形使用drawable或者Vector代替图片，大型媒体文件使用动态联网加载代替打进APK包，多Module之间复用的资源避免冗余。</p>\n<p>代码层，去除无用的第三方依赖，减少枚举类，代码混淆，</p>\n<hr>\n<h1 id=\"ListView和RecyclerView性能对比和性能优化\"><a href=\"#ListView和RecyclerView性能对比和性能优化\" class=\"headerlink\" title=\"ListView和RecyclerView性能对比和性能优化\"></a>ListView和RecyclerView性能对比和性能优化</h1><p>ListView 开发成本低，性能和功能上 RecyclerView 更优。</p>\n<p>RecyclerView在很多方面能取代ListView，Google为什么还不弃用ListView？</p>\n<p>在某些轻量级场景下，例如纯文字的列表时，RecyclerView强制使用Holder的形式芳儿增加了开销，而且开发成本也更高一些。</p>\n<p>（1）ListView：</p>\n<p>Adapter.getView中，ConvertView==null时，说明当前的Item的View还没创建，LayoutInflate一个View，否则说明View可复用，直接让View=convertView。</p>\n<p>根据每个Item都有的布局创建一个ViewHolder，这个ViewHolder保存了每一个Item通用的布局的View的对象，如果ConvertView==null，说明当前Item的View还没创建，则新建一个ViewHolder并将该Holder存入View.tag里，否则说明可复用，直接getTag取出holder，然后重新给里面的View对象赋值。</p>\n<p>（2）RecyclerView：</p>\n<p>onBindViewHolder运行在UI线程中，尽量避免耗时操作</p>\n<p>数据量较大时，用DiffUtil代替notifyDataSetChanged，只刷新局部数据：<br>DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(oldDatas, newDatas), true);<br>diffResult.dispatchUpdatesTo(mAdapter);<br>其本质是计算出新旧数据具体在哪些地方和哪一段发生了变化，然后根据实际情况调用：<br>mAdapter.notifyItemRangeInserted(position, count);<br>mAdapter.notifyItemRangeRemoved(position, count);<br>mAdapter.notifyItemMoved(fromPosition, toPosition);<br>mAdapter.notifyItemRangeChanged(position, count, payload);<br>来实现的。</p>\n<p>布局优化，减少Item的过度绘制、减少Item的层级</p>\n<p>RecyclerView的Item很灵活，因此每一次加载，都会调用requestLayout来刷新父布局，如果所有Item的高度固定，可以调用RecyclerView.setHasFixedSize(true);避免</p>\n<p>如果RecyclerView嵌套了RecyclerView，且可以使用相同的Adapter，则可以设置RecyclerView.setRecycledViewPool(pool)来共用一个RecycledViewPool，如果LayoutManager是LinearLayoutManager或其子类，需要手动开启：layout.setRecycleChildrenOnDetach(true)</p>\n<hr>\n<h1 id=\"Bitmap加载大图（加载局部）\"><a href=\"#Bitmap加载大图（加载局部）\" class=\"headerlink\" title=\"Bitmap加载大图（加载局部）\"></a>Bitmap加载大图（加载局部）</h1><p><a href=\"https://www.jianshu.com/p/73aecb2b85e6\">https://www.jianshu.com/p/73aecb2b85e6</a></p>\n<p>（1）设置 <code>inJustDecodeBounds</code> 来预检测图片大小。</p>\n<p>（2）大图尝试先压缩显示预览图。</p>\n<p>（3）当放大显示时，测量当前 ImageView 实际可显示的范围，按照实际可显示范围加载局部图（<code>BitmapRegionDecoder</code>）。</p>\n<p>（4）<code>BitmapRegionDecoder.newInstance(InputStream, boolean)</code>，传入图片输入流实例化一个 <code>bitmapRegionDecoder</code>。</p>\n<p>（5）编码局部：<code>bitmapRegionDecoder.decodeRegion(Rect, BitmapFactory.Options);</code></p>\n<p>（6）绘制：<code>canvas.drawBitmap()</code></p>\n<p>（7）通过手势监听类 GestureDetector 的实例对象在 <code>onTouch(View v, MotionEvent event)</code> 中调用 <code>gestureDetector.onTouchEvent(event)</code>，并继承重写 <code>GestureDetector.onScroll(motionEvent e1, MotionEvent e2, float distanceX, float distanceY)</code> 来监听手势变化，并重新计算需要显示的矩形范围，然后在 <code>onDraw()</code> 中重新绘制对应区域的 Bitmap。</p>\n<hr>\n","categories":["Android"],"tags":["Androi"]},{"title":"Android-Messenger","url":"/post/android/android-messenger/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Messenger\"><a href=\"#Android-Messenger\" class=\"headerlink\" title=\"Android-Messenger\"></a>Android-Messenger</h1>","categories":["Android"],"tags":["Android","Messenger"]},{"title":"Android-NDK开发","url":"/post/android/android-ndk/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-NDK开发\"><a href=\"#Android-NDK开发\" class=\"headerlink\" title=\"Android-NDK开发\"></a>Android-NDK开发</h1><p>粗略的说：JNI 就是在 Java 中调用 C/C++ 代码。早期 Android 版本通常使用 NDK-Build 方式构建，但由于不便于管理等原因，Android Studio 在 3.2 版本后弃用了 <code>NDK-Build</code> 方式，改为推荐使用 <code>CMake</code>。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://developer.android.google.cn/ndk/guides\" title=\"@LINK\">什么是NDK</a></li>\n<li><a href=\"https://baike.baidu.com/item/JNI/9412164?fr=aladdin\" title=\"@LINK\">什么是JNI</a></li>\n<li><a href=\"https://blog.csdn.net/Ithink213/article/details/88580558\" title=\"@LINK\">为什么Java可以调用C/C++</a>（编译的时候，会把JNI层的代码编译为SO库，然后在运行到JNI层的方法时，其实是链接到了编译出来的SO库中运行。）</li>\n<li><a href=\"https://www.oschina.net/question/2241352_213433\" title=\"@LINK\">定位Native Crash</a>（利用 NDK/ndk-stack 工具。发生 NativeCrash 时，可在 Log 信息中心，看到报错的地方显示的是某个 SO 文件，并且会标出 JNI 方法名，然后根据发生 Crash 时运行的手机平台，比如 <code>x86</code> 或者 <code>armeabi</code>，执行 <code>adb shell logcat | ndk-stack -sym 项目/obj/local/armeabi（平台）</code>，然后就能看到日志中标注了具体哪个 JNI 方法中的第几行发生 Crash。）</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"1-官方Demo\"><a href=\"#1-官方Demo\" class=\"headerlink\" title=\"1. 官方Demo\"></a>1. 官方Demo</h2><p>先新建一个原生支持NDK的Android项目，即在新建项目的时候勾选 <code>Include C++ support</code> ，观察一下谷歌建议我们使用的CMake方式的样子。在官方的Demo中，调用和以前的方式并无区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Used to load the &#x27;native-lib&#x27; library on application startup.</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;native-lib&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Example of a call to a native method</span></span><br><span class=\"line\">        TextView tv = (TextView) findViewById(R.id.sample_text);</span><br><span class=\"line\">        tv.setText(stringFromJNI());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A native method that is implemented by the &#x27;native-lib&#x27; native library,</span></span><br><span class=\"line\"><span class=\"comment\">     * which is packaged with this application.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>都是先用静态代码块 <code>static&#123;&#125;</code> 加载JNI模块，然后声明一个 Native 方法并调用。当然，JNI 方法的加载和调用不推荐在 Activity 中实现，应该放在数据处理类或工具类中按需调用，这里涉及到一些性能和安全性的问题。具体的 JNI 方法也很简单，只是返回了一个 String 字符串。重要的是 Gradle 和 <code>CMakeLists.txt</code> 文件里的代码，尤其是官方注释，需要注意的地方是：</p>\n<ul>\n<li>C/C++文件的JNI方法；</li>\n<li>项目 Gradle；</li>\n<li><code>CMakeLists.txt</code> 里的内容。</li>\n</ul>\n<p>先不急着对官方Demo解释，为了实现手动增加 NDK 支持，再创建一个不支持原生 NDK 的空项目，一边改一边对各个模块解释说明。</p>\n<p>在 C++ 文件的函数头中，有这么一句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br></pre></td></tr></table></figure>\n\n<p>这一行代码其实可以分成两个部分：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一部分</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 第二部分</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br></pre></td></tr></table></figure>\n\n<p>第一部分 <code>extern &quot;C&quot;</code> 表示对编译 C 的支持，第二部分 <code>JNIEXPORT jstring JNICALL</code> 可以看成定义了函数的返回值， <code>jstring</code> 可以理解为 Java 中的 <code>String</code>。如果在 JNI 文件中有多个函数，可以用一个大的 <code>extern &quot;C&quot;</code> 将多个函数一次性括起来，但是 C 函数和 C++ 函数不能混用，必须分成两个文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromCpp1</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++1&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromCpp2</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++2&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-为已有项目增加NDK支持\"><a href=\"#2-为已有项目增加NDK支持\" class=\"headerlink\" title=\"2. 为已有项目增加NDK支持\"></a>2. 为已有项目增加NDK支持</h2><p>既然是要给已有项目增加 NDK 支持，那就首先创建一个新的空项目模拟一个已存在的项目，然后再通过手动配置添加 NDK。</p>\n<h3 id=\"2-1-创建JNI文件\"><a href=\"#2-1-创建JNI文件\" class=\"headerlink\" title=\"2.1 创建JNI文件\"></a>2.1 创建JNI文件</h3><p>（1）在如下图所示的目录层级下创建一个文件夹用来存放 C/C++ 代码：</p>\n<p><img data-src=\"./create_jni_folder.png\" alt=\"创建JNI文件夹\" title=\"@ASSET\"></p>\n<p>（2）接着在这个 <code>JNI</code> 文件夹里新建 <code>C/C++ Source File</code> ，先创建一个 C 文件起名为 <code>HelloC</code> ，在下方的 <code>Type:</code> 下拉框中选择 <code>.c</code> ，同时勾选 <code>Create an associated header</code> 自动创建对应的头文件。</p>\n<p><img data-src=\"./create_c_file.png\" alt=\"创建C文件\" title=\"@ASSET\"></p>\n<p>点击 OK 就会创建 <code>HelloC.c</code> 和 <code>HelloC.h</code> 并自动将头文件导入到 C 文件中。函数很简单，直接返回一个String：<code>&quot;Hello from C&quot;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;HelloC.h&quot;</span><br><span class=\"line\">#include &lt;jni.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromC</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jobject obj <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">&quot;Hello from C&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里要说明一点，代码中 <code>Java_com_demo_ndktest_MainActivity_helloFromC</code> 可以看成是一个方法名，但是这个方法名有严格的命名限制：首先命名必须以 <code>Java_</code> 开头，后面紧跟着的 <code>com_demo</code> 是项目的包名， <code>ndktest</code> 是项目名，<code>MainActivity</code> 是调用这个JNI方法的类名，最后 <code>helloFromC</code> 才是这个JNI方法的方法名。如果把 <code>com_demo_ndktest_MainActivity</code> 连在一起看，其实就是调用这个 JNI 的方法的类的绝对路径，也即 <code>MainActivity</code> 的绝对路径，只不过把包的层级表示从点 <code>.</code> 换成了下划线 <code>_</code>。</p>\n<blockquote>\n<p>如果怕出错，可以在我们想要调用这个JNI方法的类的最上方找到绝对路径，再把点都替换成下划线即可：</p>\n<p><img data-src=\"./set_package_name.png\" alt=\"设置包名\" title=\"@ASSET\"></p>\n</blockquote>\n<p>另外，<code>extern &quot;C&quot;</code> 关键字通常在 C/C++ 混合编程中用于 <strong>指定使用 C 编译方式编译的代码块</strong> ，但是这里本来就是在 C 文件中写 C 语言代码，所以没有必要也不允许使用这个关键字了。</p>\n<h3 id=\"2-2-创建CMakeLists-txt\"><a href=\"#2-2-创建CMakeLists-txt\" class=\"headerlink\" title=\"2.2 创建CMakeLists.txt\"></a>2.2 创建CMakeLists.txt</h3><p>确定好 JNI 文件后，开始写 <strong>CMakeLists.txt</strong>。在创建 CMake 文件时，理论上可以在任意位置创建，但是一方面为了便于项目管理，另一方面为了防止混淆，通常选择创建在当前 Module 根目录下。右键 Module 目录，选择 <code>New File</code> ，输入文件名 <code>CMakeLists.txt</code>。</p>\n<p><strong>文件名必须是 <code>CMakeLists.txt</code> 而不能自定义</strong>。</p>\n<p><img data-src=\"./cmake_file_path.png\" alt=\"创建CMakeLists.txt的位置\" title=\"@ASSET\"></p>\n<p>创建完成后向里面写构件库的内容。</p>\n<p><strong>（1）指定CMake的最低版本</strong> 。这是第一条也是必要的一条：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）为项目增加一个lib库</strong> 。也就是指定刚才写的 <code>HelloC.c</code> 文件，这里我们要指定出C文件的绝对路径： <code>src/main/jni/HelloC.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_library( # Sets the name of the library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Sets the library as a shared library.</span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        # Provides a relative path to your source file(s).</span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>HelloC</code> 是创建这个库的命名，可以任意指定，这个名称将在Java中 <strong>加载JNI</strong> 时用到。</li>\n<li><code>SHARED</code> 代表这是个动态库，除了这个选项外还有 <code>STATIC</code> 可选</li>\n</ul>\n<p><strong>（3）使用原生log模块</strong> 。因为要给项目添加NDK支持，所以需要用到NDK库，采用 <code>find_library</code> 使用原生的库和API：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find_library( # Sets the name of the path variable.</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        # Specifies the name of the NDK library that</span><br><span class=\"line\">        <span class=\"meta\"># you want CMake to locate.</span></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>log-lib</code> 是给要使用的NDK库命名，可以自定义，在 <strong>CMake关联指定库</strong> 时会用到</li>\n<li><code>log</code> 是我们要使用的库： <strong>log模块</strong></li>\n</ul>\n<p><strong>（4）CMake关联指定库</strong> 。这一步将第（2）步中添加的库关联给CMake：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">target_link_libraries( # Specifies the target library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Links the target library to the <span class=\"built_in\">log</span> library</span><br><span class=\"line\">        <span class=\"meta\"># included in the NDK.</span></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>HelloC</code> 就是第（2）步新增库时给库的命名</li>\n<li><code>$&#123;log-lib&#125;)</code> 是引用第（3）步中定义的log模块</li>\n</ul>\n<p>完成之后整体的代码（从注释也基本可以看出每一行的用途）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add_library( # Sets the name of the library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Sets the library as a shared library.</span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        # Provides a relative path to your source file(s).</span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br><span class=\"line\"></span><br><span class=\"line\">find_library( # Sets the name of the path variable.</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        # Specifies the name of the NDK library that</span><br><span class=\"line\">        <span class=\"meta\"># you want CMake to locate.</span></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">target_link_libraries( # Specifies the target library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Links the target library to the <span class=\"built_in\">log</span> library</span><br><span class=\"line\">        <span class=\"meta\"># included in the NDK.</span></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时CMakeLists.txt部分就已经完成！</p>\n<h3 id=\"2-3-多JNI方法支持\"><a href=\"#2-3-多JNI方法支持\" class=\"headerlink\" title=\"2.3 多JNI方法支持\"></a>2.3 多JNI方法支持</h3><p>对于大部分时候，JNI和CMakeLIsts的配置就大概如此了，但是有时候可能会遇到需要多个JNI接口的时候，此时就需要在CMakeLists中添加多个库了。在本例中，再新增一个C++的JNI方法，并通过CMake增加到库中。</p>\n<h4 id=\"2-3-1-创建第二个JNI方法（C-）\"><a href=\"#2-3-1-创建第二个JNI方法（C-）\" class=\"headerlink\" title=\"2.3.1 创建第二个JNI方法（C++）\"></a>2.3.1 创建第二个JNI方法（C++）</h4><p>同样在 <strong>jni</strong> 目录下新建一个C++文件 <strong>HelloCPP.cpp</strong> ，与之前创建 <strong>HelloC.c</strong> 时一样，勾选自动关联头文件，代码和官方Demo如出一辙，只不过把函数名改为 <code>helloFromCPP</code> ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_com_demo_ndkdemo_MainActivity_stringFromJNI(</span><br><span class=\"line\">        JNIEnv *env,</span><br><span class=\"line\">        jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，既然要让这个JNI方法被编译，就需要在CMakeLists中进行添加和关联。</p>\n<h4 id=\"2-3-2在CMake中添加和关联两个JNI接口\"><a href=\"#2-3-2在CMake中添加和关联两个JNI接口\" class=\"headerlink\" title=\"2.3.2在CMake中添加和关联两个JNI接口\"></a>2.3.2在CMake中添加和关联两个JNI接口</h4><p>步骤与C文件的步骤一模一样，只需要注意库命名和绝对路径正确即可，直接贴代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第一个JNI（HelloC）</span><br><span class=\"line\">add_library(</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第二个JNI（HelloCPP）</span><br><span class=\"line\">add_library(</span><br><span class=\"line\">        HelloCPP</span><br><span class=\"line\"></span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        src/main/jni/HelloCPP.cpp</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">find_library(</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 连接到第一个库</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 连接到第二个库</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">        HelloCPP</span><br><span class=\"line\"></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样就把两个JNI方法都连接到CMake了，接下来就是Gradle的配置，使得系统可以调用JNI方法。</p>\n<h3 id=\"2-4-修改Gradle配置\"><a href=\"#2-4-修改Gradle配置\" class=\"headerlink\" title=\"2.4 修改Gradle配置\"></a>2.4 修改Gradle配置</h3><p>修改模块的Gradle： <strong>build.gradle (Module: app)</strong> 。先在 <code>defaultConfig</code> 内部增加CMake的一些参数：预处理选项 <code>cppFlags</code> 和架构选择 <code>abiFilters</code>，对于默认情况， <code>cppFlags</code> 为空即可， <code>abiFilters</code> 可以控制生成指定的abi，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        cppFlags <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        abiFilters &#x27;armeabi&#x27;,&#x27;armeabi-v7a&#x27;,&#x27;x86&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者删除 <code>abiFilters</code> 语句表示生成支持所有架构的so库。<br>接着在与 <code>buildTypes</code> 同级的地方增加一个CMakeLists文件的连接：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path <span class=\"string\">&quot;CMakeLists.txt&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成后整个Gradle的配置大致如下（省略非必要部分的内容，但保留了层级关系便于比对）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 此处添加CMake参数</span></span><br><span class=\"line\">        externalNativeBuild &#123;</span><br><span class=\"line\">            cmake &#123;</span><br><span class=\"line\">                cppFlags <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处指定CMake文件</span></span><br><span class=\"line\">    externalNativeBuild &#123;</span><br><span class=\"line\">        cmake &#123;</span><br><span class=\"line\">            path <span class=\"string\">&quot;CMakeLists.txt&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Sync同步一下，再Rebuild一下项目确保没有问题后，就可以运行测试啦！</p>\n<hr>\n<h2 id=\"3-完成效果\"><a href=\"#3-完成效果\" class=\"headerlink\" title=\"3. 完成效果\"></a>3. 完成效果</h2><p>布局很简单就不放代码了，一个 <code>TextView</code> 用来显示String返回值，和两个 <code>Button</code> 分别用来获取C和C++文件JNI方法的字符串并设置到TextView上。代码调用和JNI加载伪代码如下（省略点击监听和控件初始化等）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> priv.luis.demo.ndktest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnClickListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过静态初始化块加载两个编译库</span></span><br><span class=\"line\">    <span class=\"comment\">// 库名分别是在CMakeLists.txt文件中定义的两个库名</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloC&quot;</span>);</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloCPP&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// btC：从C文件获取字符串并显示</span></span><br><span class=\"line\">    <span class=\"comment\">// btCpp：从C++文件获取字符串并显示</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView tvText;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Button btC, btCpp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        initView(); <span class=\"comment\">// 初始化控件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义JNI方法，方法名和对应的C/C++文件内的函数名相对应</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">helloFromC</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">helloFromCPP</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在需要使用的地方调用上方两个方法即可</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (v.getId()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> R.id.btC: &#123;</span><br><span class=\"line\">                tvText.setText(helloFromC());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> R.id.btCpp: &#123;</span><br><span class=\"line\">                tvText.setText(helloFromCPP());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行，分别点击两个按钮，可以看到确实成功运行了两个JNI方法并获取到了字符串返回值：</p>\n<p><img data-src=\"./run.gif\" alt=\"运行效果\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"4-总结备注\"><a href=\"#4-总结备注\" class=\"headerlink\" title=\"4. 总结备注\"></a>4. 总结备注</h2><p>对于Android项目的NDK支持基本上就是如此了，不难，但是容易出错，复杂的点通常在具体的函数实现上。最后再总结和强调一些注意事项。</p>\n<ol>\n<li>尽量不要在Activity中执行JNI的静态加载和调用</li>\n<li>CMakeLists.txt文件中 <code>add_library</code> 设置的名称与下方 <code>target_link_libraries</code> 以及静态加载JNI的地方 <code>static&#123;System.loadLibrary(&quot;LibraryName&quot;)&#125;</code> 中的 <code>&quot;LibraryName&quot;</code> 三者名称要一致</li>\n<li>C/C++函数的函数名与声明该JNI方法处的方法名要一致</li>\n<li>具体的C/C++函数定义的名称前面的包名和调用函数的类名必须与实际包名和类名一致，并且用下划线 <strong>“_”</strong> 代替点 <strong>“.”</strong> 表示层级关系</li>\n</ol>\n<p>以上。</p>\n<hr>\n<h2 id=\"5-附录-参考指导\"><a href=\"#5-附录-参考指导\" class=\"headerlink\" title=\"5. 附录[参考指导]\"></a>5. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/aidesudi/article/details/68946918\" title=\"@LINK\">【1】Android Studio 2.3使用CMake方式NDK入门（作者：狮村小孩）</a></li>\n<li><a href=\"https://blog.csdn.net/lei_notes/article/details/78548433\" title=\"@LINK\">【2】小白初用Android studio的cMake编译生成.so库并调用（作者：lei_notes）</a></li>\n<li><a href=\"https://blog.csdn.net/xufei5789651/article/details/73694634\" title=\"@LINK\">【3】NDK开发笔记—CMake构建JNI（作者：xufei5789651）</a></li>\n<li><a href=\"https://blog.csdn.net/pkandroid/article/details/67074346\" title=\"@LINK\">【4】AndroidStudio2.3 NDk Cmake配置（作者：Android小屋）</a></li>\n<li><a href=\"https://www.jianshu.com/p/cb3064450688\" title=\"@LINK\">【5】AS2.2使用CMake方式进行JNI/NDK开发（作者：于连林520wcf）</a></li>\n<li><a href=\"https://blog.csdn.net/qq_34329508/article/details/52330437\" title=\"@LINK\">【6】android ndk 调用C/C++函数（作者：至信）</a></li>\n<li><a href=\"https://blog.csdn.net/shenhuxi_yu/article/details/79788760\" title=\"@LINK\">【7】makefile中的CPPFLAGS LDFLAGS CFLAGS选项详解（作者：shenhuxi_yu）</a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","CMake","NDK","JNI","CMakeList"]},{"title":"Android-OOM","url":"/post/android/android-oom/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-OOM\"><a href=\"#Android-OOM\" class=\"headerlink\" title=\"Android-OOM\"></a>Android-OOM</h1><p>OOM（Out Of Memory）出现的原因有：</p>\n<p>（1）单次加载过大的对象，如图片。可以压缩、加载小图、绘制局部、使用第三方框架等。</p>\n<p>（2）内存中资源过多，无法为新的数据开辟内存。对不用的数据及时回收、减少内存泄漏等。</p>\n<p>（3）Dalvik 虚拟机分配的 Heap Size 太小。适当调整 HeapSize，可在 Manifest 中标注 <code>largeheap=true</code> 属性。</p>\n","categories":["Android"],"tags":["Android","OOM"]},{"title":"Android反编译和混淆加固","url":"/post/android/android-proguard/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android反编译和混淆加固\"><a href=\"#Android反编译和混淆加固\" class=\"headerlink\" title=\"Android反编译和混淆加固\"></a>Android反编译和混淆加固</h1>","categories":["Android"],"tags":["Android","反编译","混淆","加固"]},{"title":"Android渲染及绘制流程","url":"/post/android/android-render/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android渲染及绘制流程\"><a href=\"#Android渲染及绘制流程\" class=\"headerlink\" title=\"Android渲染及绘制流程\"></a>Android渲染及绘制流程</h1><p><a href=\"https://blog.csdn.net/sinat_27154507/article/details/79748010\">https://blog.csdn.net/sinat_27154507/article/details/79748010</a></p>\n<p>View 绘制中主要流程分为measure，layout， draw 三个阶段。</p>\n<ul>\n<li>measure ：根据父 view 传递的 MeasureSpec 进行计算大小。</li>\n<li>layout ：根据 measure 子 View 所得到的布局大小和布局参数，将子View放在合适的位置上。</li>\n<li>draw ：把 View 对象绘制到屏幕上。</li>\n</ul>\n<p>Window，ViewRootImpl，DecorView之间的联系：</p>\n<p>一个 Activity 包含一个Window，Window是一个抽象基类，是 Activity 和整个 View 系统交互的接口，只有一个子类实现类PhoneWindow，提供了一系列窗口的方法，比如设置背景，标题等。一个PhoneWindow 对应一个 DecorView 跟 一个 ViewRootImpl，DecorView 是ViewTree 里面的顶层布局，是继承于FrameLayout，包含两个子View，一个id=statusBarBackground 的 View 和 LineaLayout，LineaLayout 里面包含 title 跟 content，title就是平时用的TitleBar或者ActionBar，contenty也是 FrameLayout，activity通过 setContent（）加载布局的时候加载到这个View上。ViewRootImpl 就是建立 DecorView 和 Window 之间的联系。</p>\n<p>View绘制的三个阶段的核心入口是在 ViewRootImpl 类的 performTraversals() 方法中。</p>\n","categories":["Android"],"tags":["Android"]},{"title":"Android-Router路由框架浅析","url":"/post/android/android-router/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Router路由框架浅析\"><a href=\"#Android-Router路由框架浅析\" class=\"headerlink\" title=\"Android-Router路由框架浅析\"></a>Android-Router路由框架浅析</h1><p>前言：最近在思考项目 Module 解耦问题的时候，粗略了解了一下路由框架，其中最著名的又属阿里开源的 ARouter 了。但在实操的时候发现路由框架并没有我一开始想象的「能完全实现 Module 间解耦」那么美好，有着其本身的局限性，所以在本文对 ARouter 的基本原理和局限性做一个很浅显的个人总结。</p>\n<hr>\n<h2 id=\"1-什么是ARouter\"><a href=\"#1-什么是ARouter\" class=\"headerlink\" title=\"1. 什么是ARouter\"></a>1. 什么是ARouter</h2><p>ARouter 主要用于针对 Activity 跳转之间的解耦，本质上它提供了一种通过 String 类型的「路径 Path」对应到 Activity 的路由表。其核心是通过 APT 在编译时自动检索添加了 <code>@Route(path=&quot;/XXX/XXX&quot;)</code> 注解的 Activity，并以对应的 Path 为 Key 自动生成了一个 Map，然后在运行时根据 Map 存储的路由信息跳转。</p>\n<hr>\n<h2 id=\"2-ARouter的基本原理\"><a href=\"#2-ARouter的基本原理\" class=\"headerlink\" title=\"2. ARouter的基本原理\"></a>2. ARouter的基本原理</h2><p>ARouter 要求一个 Activity 的路径 Path 必须包括至少两级，例如：<code>/main/sub</code>，将 <code>main</code> 称为主路径，表示某一组 Activity 路由信息统一的主路径，<code>sub</code> 称为子路径，表示具体到某一个 Activity 的精确路由。一个主路径可以包括多个子路径，例如：<code>/main/sub</code>, <code>/main/sub2</code>…</p>\n<p>当项目很庞大或 Activity 的数量很多时，各个需要路由的 Module 下就会产生很大的 Map，因此 ARouter 做了一个优化：分段懒加载，也即运行时不会立即将所有路由信息都加载进内存，而是在发起一个路由请求时，先读取缓存，如果缓存没有，再对目标的主路径下的路由信息做懒加载。</p>\n<h3 id=\"2-1-编译时处理\"><a href=\"#2-1-编译时处理\" class=\"headerlink\" title=\"2.1 编译时处理\"></a>2.1 编译时处理</h3><p>ARouter 在编译时会通过 APT 生成两个表：</p>\n<p>（1）对每个添加了 ARouter 依赖的 Module，检索 Module 内所有添加了 <code>@Route</code> 注解的 Activity，并生成每个具体的 Path 对应 Activity 的表 <code>atlas</code>。</p>\n<ul>\n<li>假设 module_splash 下有一个 ADSActivity 添加了路由，则编译时会生成一个类似以下结构的表：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_splash</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/splash/ads&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, ADSActivity.class, <span class=\"string\">&quot;/splash/ads&quot;</span>, <span class=\"string\">&quot;splash&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>假设 module_user 下 LoginActivity 和 RegisterActivity 都添加了路由，则编译时同样会生成一个类似以下结构的表：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_user</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/login&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, LoginActivity.class, <span class=\"string\">&quot;/user/login&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/register&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, RegisterActivity.class, <span class=\"string\">&quot;/user/register&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）对所有 Router，生成一个主路径对应每个实际路由表 <code>atlas</code> 的表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Root_app</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;slpash&quot;</span>, EaseRouter_Group_splash.class);</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;user&quot;</span>, EaseRouter_Group_user.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，所有和路由相关的表都，都是通过一个实现了 <code>IRouteRoot</code> 接口的类存储的。</p>\n<h3 id=\"2-2-运行时加载\"><a href=\"#2-2-运行时加载\" class=\"headerlink\" title=\"2.2 运行时加载\"></a>2.2 运行时加载</h3><p>ARouter 会在运行时收到路由请求后再做懒加载：</p>\n<p>（1）初始化 <code>ARouter.init();</code> 时，ARouter 会开启一个子线程扫描 apk 中的所有 dex 文件，遍历当前包名下所有实现了 <code>IRouteRoot</code> 接口的类，并存进一个 className 集合中。</p>\n<p>（2）通过 <code>ARouter.getInstance().build(&quot;/XXX/XXX&quot;).navigation();</code> 请求路由到指定 Path 对应的 Activity。</p>\n<p>（3）尝试从缓存中读取对应的 Activity，如果命中缓存的路由信息，则直接定位并启动目标 Activity。</p>\n<p>（4）如果未命中缓存，说明该路由对应所在的整个路由表都没有加载。假设目标路由为：<code>/user/register</code>，则 <code>EaseRouter_Group_user</code> 加载 <code>atlas</code> 时，会同时把当前主路径，也即 <code>user</code> 下的所有路由信息都加载，所以如果找不到 <code>/user/register</code>，就说明整个 <code>user</code> 都没有加载，则根据目标路由的主路径 <code>user</code> 加载所有 <code>user</code> 下的路由信息。</p>\n<p>（5）将所有主路径为 <code>user</code> 的路由信息加载后，就能通过 <code>routes.get(&quot;user&quot;);</code> 获取到 <code>EaseRouter_Group_user</code>，然后再通过 <code>atlas.get(&quot;/user/register&quot;)</code> 获取到 <code>RegisterActivity</code>。</p>\n<hr>\n<h2 id=\"3-ARouter的局限性\"><a href=\"#3-ARouter的局限性\" class=\"headerlink\" title=\"3. ARouter的局限性\"></a>3. ARouter的局限性</h2><p>上文很简单的解释了一下 ARouter 的原理，作为一个路由框架，ARouter 最大的用途就是把多个 Module 间的 Activity 跳转解耦，发起跳转时不再需要关注实际的 Activity，只需要一个 String 类型的路由即可，从代码编写上确实看起来是解耦了，但实际上 ARouter 并没有解决依赖的问题。</p>\n<p>对于 Android 来说，Gradle 在构建 app 时是有优化的，假如一个 AModule 没有被别的 Module 依赖，或者虽然 AModule 被 BModule 依赖了，但 BMdoule 又没有被依赖，类似于 JVM 中的「引用链是断开的」，那 Gradle 在编译时就会忽略掉这些 Module，以减小最后生成的 APK 包大小以及简化资源。</p>\n<p>Gradle 这个优化本是出于减小包大小考虑的，本质上是好的，但对于想要实现 Module 间解耦来说就是一个阻碍了，因为那些我们希望解耦而去掉依赖的 Module，根本没有被打包进最后的 APK 中，那无论是采用路由、还是别的方式都无法访问。例如：</p>\n<ul>\n<li><p>app 主 Module 下有个 <code>MainActivity</code></p>\n</li>\n<li><p>module_user 下有 <code>LoginActivity</code> 和 <code>RegisterActivity</code></p>\n</li>\n<li><p>app 主 Module 和 module_user 都添加了 ARouter 依赖，并且 Activity 都添加了 <code>@Route</code> 路由信息</p>\n</li>\n<li><p>app 主 Module 并不依赖 module_user，两个 Module 都是独立的</p>\n</li>\n<li><p>编译打包，Build 日志中，ARouter 输出确实找到了 LoginActivity 和 RegisterActivity 的路由：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Note: ARouter::Compiler &gt;&gt;&gt; Found activity route: priv.luis.user.LoginActivity &lt;&lt;&lt;</span><br><span class=\"line\">Note: ARouter::Compiler &gt;&gt;&gt; Found activity route: priv.luis.user.RegisterActivity &lt;&lt;&lt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>但是打包完再反解后发现，module_user 没有被打进 APK 内，MainActivity 请求路由到 LoginActivity 时 ARouter 也报错：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ARouter::There is no route match the path [/user/login]</span><br><span class=\"line\">ARouter::There is no route match the path [/user/register]</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>也就是说，想要使用路由框架，首先也要确保 Module 能正确被打包进去，那方案只有两种：</p>\n<ol>\n<li>app 主 Module 添加所有业务子 Module 的依赖。</li>\n<li>新建一个中介 Module，中介 Module 添加所有业务子 Module 的依赖，然后 app 主 Module 再添加这个中介 Module 的依赖，除了中介 Module 外，其他 Module 都互不依赖。这样 app 主 Module 并没有显式依赖各个业务子 Module，在开发时可以避免逻辑耦合的情况，而且实际上所有业务子 Module 是间接被 app 主 Module 依赖了，所以也能确保被打包进 APK 中，这也是常用的做法。</li>\n</ol>\n<p>所以实际上路由框架并没有从根源上解决依赖的问题，从这个角度来看，ARouter 最大的好处或许其实在于其使用 APT 自动生成了路由信息的录入和查找相关代码，并且对查找路由做了分段懒加载等内存优化，在业务开发上可以节省一些编码时间，但 ARouter 最基本的使用也需要开发人员对相关 Gradle 配置、路由配置等稍有熟悉后才可上手（当然这个过程其实已经有傻瓜式文档了，使用门槛很低），对于整个 App 的路由信息，也需要专门管理，以避免路由信息混乱、重复、不规范等问题，当然这些确实都能通过良好的管理方式优化。但实际上我个人对使用 String 来管理路由的做法反倒是略有排斥的，至于是否真的使得代码变得更「内聚」、「解耦」、以及「高级」，和每个人的开发习惯有关，就见仁见智了。</p>\n<h2 id=\"附录-参考指导\"><a href=\"#附录-参考指导\" class=\"headerlink\" title=\"附录[参考指导]\"></a>附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/857aea5b54a8\" title=\"@LINK\">【1】ARouter原理剖析及手动实现（作者：xiasem）</a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","Router","ARouter","路由"]},{"title":"Android-SharedPreference","url":"/post/android/android-sharedpreference/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-SharedPreference\"><a href=\"#Android-SharedPreference\" class=\"headerlink\" title=\"Android-SharedPreference\"></a>Android-SharedPreference</h1><p>Android 中获取 SharedPreferences 的方式有 3 种：</p>\n<p>（1）Context 中的 <code>getSharedPreferences(String name, int mode)</code></p>\n<p>name 用于指定 SharedPreference 的文件名，如果不存在则创建。mode 用于指定操作模式，有以下几种选择：</p>\n<ul>\n<li>Context.MODE_PRIVATE：只能被本应用程序读、写。</li>\n<li>Context.MODE_WORLD_READABLE：能被其他应用程序读，但不能写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_WORLD_WRITEABLE：能被其他应用程序读、写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_APPEND：检查文件是否存在，存在则追加内容，否则创建新文件。</li>\n</ul>\n<p>（2）Activity 中的 <code>getPreferences(int mode)</code><br>与 <code>getSharedPreferences()</code> 类似，但自动将当前活动的类名作为 SharedPreferences 的文件名。</p>\n<p>（3）PreferenceManager 中的 <code>getDefaultSharedPreferences(Context context)</code><br> 这是一个静态方法，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。</p>\n<hr>\n<h2 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h2><p>SP的本质是HashMap，存储的是键值对数据，在本地存储中以xml文件的形式保存。</p>\n<p>SP本身是线程安全的，读写都用synchronized锁住了，但由于每次修改都会生成一个EditorImpl对象，因此最好是批量处理，最后统一提交。</p>\n<p>提交时有两种方案，commit在UI线程，apply在子线程，使用commit如果耗时太长超过5s，会导致ANR，使用commit，如果提交时关闭Activity，会检查一个工作任务队列sPendingWorkFinishers中的任务是否全部完成，如果有未完成的任务，就会一直等待，所以如果commit太大量的数据导致Activity结束时等待超过5s，一样会导致ANR。</p>\n<p>由于读取本地文件的性能开销很大，所以SP读取数据后，会一直保存在内存，因此如果存放了过大的数据，会导致频繁GC甚至OOM。</p>\n<p>如果SP数据较多，频繁读取的数据和非频繁读取的数据最好分成不同的SP文件。</p>\n","categories":["Android"],"tags":["Android","五大存储","SharedPreference"]},{"title":"Android-SingleInstance模式从后台返回的坑","url":"/post/android/android-singleinstance_in_background/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-SingleInstance模式从后台返回的坑\"><a href=\"#Android-SingleInstance模式从后台返回的坑\" class=\"headerlink\" title=\"Android-SingleInstance模式从后台返回的坑\"></a>Android-SingleInstance模式从后台返回的坑</h1><h2 id=\"1-项目中尝试使用SingleInstance\"><a href=\"#1-项目中尝试使用SingleInstance\" class=\"headerlink\" title=\"1. 项目中尝试使用SingleInstance\"></a>1. 项目中尝试使用SingleInstance</h2><p>平时开发在绝大多数时候，都不会给 Activity 设置为 SingleInstance 模式，所以了解不够深入。有一次遇到一个需求，要给 App 开发一套闪屏 SplashActivity 流程，考虑到如下技术方案需求：</p>\n<ul>\n<li>闪屏页是 App 唯一的。</li>\n<li>由于闪屏是很重要的商业化手段，所以希望闪屏页可以在任意一个其他页面存在时被激活到前台。</li>\n<li>闪屏启动结束后，还需要返回到原来的页面（这也明确了不能使用 singleTask）。</li>\n</ul>\n<p>根据这三个需求，自然而然想到了 singleInstance，表面上看似乎完全满足以上条件。另外因为闪屏页会经常在触发某些条件时被唤起，但并不一定每一次都需要真实可见，例如闪屏资源未准备好时就需要直接 <code>finish()</code>，用伪代码表示如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Manifest</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;activity</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;demo.SplashActivity&quot;</span></span><br><span class=\"line\">        android:launchMode=<span class=\"string\">&quot;singleInstance&quot;</span>&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\">    &lt;activity android:name=<span class=\"string\">&quot;demo.MainActivity&quot;</span> /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SplashActivity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplashActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里用 isFirstTime 模拟第一次进入 App 后，会跳转到 MainActivity，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后退到后台再切回来后，即第二次打开时，视为不满足闪屏条件，直接关闭闪屏。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isFirstTime = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFirstTime) &#123;</span><br><span class=\"line\">            isFirstTime = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            startActivity(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, MainActivity.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finish();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译运行，SplashActivity 正常跳转到 MainActivity，<strong>但此时如果在 MainActivity 点击 Home 键回到桌面，再点击 App 图标，不仅 App 无法唤起，而且最近任务中也没有 App 的记录了。</strong></p>\n<p><img data-src=\"./failed_to_start_app.gif\" alt=\"返回桌面后，点击图标无法启动 Activity，且最近任务记录消失\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"2-问题定位\"><a href=\"#2-问题定位\" class=\"headerlink\" title=\"2. 问题定位\"></a>2. 问题定位</h2><p>出现这个现象，我的第一反应就是：两个 Activity 都被杀了，于是分别给两个 Activity 都添加了生命周期的日志，发现打印出来的如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 首次启动 App 后：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onResume</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onDestroy</span><br><span class=\"line\">// 点击 Home 键：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onPause</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onStop</span><br><span class=\"line\">// 点击多任务键，从最近任务中返回 App：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onResume</span><br><span class=\"line\">// 再次点击 Home 键：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onPause</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onStop</span><br><span class=\"line\">// 点击 App 图标：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onDestroy</span><br></pre></td></tr></table></figure>\n\n<p>从日志上看，MainActivity 自始至终都没有被杀掉。如果仔细看录屏的后半部分，有一次在点击桌面图标之后，App 在一瞬间被拉起来了，然后又自动关闭了。结合点击 App 图标之后的日志来看，很明显是因为点击 App 图标后启动的是 <code>SplashActivity</code>，由于 <code>isFirstTime == false</code> 所以直接执行了 <code>finish()</code>。</p>\n<ul>\n<li>但是为什么 MainActivity 无法启动呢？难道是因为给 <code>SplashActivity</code> 设置了 <code>singleInstance</code> 吗？但即使改为给 <code>MainActivity</code> 设置 <code>singleInstance</code>，依然是同样的现象。</li>\n<li>为什么第一次点 Home 键返回桌面，最近任务中有 App 的记录，但是从桌面点击了 App 图标之后，即使 MainActivity 仍然存活，但最近任务中就没有 App 记录了呢？</li>\n<li>难道是 Application 被强制 Kill 掉了，以至于连 Log 的机会都没有吗？</li>\n</ul>\n<p>再次重复整个步骤，并且每一步都通过 ADB 查看当前 Activity 栈信息：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （1）首次打开 APP，MainActivity 处于前台，Launcher 处于后台。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;392952a #745 A=.abc U=0 StackId=744 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;a4f60c2 u0 priv.luis.launchmodetest/.MainActivity t745&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;cf7cd87 #2 I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=0 StackId=0 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）点击 Home 键回到 Launcher，MainActivity 处于后台。</span></span><br><span class=\"line\"><span class=\"comment\">// 此时多任务中 App 记录正常显示，停留在 MainActivity 界面。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;cf7cd87 #2 I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=0 StackId=0 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;392952a #745 A=.abc U=0 StackId=744 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;a4f60c2 u0 priv.luis.launchmodetest/.MainActivity t745&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）点击 App 图标，App 未被唤起，仍然停留在桌面。</span></span><br><span class=\"line\"><span class=\"comment\">// 此时 多任务中 App 记录已经消失。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;cf7cd87 #2 I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=0 StackId=0 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\">  TaskRecord&#123;96b6b62 #750 A=.abc U=0 StackId=749 sz=1&#125;</span><br><span class=\"line\">    Run #0: ActivityRecord&#123;e949a28 u0 priv.luis.launchmodetest/.MainActivity t750&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WTF？<code>MainActivity</code> 竟然还存活着，说明 App 并没有被杀死，然而最近任务并没有任何记录！</p>\n<hr>\n<h2 id=\"3-原因分析\"><a href=\"#3-原因分析\" class=\"headerlink\" title=\"3. 原因分析\"></a>3. 原因分析</h2><h3 id=\"3-1-验证MainActivity状态\"><a href=\"#3-1-验证MainActivity状态\" class=\"headerlink\" title=\"3.1 验证MainActivity状态\"></a>3.1 验证MainActivity状态</h3><p>首先尝试反向验证，在 SplashActivity 启动 MainActivity 的 Intent 中添加两个 Flag，并且去掉 SplashActivity 中 <code>finish()</code> 的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Manifest</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;activity</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;demo.SplashActivity&quot;</span></span><br><span class=\"line\">        android:launchMode=<span class=\"string\">&quot;singleInstance&quot;</span>&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\">    &lt;activity android:name=<span class=\"string\">&quot;demo.MainActivity&quot;</span> /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SplashActivity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplashActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里用 isFirstTime 模拟第一次进入 App 后，会跳转到 MainActivity，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后退到后台再切回来后，即第二次打开时，视为不满足闪屏条件，直接关闭闪屏。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isFirstTime = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里延迟 2 秒，只是为了让 SplashActivity 的界面加载出来，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这样在最近任务中能看的更清晰，否则可能无法生成 Activity 的缩略图。</span></span><br><span class=\"line\">        mainHandler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isFirstTime) &#123;</span><br><span class=\"line\">                    isFirstTime = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Intent intent = <span class=\"keyword\">new</span> Intent(SplashActivity.<span class=\"keyword\">this</span>, MainActivity.class);</span><br><span class=\"line\">                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);</span><br><span class=\"line\">                    intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);</span><br><span class=\"line\">                    startActivity(intent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不再退出 SplashActivity</span></span><br><span class=\"line\">        <span class=\"comment\">// finish();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试，即可在最近任务中看到 MainActivity 从启动后就一直存在未被销毁，只不过因为 App 进入后台后，点击图标启动时每次启动的都是 SplashActivity，且直接走了 <code>finishi()</code> 的逻辑（如果删除 <code>finish()</code> 的逻辑，就会停留在 SplashActivity 界面中），所以一直没有机会被唤醒而已：</p>\n<p><img data-src=\"./show_in_recent_task.gif\" alt=\"在最近任务中显示 MainActivity 的记录\" title=\"@ASSET\"></p>\n<h3 id=\"3-2-SingleInstance对Activity栈的影响\"><a href=\"#3-2-SingleInstance对Activity栈的影响\" class=\"headerlink\" title=\"3.2 SingleInstance对Activity栈的影响\"></a>3.2 SingleInstance对Activity栈的影响</h3><p>（1）思考一个问题，从一个 App 返回到桌面（App 在后台）后，「点击 App 图标打开」和「从最近任务列表打开」有什么不同？</p>\n<p>答案如下：</p>\n<ul>\n<li>Android 的桌面（或者应用列表）本身也是一个 Activity（Launcher），因此从桌面点击 App 图标打开一个 Activity，本质上也是一个 Activity 通过 <code>startActivity()</code> 启动另一个 Activity 的过程，只不过此时会默认给 Intent 添加一个 <code>FLAG_ACTIVITY_NEW_TASK</code> 的 Flag，作用是先查找目标 Activity 指定的 <code>taskAffinity</code> 栈是否存在，如果存在就会直接唤起这个栈。</li>\n<li>Android 在通过点击 App 图标启动时，启动的是 Manifest 中指定了 <code>android.intent.category.LAUNCHER</code> 属性的 Activity，而最近任务列表中显示的则是 App 最后活跃的栈中的栈顶 Activity。</li>\n</ul>\n<p>（2）因此，对上文 4.1 节的异常现象完整回放整个 App 的 Activity 栈状态。其中，用 <code>/</code> 表示一个栈的栈底，用 <code>&gt;</code> 表示一个栈的栈顶，用 <code>***</code> 表示会被显示在最近任务记录中的栈，且最后活跃的栈位于最上方：</p>\n<ol>\n<li><p>首次点击 App 图标打开 App，打开的是作为 <code>android.intent.category.LAUNCHER</code> 的 SplashActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ SplashActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 启动 MainActivity，由于 SplashActivity 是 singleInstance 模式而独享一个栈，因此 MainActivity 被启动到新建的栈中：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ SplashActivity &gt;</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 调用 <code>finish()</code>，由于退出后其栈内所有 Activity 均已退出，所以该栈也被清理销毁：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 MainActivity 中点击 Home 键返回桌面，MainActivity 及其栈进入后台：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Laucher &gt;</span><br><span class=\"line\">/ MainActivity &gt; ***</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据栈状态可知，此时最近任务中记录的是 MainActivity 及其栈，因此从最近任务中点击进入，也自然会激活 MainActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再次点击 Home 键回到桌面，MainActivity 再次进入后台：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Laucher &gt;</span><br><span class=\"line\">/ MainActivity &gt; ***</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>点击 App 图标打开 App，Launcher 通过 Manifest 定义的 <code>android.intent.category.LAUNCHER</code> 打开 SplashActivity，由于设置了 <code>singleInstance</code>，所以新建一个栈并在其中打开 SplashActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ SplashActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br><span class=\"line\">/ MainActivity &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 执行了 <code>finish()</code>，并且由于栈内所有 Activity 均已销毁，该栈也被清理销毁：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Launcher &gt;</span><br><span class=\"line\">/ MainActivity &gt;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>正是这一步将最近任务中的 App 记录清理了。因为默认情况下，一个 App 只在最近任务中记录一个栈，也就是最后活跃的栈，这个栈一旦被销毁，又没有其他栈被激活，则 App 记录就会从最近任务中删除。</strong></p>\n</li>\n</ol>\n","categories":["Android"],"tags":["Android","Activty","SingleInstance","taskAffinity"]},{"title":"Android-SQLite","url":"/post/android/android-sqlite/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-SQLite\"><a href=\"#Android-SQLite\" class=\"headerlink\" title=\"Android-SQLite\"></a>Android-SQLite</h1><h2 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h2><p>（1）插入数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> TableName <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"string\">&#x27;data&#x27;</span>, ...);</span><br></pre></td></tr></table></figure>\n\n<p>（2）删除数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> TableName <span class=\"keyword\">WHERE</span> attr<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>（3）更新数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE TableName <span class=\"keyword\">set</span> attr1<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span> <span class=\"keyword\">WHERE</span> attr2<span class=\"operator\">=</span><span class=\"string\">&#x27;data2&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>（4）查询数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> TableName;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> attr1, attr2 <span class=\"keyword\">FROM</span> TableName <span class=\"keyword\">WHERE</span> attr<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span>;</span><br></pre></td></tr></table></figure>\n","categories":["Android"],"tags":["Android","五大存储","SQLite"]},{"title":"Android-触摸事件","url":"/post/android/android-touch_event/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-触摸事件\"><a href=\"#Android-触摸事件\" class=\"headerlink\" title=\"Android-触摸事件\"></a>Android-触摸事件</h1><p>Android 的触摸事件有两个方向，一个是向下分发（子控件），一个是向上传递（父控件），onInterceptTouchEvent 表示是否拦截向下分发，返回 true 则子控件不会响应触摸事件，返回 false 则子控件的 onInterceptTouchEvent 被调用。onTouchEvent 表示是否处理事件，返回 true 则表示触摸事件在该 View 处理，不再向上传递。通常，ViewGroup 的 onInterceptTouchEvent 返回 false，onTouchEvent 返回 false，子 View 如果不是 ViewGroup，则没有 onInterceptTouchEvent 方法，onTouchEvent 返回 true，需要处理事件的子 View 如果在 ACTION_DOWN 时 onTouchEvent 不返回 true，表示没有消费 ACTION_DOWN，则将无法响应 ACTION_MOVE 和 ACTION_UP。</p>\n<ul>\n<li>ViewRootImpl接受事件吗</li>\n</ul>\n<p>接收。事件的传递顺序：硬件（屏幕）、ViewRootImpl、DecorView、PhoneWindow、Activity。</p>\n","categories":["Java"],"tags":["Android","触摸事件"]},{"title":"Hexo自定义-初始化静态网站","url":"/post/hexodiy/hexodiy-init/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo自定义-初始化静态网站\"><a href=\"#Hexo自定义-初始化静态网站\" class=\"headerlink\" title=\"Hexo自定义-初始化静态网站\"></a>Hexo自定义-初始化静态网站</h1><blockquote>\n<p>本文基于GitHub 托管、Hexo 生成静态页的形式。</p>\n<p>Google 的 MarkDown 语法规范参考链接：<a href=\"https://github.com/google/styleguide/blob/gh-pages/docguide/style.md\" title=\"@LINK\">Markdown style guide</a></p>\n</blockquote>\n<h2 id=\"1-建立静态网站仓库\"><a href=\"#1-建立静态网站仓库\" class=\"headerlink\" title=\"1. 建立静态网站仓库\"></a>1. 建立静态网站仓库</h2><p>首先，在 GitHub 上新建一个仓库，名称为 <code>xxx.github.io</code>，其中 <code>xxx</code> 为自己的 GitHub 用户名，要注意是用户名而不是名字，用户名是可以用来登录的那个。创建好了之后就已经可以通过 <code>xxx.github.io</code> 访问。需要注意的是，这个仓库仅用来存储最终部署后的文件，而非平时写的文章。</p>\n<blockquote>\n<p>假设在 <code>本地仓库</code> 存储博客配置和文章，Hexo 在部署时会生成 HTML 静态网页并 Push 到 <code>Page 仓库</code>，开启了 Page 服务的仓库会在每次收到 Push 后自动把 HTML 部署并发布成公网网页。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-连接SSH\"><a href=\"#2-连接SSH\" class=\"headerlink\" title=\"2. 连接SSH\"></a>2. 连接SSH</h2><p>由于每次本地更新完网站后，都需要 Push 到 <code>Page 仓库</code>，所以需要获取 <code>Page 仓库</code> 的部署权限，推荐使用 SSH 鉴权：</p>\n<ol>\n<li>查看本地是否存在目录 <code>~/.ssh</code>，若存在，且密钥绑定的邮箱和 GitHub 账号绑定的邮箱一致，则可跳过该步骤。<ul>\n<li>若不存在或不知道怎么检查，可以重新生成。</li>\n<li>执行命令生成绑定 GitHub 邮箱的密钥：<code>ssh-keygen -t rsa -C &quot;xxx@yyy.com&quot;</code></li>\n<li>回车执行后根据提示输入 GitHub 的账号密码，若提示 id 文件已保存，则创建成功</li>\n<li>目录下将生成两个文件：<code>id_rsa.pub</code> 和 <code>id_rsa</code>。</li>\n</ul>\n</li>\n<li>在 <code>Page 仓库 -&gt; Settings -&gt; Deploy Keys</code> 中点击 <code>Add deploy key</code> 新建一个部署密钥，把生成的公钥 <code>id_rsa.pub</code> 的内容复制到 Key栏并保存，Title 可随意输入。</li>\n<li>本地终端验证密钥，执行命令：<code>shh -T git@github.com</code>，若显示 <code>Hi XXX! You&#39;ve successfully authenticated...</code> 则连接成功。</li>\n</ol>\n<hr>\n<h2 id=\"3-安装必要环境\"><a href=\"#3-安装必要环境\" class=\"headerlink\" title=\"3. 安装必要环境\"></a>3. 安装必要环境</h2><p>通常，基于 Hexo 驱动的静态博客，只需要这三个环境就够了：<code>Git</code>、<code>Hexo</code>、<code>Node.JS</code>，其中 Node.JS 主要是使用其内含的包管理器 <code>npm</code>，通过这个管理器可以为博客部署很多有意思的插件。另外有个小提示，如果在国内使用感觉网速太慢的话，可以用 <code>cnpm</code> 命令替换。</p>\n<ol>\n<li><p>Git 下载地址：<a href=\"https://git-scm.com/downloads\" title=\"@LINK\">Git 下载</a></p>\n</li>\n<li><p>Node.JS下载地址：<a href=\"https://nodejs.org/en/download/\" title=\"@LINK\">Node.JS 下载</a></p>\n</li>\n<li><p>终端安装 Hexo 命令（在安装完 Node.JS 之后）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p> 如果安装结果出现红字报错无权限的情况，可以尝试以下两个命令其中一个：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 尝试1：</span></span><br><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试2：</span></span><br><span class=\"line\">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查环境安装情况：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Git 环境检查：</span></span><br><span class=\"line\">git --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Node.JS 环境检查：</span></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hexo 环境检查：</span></span><br><span class=\"line\">hexo --Version</span><br></pre></td></tr></table></figure>\n\n<p> 如果均能输出对应版本号即表示环境配置成功。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-初始化本地静态博客页\"><a href=\"#4-初始化本地静态博客页\" class=\"headerlink\" title=\"4. 初始化本地静态博客页\"></a>4. 初始化本地静态博客页</h2><p>Hexo 环境安装完以后，就可以在本地建立管理目录了。在终端进入想要作为博客维护目录的路径，并执行以下命令初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n\n<p>执行完之后，目录下应该会出现几个文件及文件夹：</p>\n<ul>\n<li>node_modules: 模块目录，包含了博客基础和自定义功能所需的组件。</li>\n<li>public: 生成的最终部署到网页上所需的 HTML 文件。</li>\n<li>scaffolds: 网站页面模板，用于在新建不同类型文件时，自动应用模板。</li>\n<li>source: 网站内所有页面读取的根目录，包括文章、分类、标签、资源等等。</li>\n<li>themes: 网站的主题，目录内可以包括各种不同的主题，并且可以在网站配置文件内随时更换。</li>\n</ul>\n<p>Hexo 目录初始化完毕后，通过命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以一键式安装所有必须的组件，为了能通过 Hexo 部署到 GitHub 上去，还要再额外安装 Git Deploy 组件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>另附几个常用组件（可能已预装，可以通过 <code>npm list</code> 先查看已安装列表）：</p>\n<ul>\n<li>SiteMap 生成器：<code>npm install hexo-generator-sitemap --save</code></li>\n<li>本地搜索：<code>npm install hexo-generator-searchdb --save</code></li>\n<li>字数及阅读时间统计：<code>npm install hexo-word-counter --save</code></li>\n</ul>\n<hr>\n<h2 id=\"5-常用Hexo命令\"><a href=\"#5-常用Hexo命令\" class=\"headerlink\" title=\"5. 常用Hexo命令\"></a>5. 常用Hexo命令</h2><p>常用的 Hexo 命令大致有如下数条：</p>\n<ul>\n<li><code>hexo init [folder]</code>: 初始化本地项目，可指定路径 folder，或默认为当前目录。</li>\n<li><code>hexo generate</code> / <code>hexo g</code>: 生成本地静态文件。</li>\n<li><code>hexo server</code> / <code>hexo s</code>: 启动本地服务器，启动后可在 <code>localhost:4000</code> 查看页面效果（如果 4000 端口被占用，可以通过修改 Hexo 的 Server 端口更换）。</li>\n<li><code>hexo deploy</code> / <code>hexo d</code>: 部署到 Github（或其他代码托管网站），由根目录下的 <code>_config.yml</code> 文件设定。</li>\n<li><code>hexo clean</code>: 清理缓存文件。</li>\n<li><code>hexo new [layout] &lt;title&gt;</code>: 新建文件（夹），可指定文件类型 layout，或默认由 <code>_config.yml</code> 中的 default_layout 决定。必填项 title 用于指定文章标题，若参数值中含有空格，需使用英文双引号包括。</li>\n<li><code>hexo --safe</code>: 安全模式，禁用加载插件和脚本，可在安装新插件遇到问题时启用。</li>\n<li><code>hexo --debug</code>: 调试模式，用于将消息详细记录到终端和 debug.log 文件。</li>\n<li><code>hexo --silent</code>: 静默模式，用于静默输出到终端。</li>\n<li><code>hexo g -d</code> / <code>hexo d -g</code>: 表示自动按顺序执行 <code>hexo g</code> 和 <code>hexo d</code>。</li>\n</ul>\n<hr>\n<h2 id=\"6-部署博客基本功能\"><a href=\"#6-部署博客基本功能\" class=\"headerlink\" title=\"6. 部署博客基本功能\"></a>6. 部署博客基本功能</h2><p>到上一步为止，博客是已经建立完基础功能了，但此时本地博客和 GitHub 上的静态托管还没有建立联系，想要在本地维护的博客能同步到 GitHub 仓库上，使得外网能通过 <code>xxx.github.io</code> 网页形式访问，还需要配置一下站点配置文件 <code>_config.yml</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>在其中的 <code>repository</code> 后面填写自己的 <code>Page 仓库</code> 地址，修改完保存并三连部署，即可部署到 <code>Page 仓库</code> 上并通过公网访问。</p>\n<p>另外还可以预先安装站点地图和百度站点地图生成插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-generator-sitemap</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install --save hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>\n\n<p>并在站点配置文件中进行如下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成sitemap</span></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<p>这样在部署后就会自动在网站根目录下生成对应的文件，可通过 <code>网站地址/sitemap.xml</code> 或 <code>网站地址/baidusitemap.xml</code> 访问。</p>\n<hr>\n<h2 id=\"7-修改文章URL格式\"><a href=\"#7-修改文章URL格式\" class=\"headerlink\" title=\"7. 修改文章URL格式\"></a>7. 修改文章URL格式</h2><p>默认情况下，文章的 URL 路径通常都是类似于：<code>XXX/2018/07/22/aaa/bbb</code>，不利于维护。Hexo 允许自定义 URL 格式配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 实际域名，如果有自定义域名则修改为自定义域名</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">XXXXX</span></span><br><span class=\"line\"><span class=\"comment\"># 文章的根目录，相对于 source 目录的地址</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"comment\"># 文章的链接格式，&quot;:xxx&quot; 带有冒号表示从文章的 Front-Matter 中获取的值，&quot;xxx&quot; 没有冒号表示硬编的字符串</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink_defaults:</span></span><br></pre></td></tr></table></figure>\n\n<p>假如一篇文章的文件名为 <code>demo.md</code>，文章内的 Front-Matter 为：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">文章标题（文件名为demo.md）</span></span><br><span class=\"line\"><span class=\"attr\">from:</span> <span class=\"string\">test</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果设置 <code>permalink: post/:title/</code>，则生成的文章链接为：<code>url/post/demo</code>。</li>\n<li>如果设置 <code>permalink: :from/:title/</code>，则生成的文章链接为：<code>url/test/demo</code>。</li>\n</ul>\n","categories":["HexoDIY"],"tags":["Hexo","自定义"]},{"title":"HexoDIY-自定义样式","url":"/post/hexodiy/hexodiy-style/","content":"<span id=\"more\"></span>\n\n<h1 id=\"HexoDIY-自定义样式\"><a href=\"#HexoDIY-自定义样式\" class=\"headerlink\" title=\"HexoDIY-自定义样式\"></a>HexoDIY-自定义样式</h1><p>网站使用 Hexo-NexT 主题：</p>\n<ul>\n<li><a href=\"https://github.com/next-theme/hexo-theme-next\" title=\"@LINK\">Next-Theme（最新版本）</a></li>\n<li><a href=\"https://github.com/theme-next/hexo-theme-next\" title=\"@LINK\">Theme-Next（7.8 及更早版本）</a></li>\n</ul>\n<h2 id=\"0-NexT主题自定义\"><a href=\"#0-NexT主题自定义\" class=\"headerlink\" title=\"0. NexT主题自定义\"></a>0. NexT主题自定义</h2><p>NexT 主题提供了使用数据文件来自定义默认样式的能力，可以避免侵入修改源码，相关设置在 NexT 主题配置文件内：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">custom_file_path:</span></span><br><span class=\"line\">  <span class=\"attr\">head:</span> <span class=\"string\">source/_data/NextStyle/layout/head.njk</span></span><br><span class=\"line\">  <span class=\"attr\">header:</span> <span class=\"string\">source/_data/NextStyle/layout/header.njk</span></span><br><span class=\"line\">  <span class=\"attr\">sidebar:</span> <span class=\"string\">source/_data/NextStyle/layout/sidebar.njk</span></span><br><span class=\"line\">  <span class=\"attr\">postMeta:</span> <span class=\"string\">source/_data/NextStyle/post/post-meta.njk</span></span><br><span class=\"line\">  <span class=\"attr\">postBodyEnd:</span> <span class=\"string\">source/_data/NextStyle/post/post-body-end.njk</span></span><br><span class=\"line\">  <span class=\"attr\">footer:</span> <span class=\"string\">source/_data/NextStyle/layout/footer.njk</span></span><br><span class=\"line\">  <span class=\"attr\">bodyEnd:</span> <span class=\"string\">source/_data/NextStyle/layout/body-end.njk</span></span><br><span class=\"line\">  <span class=\"attr\">variable:</span> <span class=\"string\">source/_data/NextStyle/variables.styl</span></span><br><span class=\"line\">  <span class=\"comment\"># mixin: source/_data/NextStyle/mixins.styl</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">source/_data/NextStyle/custom.styl</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-侧栏头像动画\"><a href=\"#1-侧栏头像动画\" class=\"headerlink\" title=\"1. 侧栏头像动画\"></a>1. 侧栏头像动画</h2><p>使用自定义头像，将图片放入 <code>/source/images/</code> 下，然后在主题配置文件中修改：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">avatar:</span></span><br><span class=\"line\">  <span class=\"comment\"># 修改为自定义的头像图片文件路径，也可以是网络路径</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"string\">/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"comment\"># 是否显示为圆形头像</span></span><br><span class=\"line\">  <span class=\"attr\">rounded:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># 头像透明度</span></span><br><span class=\"line\">  <span class=\"attr\">opacity:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\"># 是否在鼠标覆盖在头像上时旋转头像</span></span><br><span class=\"line\">  <span class=\"attr\">rotated:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-自定义头像旋转效果\"><a href=\"#1-1-自定义头像旋转效果\" class=\"headerlink\" title=\"1.1 自定义头像旋转效果\"></a>1.1 自定义头像旋转效果</h3><p>头像的样式是通过 CSS 控制的，所以可以通过注入 <code>custom.style</code> 来修改。</p>\n<h4 id=\"1-1-1-鼠标Hover时旋转\"><a href=\"#1-1-1-鼠标Hover时旋转\" class=\"headerlink\" title=\"1.1.1 鼠标Hover时旋转\"></a>1.1.1 鼠标Hover时旋转</h4><p>如果想让鼠标一过去头像就控记不住记几鬼畜疯狂旋转，则在 <code>custom.style</code> 中添加自定义 CSS 动画：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    transition: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* 原本只是简单地逆时针旋转 180°</span></span><br><span class=\"line\"><span class=\"comment\">  .site-author-image:hover &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    transform: rotateZ(-180deg);</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"comment\">// 鼠标 Hover 时执行 rotateAvatar 动画，动画每次 0.15 秒，线性加速度，重复无限次</span></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    animation: rotateAvatar <span class=\"number\">0.</span>15s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// rotateAvatar 定义动画为旋转 360 度</span></span><br><span class=\"line\">  @keyframes rotateAvatar&#123;<span class=\"keyword\">from</span>&#123;<span class=\"attr\">transform</span>: rotate(0deg)&#125;</span><br><span class=\"line\">  to&#123;<span class=\"attr\">transform</span>: rotate(360deg)&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"./avatar_rotate_hover.gif\" alt=\"鼠标覆盖头像鬼畜式旋转\" title=\"@ASSET\"></p>\n<h4 id=\"1-1-2-唱片式旋转\"><a href=\"#1-1-2-唱片式旋转\" class=\"headerlink\" title=\"1.1.2 唱片式旋转\"></a>1.1.2 唱片式旋转</h4><p>如果想让头像一直缓慢旋转，不受其他操作影响，同样在 <code>custom.style</code> 中添加自定义 CSS 动画：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    transition: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">    <span class=\"comment\">// 对自定义头像的 CSS 执行动画 rotateAvatar，动画每次 5 秒，线性加速度，重复无限次</span></span><br><span class=\"line\">    animation: rotateAvatar 5s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 去掉原本定义的鼠标 Hover 动画</span></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    transform: none;</span><br><span class=\"line\">    <span class=\"comment\">// animation: rotateAvatar 0.15s linear infinite;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rotateAvatar 定义动画为从 0 度旋转岛 360 度</span></span><br><span class=\"line\">  @keyframes rotateAvatar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">from</span> &#123;</span><br><span class=\"line\">      transform: rotate(0deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    to &#123;</span><br><span class=\"line\">      transform: rotate(360deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"./avatar_rotate_normal.gif\" alt=\"唱片式旋转\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"2-浏览器标签页动态标题\"><a href=\"#2-浏览器标签页动态标题\" class=\"headerlink\" title=\"2. 浏览器标签页动态标题\"></a>2. 浏览器标签页动态标题</h2><p><img data-src=\"./animate_browser_title.gif\" alt=\"浏览器标签页动态标题\" title=\"@ASSET\"></p>\n<p>由于只在打开某篇文章时才需要这个动画效果，因此可以在自定义数据文件 <code>post-body-end.njk</code> 中加载一个 JS：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;# 可写进 js 文件中并放在【hexo/source/xxx/】目录下或【next/source/xxx/】目录下 #&#125;</span><br><span class=\"line\">&#123;# 然后通过：&lt;script type=&quot;text/javascript&quot; src=&quot;/xxx/*.js&quot;&gt;&lt;/script&gt; 方式调用 #&#125;</span><br><span class=\"line\">&#123;# 但目录不能以下划线开头（会视为隐藏文件夹而无法访问） #&#125;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    &lt;!--动态浏览器标签--&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> OriginTitle = <span class=\"built_in\">document</span>.title;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime2;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime3;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> blankTitle = <span class=\"string\">&quot;\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000&quot;</span></span><br><span class=\"line\">    blankTitle = blankTitle + blankTitle + blankTitle;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;visibilitychange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.hidden) &#123;</span><br><span class=\"line\">            $(<span class=\"string\">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).attr(<span class=\"string\">&#x27;href&#x27;</span>, <span class=\"string\">&quot;/images/favicon-32x32-next.png&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 失去焦点时不切换标题</span></span><br><span class=\"line\">            <span class=\"comment\">// document.title = &quot;Waiting...&quot;;</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.title = OriginTitle;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime);</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime2);</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome&quot;</span>;</span><br><span class=\"line\">            titleTime = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Back&quot;</span>;</span><br><span class=\"line\">                titleTime2 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome Back !&quot;</span>;</span><br><span class=\"line\">                    titleTime3 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">document</span>.title = OriginTitle;</span><br><span class=\"line\">                    &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>具体的文件名和路径请按照实际情况修改。其实这种三个定时器的嵌套比较 Low，不知道有没有办法可以重用定时器。</p>\n<p><code>icon</code> 处可以自定义一个小图像，可以是本地图像也可以是网络图片。不过需要注意的是，这里如果选择本地图片，“/”表示的就不是博客根目录而是主题根目录，所以 <code>/images/</code> 其实等价于 <code>/next/images/</code>。同理，在主题配置文件中的 <code>favicon</code> 选项设置的也是浏览器标签页小图标，指定的路径也是以主题根目录为起始路径的。</p>\n</blockquote>\n<hr>\n<h2 id=\"3-其他收录\"><a href=\"#3-其他收录\" class=\"headerlink\" title=\"3. 其他收录\"></a>3. 其他收录</h2><p>文章加密：<a href=\"https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md\" title=\"@LINK\">hexo-blog-encrypt（作者：MikeCoder）</a></p>\n<p>点击爱心（会导致双击选中、三击选中整行失效）：<a href=\"https://asdfv1929.github.io/2018/01/26/click-love/\" title=\"@LINK\">Hexo NexT主题添加点击爱心效果（作者：asdfv1929）</a></p>\n<p>页面加载进度条：<a href=\"https://blog.csdn.net/u011236348/article/details/88146947\" title=\"@LINK\">Hexo博客NexT主题美化之顶部加载进度条（作者：潘高）</a></p>\n<p>GitHub 角标：<a href=\"http://tholman.com/github-corners/\" title=\"@LINK\">GitHub Corners</a></p>\n<p>文章编辑器：<a href=\"https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md\" title=\"@LINK\">HexoEditor</a></p>\n","categories":["HexoDIY"],"tags":["Hexo","自定义"]},{"title":"算法-数列查找","url":"/post/algorithm/algorithm-find_from_series/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-数列查找\"><a href=\"#算法-数列查找\" class=\"headerlink\" title=\"算法-数列查找\"></a>算法-数列查找</h1><h2 id=\"1-从两个正序数组中找出中位数\"><a href=\"#1-从两个正序数组中找出中位数\" class=\"headerlink\" title=\"1. 从两个正序数组中找出中位数\"></a>1. 从两个正序数组中找出中位数</h2><p>说明：给定两个正序（从小到大）整数数组：<code>nums1 = int[n]</code>、<code>nums2 = int[m]</code>，找出这两个数组全部元素的中位数，假定两个数组均非空（<code>n, m &gt;= 0</code>），且不同时为空数组（<code>n + m &gt;= 1</code>）。</p>\n<blockquote>\n<p>例 1：</p>\n<p><code>nums1 = [1,3]</code>、<code>nums2 = [2]</code>；则合并后数组为 <code>[1, 2, 3]</code>，中位数为 2。</p>\n<p>例 2：</p>\n<p><code>nums1 = [1,2]</code>、<code>nums2 = [3,4]</code>；则合并后数组为 <code>[1, 2, 3, 4]</code>，中位数为 <code>(2 + 3) / 2 = 2.5</code>。</p>\n</blockquote>\n<h3 id=\"1-1-数组归并法\"><a href=\"#1-1-数组归并法\" class=\"headerlink\" title=\"1.1 数组归并法\"></a>1.1 数组归并法</h3><p>首先「归并」两个有序数组，假设数组长度分别为 <code>length1</code> 和 <code>length2</code>，归并后中位数下标为 <code>midIndex</code>。</p>\n<ul>\n<li>由于归并后元素个数 <code>sum</code> 可能为奇数或偶数，所以 <code>midIndex</code> 需要取更大的，确保包括中位数，<ul>\n<li>奇数个的中位数位于 <code>(sum / 2) + 1</code>，下标为 <code>sum / 2</code>；</li>\n<li>偶数个的中位数位于 <code>sum / 2</code> 和 <code>(sum / 2) + 1</code>，下标为 <code>(sum / 2) - 1</code> 和 <code>sum / 2</code>；</li>\n<li>取最大的，也就是 <code>midIndex = sum / 2</code>。</li>\n</ul>\n</li>\n<li>所以偶数个 <code>isEven == true</code> 时，可以记录 <code>value = merge[midIndex - 1]</code>，再累加 <code>value += merge[midIndex]</code>，然后遍历结束后，如果 <code>isEven == true</code>，则 <code>value /= 2</code>。</li>\n<li>但实际上，由于题目只需要查找中位数，所以只需要保证中位数及之前的元素有序即可，因此只需要排序 <code>midIndex + 1</code> 个元素，可以通过循环 <code>for (i = 0; i &lt;= midIndex; i++)</code> 来控制。由于题目给出两个数组都是正序排列（从小到大），可以每次都从两个数组中取一位最小的，直到一共取了 <code>midIndex + 1</code> 个元素为止，因此需要两个变量 <code>index1</code> 和 <code>index2</code> 分别记录两个数组下一次从哪个元素开始取。</li>\n<li>由于 <code>midIndex</code> 是两个数组归并后的中位数下标，所以从逻辑上可以确定一个特征：<ul>\n<li>如果循环到第 <code>i</code> 次时，一个数组已被取完，即 <code>index1 &gt;= length1</code> 或 <code>index2 &gt;= length2</code> 下标越界，但归并后数组元素个数仍然小于 <code>midIndex + 1</code> 个，则另一个数组的下标 <code>i</code> 一定还未越界。换句话说，从 <code>i = 0</code> 循环到 <code>i = midIndex</code> 的过程中，两个数组对下标 <code>i</code> 的取值不可能同时越界。</li>\n</ul>\n</li>\n<li>归并时从哪个数组取了元素，就将对应数组的 <code>index</code> 更新到该元素的下标，表示数组剩余元素最小值的下标。</li>\n</ul>\n<p>例如 <code>[1, 2]</code> 和 <code>[0, 3, 4, 5, 6]</code>，用 &gt; 表示两个数组归并过程中的的 <code>index</code>，一共有 7 个元素，则归并后的中位数下标 <code>midIndex == 3</code>；也即一共只需要归并 4 个元素即可：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">归并下标 <code>i</code></th>\n<th align=\"center\">merge</th>\n<th align=\"center\">nums1</th>\n<th align=\"center\">nums2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]</code></td>\n<td align=\"center\"><code>[&gt;1, 2]</code> <code>index1 = 0</code></td>\n<td align=\"center\"><code>[&gt;0, 3, 4, 5, 6]</code> <code>index2 = 0</code></td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[0]</code></td>\n<td align=\"center\"><code>[&gt;1, 2]</code> <code>index1 = 0</code></td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>[0, 1]</code></td>\n<td align=\"center\"><code>[1, &gt;2]</code> <code>index1 = 1</code></td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>[0, 1, 2]</code></td>\n<td align=\"center\"><code>[1, 2 &gt;]</code> <code>index1 = 2</code> 越界</td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>[0, 1, 2, 3]</code></td>\n<td align=\"center\"><code>[1, 2 &gt;]</code> <code>index1 = 2</code> 越界</td>\n<td align=\"center\"><code>[0, 3, &gt;4, 5, 6]</code> <code>index2 = 2</code></td>\n</tr>\n</tbody></table>\n<p>归并完成，中位数即为 <code>merge[midIndex] == merge[3] == 3</code>，如果元素总数为偶数，思路也是一样的，只是最终计算中位数为 <code>(merge[midIndex - 1] + merge[midIndex]) / 2</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Merge</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((nums1 == <span class=\"keyword\">null</span> || nums1.length == <span class=\"number\">0</span>) &amp;&amp; (nums2 == <span class=\"keyword\">null</span> || nums2.length == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 元素总个数：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sumLength = nums1.length + nums2.length;</span><br><span class=\"line\">        <span class=\"comment\">// 是否总共有偶数个元素，如果是，则需要累加中间的两个元素并除以二：</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isEven = (sumLength % <span class=\"number\">2</span> == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 中位数下标，如果共有奇数个则代表中位数本身，如果是偶数个则代表中间两个元素中下标更大的：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> midIndex = sumLength / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录两个数组分别归并到了第几位元素，也即接下来需要归并的第一位元素的下标：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录实际中位数的值，注意因为精确到小数，所以要用 double：</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> midValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录最新一个被归并的元素的值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">        <span class=\"comment\">// 只需要归并 midIndex + 1 次</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= midIndex; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 &gt;= nums1.length) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 数组 1 越界说明已经被归并完了，则下一位被归并的就是从数组 2 取接下来的第 1 位元素</span></span><br><span class=\"line\">                value = nums2[index2++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index2 &gt;= nums2.length) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 数组 2 越界说明已经被归并完了，则下一位被归并的就是从数组 1 取接下来的第 1 位元素</span></span><br><span class=\"line\">                value = nums1[index1++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则如果数组 1 接下来一位比数组 2 接下来一位更小，则取数组 1 的接下来一位</span></span><br><span class=\"line\">                value = nums2[index2++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则如果数组 2 接下来一位比数组 1 接下来一位更小，则取数组 2 的接下来一位</span></span><br><span class=\"line\">                value = nums1[index1++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果共有偶数个元素，则中位数需要取中间两位，因此在 i == midIndex - 1 时先赋值，</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则不处理相当于先赋了默认值 0。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isEven &amp;&amp; i == midIndex - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                midValue = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不论共有奇数个还是偶数个，都需要加上 midIndex 元素的值，为了兼容两种情况所以使用累加</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == midIndex) &#123;</span><br><span class=\"line\">                midValue += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 此时如果共有奇数个，则 midValue 就是最终中位数，否则 midValue 等于中间两个数的和，</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以如果是偶数个，还需要除以二：</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEven) &#123;</span><br><span class=\"line\">            midValue /= <span class=\"number\">2.0d</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> midValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-从数组中找出和为给定值的两个元素\"><a href=\"#2-从数组中找出和为给定值的两个元素\" class=\"headerlink\" title=\"2. 从数组中找出和为给定值的两个元素\"></a>2. 从数组中找出和为给定值的两个元素</h2><p>说明：给定一个整型数组 <code>nums</code>，找出「和为给定整数 <code>target</code>」的「两个」元素下标（忽略顺序）。数组中的每个元素不能被重复选择，假定每个输入有且仅有一个解。</p>\n<blockquote>\n<p>例 1:</p>\n<p><code>nums = [2, 7, 11, 15]</code>、<code>target = 9</code>，则输出 <code>[0, 1]</code> 或 <code>[1, 0]</code>。</p>\n<p>例 2:</p>\n<p><code>nums = [3, 3]</code>、<code>target = 6</code>，则输出 <code>[0, 1]</code> 或 <code>[1, 0]</code>。</p>\n</blockquote>\n<h3 id=\"2-1-双重循环暴力法\"><a href=\"#2-1-双重循环暴力法\" class=\"headerlink\" title=\"2.1 双重循环暴力法\"></a>2.1 双重循环暴力法</h3><p>用双重循环比较任意两个元素的和是否与给定的 <code>target</code> 相等，如果相等则直接返回两个元素对应的下标组成的新数组，否则返回一个默认值 <code>[0, 0]</code>，由于题目假定每个输入都会有且仅有一个解，因此可以假定一定会返回有效解。</p>\n<p>注意：由于双重循环，判断两个元素之和在内层循环中，找到有效解时应当直接跳出外层循环，所以应该使用「定义循环名」的方式，避免多用一个 <code>Flag</code> 变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DoubleLoop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 定义外层循环名</span></span><br><span class=\"line\">        outer:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 题目给出了 2 &lt;= nums.length &lt;= 10^4，所以不用判断 j = i + 1 是否越界</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到了，直接跳出外层循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span> outer;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;i, j&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Map哈希法\"><a href=\"#2-2-Map哈希法\" class=\"headerlink\" title=\"2.2 Map哈希法\"></a>2.2 Map哈希法</h3><p>因为主要目标是找到和等于 <code>target</code> 的两个元素，所以在确定其中一个元素 <code>nums[i]</code> 时，另一个元素「应该的取值」就已经确定为 <code>nums[j] = target - nums[i]</code>，假如存在则结果就为 <code>[i, j]</code>。所以问题可以转换为：每遍历到一个元素 <code>nums[i]</code> 时，都查找是否存在 <code>nums[j] = target - nums[i]</code>：</p>\n<ul>\n<li>遍历时将每个遍历过的元素及其对应下标都存入一个 Map；</li>\n<li>每遍历一个新的元素 <code>nums[i]</code> 时，计算 <code>nums[i]</code>「应该」匹配的数为 <code>diff = target - nums[i]</code>；</li>\n<li>判断是否存在 <code>Map.contains(diff)</code>；<ul>\n<li>如果存在，则获取这个数的下标 <code>j = Map.get(diff)</code>，然后返回 <code>[i, j]</code>。</li>\n<li>否则继续遍历，直到最终仍找不到匹配的两个元素，返回默认值（依照题意则不会遇到这种情况）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_MapHash</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; nums.length; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> diff = target - nums[index];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(diff)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;index, map.get(diff)&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[index], index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-数据库中查找图片","url":"/post/algorithm/algorithm-find_pictures/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-数据库中查找图片\"><a href=\"#算法-数据库中查找图片\" class=\"headerlink\" title=\"算法-数据库中查找图片\"></a>算法-数据库中查找图片</h1>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-查找子串","url":"/post/algorithm/algorithm-substring/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-查找子串\"><a href=\"#算法-查找子串\" class=\"headerlink\" title=\"算法-查找子串\"></a>算法-查找子串</h1><h2 id=\"1-最长无重复字符子串\"><a href=\"#1-最长无重复字符子串\" class=\"headerlink\" title=\"1. 最长无重复字符子串\"></a>1. 最长无重复字符子串</h2><p>说明：给定一个字符串，找出不含重复字符的最长子串的长度。</p>\n<blockquote>\n<p>例 1：</p>\n<p>“abcabcbb” 最长非重复子串为 “abc”，长度为 3。</p>\n<p>例 2：</p>\n<p>“” 最长非重复子串为 “”，长度为 0。</p>\n</blockquote>\n<h3 id=\"1-1-双重循环暴力法\"><a href=\"#1-1-双重循环暴力法\" class=\"headerlink\" title=\"1.1 双重循环暴力法\"></a>1.1 双重循环暴力法</h3><p>遍历每一个字符，并以该字符为起点，向后再次遍历整个字符串，如果下一个字符是新字符则当前子串长度 + 1，否则跳出内层循环，并比较当前子串和记录的最大子串长度，如果当前子串更长，则更新最长子串的长度记录。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DoubleLoop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 外层循环遍历整个字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> charIndex = <span class=\"number\">0</span>; charIndex &lt; charArray.length; charIndex++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxSubCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            String maxSubStr = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 内层循环从</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> subIndex = charIndex; subIndex &lt; charArray.length; subIndex++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxSubStr.contains(<span class=\"string\">&quot;&quot;</span> + charArray[subIndex])) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    maxSubCount++;</span><br><span class=\"line\">                    maxSubStr += charArray[subIndex];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxSubCount &gt; maxCount) &#123;</span><br><span class=\"line\">                maxCount = maxSubCount;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-滑动窗口法（List）\"><a href=\"#1-2-滑动窗口法（List）\" class=\"headerlink\" title=\"1.2 滑动窗口法（List）\"></a>1.2 滑动窗口法（List）</h3><p>用「窗口」的概念表示一段子串，左侧表示子串的起始字符，右侧表示子串的终止字符，窗口初始宽度为 0，遍历字符串，每次将右侧一个字符加入窗口，即窗口「右侧」向右「扩张」一个字符；</p>\n<ul>\n<li>如果窗口内子串仍符合条件，且长度大于记录的最大子串长度，则更新最大子串长度记录。</li>\n<li>否则窗口的「左侧」向右不断「缩小」，直到窗口内的子串再次符合条件为止。</li>\n</ul>\n<p>由于滑动窗口需要频繁修改窗口的起始和终止范围，所以可以用 List 来作为窗口，List 可以很方便操作首位和末尾，用 List 的首位表示窗口起始下标，List 的末位表示窗口终止下标。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_SlidingWindow_List</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Character&gt; charList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (charList.contains(s.charAt(index))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> repeatIndex = charList.indexOf(s.charAt(index));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> rmIndex = <span class=\"number\">0</span>; rmIndex &lt;= repeatIndex; rmIndex++) &#123;</span><br><span class=\"line\">                    charList.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                charList.add(s.charAt(index));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                charList.add(s.charAt(index));</span><br><span class=\"line\">                max = Math.max(max, charList.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-滑动窗口法（Map）\"><a href=\"#1-3-滑动窗口法（Map）\" class=\"headerlink\" title=\"1.3 滑动窗口法（Map）\"></a>1.3 滑动窗口法（Map）</h3><p>用「窗口」的概念表示一段子串，左侧表示子串的起始字符，右侧表示子串的终止字符，窗口初始宽度为 0，遍历字符串，每次将右侧一个字符加入窗口，即窗口「右侧」向右「扩张」一个字符；</p>\n<ul>\n<li>如果窗口内子串仍符合条件，且长度大于记录的最大子串长度，则更新最大子串长度记录。</li>\n<li>否则窗口的「左侧」向右不断「缩小」，直到窗口内的子串再次符合条件为止。</li>\n</ul>\n<p>使用 List 解法最大的问题在于，如果新加入一个字符后，窗口内子串不满足条件，也即与窗口内第 <code>i</code> 个字符重复，则需要一个内层循环从窗口的首位 0 一直 <code>remove</code> 到第 <code>i</code> 个元素。因此可以改用 Map，用一个单独的变量 <code>left</code> 保存窗口的起始下标（终止下标就是当前遍历的字符下标）；</p>\n<ul>\n<li>每次窗口成功扩张时（说明新字符加入后满足条件），都记录新的字符 <code>char</code> 及其对应的下标 <code>i</code>，并且比较 <code>left</code> 到新字符下标的长度是否大于记录的最大子串长度，如果是则更新最大子串长度记录。</li>\n<li>否则可以直接通过 <code>Map.get(char)</code> 一步获取到子串中重复字符的下标 <code>i</code>;<ul>\n<li>直接将 <code>left</code> 指向子串中重复字符的下一位 <code>i + 1</code>；</li>\n<li>将新的字符（即重复的字符）的下标更新到 Map 中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：<code>left</code> 始终只会向右移动。</strong> 由于采用 Map 记录字符及对应下标，所以发现重复字符时，<code>left</code> 直接移动到窗口内子串的重复字符下一位，这就导致 <code>last left</code> 到 <code>new left</code> 中间的字符，在 Map 中的下标并没有更新也没有被移除，而下一个字符有可能命中这中间的字符，也即 <code>Map.contains(char) == true</code>，但实际上窗口已经不包括这些字符了，也即 <code>left</code> 指向的下标已经大于这些重复字符的下标，因此这种情况下即使 <code>Map.contains(char) == true</code>，也不应该视为字符重复，所以仅当 <code>Map.get(char) &gt;= left</code> 时，才应该更新 <code>left</code>。</p>\n<p>例如 “abba”，用 <code>[]</code> 表示滑动窗口，其包括的就是满足条件的子串；<code>left</code> 表示窗口左侧字符的下标；<code>max</code> 表示满足条件的最长子串长度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">遍历下标 <code>i</code></th>\n<th align=\"center\">滑动窗口</th>\n<th align=\"center\">窗口状态</th>\n<th align=\"center\">left</th>\n<th align=\"center\">max</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]abba</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[a]bba</code></td>\n<td align=\"center\">正确，<code>Map(a) = 0</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>i - left + 1 == 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>[ab]ba</code></td>\n<td align=\"center\">正确，<code>Map(b) = 1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>i - left + 1 == 2</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>[abb]a</code></td>\n<td align=\"center\">字符重复，将 left 指向重复字符下一位</td>\n<td align=\"center\"><code>Map(b) + 1 == 2</code></td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ab[b]a</code></td>\n<td align=\"center\">更新重复字符的 Map 下标，<code>Map(b) = 2</code></td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>ab[ba]</code></td>\n<td align=\"center\">正确，尽管字符 “a” 重复，但不在窗口内（<code>Map(a) == 0 &lt; left == 2</code>），不更新 <code>left</code></td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_SlidingWindow_Map</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录遍历过的字符及对应的下标，用于遇到重复字符时，直接移动窗口起始下标到子串重复位的下一位。</span></span><br><span class=\"line\">        Map&lt;Character, Integer&gt; charMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 表示当前有效子串的起始下标，配合最新字符下标可计算窗口范围（即子串长度）。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最大窗口范围（即子串长度）。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> next = s.charAt(index);</span><br><span class=\"line\">            <span class=\"comment\">// 只有存在该字符「且记录的位置大于当前窗口起始坐标时」才移动窗口，否则例如 abba：</span></span><br><span class=\"line\">            <span class=\"comment\">//   - 当 index == 2，left = get(b) + 1 = 2，</span></span><br><span class=\"line\">            <span class=\"comment\">//   - 当 index == 3，left = get(a) + 1 = 1，显然不对，此时应该让 left 保持为 2。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (charMap.containsKey(next) &amp;&amp; charMap.get(next) &gt;= left) &#123;</span><br><span class=\"line\">                left = charMap.get(next) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                max = Math.max(max, (index - left + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不论是否重复都需要记录，如果重复了就需要更新</span></span><br><span class=\"line\">            charMap.put(next, index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-最长回文子串\"><a href=\"#2-最长回文子串\" class=\"headerlink\" title=\"2 最长回文子串\"></a>2 最长回文子串</h2><p>说明：从给定的字符串中找出最长的回文子串，假定字符串一定不为空，即 <code>s.length() &gt;= 1</code>。</p>\n<blockquote>\n<p>例 1：</p>\n<p>输入 “babad”，输出 “bab” 或 “aba”</p>\n<p>例 2：</p>\n<p>输入 “cbbd”，输出 “bb”</p>\n</blockquote>\n<h3 id=\"2-1-中心扩散法\"><a href=\"#2-1-中心扩散法\" class=\"headerlink\" title=\"2.1 中心扩散法\"></a>2.1 中心扩散法</h3><p>遍历每个字符，比较「中心字符」向左和向右 n 个字符是否相等；</p>\n<ul>\n<li>如果相等并且长度大于记录的最大长度，则更新最大长度记录；<ul>\n<li>重复该比较，直到遇到不想等的字符为止。</li>\n</ul>\n</li>\n<li>否则遍历到下一个字符重复上述判断。</li>\n</ul>\n<p>注意：因为同一个字符重复也可以算作回文，所以「中心字符」并不一定只是「1 个」字符，也可能是几个重复的字符，因此在寻找下一个中心字符时，需要先向左右判断是否有重复字符，如果有则合并到「中心」，因此开始扩散前，需要先记录「中心字符」的左侧下标和右侧下标。</p>\n<p>例如 <code>s = &quot;acbbcd&quot;</code>，用 <code>[]</code> 表示中心字符，<code>max</code> 表示当前中心字符最长子串长度，<code>maxSub</code> 表示最终解的最长子串长度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">遍历下标 <code>i</code></th>\n<th align=\"center\">扩散中心</th>\n<th align=\"center\">中心范围</th>\n<th align=\"center\">状态</th>\n<th align=\"center\"><code>sub</code></th>\n<th align=\"center\"><code>maxSub</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]acbbcd</code></td>\n<td align=\"center\"><code>left = 0</code> <code>right = 0</code></td>\n<td align=\"center\">初始化</td>\n<td align=\"center\">“”</td>\n<td align=\"center\">“”</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[a]cbbcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“a”</td>\n<td align=\"center\">“a”</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>a[c]bbcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“c”</td>\n<td align=\"center\">“c”</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>ac[b]bcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[i] == s[right]</code> 需要向右合并中心</td>\n<td align=\"center\">“b”</td>\n<td align=\"center\">“b”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ac[bb]cd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] == s[right]</code> 可以向左右扩散</td>\n<td align=\"center\">“bb”</td>\n<td align=\"center\">“bb”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>a[cbbc]d</code></td>\n<td align=\"center\"><code>left--</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“cbbc”</td>\n<td align=\"center\">“cbbc”</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>acb[b]cd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[i] == s[left]</code> 需要向左合并中心</td>\n<td align=\"center\">“b”</td>\n<td align=\"center\">“cbbc”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ac[bb]cd</code></td>\n<td align=\"center\"><code>left--</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] == s[right]</code> 可以向左右扩散</td>\n<td align=\"center\">“bb”</td>\n<td align=\"center\">“cbbc”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>a[cbbc]d</code></td>\n<td align=\"center\"><code>left--</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“cbbc”</td>\n<td align=\"center\">“cbbc</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><code>acbb[c]d</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“c”</td>\n<td align=\"center\">“cbbc”</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><code>acbbc[d]</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">“d”</td>\n<td align=\"center\">“cbbc”</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_CenterSpread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串</span></span><br><span class=\"line\">        String maxSub = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的回文子串</span></span><br><span class=\"line\">        String sub = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的左侧下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的右侧下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            left = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            right = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 最长子串至少也是当前字符</span></span><br><span class=\"line\">            sub = <span class=\"string\">&quot;&quot;</span> + s.charAt(i);</span><br><span class=\"line\">            <span class=\"comment\">// 先向左寻找，与当前字符重复的字符都纳入「中心字符」，直到遇到第一个不重复的为止。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(left) == s.charAt(i)) &#123;</span><br><span class=\"line\">                sub = s.charAt(left) + sub;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再向右寻找，与当前字符重复的字符都纳入「中心字符」，直到遇到第一个不重复的为止。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (right &lt; s.length() &amp;&amp; s.charAt(right) == s.charAt(i)) &#123;</span><br><span class=\"line\">                sub = sub + s.charAt(right);</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 然后同时向两边扩散，如果两侧字符相等，则都纳入子串，直到遇到不相等的一对。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                sub = s.charAt(left) + sub + s.charAt(right);</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前「中心字符」的回文子串大于记录的最长子串，则更新记录。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub.length() &gt; maxSub.length()) &#123;</span><br><span class=\"line\">                maxSub = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSub;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-动态规划法\"><a href=\"#2-2-动态规划法\" class=\"headerlink\" title=\"2.2 动态规划法\"></a>2.2 动态规划法</h3><p>中心扩散法最主要的问题，是每次遍历时都需要重复向左右两边合并中心、比较两侧、判断扩散等。但实际上，如果有一段回文子串 <code>sub</code>，并且该子串的左侧字符 <code>s[left]</code> 和右侧字符 <code>s[right]</code> 相等，那么 <code>s[left] + sub + s[right]</code> 也是一段回文子串。</p>\n<p>反过来说，假如 <code>s[left] + sub + s[right]</code> 是一段回文子串，则需要满足 <code>s[left] == s[right]</code>，以及 <code>sub</code> 也是一段回文子串。</p>\n<p>再进一步：</p>\n<ul>\n<li>当 <code>s[left] != s[right]</code> 时，则 <code>s[left]...s[right]</code> 这段范围的子串「一定不是」回文子串。</li>\n<li>当 <code>s[left] == s[right]</code> 时，假设被 <code>s[left]</code> 和 <code>s[right]</code> 包住的中间的字符串是 <code>sub</code>，那么如果 <code>sub</code> 是回文子串，则 <code>s[left]...s[right]</code> 就是回文子串，否则就不是。</li>\n</ul>\n<p>因此，如果 <code>s[left]...s[right]</code> 是回文子串，则需要满足 <code>s[left] == s[right]</code>，并且 <code>s[left + 1]...s[right - 1]</code> 也是回文子串，这就产生了递归推导。</p>\n<p>注意：这种思路下，需要规定 <code>right</code> 一定不小于 <code>left</code>，可以通过两层循环控制。此外，还需要区分不同情况：</p>\n<ul>\n<li>只选中 1 个字符，即 <code>left == right</code>，这种情况肯定是回文子串。</li>\n<li>选中 2 个字符，即 <code>right - left == 1</code>，这种情况如果 <code>s[left] == s[right]</code> 则是回文子串，否则不是。</li>\n<li>选中 3 个或以上字符，即 <code>right - left &gt;= 2</code>，这种情况则仅当 <code>s[left] == s[right]</code> 并且 <code>s[left + 1]...s[right - 1]</code> 也是回文子串时，<code>s[left]...s[right]</code> 才是回文子串；<ul>\n<li>然后再对 <code>s[left + 1]...s[right - 1]</code> 同样采用上述步骤递归判断。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DynamicProgramming</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串在原字符串的起始下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSubLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSubLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用一个二维数组 dp[left][right] 表示从 s[left]...s[right] 是否为回文子串，</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[left][right] 初始化时默认值全为 false。</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length()][s.length()];</span><br><span class=\"line\">        <span class=\"comment\">// 因为 dp[left][right] 数组的定义，right 一定大于等于 left</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> right = <span class=\"number\">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>; left &lt;= right; left++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果 s[left] == s[right]，分为三种情况</span></span><br><span class=\"line\">                <span class=\"comment\">// （1）left == right</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示当前 1 个字符，则肯定是回文子串，dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"comment\">// （2）right - left = 1</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示 2 个相邻重复字符，既然相等则肯定也是回文子串，dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"comment\">// （3）right - left &gt; 1</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示子串至少包含 3 个字符，例如 aba 或 abba，则这个子串是否为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">//     依赖于 s[left + 1]...s[right - 1] 是否为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">//     即依赖于 dp[left + 1][right - 1] 是否为 true。</span></span><br><span class=\"line\">                <span class=\"comment\">// 以上情况（1）和情况（2），都能直接确定 dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 对应情况（1）和情况（2）</span></span><br><span class=\"line\">                        dp[left][right] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dp[left + <span class=\"number\">1</span>][right - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 对应情况（3）</span></span><br><span class=\"line\">                        dp[left][right] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// dp[left][right] 数组初始化时默认所有元素都是 false，</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以如果 dp[left][right] == true，</span></span><br><span class=\"line\">                <span class=\"comment\">// 就表示上面的条件种判断了 s[left]...s[right] 为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则如果这个回文子串的长度大于记录的最大长度，就可以更新记录。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[left][right] &amp;&amp; right - left + <span class=\"number\">1</span> &gt; maxSubLength) &#123;</span><br><span class=\"line\">                    maxSubLeft = left;</span><br><span class=\"line\">                    maxSubLength = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// String#substring(startIndex, endIndex) 返回的是一个 [左闭, 右开) 区间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(maxSubLeft, maxSubLeft + maxSubLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-求和问题","url":"/post/algorithm/algorithm-sum_of_numbers/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-求和问题\"><a href=\"#算法-求和问题\" class=\"headerlink\" title=\"算法-求和问题\"></a>算法-求和问题</h1><h2 id=\"1-两个List表示的数字求和\"><a href=\"#1-两个List表示的数字求和\" class=\"headerlink\" title=\"1. 两个List表示的数字求和\"></a>1. 两个List表示的数字求和</h2><p>说明：给定两个「非空」链表，「逆序」存储两个「非负」整数，每个节点仅存储「一位」数字，除了数字 0 以外都不会以 0 开头，请以相同方式返回一个新的链表，表示两个数的和。</p>\n<blockquote>\n<p>例 1：</p>\n<p>[2 -&gt; 4 -&gt; 3] + [5 -&gt; 6 -&gt; 4] = [7 -&gt; 0 -&gt; 8]</p>\n<p>题解：342 + 465 = 807</p>\n</blockquote>\n<p>列表节点的数据结构为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val, ListNode next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-循环解法\"><a href=\"#1-1-循环解法\" class=\"headerlink\" title=\"1.1 循环解法\"></a>1.1 循环解法</h3><p>由于题目给出链表是「逆序」，因此头部节点表示的是实际数字的末位，所以可以直接从两个链表的头部节点开始循环，逐个节点位移，每次都对两个链表同一位的节点求和，并判断进位，如果其中一个链表已经结束，则可以视其对应位的值为 0，直到两个链表都已结束。</p>\n<p>注意：对两个链表按位遍历求和结束后，还需要对最终结果判断一次进位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Loop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode result = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode resultNext = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> || l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对 result 的扩展需要在下一轮的循环初始判断，如果能进入下一轮循环说明 result 还需要新增节点，</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则在尾部扩展可能下一轮循环不满足条件退出，导致 result 多出一个 0 节点（默认值）。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resultNext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// resultNext == null 说明是第一次进入循环，则 next 就等于头节点。</span></span><br><span class=\"line\">                resultNext = result;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// resultNext != null 说明进入新一轮循环，说明还有节点需要求和，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则令创建一个新的 result 节点并拼接到 result 链表的尾部。</span></span><br><span class=\"line\">                resultNext.next = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">                resultNext = resultNext.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任意一条链表已经结束，则按 0 取值。</span></span><br><span class=\"line\">            sum = getVal(l1) + getVal(l2);</span><br><span class=\"line\">            <span class=\"comment\">// 上一轮循环是否需要进位，如果需要则 + 1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needAdd) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 对当前位的节点求和并加了进位后，再判断是否大于等于 10，是则继续进位。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                sum %= <span class=\"number\">10</span>;</span><br><span class=\"line\">                needAdd = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            resultNext.val = sum;</span><br><span class=\"line\">            <span class=\"comment\">// 为下一轮循环准备需要求和的节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 循环结束后，还需要对是否有最后一个进位做判断，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此需要确保最后进位的是链表最末端的 next 节点，</span></span><br><span class=\"line\">        <span class=\"comment\">// 但有可能没有进循环导致 resultNext 为空，所以需要多一层判断。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultNext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resultNext = result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needAdd) &#123;</span><br><span class=\"line\">            resultNext.next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getVal</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (node == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-递归解法\"><a href=\"#1-2-递归解法\" class=\"headerlink\" title=\"1.2 递归解法\"></a>1.2 递归解法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Recursion</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录是否需要进位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 使用递归的方式，将该方法的返回值作为结果链表的「next」节点。</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个链表均便利完成，且没有进位，说明运算结束，也即「next」为 null。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span> &amp;&amp; l2 == <span class=\"keyword\">null</span> &amp;&amp; !needAdd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 计算 l1 和 l2 当前节点的和（以及前一项是否有进位）</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = getVal(l1) + getVal(l2) + (needAdd ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// sum 除以 10 大于零表示需要进位</span></span><br><span class=\"line\">        needAdd = (sum / <span class=\"number\">10</span>) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录「next」节点的值，如果是第一个节点，则「next」就表示首个节点。</span></span><br><span class=\"line\">        ListNode next = <span class=\"keyword\">new</span> ListNode(sum %= <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 递归获取「next.next」节点</span></span><br><span class=\"line\">        next.next = addTwoNumbers((l1 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : l1.next), (l2 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : l2.next));</span><br><span class=\"line\">        <span class=\"comment\">// 所有节点的「next」节点都递归获取后，返回首节点。</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于递归时声明的 next 是在方法体内的，所以最终返回的 next 是最外层的 next，即首节点。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getVal</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (node == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-大数相加\"><a href=\"#2-大数相加\" class=\"headerlink\" title=\"2. 大数相加\"></a>2. 大数相加</h2>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-运输和消耗最优解问题","url":"/post/algorithm/algorithm-transport_and_consume/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-运输和消耗最优解问题\"><a href=\"#算法-运输和消耗最优解问题\" class=\"headerlink\" title=\"算法-运输和消耗最优解问题\"></a>算法-运输和消耗最优解问题</h1>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"Java类加载机制","url":"/post/java/java-class/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java类加载机制\"><a href=\"#Java类加载机制\" class=\"headerlink\" title=\"Java类加载机制\"></a>Java类加载机制</h1><h1 id=\"ClassLoader原理\"><a href=\"#ClassLoader原理\" class=\"headerlink\" title=\"ClassLoader原理\"></a>ClassLoader原理</h1><p><a href=\"http://blog.sina.com.cn/s/blog_6383597b0100fsiw.html\">http://blog.sina.com.cn/s/blog_6383597b0100fsiw.html</a></p>\n<p>ClassLoader 查找类的步骤：<a href=\"https://blog.csdn.net/hngmduyi/article/details/84292549\">https://blog.csdn.net/hngmduyi/article/details/84292549</a></p>\n<p>JVM启动时，运行BootStrap ClassLoader，用于加载Java核心API，BootStrap ClassLoader还会加载另外两个ClassLoader：Extension ClassLoader（用于加载扩展的Java Class，例如JavaX开头的包和存放在JRE的ext目录下的类等）、Application ClassLoader（也叫System ClassLoader，用于加载应用程序自身的类，比如ClassPath目录下定义的Class文件），这三个ClassLoader在加载Class文件时采用双亲委托模式，每一个ClassLoader都继承自ClassLoader抽象类，且都有一个parent ClassLoader，有一个getParent()方法用于返回双亲ClassLoader，如果getParent()为null，则认为该ClassLoader的Parent就直接是BootStrap ClassLoader。所有的ClassLoader在加载class之前，都会先委托它的双亲ClassLoader加载，只有Parent无法加载时，才由它加载。</p>\n<ul>\n<li>为什么要用双亲委托式？</li>\n</ul>\n<p>出于安全考虑。假如不使用双亲委托，用户自己写了一个java.lang.system的类并加入到ClassPath中，就会被System ClassLoader加载进来，那用户就能随意操控系统了。而使用双亲委托后，即使用户把这样的Class放进了ClassPath中，System ClassLoader会首先请求它的Parent，也就是BootStrap ClassLoader来加载这样的类，但是由于Android关键的一些类，都已经被封装进了系统，因此BootStrap ClassLoader已经加载过了系统里面的关键类，则会跳过这样的非法加载。</p>\n<hr>\n<h1 id=\"34-热修复（热更新）的原理\"><a href=\"#34-热修复（热更新）的原理\" class=\"headerlink\" title=\"34. 热修复（热更新）的原理\"></a>34. 热修复（热更新）的原理</h1><h2 id=\"代码替换\"><a href=\"#代码替换\" class=\"headerlink\" title=\"代码替换\"></a>代码替换</h2><p>两个方案：Native替换和Dex插桩。</p>\n<p>（1）Native替换</p>\n<p>例如阿里的AndFix，是先在Native层找到需要修复的方法的结构体，然后改变其NativeFunc字段值，这个值是用来指定JVM执行方法时在Native层对应的指针位置，也即：Native层在执行代码的时候，不同的方法存在内存中由Native层的指针指向不同的地址里，修改了某个方法后，将新的方法的NativeFunc字段指定为旧方法的，使得Native指针指向的方法所在的内存为新方法所在的内存，来达到替换的效果。</p>\n<p>优点是不需要重启就能生效，是基于方法级别的修复。<br>缺点是不能新增变量和类、方法等，因为如果新增了方法或类，就会导致编译后的Dex中方法数发生变化，则 <code>dexElements[]</code> 中方法的索引就会变化，原来的索引对应的方法就可能发生错乱。</p>\n<p>（2）Dex插桩</p>\n<p>在编译 Android 代码时，会把代码编译成 dex 字节码，Android 在运行一个 App 时，会通过 ClassLoader 来加载 dex 文件，加载时，越靠前的Dex优先被使用，因此可以通过把热更新后的类或方法编译成的 patch.dex 文件插入到 <code>dexElements[]</code> 数组的头部使得虚拟机只加载修复后的类。</p>\n<p>优点是可以做较大的改动，稳定性高，不会侵入进程（因为需要重启才生效）。<br>缺点是影响性能，安装APK时，如果某个Dex中的类，在static方法、private方法、构造方法、override方法中引用的对象，也在同一个Dex文件内，则虚拟机会给该Class打上CLASS_ISPREVERIFIED已验证标签，运行时对应的对象就直接在当前Dex中找，否则没有打上标签的类，在运行时，就需要遍历所有的Dex查找，会影响性能。但热修复时，打出来的patch.dex，只包含了修复的class，所以绝大部分情况下，是不能打CLASS_ISPREVERIFIED标志的，否则在运行时，在patch.dex中找不到引用的对象，会抛出IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation错误。所以需要强制不打标志，不打标志就会导致在加载的时候要遍历所有的Dex，因此影响性能。</p>\n<h2 id=\"资源替换\"><a href=\"#资源替换\" class=\"headerlink\" title=\"资源替换\"></a>资源替换</h2><p>（1）资源的加载是通过 AssetManager 实现的，通过反射调用addAssetPath，将完整的新资源包加入到AssetManager中来替换掉整个AssetManager中持有的资源。然后查找所有引用了旧AssetManager的地方，通过反射替换为新的AssetManager的引用。</p>\n<p>（2）SO库的修复本质上就是对Native方法的修复和替换，把新SO库的路径插入到<code>NativeLibraryDirectories[]</code> 数组的最前面，就能使得Native层加载SO时加载的是新的SO库。</p>\n","categories":["Java"],"tags":["Java"]},{"title":"Java-finally关键字","url":"/post/java/java-finally/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-finally关键字\"><a href=\"#Java-finally关键字\" class=\"headerlink\" title=\"Java-finally关键字\"></a>Java-finally关键字</h1><h2 id=\"1-finally和return的执行顺序\"><a href=\"#1-finally和return的执行顺序\" class=\"headerlink\" title=\"1. finally和return的执行顺序\"></a>1. finally和return的执行顺序</h2><p>一句话总结：当 <code>try - catch</code> 中使用 <code>break</code> 或 <code>return</code> 返回时，<code>finally</code> 会执行，当调用了 <code>System.exit(0)</code> 退出时，由于直接终止了 JVM，因此 <code>finally</code> 不会执行。</p>\n<p>在 try - catch 中的 return 语句执行之后、方法返回之前，程序会将 return 的返回值写入内存中，然后等待 finally 语句执行完，如果在 finally 代码块中，只改变了引用（例如对变量重新赋值），由于 return 时已经将返回值写入了内存中，则不会改变，而如果是改变了同一个变量的值，则会改变。如果 finally 中包含 return 语句，则会覆盖原本的return。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 10。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 20。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringBuilder <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;AAA&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sb.append(<span class=\"string\">&quot;BBB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;CCC&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 “AAABBBCCC”。</p>\n","categories":["Java"],"tags":["Java","finally"]},{"title":"JVM的GC策略","url":"/post/java/java-gc/","content":"<span id=\"more\"></span>\n\n<h1 id=\"JVM的GC策略\"><a href=\"#JVM的GC策略\" class=\"headerlink\" title=\"JVM的GC策略\"></a>JVM的GC策略</h1><p>前言：GC 即：Garbage Collection 垃圾回收，是 JVM 中非常必要的一个机制，之所以需要 GC，是因为程序在运行中，会产生很多 Garbage，而 JVM 的内存是有限制的，如果不及时对这些 Garbage 进行整理和清除，会使得内存占用越来越大，最后导致没有足够的内存生成新的对象。GC 中有一个很重要的前提：Stop-The-World，也即：JVM 由于要执行 GC 而停止了应用程序的执行。当 GC 发生时，除了 GC 所需的线程外，其他所有线程都处于等待状态直到 GC 任务完成。而通常做 GC 优化的目的，就是减少 GC 发生，以减少卡顿。</p>\n<hr>\n<h2 id=\"1-GC的两种核心判定原则\"><a href=\"#1-GC的两种核心判定原则\" class=\"headerlink\" title=\"1. GC的两种核心判定原则\"></a>1. GC的两种核心判定原则</h2><h3 id=\"1-1-引用计数\"><a href=\"#1-1-引用计数\" class=\"headerlink\" title=\"1.1 引用计数\"></a>1.1 引用计数</h3><p>引用计数也即：为实际内存中存储的对象所具有引用记录引用数，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略类 A 和 B 之间的关系</span></span><br><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b = a;</span><br></pre></td></tr></table></figure>\n\n<p>此时，<code>new A()</code> 执行后在内存中实际存储的对象数据，就具有了 <code>a</code> 和 <code>b</code> 两个引用，则其引用计数为 2，而 <code>new B()</code> 生成的实际对象数据则引用计数为 0。</p>\n<p>引用计数法的核心思想即：一个对象，每增加一个引用，则引用计数 +1，每减少一个引用，则引用计数 -1，任何时刻，计数值为 0 的对象，就是不可再使用的（例如，<code>b = a;</code> 后，原本 <code>new</code> 出来的 <code>B</code> 对象，就无法再通过代码获取到了），即可马上将自己当做空闲空间链接到空闲链表。</p>\n<h3 id=\"1-2-引用链\"><a href=\"#1-2-引用链\" class=\"headerlink\" title=\"1.2 引用链\"></a>1.2 引用链</h3><p>提出一个初始根节点对象的概念：GC Root，当一个对象产生时，会将其建立与 GC Root 的直接或间接连接，例如一个外部类可能直接连接 GC Root，而该类的子类则先连接到该类，再连接到 GC Root。也就是说，GC Root 本身也是对象，只是这些对象，在整个程序运行期间，都有用或不会被销毁，那么与这些对象相连接的对象，则说明是有用的，则不需要被回收。而某些对象与这些 GC Roots 没有连接，则说明这些对象不是必要的，则 GC 可以回收。这些引用关系，被称为：<strong>引用链</strong>。</p>\n<p>例如：通常一个 Java 程序，都是从 <code>main</code> 方法开始执行，可以将 <code>main</code> 方法的实际内存引用作为 GC Root，如果在 <code>main</code> 方法中声明两个对象：<code>A a;</code> 和 <code>B b;</code>，则 <code>a</code> 和 <code>b</code> 都是与 <code>main</code> 相连接的平行平级的对象，这时如果执行：<code>b = a;</code>，则将内存中 <code>a</code> 的实际引用（指向内存中的实际数据）赋值给了 <code>b</code>，则原本 <code>b</code> 的引用（内存中实际的一个 <code>B</code> 的对象）被中断，此时的引用链则是：</p>\n<p><code>main</code> 连接到平行平级的 <code>a</code> 和 <code>b</code>，然后 <code>a</code> 和 <code>b</code> 同时连接到内存中 <code>A</code> 的实际对象，而内存中 <code>B</code> 的实际对象则失去任何引用。</p>\n<p>当一个对象，可以连接到 GC Root，则称之为是“可达的”，或“具有可达性”，否则为“不可达”或“不具有可达性”。</p>\n<hr>\n<h2 id=\"2-常见的GC算法\"><a href=\"#2-常见的GC算法\" class=\"headerlink\" title=\"2. 常见的GC算法\"></a>2. 常见的GC算法</h2><p>常见的 GC 算法有：引用计数法、标记清除法、复制法、标记整理法、分代收集法。</p>\n<h3 id=\"2-1-引用计数法\"><a href=\"#2-1-引用计数法\" class=\"headerlink\" title=\"2.1 引用计数法\"></a>2.1 引用计数法</h3><p>即是通过判断引用计数是否为 0 来决定是否回收，引用计数法最致命的缺点，是当发生循环引用时，无法回收无用对象。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">a.friend = b;</span><br><span class=\"line\">b.friend = a;</span><br></pre></td></tr></table></figure>\n\n<p>则 <code>a</code> 和 <code>b</code> 二者互相引用，执行完这段代码后，其引用计数始终不为 0，则 GC 始终无法回收。</p>\n<h3 id=\"2-2-标记清除法\"><a href=\"#2-2-标记清除法\" class=\"headerlink\" title=\"2.2 标记清除法\"></a>2.2 标记清除法</h3><p>标记清除法分为“标记”和“清除”两个阶段。</p>\n<ul>\n<li>标记阶段，从 GC Root 出发，遍历所有的子节点，并将所有可达的对象进行标记。</li>\n<li>清除阶段，遍历所有的对象，将未标记的对象回收。</li>\n</ul>\n<p>标记清除法最致命的缺点是：多次 GC 会导致内存碎片化，即空闲内存在实际内存中不是连续的，导致当有大内存对象产生时，无法找到足够的连续内存而又一次触发 GC。</p>\n<h3 id=\"2-3-复制法\"><a href=\"#2-3-复制法\" class=\"headerlink\" title=\"2.3 复制法\"></a>2.3 复制法</h3><p>将内存划分为大小相等的两个区域，每次只使用其中一半，当 GC 发生时，找出其中存活的对象，按照顺序复制到另一半内存中连续的区域，然后直接把之前的一半内存清空，这样就不会出现内存碎片的情况。这种方案适用于大部分对象生命周期都比较短的情况，例如新生代中的对象，而当遇到极端情况，例如一半的内存中，在 GC 时所有的对象都存活，则直接把这一半内存全部复制到另一半，结果还是全部存活，又要复制回来···，实际上就是浪费了 50% 的空间，所以像老年代（存放经过多次 GC 后仍然存活的对象，所以这些对象被 GC 后仍然存活的几率很高）就不能用这种方案。</p>\n<h3 id=\"2-4-标记整理法\"><a href=\"#2-4-标记整理法\" class=\"headerlink\" title=\"2.4 标记整理法\"></a>2.4 标记整理法</h3><p>标记整理法和标记清除法类似，都是通过遍历标记所有可达的对象，但不是直接清理掉不可达对象，而是将所有含有标记的对象，向内存的一侧移动，用空闲指针来标记最后一个存活对象，然后清理掉空闲指针之后的内存空间，这样清理后的空闲内存则是连续的一段。</p>\n<h3 id=\"2-5-分代收集法\"><a href=\"#2-5-分代收集法\" class=\"headerlink\" title=\"2.5 分代收集法\"></a>2.5 分代收集法</h3><p>首先需要明确的是，分代收集法本质上并不是一种 GC 算法，对于一个复杂的系统，例如 JVM，只是用一种单一的 GC 算法是不足以应对所有场景的，因此需要针对多个场景制定一套算法，而分代收集法就是基于这个理念创立的。</p>\n<p>堆区本身有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n","categories":["Java"],"tags":["Java","GC","垃圾回收"]},{"title":"Java-HashCode","url":"/post/java/java-hashcode/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-HashCode\"><a href=\"#Java-HashCode\" class=\"headerlink\" title=\"Java-HashCode\"></a>Java-HashCode</h1><h2 id=\"1-Equals和-的区别\"><a href=\"#1-Equals和-的区别\" class=\"headerlink\" title=\"1. Equals和==的区别\"></a>1. Equals和==的区别</h2><p><code>==</code> 仅在相比较的对象就是自己本身时，才返回 <code>true</code>。而 <code>equals</code> 是 Object 类中的方法，其返回值可以根据需求定义，默认情况下，<code>equals</code> 返回的也是 <code>==</code> 的值，但在像 HashMap、Array 中等则会返回 key 或 value 是否相等。</p>\n<p>由于 String 和常数是存放在常量池，因此直接比较 String 的值时，相同的字符串两个都会返回 <code>true</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String sa = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">String sb = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">String sc = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">String sd = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sa == sb <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">sa.equals(sb) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">sc == sd <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">sc.equals(sd) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">42</span> == <span class=\"number\">42.00</span> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-为什么要同时重写equals-和hashcode\"><a href=\"#2-为什么要同时重写equals-和hashcode\" class=\"headerlink\" title=\"2. 为什么要同时重写equals()和hashcode()\"></a>2. 为什么要同时重写equals()和hashcode()</h2><p>默认情况下，equals比较的是两个对象的内存地址是否相等，重写equals 方法通常是转换成比较值是否相等，如果重写了equals方法而不重写hashcode方法，默认情况下hashcode是根据对象的内存地址计算的，则可能出现equals为true而hashcode不相等的情况，这和hashcode的本意是不符的。HashCode不相等的两个对象一定不相等，相等的两个对象HashCode一定向等。</p>\n<p>（1）为什么要有HashCode方法？</p>\n<p>可以根据HashCode来判断两个对象是否相等，而不需要依次比较equals。switch判断String时，判断的是hashCode。</p>\n<p>（2）hash算法的原理是什么？</p>\n<p>（3）在Java中哪些地方用到了HashCode？</p>\n","categories":["Java"],"tags":["Java","Equals"]},{"title":"Java-HashMap","url":"/post/java/java-hashmap/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-HashMap\"><a href=\"#Java-HashMap\" class=\"headerlink\" title=\"Java-HashMap\"></a>Java-HashMap</h1><h2 id=\"1-哈希散列表\"><a href=\"#1-哈希散列表\" class=\"headerlink\" title=\"1. 哈希散列表\"></a>1. 哈希散列表</h2><p>HashMap的最基本原理就是哈希表，哈希表也就是，把一组不相干的数据，通过哈希函数计算后，映射到一个数组中，这样通过数组下标就能直接确认原来数据的存储位置。但哈希映射有可能会导致哈希碰撞，解决方案有：开放定址法、再散列函数法、链地址法，而HashMap采用的是链地址法。</p>\n<h3 id=\"1-1-开放定址法\"><a href=\"#1-1-开放定址法\" class=\"headerlink\" title=\"1.1 开放定址法\"></a>1.1 开放定址法</h3><p>开放定址法的核心思想就是增加偏移量，其中增加偏移量的方法有多种：线性探测、平方探测等，但整体思路是类似的。当插入一个新的数据时，发现经过哈希计算后，原Key的目标插入节点已经被占用了，发生碰撞，则向后偏移一位，再次检测，如果仍旧发生碰撞则继续偏移，直到到达数组尾端，根据不同的策略，可以绕回到数组头（负偏移）或扩大散列表。</p>\n<p>线性探测会导致元素聚集，这和哈希散列表的初衷不符。</p>\n<p>平方探测则是用：1, -1, 4, -4 … 这样的方式进行左右跳跃性查找。</p>\n<p>伪随机探测，即一开始就定义一个伪随机数列，每次发生冲突即从伪随机数列中取出下一个伪随机数作为偏移量。</p>\n<h3 id=\"1-2-再散列函数法\"><a href=\"#1-2-再散列函数法\" class=\"headerlink\" title=\"1.2 再散列函数法\"></a>1.2 再散列函数法</h3><p>也即每次发生冲突时，就再用哈希函数散列一次。缺点是增大计算量。</p>\n<h3 id=\"1-3-链地址法\"><a href=\"#1-3-链地址法\" class=\"headerlink\" title=\"1.3 链地址法\"></a>1.3 链地址法</h3><p>也即，哈希表的主体是一个数组，数组的每一个结点，都是一个链表，当发生哈希碰撞时，后插入的Key则插入到对应结点的链表的末端。</p>\n<p>如果不存在哈希冲突，也即 HashMap 数组中不包含链表，则每次添加、查找都是单次寻址，时间复杂度为 O(1)。如果目标节点存在哈希冲突，则添加、查找都需要遍历整个链表，时间复杂度为 O(n)，其中：查找时，通过 key 对象的 equals 方法逐一比较，相同则返回；新增时，遍历链表，若存在相同 key，则覆盖，否则新增至链表末端。</p>\n<p>hashMap 与 hashTable 其中不同的一点是 HashMap 允许 key 为 null，把 key 为 null 的对象存在数组首位（<code>table[0]</code>）。</p>\n<hr>\n<h2 id=\"2-HashMap源码分析\"><a href=\"#2-HashMap源码分析\" class=\"headerlink\" title=\"2. HashMap源码分析\"></a>2. HashMap源码分析</h2><h3 id=\"2-1-静态内部类Entry\"><a href=\"#2-1-静态内部类Entry\" class=\"headerlink\" title=\"2.1 静态内部类Entry\"></a>2.1 静态内部类Entry</h3><p>HashMap 有一个静态内部类 Entry，其源码清晰描述了 HashMap 数组 + 链表 的数据结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 存储指向下一个Entry的引用，单链表结构</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Creates new entry.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">        next = n;</span><br><span class=\"line\">        key = k;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">          V oldValue = value;</span><br><span class=\"line\">          value = newValue;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-HashMap的重要成员变量\"><a href=\"#2-2-HashMap的重要成员变量\" class=\"headerlink\" title=\"2.2 HashMap的重要成员变量\"></a>2.2 HashMap的重要成员变量</h3><ul>\n<li><code>transient Entry[] table;</code>：实际存储键值对的表。<br><code>transient</code> 关键字仅可修饰成员变量，表示“禁止序列化该数据”，其意义是：HashMap 本身的数组，通常会有很多空闲的节点，对空闲的节点空间序列化没有意义，所以其手动实现了 <code>writeObject()</code> 方法进行实际的序列化。<code>table</code>、<code>size</code>、<code>modCount</code> 都被 <code>transient</code> 关键字修饰，是因为每次 HashMap 执行 put 或 remove 操作后，三者都会发生变化，由于三者状态常变，所以没有必要在默认序列化类对象时将其指代入。</li>\n<li><code>static final int DEFAULT_INITIAL_CAPACITY = 16;</code>：默认初始容量为 16，必须为 2 的幂。</li>\n<li><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：最大容量，必须为 2 的幂且要小于 2 的 30 次方，传入大于该值的参数将被该值替换。</li>\n<li><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>：默认加载因子。</li>\n<li><code>final float loadFactor;</code>：实际加载因子。</li>\n</ul>\n<p>为了降低哈希冲突的概率，默认当 HashMap 中的键值对达到数组大小的 75% 时，会触发扩容操作。因此如果预估容量是 100，即需要设定 100 / 0.75 ＝ 134 的数组大小。</p>\n<ul>\n<li><code>transient int size</code>：Map 中实际存储的键值对个数。</li>\n<li><code>threshold</code>：阈值。</li>\n<li><code>transient volatile int modCount;</code>：HashMao 被改变的次数，用于快速失败。</li>\n</ul>\n<blockquote>\n<p><code>volatile</code> 关键字修饰的成员变量，可以阻禁止代码重排序，保证所有的写操作都在读操作之前，使得变量在内存中的变化可以被多线程所知。由于 HashMap 线程不安全，<code>modCount</code> 用于快速失败机制，所以写线程执行时带来的变化需要及时被读线程所知。</p>\n<p>put 操作时，若 key 已存在替换 value 时，<code>modCount</code> 不会增加，不存在新增时才会增加。也即，只有 HashMap 中元素的数量增多或减少时，才认为 HashMap 的结构发生了变化。</p>\n</blockquote>\n<h3 id=\"2-3-HashMap长度必须为2的幂\"><a href=\"#2-3-HashMap长度必须为2的幂\" class=\"headerlink\" title=\"2.3 HashMap长度必须为2的幂\"></a>2.3 HashMap长度必须为2的幂</h3><p>HashMap 在将一个 key 经过 hash 后映射进数组节点中时，经过了如下运算：</p>\n<ol>\n<li>计算 key 的 二次 hash；</li>\n<li>将 hash 值的二进制与 HashMap 的 (length - 1) 的二进制进行 &amp; 与运算；</li>\n<li>得出的结果即为需要存进的数组节点下标。</li>\n</ol>\n<p>（1）如果数组长度为 2 的幂，则 (length - 1) 的二进制一定是各个位都是 1，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">4</span> - <span class=\"number\">1</span> = <span class=\"number\">15</span>(d) = <span class=\"number\">1111</span>(b)</span><br><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">5</span> - <span class=\"number\">1</span> = <span class=\"number\">31</span>(d) = <span class=\"number\">11111</span>(b)</span><br></pre></td></tr></table></figure>\n\n<p>由于与运算是“两位为 1 才为 1”，因此用 hash 的二进制和 (length - 1) 的二进制做与运算，其结果就完全取决于 hash 的二进制数。例如：</p>\n<ul>\n<li>若 hash = 1011011，(length - 1) = 1111，则 hash &amp; (length - 1) = 1011。</li>\n<li>若 hash = 1101100010，(length - 1) = 11111，则 hash &amp; (length - 1) = 10。</li>\n</ul>\n<p>这样可以使得键值对尽可能均匀的分布在 HashMap 数组的各个节点。并且在扩容时，由于二进制的每一位只有可能是 1 或者 0，且扩容后的 (length - 1) 依然是各个位全为 1 的二进制数，也即经过与运算后，有一半几率该点依然位于原来的数组节点（而在链表中的位置则不确定），另一半的几率会被重新分配到其他的数组节点，从而可以保障扩容后键值对存储位置的均衡性。</p>\n<p>（2）假如 HashMap 的长度不是 2 的幂，也即 (length - 1) 的二进制中可能存在 0，例如：</p>\n<ul>\n<li>若 hash = 1011011，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</li>\n<li>若 hash = 1101101111，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</li>\n</ul>\n<p>不仅会导致哈希碰撞的概率增大，并且在上例中，由于 (length - 1) = 1001，则注定任何一个 hash 与之做与运算，其第 2、3 位都一定是 0，也即有些 HashMap 的数组节点则一定不会被用到。比如上例中当数组长度为 10 时，(length - 1) = 1001，则下标为：<code>0111(b) = 7(d)</code>、<code>0101(b) = 5(d)</code>、<code>0011(b) = 3(d)</code>、<code>0010(b) = 2(d)</code> 的数组节点一定不会被用于存储，这是显然不符合 Hash 散列表特性的。</p>\n<hr>\n<h2 id=\"3-HashMap流程\"><a href=\"#3-HashMap流程\" class=\"headerlink\" title=\"3. HashMap流程\"></a>3. HashMap流程</h2><p>在向 HashMap 存储数据时，会首先判断 key 是否为 null，如果为 null，则直接存入 <code>table[0]</code> 中，每次存储都会直接覆盖。若 key 不为 null，则会对 key 进行重哈希，也即哈希两次：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hash = hash(key.hashCode());</span><br></pre></td></tr></table></figure>\n\n<p>通过计算出来的 hash 值，判断该键值对的目标数组节点下标：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>\n\n<p>然后遍历该节点中的链表，依次与之比较 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    Object k;</span><br><span class=\"line\">    <span class=\"comment\">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">        V oldValue = e.value;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若遍历链表中已存储的键值对对象 e 时发现已存在，即：<code>e.hash == hash</code>，则直接用新的 <code>value</code> 取代旧的并退出，否则也即遍历 <code>e = e.next</code> 直到 <code>e == null</code>，则调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">addEntry(hash, key, value, i);</span><br></pre></td></tr></table></figure>\n\n<p>将当前键值对存储到链表末端，并使前一个 <code>e.next</code> 指向该新键值对。</p>\n<hr>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h2><p><code>HashMap.get(key)</code> 方法返回 <code>null</code> 时，可能是 key 对应的 value 为 <code>null</code>，也可能是没有找到对应的 key，因此判断 HashMap 中是否含有某个 key 时，应调用 <code>containsKey()</code> 方法。</p>\n<p>HashMap 是线程不安全的，其迭代器是 Fail-Fast（快速失败）的，也即：当有其他线程改变了 HashMap 的结构（增加或移除了元素），则有可能抛出 <code>ConcurrentModificationException</code> 异常，但迭代器本身的 <code>remove()</code> 则不会引起该异常。</p>\n<hr>\n<h2 id=\"5-附录-参考指导\"><a href=\"#5-附录-参考指导\" class=\"headerlink\" title=\"5. 附录[参考指导]\"></a>5. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_40118851/article/details/82804510\" title=\"@LINK\">【1】HashMap底层实现原理（作者：Right_Boy）</a></li>\n</ul>\n</blockquote>\n","categories":["Java"],"tags":["Java","HashMap","集合框架"]},{"title":"Java同步锁","url":"/post/java/java-lock/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java同步锁\"><a href=\"#Java同步锁\" class=\"headerlink\" title=\"Java同步锁\"></a>Java同步锁</h1><h2 id=\"1-Java锁的基本概念\"><a href=\"#1-Java锁的基本概念\" class=\"headerlink\" title=\"1. Java锁的基本概念\"></a>1. Java锁的基本概念</h2><h3 id=\"1-1-锁的种类\"><a href=\"#1-1-锁的种类\" class=\"headerlink\" title=\"1.1 锁的种类\"></a>1.1 锁的种类</h3><p><a href=\"https://blog.csdn.net/qq_41931837/article/details/82314478\">https://blog.csdn.net/qq_41931837/article/details/82314478</a></p>\n<h4 id=\"1-1-1-乐观锁和悲观锁\"><a href=\"#1-1-1-乐观锁和悲观锁\" class=\"headerlink\" title=\"1.1.1 乐观锁和悲观锁\"></a>1.1.1 乐观锁和悲观锁</h4><p>悲观锁认为一定会有别的线程抢占数据，因此操作数据前都要先获取数据的锁，<code>synchronized</code> 和 <code>lock</code> 都是悲观锁，适用于写操作较多的场景。</p>\n<p>乐观锁认为不会有别的线程抢占数据，因此只在写操作前判断是否有其他线程更新了数据，CAS（Compare And Swap）就是乐观锁的一种实现方式，适用于读操作较多的场景。</p>\n<h4 id=\"1-1-2-公平锁和非公平锁\"><a href=\"#1-1-2-公平锁和非公平锁\" class=\"headerlink\" title=\"1.1.2 公平锁和非公平锁\"></a>1.1.2 公平锁和非公平锁</h4><p>公平锁是多个线程按照申请锁的顺序来获取锁，非公平锁则不规定线程顺序。synchronized是非公平锁，ReentrantLock可以通过指定构造方法的参数来创建公平或非公平锁。</p>\n<h4 id=\"1-1-3-独享锁和共享锁\"><a href=\"#1-1-3-独享锁和共享锁\" class=\"headerlink\" title=\"1.1.3 独享锁和共享锁\"></a>1.1.3 独享锁和共享锁</h4><p>独享锁即一次只能被一个线程持有，共享锁一次可以被多个线程池有，synchronized和ReentrantLock都是独享锁，ReentrantReadWriteLock的读锁是共享锁，写锁是独享锁。</p>\n<h4 id=\"1-1-4-互斥锁和读写锁\"><a href=\"#1-1-4-互斥锁和读写锁\" class=\"headerlink\" title=\"1.1.4 互斥锁和读写锁\"></a>1.1.4 互斥锁和读写锁</h4><p>和独享、共享是一个意思。</p>\n<h4 id=\"1-1-5-可重入锁和不可重入锁\"><a href=\"#1-1-5-可重入锁和不可重入锁\" class=\"headerlink\" title=\"1.1.5 可重入锁和不可重入锁\"></a>1.1.5 可重入锁和不可重入锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychrnozied <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    xxxxxx;</span><br><span class=\"line\">    test2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    yyyyy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reentrant</code> 就是可重入的意思，所以 <code>Reentrant</code> 和 <code>synchronized</code> 都是可重入锁，也即上面的代码可以顺利执行，<code>test()</code> 获取了对象锁后，再调用 <code>test2()</code> 时，可以直接用已持有的对象锁直接进入 <code>test2()</code>，如果是不可重入锁则会发生死锁。</p>\n<h4 id=\"1-1-6-自旋锁\"><a href=\"#1-1-6-自旋锁\" class=\"headerlink\" title=\"1.1.6 自旋锁\"></a>1.1.6 自旋锁</h4><p>自旋锁就是使用循环尝试获取来替代线程阻塞等待，好处是减少线程切换的消耗，但会增加CPU资源消耗。</p>\n<h4 id=\"1-1-7-偏向锁、轻量级锁、重量级锁\"><a href=\"#1-1-7-偏向锁、轻量级锁、重量级锁\" class=\"headerlink\" title=\"1.1.7 偏向锁、轻量级锁、重量级锁\"></a>1.1.7 偏向锁、轻量级锁、重量级锁</h4><p>这是三种锁的状态，是针对 synchronized 字段优化的，通过对象监视器在内存中的头部字段来标明。</p>\n<ul>\n<li>偏向锁是指，如果一段同步代码一直被一个线程访问，则该线程会自动获取锁而不需要申请，以降低获取锁的资源消耗。</li>\n<li>轻量锁是指如果锁是偏向锁时，有另一个线程访问了同步代码块，则将偏向锁改为轻量锁。此时另外的线程不会阻塞等待，而是通过自旋来尝试获取锁。</li>\n<li>重量级锁则是，如果锁是轻量锁，另一个线程虽然是自旋，但不会一直持续下去，当自旋超过一定次数还没有获取到锁，就会进入阻塞状态，该锁膨胀为重量级锁。</li>\n</ul>\n<h4 id=\"1-1-8-分段锁\"><a href=\"#1-1-8-分段锁\" class=\"headerlink\" title=\"1.1.8 分段锁\"></a>1.1.8 分段锁</h4><p>分段锁不是一种具体的锁，也不是锁的形式，只是一种设计方案，在ConcurrentHashMap内部使用，通过将数据分段并分别加锁，来提升并发情况下的写入性能。</p>\n<h4 id=\"1-1-9-同步锁\"><a href=\"#1-1-9-同步锁\" class=\"headerlink\" title=\"1.1.9 同步锁\"></a>1.1.9 同步锁</h4><p>（1）对象锁（方法锁）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(Object object) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个线程使用同一个对象锁则可以达到同步的效果，否则无效。</p>\n<p>当 <code>synchronized</code> 修饰方法时，实际上等同于获取该方法所在的外部类对象的对象锁。</p>\n<p>（2）类锁（静态锁）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(DemoClass.class) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个类只有一个类锁，但每个类的实例对象都有自己的对象锁，因此当使用类锁时，所有该类的实例对象拿到的都是同一把锁，而使用对象锁时，不同实例对象之间是无关的。</p>\n<p><code>synchronized</code> 修饰静态方法时，即为静态锁。由于非静态方法会自动持有其所在外部类对象的引用，因此非静态方法加锁等同于其所在外部类实例对象的对象锁，而静态方法不会持有其外部类对象的引用，因此是使用其外部类的字节码对象作为锁。</p>\n<h3 id=\"1-2-锁粗化和锁消除\"><a href=\"#1-2-锁粗化和锁消除\" class=\"headerlink\" title=\"1.2 锁粗化和锁消除\"></a>1.2 锁粗化和锁消除</h3><p>锁粗化和锁消除的本意都是尽量减少锁的获取和释放，节约资源。</p>\n<p>锁消除是虚拟机在编译阶段做逃逸分析时，判断到某段代码，虽然加了锁，但不可能会被其他线程访问到，因此加锁是没必要的，则在编译阶段就去除加锁部分。</p>\n<p>锁粗化可以理解为扩展锁的域，例如在一个循环内部对一个操作加锁，由于重复获取和释放锁会带来很大的开销，因此虚拟机在编译阶段，将锁粗化，加载循环体外部。</p>\n<hr>\n<h2 id=\"2-Synchronized关键字\"><a href=\"#2-Synchronized关键字\" class=\"headerlink\" title=\"2. Synchronized关键字\"></a>2. Synchronized关键字</h2><p><code>synchronized</code> 只会同步尝试获取同一个 <code>monitor</code> 对象的线程，如果一个线程已经持有该 <code>monitor</code>，则后续所有尝试持有该 <code>monitor</code> 的线程都需要依次等待前面的线程释放 <code>monitor</code> 才能继续执行。</p>\n<ul>\n<li>对非静态方法加 <code>synchronized</code> 相当于对象锁。</li>\n<li>对静态方法加 <code>synchronized</code> 相等于类锁。</li>\n<li>用常量池和自动装箱的基本变量作为监视器，一旦改变了值就相当于改变了监视器。</li>\n</ul>\n<h3 id=\"2-1-Synchronized如何保证原子性\"><a href=\"#2-1-Synchronized如何保证原子性\" class=\"headerlink\" title=\"2.1 Synchronized如何保证原子性\"></a>2.1 Synchronized如何保证原子性</h3><p>所谓原子性指的是不会被线程调度机制打断的操作。java中对基本数据类型的读和写是原子性操作，但自增自减不是。例如 <code>i++</code> 在 JVM 中实际上是三步：</p>\n<ul>\n<li>取出 <code>i</code> 的值</li>\n<li>对值做 <code>+1</code> 操作</li>\n<li>重新赋值给 <code>i</code></li>\n</ul>\n<p>虽然其中的每一步都是原子性操作，但这个过程并不是原子性的。所以如果需要保证原子性，可以通过 <code>synchronized</code> 关键字实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;i++;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者使用原子类 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等，其中 <code>AtomicInteger#getAndIncrement()</code> 效果相当于 <code>i++</code>，<code>AtomicInteger#getAndDecrement()</code> 效果相当于 <code>i--</code>，<code>AtomicInteger#incrementAndGet()</code> 效果相当于 <code>++i</code>，其内部原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-Lock\"><a href=\"#3-Lock\" class=\"headerlink\" title=\"3. Lock\"></a>3. Lock</h2><h3 id=\"3-1-Lock的基本用法\"><a href=\"#3-1-Lock的基本用法\" class=\"headerlink\" title=\"3.1 Lock的基本用法\"></a>3.1 Lock的基本用法</h3><p><code>Lock</code> 的基本用法为：<code>Lock lock = new ReentrantLock();</code>，可以通过 <code>lock.lock()</code> 手动加锁，通过 <code>lock.unlock()</code> 手动释放锁。但 <code>Lock</code> 的性能很差，需要注意在 <code>finally</code> 中释放锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"keyword\">int</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    value++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-Lock的实现原理\"><a href=\"#3-2-Lock的实现原理\" class=\"headerlink\" title=\"3.2 Lock的实现原理\"></a>3.2 Lock的实现原理</h3><p><a href=\"https://yq.aliyun.com/articles/640868\">https://yq.aliyun.com/articles/640868</a></p>\n<p><code>Lock</code> 本质还是通过 <strong>CAS 乐观锁</strong> 实现的。一个线程尝试去获取锁，如果获取到，则更新一个 <code>state</code> 字段，表示当前是正在等待锁还是持有锁还是释放锁的状态，然后去执行操作。否则如果没获取到，则将该线程放到记录等待线程的双向链表中，然后线程做自旋，直到获取到锁。<code>Lock</code> 建议在低锁冲突的情况下用，否则非必要（例如需要公平锁）的情况下，还是使用 <code>synchronized</code> 更好。</p>\n<hr>\n<h2 id=\"4-基于原生方法手动实现公平锁\"><a href=\"#4-基于原生方法手动实现公平锁\" class=\"headerlink\" title=\"4. 基于原生方法手动实现公平锁\"></a>4. 基于原生方法手动实现公平锁</h2><p><a href=\"https://blog.csdn.net/sddh1988/article/details/68068971\">https://blog.csdn.net/sddh1988/article/details/68068971</a></p>\n<p>使用队列，在 <code>lock()</code> 内按顺序添加等待的线程名 <code>currentThread()#getName()</code>，然后 <code>peek</code> 出最前的线程名，自旋对比当前线程是否是 <code>peek</code> 出来的线程，如果不是则一直循环。</p>\n<hr>\n<h2 id=\"5-死锁\"><a href=\"#5-死锁\" class=\"headerlink\" title=\"5. 死锁\"></a>5. 死锁</h2><p>死锁产生有四个必要条件：</p>\n<ul>\n<li>互斥（线程要求的资源仅能被一个线程所独占）</li>\n<li>保持（线程因请求被其他线程独占的资源而阻塞时，保持已获得的资源不释放）</li>\n<li>不剥夺（线程独占的资源未使用完之前，不可剥夺该线程对资源的独占）</li>\n<li>环路等待（发生死锁时，必然存在线程-资源的环形请求链）。</li>\n</ul>\n<p>预防死锁的方式有：</p>\n<ul>\n<li>避免运行中请求资源，线程所需的资源一次性分配</li>\n<li>一个线程如果请求独占某个资源失败，则其他的资源也拒绝被该线程独占</li>\n<li>如果一个线程请求独占某个资源失败，则释放该线程原有的独占资源</li>\n<li>给资源进行编号，线程按顺序请求资源，逆序释放资源</li>\n<li>超时放弃，尝试获取锁一段时间不成功，则放弃自身独占的资源（如 <code>Lock#tryLock(long time, TimeUnit unit)</code>）</li>\n</ul>\n<hr>\n<h2 id=\"6-wait和sleep\"><a href=\"#6-wait和sleep\" class=\"headerlink\" title=\"6. wait和sleep\"></a>6. wait和sleep</h2><p><a href=\"https://www.cnblogs.com/loren-Yang/p/7538482.html\">https://www.cnblogs.com/loren-Yang/p/7538482.html</a></p>\n<ul>\n<li><code>sleep()</code> 是 <code>Thread</code> 类中的方法，<code>wait()</code> 是 <code>Object</code> 类中的方法，因此所有的对象都能调用 <code>wait()</code>。</li>\n<li><code>wait()</code> 会释放该对象持有的锁资源，所以一旦一个对象调用了 <code>wait()</code>，其他线程可以通过 <code>notify()</code> 或 <code>notyfyAll()</code> 来唤醒，而 <code>sleep()</code> 不释放锁资源，因此其他线程无法使用同步控制块。</li>\n</ul>\n<h2 id=\"7-Volatile关键字\"><a href=\"#7-Volatile关键字\" class=\"headerlink\" title=\"7. Volatile关键字\"></a>7. Volatile关键字</h2><p><code>volatile</code> 一般用在多个线程访问同一个变量时，对该变量进行唯一性约束，<code>volatile</code> 保证了变量的可见性，但不能保证原子性。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Thread read = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">write.start();</span><br><span class=\"line\">read.start();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，在某些极端情况下，可能会输出 1，也就是：</p>\n<ul>\n<li>write 线程先执行了 <code>flag = true</code></li>\n<li>然后 read 线程执行了 <code>if</code> 判断并通过，输出 1</li>\n<li>然后 write 线程才执行 <code>i = 2</code></li>\n</ul>\n<p>为了避免这个情况，可以如下改写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Thread read = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">write.start();</span><br><span class=\"line\">read.start();</span><br></pre></td></tr></table></figure>\n\n<p><code>volatile</code> 用于告诉 JVM 变量不允许线程缓存以及代码重排序，会使得其所在域的写操作一定发生在读操作之前，且每次有写操作后，都将所在域中的写入值同步到主内存中，从而避免其他线程从缓存中拿到旧数据。</p>\n","categories":["Java"],"tags":["Java","同步锁"]},{"title":"LRU算法及其优化","url":"/post/java/java-lru/","content":"<span id=\"more\"></span>\n\n<h1 id=\"LRU算法及其优化\"><a href=\"#LRU算法及其优化\" class=\"headerlink\" title=\"LRU算法及其优化\"></a>LRU算法及其优化</h1><p>LRU（Least Recently Used，最近最少使用）的本质是一个链表，新数据插入到链表头部，每当缓存命中，则将数据移到链表头部，当链表满了或者需要清理内存时，将链表尾部的数据丢弃。</p>\n<p>特点：当存在热点数据时，LRU 的效率很高，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧下降，产生缓存污染的（将不常用的数据也存入缓存，降低了缓存效率）问题，且每次缓存命中时，都需要遍历链表，找到命中的数据块索引并移到头部。</p>\n<h2 id=\"1-LRU-K\"><a href=\"#1-LRU-K\" class=\"headerlink\" title=\"1. LRU-K\"></a>1. LRU-K</h2><p>为了改善 LRU 算法的缓存污染问题，额外维护一个队列用于记录所有缓存数据被访问的历史，只有当数据的访问次数打到 K 次，才存入缓存中。当数据被访问次数不到 K 次时，按照一定规则（FIFO、LRU 等）淘汰，当历史队列中的数据访问达到 K 次后，将其从队列中删除转移到缓存中，并按照时间顺序重新排列缓存数据，且缓存中的数据每次被访问后重新排序。当需要清理缓存时，淘汰缓存中排在末尾的数据，也即淘汰距离上次访问最久的数据。</p>\n<p>特点：LRU-K 降低了缓存污染带来的代价，命中率比 LRU 高，但由于其历史队列和缓存中的数据都具有优先级（可以即时排序也可以在需要淘汰数据时才排序），因此其算法复杂度和性能代价较高。尤其当有大量存入历史队列却还未存入缓存中的数据时，内存消耗较大。</p>\n<p>通常，LRU-2 是综合因素下的最优选择，LRU-3 或更高 K 值会提高命中率，但适应性较差，需要大量的数据访问才能冲洗历史队列表。</p>\n<h2 id=\"2-LRU-Two-Queues\"><a href=\"#2-LRU-Two-Queues\" class=\"headerlink\" title=\"2. LRU-Two Queues\"></a>2. LRU-Two Queues</h2><p>LRU-2Q 祛除了历史队列，而是直接使用两个缓存队列进行管理，其中一个缓存队列采用 FIFO 淘汰规则，另一个缓存队列采用 LRU 淘汰规则。一个新的数据首次被访问时，假如 FIFO 队列，当该数据再次被访问时，则转移到 LRU 队列中，LRU 队列中的数据再次被访问时，则移至 LRU 队列的头部，两个队列分别根据对应的淘汰规则按需淘汰数据。</p>\n<p>L特点：RU-2Q 的命中率高于 LRU，尽管需要两个队列，但两个队列的维护算法都比较简单。LRU-2Q 和 LRU-2 命中率、内存消耗都比较接近，不同处在于，LRU-2 中，数据首次被访问加入历史队列后，需要被访问 2 次才转移至缓存中，而 LRU-2Q 在数据首次被访问加入 FIFO 队列后，仅需再被访问 1 次即转移到缓存中。</p>\n<h2 id=\"3-LRU-Multi-Queues\"><a href=\"#3-LRU-Multi-Queues\" class=\"headerlink\" title=\"3. LRU-Multi Queues\"></a>3. LRU-Multi Queues</h2><p>LRU-MQ 拥有一个 LRU 历史队列 和 K 个 LRU 缓存队列，均采用 LRU 淘汰规则。当一个数据首次被访问时，加入到最低优先级的 LRU 缓存队列中，队列中的数据每次被访问则重新计算优先级并排序，当低优先级的队列中，当某个数据优先级达到下一级 LRU 缓存队列时，将其从当前 LRU 缓存队列转移到更高级的 LRU 缓存队列的头部。为避免高优先级的数据永不淘汰，当高优先级的 LRU 缓存队列中某个数据在指定时间内未被访问时，降低其优先级并转移到低优先级的 LRU 缓存队列的头部。所有 K 个 LRU 缓存队列中被淘汰的数据，均转移到 LRU 历史队列的头部，若 LRU 历史队列中的数据重新被访问，则重新计算优先级，并根据优先级转移到目标 LRU 缓存队列的头部，否则根据 LRU 算法直到被完全淘汰，</p>\n<p>LRU-MQ 进一步降低了缓存污染的问题，着重突出了“优先缓存访问次数多的数据”的思想，但由于具有多个队列，且每个队列都需要维护每个数据的访问时间，当 LRU-MQ 中队列数和数据量过多时，具有较高的复杂度。不过，尽管 LRU-MQ 的队列数量较多，但由于内存是有限的，因此所有的队列所占内存之和仍是受限的，因此多个短队列的长度之和与单个长队列的长度相差不大，其队列扫描性能仍然比较接近。</p>\n<h2 id=\"4-LRUCache\"><a href=\"#4-LRUCache\" class=\"headerlink\" title=\"4. LRUCache\"></a>4. LRUCache</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mLruCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//计算一个元素的缓存大小</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getByteCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">addBitmap(String key, Bitmap bitmap) &#123;&#125;</span><br><span class=\"line\">getBitmap(String key) &#123;&#125;</span><br><span class=\"line\">removeBitmapFromMemory(String key) &#123;&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java"],"tags":["LRU"]},{"title":"Java中的引用","url":"/post/java/java-reference/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java中的引用\"><a href=\"#Java中的引用\" class=\"headerlink\" title=\"Java中的引用\"></a>Java中的引用</h1><p>Java 中的引用，是指除了基本数据类型以外的所有类型，这些类型在内存中，会在堆区存储实际的数据，在栈区存储一个别名（Alias），应用通过栈区的别名指向堆区的实际存储空间，来操作实际的数据，详细参考：<a href=\"/post/java/java-jvm/\" title=\"@LINK\">JVM内存模型</a>。</p>\n<h2 id=\"1-四种引用关系\"><a href=\"#1-四种引用关系\" class=\"headerlink\" title=\"1. 四种引用关系\"></a>1. 四种引用关系</h2><h3 id=\"1-1-强引用\"><a href=\"#1-1-强引用\" class=\"headerlink\" title=\"1.1 强引用\"></a>1.1 强引用</h3><p>直接 new 出来的对象就是强引用。只要强引用还存在，则不会被 GC，若内存不足，则 JVM 会直接抛出 OOM，可通过置为 null 来尝试回收。</p>\n<h3 id=\"1-2-软引用SoftReference\"><a href=\"#1-2-软引用SoftReference\" class=\"headerlink\" title=\"1.2 软引用SoftReference\"></a>1.2 软引用SoftReference</h3><p>若内存足够，发生 GC 时不会被回收，若内存不足，发生 GC 时会被回收。若回收软引用对象后仍然内存不足，则抛出 OOM。使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;Type T&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(Object obj);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-弱引用WeakReference\"><a href=\"#1-3-弱引用WeakReference\" class=\"headerlink\" title=\"1.3 弱引用WeakReference\"></a>1.3 弱引用WeakReference</h3><p>不论内存是否足够，只要 GC，都会回收。</p>\n<h3 id=\"1-4-虚引用PhantomReference\"><a href=\"#1-4-虚引用PhantomReference\" class=\"headerlink\" title=\"1.4 虚引用PhantomReference\"></a>1.4 虚引用PhantomReference</h3><p>一个对象持有虚引用几乎相当于未持有任何引用，随时都可能会被回收。虚引用必须配合引用队列一起使用。</p>\n<hr>\n<h2 id=\"2-引用队列ReferenceQueue\"><a href=\"#2-引用队列ReferenceQueue\" class=\"headerlink\" title=\"2. 引用队列ReferenceQueue\"></a>2. 引用队列ReferenceQueue</h2><p>可配合软引用、弱引用、虚引用使用。当 GC 准备回收一个对象时，若发现该对象存在引用，则会先将其加入到与之关联的引用队列中，可以通过判断引用队列中是否存在引用来判断被引用的对象是否将要被回收。</p>\n","categories":["Java"],"tags":["Java","引用","强引用","软引用","弱引用","虚引用"]},{"title":"Java-反射","url":"/post/java/java-reflect/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-反射\"><a href=\"#Java-反射\" class=\"headerlink\" title=\"Java-反射\"></a>Java-反射</h1>","categories":["Java"],"tags":["Java","反射"]},{"title":"Java-String","url":"/post/java/java-string/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-String\"><a href=\"#Java-String\" class=\"headerlink\" title=\"Java-String\"></a>Java-String</h1><h2 id=\"1-StringBuilder和StringBuffer的区别\"><a href=\"#1-StringBuilder和StringBuffer的区别\" class=\"headerlink\" title=\"1. StringBuilder和StringBuffer的区别\"></a>1. StringBuilder和StringBuffer的区别</h2><p>StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是 StringBuffer 中的方法大都采用了 <code>synchronized</code> 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p>\n<p>在单线程程序下，StringBuilder 效率更快，因为它不需要加锁、不具备多线程安全；而 StringBuffer 则每次都需要判断锁，效率相对更低。</p>\n<hr>\n<h2 id=\"2-扩容策略\"><a href=\"#2-扩容策略\" class=\"headerlink\" title=\"2. 扩容策略\"></a>2. 扩容策略</h2><p>StringBuilder 的初始容量可以容纳 <code>16</code> 个字符，当该对象的实体存放的字符的长度大于 <code>16</code> 时，实体容量就自动增加。StringBuilder 对象可以通过 <code>length()</code> 方法获取实体中存放的字符序列长度，通过 <code>capacity()</code> 方法来获取当前实体的实际容量。</p>\n<p><code>StringBuilder(int size)</code> 可以指定分配给该对象的实体的初始容量参数为 <code>size</code>。当该对象的实体存放的字符序列的长度大于 <code>size</code> 个字符时，实体的容量就自动的增加。以便存放所增加的字符。</p>\n<p><code>StringBuilder(String s)</code> 可以指定给对象的实体的初始容量 <code>size</code> 为 <code>s</code> 的长度 <strong>额外再加 <code>16</code> 个字符</strong>。当该对象的实体存放的字符序列长度大于 <code>size</code> 个字符时，实体的容量自动的增加，以便存放所增加的字符。</p>\n<h3 id=\"2-1-扩容算法\"><a href=\"#2-1-扩容算法\" class=\"headerlink\" title=\"2.1 扩容算法\"></a>2.1 扩容算法</h3><p>使用 <code>append()</code> 方法在字符串后面追加东西的时候，如果长度超过了该字符串存储空间大小了就需要进行扩容：构建新的存储空间更大的字符串，将旧的复制过去；</p>\n<ul>\n<li>在进行字符串 <code>append()</code> 的时候，会先计算追加后字符串大小；</li>\n<li>将追加后的字符串大小传入 <code>ensureCapacityInternal()</code>，由这个方法进行是否扩容的判断；<ul>\n<li>如果需要扩容就调用 <code>expandCapacity()</code> 进行扩容，尝试将新容量扩为大小变成 <code>当前容量 * 2 + 2</code>；</li>\n<li><code>if</code> 判断一下，如果容量还是不够，直接扩充到需要的容量大小。</li>\n</ul>\n</li>\n</ul>\n","categories":["Java"],"tags":["Java","String"]},{"title":"Java-ThreadLocal","url":"/post/java/java-threadlocal/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-ThreadLocal\"><a href=\"#Java-ThreadLocal\" class=\"headerlink\" title=\"Java-ThreadLocal\"></a>Java-ThreadLocal</h1><h2 id=\"1-认识ThreadLocal\"><a href=\"#1-认识ThreadLocal\" class=\"headerlink\" title=\"1. 认识ThreadLocal\"></a>1. 认识ThreadLocal</h2><p>ThreadLocal 是 Java 中一种很重要的机制 / 数据处理方式，尤其在并发中，数据是否共有、唯一，会直接影响项目的运行逻辑。一般情况下，防止并发冲突或数据不安全的做法是给对象、方法加同步锁 <code>synchronized</code>。但同步锁并不是万能的，例如同步锁会降低批量处理的效率，或者当业务需要保证数据的隔离性，使用同步锁则需要在方法内频繁销毁、重建对象，如果数据使用独立的处理模块，还会破坏模块化，提高耦合。为此，JDK 1.2 增加了一个工具类：即 <strong><code>ThreadLocal</code></strong>。</p>\n<hr>\n<h2 id=\"2-不使用ThreadLocal的问题\"><a href=\"#2-不使用ThreadLocal的问题\" class=\"headerlink\" title=\"2. 不使用ThreadLocal的问题\"></a>2. 不使用ThreadLocal的问题</h2><p>为了更好地理解 ThreadLocal 的设计理念，首先考虑以下两个更普遍一些的场景：</p>\n<ol>\n<li>一个客户端，需要并发地和服务器交互，并且每个连接都需要持久化（需要保存 Cookie）。</li>\n<li>一个客户端，需要并发地存取数据库，并且每个连接都可能会提交超过一个操作。</li>\n</ol>\n<p>（1）如果按最简单的方式来做，每个线程都维护一套自己的网络请求框架，确实不会导致什么异常，但是第一：实际项目中不可能采用这个方案，第二：这么做简直就是“高耦合低内聚”的代表，第三：重新参考以上两条。项目中，绝大部分情况下，一个连接会话会在一个独立的线程内执行，这个线程需要维护一个仅对自己可见的 Cookie，不仅对其他会话不可见，同时也要确保只能获取到自己的 Cookie。</p>\n<p>（2）同样，每个线程都独立维护一套数据库会话管理是不现实的，通常会封装到一个工具类中，从工具类中获取、开启、关闭会话以及提交事务等。假如有一个业务：当修改用户信息时，把这个操作记录保存下来。假如每一次的操作都从连接池获取 Connection，就有可能一个操作执行了另一个可能因为某些原因没有执行，所以一般通过以下方式来获取管理 Connection：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection connection;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(driver);</span><br><span class=\"line\">            connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后用 Transaction 统一提交事务。到目前为止，如果是单线程做这个操作，那是没问题的，但是如果出现并发的情况呢？如果并发很低并且操作轻量，给这个业务方法上同步锁，也是没有问题的，但是如果并发稍微高一些，就不可能放个同步锁了，这时如果还使用这个方案，很有可能会出现 <code>No operations allowed after connection closed</code> 错误，这是因为连接是共享的，如果后启动的线程 2 先执行完并且关闭了连接，先启动的线程 1 再执行相关操作时连接已经被关闭了。</p>\n<hr>\n<h2 id=\"3-ThreadLocal如何解决问题\"><a href=\"#3-ThreadLocal如何解决问题\" class=\"headerlink\" title=\"3. ThreadLocal如何解决问题\"></a>3. ThreadLocal如何解决问题</h2><p>ThreadLocal 为每个线程分配了一个独立的资源副本，并在内部通过一个 Table 表来维护每个线程和其拥有的独立资源副本的映射关系，所有的线程共享这个 Table。简单点说，ThreadLocal 中通过 <code>set()</code> 方法存入对象，通过 <code>get()</code> 方法取出对象，且线程存入的对象只有该线程自己可以获取到，，每个线程也只能获取到自己之前存入的对象，如果没有存入则调用 <code>get()</code> 返回的是 <code>null</code>。</p>\n<p>因此针对以上两个场景，用 ThreadLocal 就可以很好地解决痛点。</p>\n<p>（1）首先是会话连接的持久化，每个线程在建立连接后，调用 <code>set()</code>将自己的 Cookie 存入，并在需要的时候调用 <code>get()</code> 获取即可，对于每个会话线程，<code>get()</code> 到的都只是自己的 Cookie。</p>\n<p>（2）第二个数据库连接管理，也可以把共用的 Connection 放进 ThreadLocal 中管理，改成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Connection&gt; localConnection = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(connection == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Class.forName(driver);</span><br><span class=\"line\">                connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.set(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个新线程调用 <code>DBUtil.getConnection()</code> 时，会先判断当前线程是否已经存入了一个连接，如果已经存入则直接获取并返回，否则创建一个新的连接，关闭连接时同理。这样，线程之间的连接都是自己的独立对象，不会互相影响。</p>\n<hr>\n<h2 id=\"4-ThreadLocal和同步锁的比较\"><a href=\"#4-ThreadLocal和同步锁的比较\" class=\"headerlink\" title=\"4. ThreadLocal和同步锁的比较\"></a>4. ThreadLocal和同步锁的比较</h2><p>当然，ThreadLocal 并不是万能的，相比较同步锁方式，由于每个线程都拥有自己的资源副本，因此消耗的内存也更多，需要根据具体的业务确定方案。详细分析将在之后重新整理一份独立文章。</p>\n<hr>\n<h2 id=\"5-ThreadLocal源码分析\"><a href=\"#5-ThreadLocal源码分析\" class=\"headerlink\" title=\"5. ThreadLocal源码分析\"></a>5. ThreadLocal源码分析</h2><p>暂未完成</p>\n","categories":["Java"],"tags":["源码","Java","ThreadLocal"]},{"title":"ML入门-机器学习简介","url":"/post/machinelearning/ml-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-机器学习简介\"><a href=\"#ML入门-机器学习简介\" class=\"headerlink\" title=\"ML入门-机器学习简介\"></a>ML入门-机器学习简介</h1><h2 id=\"1-什么是机器学习\"><a href=\"#1-什么是机器学习\" class=\"headerlink\" title=\"1. 什么是机器学习\"></a>1. 什么是机器学习</h2><p>机器学习是人工智能的一个分支，主要关于构造和研究可以从数据中学习的系统。</p>\n<p>这也说明，机器学习的本质是通过数据实现的，更进一步讲，是从大量无法手动推算出规律、分布、结构的数据中，利用 CPU 强大的计算能力、通过迭代等科学的计算方法来自动计算出某种类型数据的共性，并使用这些共性为新来的数据假设、模拟出其可能的结果。</p>\n<p>机器学习的数据通常包括训练数据和校验数据，其中：</p>\n<ul>\n<li>训练数据用于建立机器学习模型，通常包括：① 输入（特征 <strong>X</strong>）和 ② 输出（标签 y）。<br>注意：此处黑体 <strong>X</strong> 表示矩阵，且有一些模型可以没有输出 y。</li>\n<li>校验数据用于在模型初步建立完毕后检验模型的效果，常常从训练数据中分割一部分作为校验数据，与训练数据具有相同的分布和格式。</li>\n</ul>\n<hr>\n<h2 id=\"2-机器学习的学习类型\"><a href=\"#2-机器学习的学习类型\" class=\"headerlink\" title=\"2. 机器学习的学习类型\"></a>2. 机器学习的学习类型</h2><ol>\n<li>监督学习[Supervised Learning]：从带标签的数据中学习。例：房价预测、邮件识别等。</li>\n<li>非监督学习[Unsupervised Learning]：从无标签的数据中学习蕴含的结构。例：文档聚类等。</li>\n<li>强化学习[Reinforcement Learning]：通过曾经执行的动作及带来的奖惩进行学习，强化学习的标签 y 具有延迟性。例：AI 下棋等，当前棋子带来的影响需要经过一段时间才会表现出来。</li>\n</ol>\n<h3 id=\"2-1-监督学习\"><a href=\"#2-1-监督学习\" class=\"headerlink\" title=\"2.1 监督学习\"></a>2.1 监督学习</h3><p>（1）两种任务类型：</p>\n<ol>\n<li>回归任务（Regression）：输出 $y\\in R$ 为连续值。</li>\n<li>分类任务（Classification）：输出 y 为离散值。</li>\n</ol>\n<p>（2）学习目的：学习到一个 <strong>X</strong> 到 y 的映射 f，从而对新输入的 <strong>X</strong> 预测其输出</p>\n<blockquote>\n<p>$\\hat{y}=f(\\textbf{X})$。</p>\n</blockquote>\n<p>（3）监督学习的训练数据包含标签 y，即标签在训练数据中是可见变量。</p>\n<p>（4）数据样式：</p>\n<blockquote>\n<p>$D=\\{\\textbf{X}_i, y_i\\}_{i=1}^N$</p>\n</blockquote>\n<p>其中 D 为数据集，$X_i$ 与 $y_i$ 为第 i 个样本的输入与输出，N 为样本总数。</p>\n<p>（5）Scikit-Learn 中监督学习的大致流程：</p>\n<ol>\n<li>estimator.fit(X_train, y_train)</li>\n<li>estimator.predict(X_test)</li>\n<li>estimator.score(X_test, y_test)</li>\n</ol>\n<h3 id=\"2-2-非监督学习\"><a href=\"#2-2-非监督学习\" class=\"headerlink\" title=\"2.2 非监督学习\"></a>2.2 非监督学习</h3><p>（1）两种任务类型：</p>\n<blockquote>\n<ol>\n<li>聚类（Clustering）</li>\n<li>降维（Dimension Reduction）</li>\n</ol>\n</blockquote>\n<p>（2）学习目的：发现数据中的“有意义的模式”，亦称为“知识发现”。</p>\n<p>（3）非监督学习的训练数据不包含标签 y，即标签在训练数据中为隐含变量。</p>\n<p>（4）数据样式：</p>\n<blockquote>\n<p>$D=\\{\\textbf{X}_i\\}_{i=1}^N$</p>\n</blockquote>\n<p>（5）Scikit-Learn 中非监督学习的大致流程：</p>\n<ol>\n<li><code>transformer.fit(X_train)</code></li>\n<li><code>X_train_trans = transformer.transform(X_train)</code></li>\n<li><code>X_test_trans = transformer.transform(X_test)</code></li>\n</ol>\n<h3 id=\"2-3-增强学习\"><a href=\"#2-3-增强学习\" class=\"headerlink\" title=\"2.3 增强学习\"></a>2.3 增强学习</h3><p>（1）学习目的：从行为的反馈（奖励或惩罚）中学习，以找到一条回报值最大的路径。</p>\n<p>（2）步骤：设计一个回报函数[Reward Function]，若 Learning Agent 在执行一个动作后获得了较好的结果，则给予一些奖励（例如：回报函数为正），否则给予一些惩罚（例如：回报函数为负），驱使 Learning Agent 寻找出一条最终获得回报总和最高的学习路径。</p>\n","categories":["MachineLearning"],"tags":["AI","MachineLearning","人工智能","机器学习"]},{"title":"Mac编译FFmpeg踩坑记录","url":"/post/note/note-build-ffmpeg/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Mac编译FFmpeg踩坑记录\"><a href=\"#Mac编译FFmpeg踩坑记录\" class=\"headerlink\" title=\"Mac编译FFmpeg踩坑记录\"></a>Mac编译FFmpeg踩坑记录</h1><p>前言：实际上网上关于如何编译 FFmpeg 的文章已经相当多了，但是等到自己真的要用的时候才发现，能找到的大部分文章多少都有些不够完善，或是有遗漏的说明，或是版本、环境太久远，为此踩了不少的坑，最后发现还是读官方文档最省事。特地记录一篇文章，并尽可能详细地写出具体步骤。</p>\n<hr>\n<h2 id=\"1-环境和所需的文件\"><a href=\"#1-环境和所需的文件\" class=\"headerlink\" title=\"1. 环境和所需的文件\"></a>1. 环境和所需的文件</h2><p>先是环境：</p>\n<ul>\n<li>FFmpeg：3.3.9</li>\n<li>NDK：android-ndk-r14b</li>\n<li>系统：MacOS 10.15</li>\n<li>编译目标：给 Android 用的 ARM 平台</li>\n</ul>\n<p>再给出几个下载链接：</p>\n<ul>\n<li>FFmpeg：<a href=\"https://ffmpeg.org/download.html#releases\" title=\"@LINK\">点此下载</a></li>\n<li>NDK：<a href=\"https://developer.android.google.cn/ndk/downloads/index.html\" title=\"@LINK\">点此下载</a></li>\n</ul>\n<blockquote>\n<p><strong>不建议使用 AndroidStudio 自带的 ndk-bundle 编译，不建议使用最新版 FFmpeg，不建议使用最新版 NDK，理由不明（笑）。</strong></p>\n</blockquote>\n<p>使用最新的 FFmpeg 4.x，按照网上主流的做法，修改 <code>configure</code> 文件然后新建脚本 <code>build_android.sh</code> 的方法，会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\">Makefile:67: /common.mak: No such file or directory</span><br><span class=\"line\">Makefile:114: /libavutil/Makefile: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">C compiler <span class=\"built_in\">test</span> failed.</span><br><span class=\"line\"></span><br><span class=\"line\">If you think configure made a mistake, make sure you are using the latest</span><br><span class=\"line\">version from Git.  If the latest version fails, report the problem to the</span><br><span class=\"line\">ffmpeg-user@ffmpeg.org mailing list or IRC <span class=\"comment\">#ffmpeg on irc.freenode.net.</span></span><br><span class=\"line\">Include the <span class=\"built_in\">log</span> file <span class=\"string\">&quot;config.log&quot;</span> produced by configure as this will <span class=\"built_in\">help</span></span><br><span class=\"line\">solve the problem.</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">make: *** No rule to make target `/tests/Makefile<span class=\"string\">&#x27;.  Stop.</span></span><br></pre></td></tr></table></figure>\n\n<p>报了一堆 <code>No such file or directory</code> 错误，第一行的 <code>config.mak</code> 也可能是 <code>ffbuild/config.mak</code>，带着错误去搜也搜不到什么头绪，根据报错信息去 FFmpeg 的根目录下或者 <code>ffbuild/</code> 下也确实找不到所谓的 <code>config.mak</code>，一个解决方案是：</p>\n<ol>\n<li><p>先不要修改 <code>configure</code> 文件，直接执行：<code>./configure</code>，但是大概率会报这个错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nasm/yasm not found or too old. Use --disable-x86asm <span class=\"keyword\">for</span> a crippled build.</span><br></pre></td></tr></table></figure>\n\n<p>只要按照提示加上 <code>--disable-x86asm</code> 参数即可，重新执行完会自动生成缺失的文件。</p>\n</li>\n<li><p>再重新执行脚本：<code>sudo ./build_android.sh</code>。</p>\n</li>\n</ol>\n<p>但是这么做，如果是最新的 NDK 或者最新的 FFmpeg，执行完倒是不报错，但是并不会编译输出 SO 文件，所以还是老老实实用已有方案的版本吧！</p>\n<hr>\n<h2 id=\"2-编译SO文件\"><a href=\"#2-编译SO文件\" class=\"headerlink\" title=\"2. 编译SO文件\"></a>2. 编译SO文件</h2><h3 id=\"2-1-配置NDK\"><a href=\"#2-1-配置NDK\" class=\"headerlink\" title=\"2.1 配置NDK\"></a>2.1 配置NDK</h3><p>首先，NDK 下载好后，放到自定义目录中，需要添加到环境变量中去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果用的是 bash 终端：</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果用的是 zsh 终端：</span></span><br><span class=\"line\">vim ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量（按照实际目录）：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> NDK_HOME=/Applications/AndroidStudio/android-ndk-r14b/build</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;NDK_HOME&#125;</span>:<span class=\"variable\">$&#123;PATH&#125;</span>:</span><br></pre></td></tr></table></figure>\n\n<p>保存退出，然后刷新并测试环境变量，执行：<code>ndk-build</code>，如果有类似以下输出则表明配置成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android NDK: Could not find application project directory !</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>还需要给所有文件加上权限，进入 NDK 的目录并执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod -R 777 ./*</span><br></pre></td></tr></table></figure>\n\n<p><strong>温馨提示：可千万不要把 <code>./*</code> 给打错了，要是不小心把“.”漏了可就麻烦了（请务必不要尝试）。</strong></p>\n<h3 id=\"2-2-配置FFmpeg\"><a href=\"#2-2-配置FFmpeg\" class=\"headerlink\" title=\"2.2 配置FFmpeg\"></a>2.2 配置FFmpeg</h3><p>把下载好的 FFmpeg 源码解压到任意目录，同样也按上述操作给所有文件加上权限，接下来再在 FFmpeg 根目录下创建一个脚本（命名随意）：<code>build_android.sh</code>，修改内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以实际自定义临时目录为准，必须指定否则报错：Unable to create temporary file in</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> TMPDIR=/....../TEMP</span><br><span class=\"line\"><span class=\"comment\"># 以 NDK 实际路径为准</span></span><br><span class=\"line\">NDK=/Applications/Androidstudio/android-ndk-r14b</span><br><span class=\"line\"><span class=\"comment\"># 编译目标平台，本例选择最低 API 22 的 ARM 平台，输出 SO 文件放在 Android 项目的 libs/armeabi/ 目录下</span></span><br><span class=\"line\"><span class=\"comment\"># x86 架构则选择 arch-x86</span></span><br><span class=\"line\">PLATFORM=<span class=\"variable\">$NDK</span>/platforms/android-22/arch-arm</span><br><span class=\"line\"><span class=\"comment\"># 编译所需工具链，arm-linux-androideabi 对应上面的 ARM 平台，4.9 为版本号，以 NDK 中的实际版本为准</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64</span><br><span class=\"line\"><span class=\"keyword\">function</span> build_one</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">./configure \\</span><br><span class=\"line\">    --prefix=<span class=\"variable\">$PREFIX</span> \\</span><br><span class=\"line\">    --target-os=linux \\</span><br><span class=\"line\">    --cross-prefix=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \\</span><br><span class=\"line\">    --arch=arm \\</span><br><span class=\"line\">    --sysroot=<span class=\"variable\">$PLATFORM</span> \\</span><br><span class=\"line\">    --extra-cflags=<span class=\"string\">&quot;-I<span class=\"variable\">$PLATFORM</span>/usr/include&quot;</span> \\</span><br><span class=\"line\">    --cc=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-gcc \\</span><br><span class=\"line\">    --nm=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-nm \\</span><br><span class=\"line\">    --disable-shared \\</span><br><span class=\"line\">    --enable-runtime-cpudetect \\</span><br><span class=\"line\">    --enable-gpl \\</span><br><span class=\"line\">    --enable-small \\</span><br><span class=\"line\">    --enable-cross-compile \\</span><br><span class=\"line\">    --disable-debug \\</span><br><span class=\"line\">    --enable-static \\</span><br><span class=\"line\">    --disable-doc \\</span><br><span class=\"line\">    --disable-asm \\</span><br><span class=\"line\">    --disable-ffmpeg \\</span><br><span class=\"line\">    --disable-ffplay \\</span><br><span class=\"line\">    --disable-ffprobe \\</span><br><span class=\"line\">    --disable-ffserver \\</span><br><span class=\"line\">    --disable-postproc \\</span><br><span class=\"line\">    --disable-avdevice \\</span><br><span class=\"line\">    --disable-symver \\</span><br><span class=\"line\">    --disable-stripping \\</span><br><span class=\"line\"><span class=\"variable\">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINT 0/HAVE_LRINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUND 0/HAVE_ROUND 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_CBRT 0/HAVE_CBRT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_RINT 0/HAVE_RINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make -j4</span><br><span class=\"line\">make install</span><br><span class=\"line\"><span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-ld \\</span><br><span class=\"line\">-rpath-link=<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PREFIX</span>/lib \\</span><br><span class=\"line\">-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \\</span><br><span class=\"line\"><span class=\"variable\">$PREFIX</span>/libffmpeg.so \\</span><br><span class=\"line\">    libavcodec/libavcodec.a \\</span><br><span class=\"line\">    libavfilter/libavfilter.a \\</span><br><span class=\"line\">    libswresample/libswresample.a \\</span><br><span class=\"line\">    libavformat/libavformat.a \\</span><br><span class=\"line\">    libavutil/libavutil.a \\</span><br><span class=\"line\">    libswscale/libswscale.a \\</span><br><span class=\"line\">    -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \\</span><br><span class=\"line\">    <span class=\"variable\">$TOOLCHAIN</span>/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 平台类型，可以是 arm 或 armv7-a 或 x86 等</span></span><br><span class=\"line\">CPU=armv7-a</span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出 SO 的目录</span></span><br><span class=\"line\">PREFIX=./android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">ADDITIONAL_CONFIGURE_FLAG=</span><br><span class=\"line\">build_one</span><br></pre></td></tr></table></figure>\n\n<p>接下来在当前目录执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按实际创建的脚本名</span></span><br><span class=\"line\">./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>需要等一段编译时间，但总之是成功编译了，脚本配置中的“编译后 SO 文件输出目录” <code>PREFIX=./android/$CPU-vfp</code> 表示：<code>当前目录/android/平台类型</code>，比如我当前目录为 <code>/Applications/FFmpeg</code>，平台类型是 <code>arm</code>，则输出目录为：<code>/Applications/FFmpeg/android/arm/</code>。</p>\n<p>编译完可能会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">install: /usr/<span class=\"built_in\">local</span>/share/man/man1/ffmpeg.1: Permission denied</span><br><span class=\"line\">make: *** [install-man] Error 71</span><br></pre></td></tr></table></figure>\n\n<p>权限错误，也可能是 <code>man3</code> 报的错，简便一点的方法就是直接用 Super User 权限安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，在 FFmpeg 根目录下的 <code>android/armv7-a/</code> 下即可看到 <code>libffmpeg.so</code> 文件，复制到 Android 项目中再配置 NDK 即可。</p>\n<hr>\n<h2 id=\"3-附录-参考指导\"><a href=\"#3-附录-参考指导\" class=\"headerlink\" title=\"3. 附录[参考指导]\"></a>3. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/dfe9404e001a\" title=\"@LINK\">【1】Android Studio下编译FFmpeg so文件（作者：Galaxy北爱）</a></li>\n<li><a href=\"https://blog.csdn.net/vichild/article/details/82686343\" title=\"@LINK\">【1】win10子系统编译ffmpeg for android遇到的问题记录（作者：wellchang）</a></li>\n<li><a href=\"https://www.jianshu.com/p/c8ad83dd5585\" title=\"@LINK\">【1】Android编译ffmpeg常见错误（作者：JXiaoNiu）</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015631928\" title=\"@LINK\">【1】Mac中编译FFmpeg教程(Android版)（作者：码出世界）</a></li>\n</ul>\n</blockquote>\n","categories":["Note"],"tags":["FFMPEG","SO库","编译"]},{"title":"常用Git命令","url":"/post/note/note-git/","content":"<span id=\"more\"></span>\n\n<h1 id=\"常用Git命令\"><a href=\"#常用Git命令\" class=\"headerlink\" title=\"常用Git命令\"></a>常用Git命令</h1><h2 id=\"1-基本Git操作指令\"><a href=\"#1-基本Git操作指令\" class=\"headerlink\" title=\"1. 基本Git操作指令\"></a>1. 基本Git操作指令</h2><h3 id=\"1-1-创建仓库\"><a href=\"#1-1-创建仓库\" class=\"headerlink\" title=\"1.1 创建仓库\"></a>1.1 创建仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将当前目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在当前目录下创建一个新的目录，并新目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init [new dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库克隆到本地</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> [url]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-查看仓库配置\"><a href=\"#1-2-查看仓库配置\" class=\"headerlink\" title=\"1.2 查看仓库配置\"></a>1.2 查看仓库配置</h3><p>Git 配置分为全局配置、以及各个仓库自己的局部配置，仓库的局部配置会与全局配置合并去重，重复的配置项以仓库局部配置为准。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全局 Git 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 全局 Git 配置保存在 ~/.gitconfig</span></span><br><span class=\"line\">git config --global --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前目录下仓库的 Git 局部配置</span></span><br><span class=\"line\"><span class=\"comment\"># 当前仓库的 Git 配置保存在 [仓库目录]/.git/config</span></span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看接的远程仓库</span></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看连接的远程仓库的地址</span></span><br><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-分支管理\"><a href=\"#1-3-分支管理\" class=\"headerlink\" title=\"1.3 分支管理\"></a>1.3 分支管理</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从远程连接仓库拉取最新数据到本地仓库</span></span><br><span class=\"line\">git fetch [name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有远程分支</span></span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地以及远程的分支</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但不切换</span></span><br><span class=\"line\">git branch [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到新的分支，并更新工作区文件（切换到新分支的改动记录）</span></span><br><span class=\"line\">git checkout [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该新分支，同时更新工作区文件</span></span><br><span class=\"line\">git checkout -b [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将指定的本地分支连接到远程分支</span></span><br><span class=\"line\">git branch --set-upstream [<span class=\"built_in\">local</span> branch name] [remote branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个本地分支</span></span><br><span class=\"line\">git branch -d [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同时从本地和远程删除一个分支</span></span><br><span class=\"line\">git branch -dr [remote/branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将另一个本地分支的改动合并到当前分支</span></span><br><span class=\"line\">git merge [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下的某个改动提交记录同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下多个改动提交记录同时同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id1] [commit id2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左开右闭（即不包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]..[commit id5]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左闭右闭（包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]^..[commit id5]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-提交变更\"><a href=\"#1-4-提交变更\" class=\"headerlink\" title=\"1.4 提交变更\"></a>1.4 提交变更</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将改动文件提交到暂存区</span></span><br><span class=\"line\">git add [file1] [file2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将某个目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区的所有改动提交到仓库</span></span><br><span class=\"line\">git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区并同时显示每个改动的 Diff</span></span><br><span class=\"line\">git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有文件变更状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录，并显示每次提交时发生变更的文件</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-常见的跨仓库设置\"><a href=\"#2-常见的跨仓库设置\" class=\"headerlink\" title=\"2. 常见的跨仓库设置\"></a>2. 常见的跨仓库设置</h2><h3 id=\"2-1-同时Push到多个仓库\"><a href=\"#2-1-同时Push到多个仓库\" class=\"headerlink\" title=\"2.1 同时Push到多个仓库\"></a>2.1 同时Push到多个仓库</h3><p>通过 <code>git remote -v</code> 可以查看当前仓库拉取（fetch）和推送（push）的远程仓库的链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.git (fetch)</span><br><span class=\"line\">origin https://XXX.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>如果想同时 Push 到多个仓库可以通过如下方式添加多个目标仓库地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add [name] [url]</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>[name]</code> 对应的是远程仓库的别名，例如上述的 <code>origin</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add origin https://new-push-url.git</span><br></pre></td></tr></table></figure>\n\n<p>设置后再次用 <code>git remote -v</code> 查看远程仓库链接，即可看到已经有两个 Push 地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.git (fetch)</span><br><span class=\"line\">origin https://XXX.git (push)</span><br><span class=\"line\">origin https://new-push-url.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>实际上也可以通过直接修改当前仓库的局部配置文件添加，修改 <code>仓库目录/.git/config</code> 文件，在 <code>[remote]</code> 部分内添加一个 <code>url</code> 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[core]</span><br><span class=\"line\">        ......</span><br><span class=\"line\">[remote <span class=\"string\">&quot;origin&quot;</span>]</span><br><span class=\"line\">        url = https://XXX.git</span><br><span class=\"line\">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class=\"line\">        url = https://new-push-url.git</span><br><span class=\"line\">[branch <span class=\"string\">&quot;master&quot;</span>]</span><br><span class=\"line\">        ......</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-同时连接到多个远程仓库\"><a href=\"#2-2-同时连接到多个远程仓库\" class=\"headerlink\" title=\"2.2 同时连接到多个远程仓库\"></a>2.2 同时连接到多个远程仓库</h3><p>假如有一个本地仓库，出于容灾、备份、等目的，同时推送到了两个远程托管平台，以 GitHub 和 Coding 为例：</p>\n<ul>\n<li>假设 GitHub 上的远程仓库地址为 <code>https://XXX.github.git</code></li>\n<li>假设 Coding 上的远程仓库地址为 <code>https://XXX.coding.git</code>。</li>\n</ul>\n<p>而其他人分别基于不同的平台各自推送了特性分支，此时两个远程仓库的分支列表分别为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GitHub 的分支列表：</span></span><br><span class=\"line\">* develop</span><br><span class=\"line\">  main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Coding 的分支列表：</span></span><br><span class=\"line\">* release</span><br><span class=\"line\">  main</span><br></pre></td></tr></table></figure>\n\n<p>假设基于 GitHub 的远程仓库克隆了本地仓库，此时如果直接在 <code>develop</code> 分支上尝试合并 <code>release</code> 分支，会因为找不到 <code>release</code> 分支而失败：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">merge: release - not something we can merge</span><br></pre></td></tr></table></figure>\n\n<p>想要对这两个来自不同平台的独立的分支做合并，就需要让本地仓库同时连接多个远程仓库了。</p>\n<p>通过 <code>git remote -v</code> 查看本地仓库当前的远程连接地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.github.git (fetch)</span><br><span class=\"line\">origin https://XXX.github.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>给本地仓库再添加 Coding 的远程仓库连接地址，为了方便区分将新的远程仓库命名为 <code>coding</code>，则对应命令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git remote add &lt;option&gt; [name] [url]</span></span><br><span class=\"line\">git remote add coding https://XXX.coding.git</span><br></pre></td></tr></table></figure>\n\n<p>再次通过 <code>git remote -v</code> 即可看到该本地仓库已经同时连接到了两个远程仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin http://XXX.github.git (fetch)</span><br><span class=\"line\">origin http://XXX.github.git (push)</span><br><span class=\"line\">coding https://XXX.coding.git (fetch)</span><br><span class=\"line\">coding https://XXX.coding.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>接下来同时把两个远程仓库的数据都拉取下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取名为 origin 的仓库，即 GitHub 上的</span></span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取名为 coding 的仓库，即 Coding 上的</span></span><br><span class=\"line\">git fetch coding</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试在 <code>develop</code> 分支上合并 <code>release</code> 分支即可正常合并，当然如果有冲突也会进入常规流程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 develop 分支</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并 release 分支</span></span><br><span class=\"line\">git merge release</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-3-跨仓库Cherry-Pick\"><a href=\"#2-3-跨仓库Cherry-Pick\" class=\"headerlink\" title=\"2.3 跨仓库Cherry-Pick\"></a>2.3 跨仓库Cherry-Pick</h3><p>通常来说 Cherry-Pick 发生在仓库内的不同分支，用于将其他分支的改动同步到当前分支。</p>\n<p>如果一个仓库 <code>GitHub</code> 想要在 Cherry-Pick 另一个仓库 <code>Coding</code> 的提交（例如 commit123fromsource），就会报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">fatal: bad revision <span class=\"string\">&#x27;commit123fromsource&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果这两个仓库是 Fork 的关系，或者只是同一个仓库在不同托管平台的备份，本质上它们是同源的，想要互相支持 Cherry-Pick 的话就需要通过上文 2.2 中的方法，给本地仓库同时添加两份远程仓库的连接，然后就能随意 Cherry-Pick 了，当然如果发生冲突也会进入常规流程。</p>\n<p>实际上，一个本地仓库可以随意添加多个远程仓库的地址，然后就能随意操作其他仓库的分支或 Commit，但是 Cherry-Pick 需要满足一定的条件，例如涉及到的改动文件具有同源的改动记录，否则就会失败，只能从最开始文件创建的时候开始 Cherry-Pick 才行。</p>\n","categories":["Note"],"tags":["Git","Cherry-Pick","仓库","分支"]},{"title":"HTTP和HTTPS","url":"/post/network/network-http_https/","content":"<span id=\"more\"></span>\n\n<h1 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h1><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP报文格式\"><a href=\"#HTTP报文格式\" class=\"headerlink\" title=\"HTTP报文格式\"></a>HTTP报文格式</h3><p>（1）HTTP 请求报文</p>\n<p>HTTP 请求报文包括：请求行（Request Line）、请求头（Request Header）、请求数据（Request Data）、空行四个部分。</p>\n<p><a href=\"https://blog.csdn.net/zx_emily/article/details/83024065\">https://blog.csdn.net/zx_emily/article/details/83024065</a></p>\n<h3 id=\"Http缓存\"><a href=\"#Http缓存\" class=\"headerlink\" title=\"Http缓存\"></a>Http缓存</h3><ul>\n<li>常见端口号（80、443、23等）对应的含义</li>\n</ul>\n<p>23：远程登录 Telnet 服务。</p>\n<p>80：HTTP服务的端口号</p>\n<p>443：HTTPS服务的端口号</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h3><p><a href=\"https://www.cnblogs.com/jesse131/p/9080925.html\">https://www.cnblogs.com/jesse131/p/9080925.html</a></p>\n<p>对称加密：发送和接收用同一个秘钥加解密。<br>非对称加密：发送方用公钥加密，接收方用私钥解密。</p>\n<p>发送方发送一个协议版本号和一个随机数，以及客户端支持的加密算法。<br>接收方选择一个公钥，并给出数字证书以及一个新的随机数。<br>发送方确认证书有效，使用接收到的公钥发送一个新的随机数<br>接收方用私钥解密随机数，并使用之前的三个随机数生成一个对话秘钥，用这个秘钥加密接下来的整个会话数据。</p>\n<h3 id=\"HTTPS流程\"><a href=\"#HTTPS流程\" class=\"headerlink\" title=\"HTTPS流程\"></a>HTTPS流程</h3><p>客户端访问HTTPS请求，连接到Server的443端口<br>Server回应证书和公钥<br>客户端TLS验证公钥，如果有异常则弹出警告提示<br>客户端根据证书查找本地对应的证书，如果找不到，说明证书不可信。<br>如果找到了，取出本地证书对应的公钥，对Server发来的证书的签名进行解密。<br>客户端使用hash算法计算Server传来的证书的Hash值，并和解密出来的证书中的签名作对比。<br>如果一致，说明公钥没有被替换，则可以用该公钥继续后面的加密会话了。<br>客户端用公钥加密一个随机数，发送给服务端。<br>Server使用私钥解密随机值，然后将会话数据通过该值进行对称加密。<br>客户端可以同样用之前生成的随机值解密Server发过来的数据。<br>整个过程，即使被第三方监听，也无法改变。</p>\n","categories":["Network"],"tags":["Network","HTTP","SSL","HTTPS"]},{"title":"Network-Socket","url":"/post/network/network-socket/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Network-Socket\"><a href=\"#Network-Socket\" class=\"headerlink\" title=\"Network-Socket\"></a>Network-Socket</h1><h2 id=\"基于TCP的Socket\"><a href=\"#基于TCP的Socket\" class=\"headerlink\" title=\"基于TCP的Socket\"></a>基于TCP的Socket</h2><p>Socket socket = new Socket(String ip, int port); // 本地进程间通信使用 “localhost”<br>boolean isConnected = socket.isConnected();<br>BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));<br>writer.write(byte[] data);<br>writer.flush();<br>writer.close();</p>\n<p>DataInputStream input = new DataInputStream(new BufferedInputStream(socked.getInputStream));<br>byte[] bytes = new byte[MAX_LENGTH_EACH_TIME];<br>while(input.read(bytes) != -1) {</p>\n<p>}<br>服务端：<br>ServerSocket serverSocket = new ServerSocket(int port);<br>Socket socket = ServerSocket.accept();<br>InputStream ……</p>\n<ul>\n<li>socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</li>\n</ul>\n<p>没有对应关系。accept()发生在三次握手之后。服务器监听请求连接，成功三次握手的连接会被存放到连接队列中，accept()方法只是从服务器的连接队列中取出了具体的一个连接实例。</p>\n<h2 id=\"基于UDP的Socket\"><a href=\"#基于UDP的Socket\" class=\"headerlink\" title=\"基于UDP的Socket\"></a>基于UDP的Socket</h2><p>// 发送<br>DatagramSocket socket = new DatagramSocket();<br>socket.connect(String ip, int port);<br>DatagramPacket  sendPacket = new DatagramPacket(byte[] data, int data.length, String ip, int port);<br>socket.send(sendPacket);<br>// 接收<br>while(socket.isConnect()) {<br>    byte[] data = new byte[MAX_LENGTH_EACH_TIME];<br>    DatagramPacket rcvPacket = new DatagramPacket(data, data.length);<br>    socket.receive(rcvPacket);<br>    rcvPacket.getData().length // 等效于 data.length，等于 MAX_LENGTH_EACH_TIME<br>    rcvPacket.getLength() // 实际接收的数据长度，最大 64k<br>    ……<br>}</p>\n<h2 id=\"Socket长连接\"><a href=\"#Socket长连接\" class=\"headerlink\" title=\"Socket长连接\"></a>Socket长连接</h2><p>isClosed()、isConnected()、isInputStreamShutdown()、isOutputStreamShutdown()都是本地判断，只是本地操作connect()或close()方法后保存的状态，无法判断服务端是否主动断开，OutputStream.write()在服务端关闭时也能照常发送不会报错。</p>\n<p>采用服务端心跳回复的机制，客户端发送心跳后，服务端需要回复心跳，并设置中断超时，超过几次心跳后仍然没有回复则主动断开连接。</p>\n","categories":["Network"],"tags":["Network","Socket"]},{"title":"TCP和UDP","url":"/post/network/network-tcp_udp/","content":"<span id=\"more\"></span>\n\n<h1 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h1><h2 id=\"1-TCP\"><a href=\"#1-TCP\" class=\"headerlink\" title=\"1. TCP\"></a>1. TCP</h2><p>TCP 是可靠传输，使用流量控制和拥塞控制，仅支持一对一，首部最小 20 字节最大 60 字节。</p>\n<h3 id=\"1-1-连接的建立与断开\"><a href=\"#1-1-连接的建立与断开\" class=\"headerlink\" title=\"1.1 连接的建立与断开\"></a>1.1 连接的建立与断开</h3><h4 id=\"1-1-1-三次握手建立连接\"><a href=\"#1-1-1-三次握手建立连接\" class=\"headerlink\" title=\"1.1.1 三次握手建立连接\"></a>1.1.1 三次握手建立连接</h4><ul>\n<li>第一次握手：C 向 S 发送一个连接请求，包括一个 <code>SYN = 1, seq = 随机数 i</code>，C 进入 <code>SYN_SENT</code> 状态。</li>\n<li>第二次握手：S 收到请求后，回应一个：<code>SYN = 1, ACK = 1, ack = i + 1, seq = 随机数 j</code>，S 进入 <code>SYN_RCVD</code> 状态。</li>\n<li>第三次握手：C 收到回应后，发送一个 <code>ACK = 1, ack = j + 1</code>，S 接收并确认后，双方建立连接，进入 <code>ESTABLISHED</code> 状态。</li>\n</ul>\n<h4 id=\"1-1-2-四次挥手断开连接\"><a href=\"#1-1-2-四次挥手断开连接\" class=\"headerlink\" title=\"1.1.2 四次挥手断开连接\"></a>1.1.2 四次挥手断开连接</h4><ul>\n<li>第一次挥手：C 发送一个 <code>FIN = 随机数 k</code>，C 进入 <code>FIN_WAIT_1</code> 状态，此时 C 已停止发送数据，但 S 还在监听，还能发送数据。</li>\n<li>第二次挥手：S 回应一个 <code>ack = k + 1</code>，S 进入 <code>CLOSE_WAIT</code> 状态，C 确认后进入 <code>FIN_WAIT_2</code> 状态，此时服务器已经获取到 C 即将断开的信号，但 S 仍在活跃状态。</li>\n<li>第三次挥手：S 发送一个 <code>FIN = 随机数 l</code>，S 进入 <code>LAST_ACK</code> 状态，S 停止监听，进入等待断开状态，此时 C 和 S 均已停止数据交互。</li>\n<li>第四次挥手：C 确认了 S 的 <code>FIN</code> 后，C 进入 <code>TIME_WAIT</code> 状态，再发送一个 <code>ACK = 1, ack = l + 1</code>，S 进入 <code>CLOSED</code> 状态，挥手完成，连接断开。</li>\n</ul>\n<h3 id=\"1-2-连接的控制\"><a href=\"#1-2-连接的控制\" class=\"headerlink\" title=\"1.2 连接的控制\"></a>1.2 连接的控制</h3><h4 id=\"1-2-1-流量控制\"><a href=\"#1-2-1-流量控制\" class=\"headerlink\" title=\"1.2.1 流量控制\"></a>1.2.1 流量控制</h4><p>接收端通知发送端自己可接受的数据大小，叫窗口大小，TCP 首部有个 16 位的窗口大小字段，16 位最大表示 65535，但在 TCP 的 40 字节首部选项中还有个窗口扩大因子 <code>M</code>，实际的窗口大小等于窗口大小左移 <code>M</code> 位。</p>\n<p>接收端通过窗口大小告知发送端可发送的数据大小，通常可将缓冲区的大小设置为窗口大小，当缓冲区快满了，接收端就逐渐减小窗口大小，直到为 0，则发送端不再发送数据，但会定期发送一个窗口探测数据段，以保持获取接收端的窗口大小。如果接收端回复探测数据段的数据帧丢失，就会导致连接中断，所以发送端如果超时未接收到回复，就会重新发送探测数据段。</p>\n<h4 id=\"1-2-2-拥塞控制\"><a href=\"#1-2-2-拥塞控制\" class=\"headerlink\" title=\"1.2.2 拥塞控制\"></a>1.2.2 拥塞控制</h4><p>除了考虑到流量控制的情况，还需要考虑到：接收方的窗口大小是在 <code>ACK</code> 的时候才回传的，可以理解为，发送方总是慢半拍才知道接收方的窗口大小，因此不能每次都贸然发送最大的数据后再获取窗口大小来调整。为此 TCP 引入慢启动机制，核心思想就是先从少量数据开始发送，如果网络通畅则逐步增大，否则就逐步减少。</p>\n<p>发送方维护一个拥塞窗口 <code>cwnd</code>，<code>cwnd</code> 初始为较小的一个数，通常为最大分段大小（Maximum segment size，MSS）的两倍，也即“慢启动”，但如果收到了 <code>ACK</code>，则 <code>cwnd</code> 增大一倍（指数增长），因此慢启动只是启动初值低，而增长速度很快。如果 <code>cwnd</code> 增大到了慢启动阈值（Slow Start Threshold，SSThresh），则再次收到 <code>ACK</code> 时不再以指数增长，而是以 <code>cwnd = cwnd + (1 / cwnd)</code>，每次增长自身的倒数，且每经过一次数据包往返时间（Round Trip Time，RTT），就自增 1：<code>cwnd = cwnd++</code>，变成线性增长，以避免出现拥塞。</p>\n<p>如果发生超时重传（Retransmission TimeOut，RTO），则认为出现了拥塞，则将ssthresh设置为当前cwnd的一半：ssthresh = cwnd / 2，并重置cwnd变回初始值。</p>\n<p>因此，当 <code>cwnd &lt; ssthresh</code> 时，可以认为需要慢启动，进入快速增长，当 <code>cwnd &gt; ssthresh</code> 时，可以认为需要避免拥塞，进入线性增长，当 <code>cwnd ＝ ssthresh</code> 时，可以使用慢启动算法，也可以使用拥塞算法。</p>\n<p>接收方在接收数据后，会回复一个确认帧，确认帧包括了期待下一次接收的数据的序列号，发送方在接收到该确认帧后，会将下一个数据帧的序列号设置为接收方期待的序列号。而如果接收方接收到的数据中的序列号，不是自己所期待的，说明自己所期待的数据发生了丢失导致未能接收到，则需要根据所设置的重复阈值 N（例如3），连续 N 次向发送方发送 <code>ACK</code>，且 <code>ACK</code> 中包含了已丢失的那份自己所期待的数据的序列号，发送方在连续 N 次接收到了这样的 <code>ACK</code> 后，则认为发生了数据丢失，而不是拥塞，则进入快速重传阶段，立即发送中间缺失的数据（也即发送方没有收到对应 <code>ACK</code> 导致 <code>RTT</code> 的数据），同时执行快速恢复算法，将 <code>ssthresh</code> 调整为当前 <code>cwnd</code> 的一半，由于调整后 <code>cwnd &gt; ssthresh</code>，因此执行拥塞避免算法。</p>\n<h3 id=\"1-3-TCP-IP四层模型\"><a href=\"#1-3-TCP-IP四层模型\" class=\"headerlink\" title=\"1.3 TCP/IP四层模型\"></a>1.3 TCP/IP四层模型</h3><p>OSI 模型对应 TCP/IP 四层模型（从上到下）：</p>\n<ul>\n<li>应用层、表示层、会话层 - 应用层</li>\n<li>传输层 - 传输层</li>\n<li>网络层 - 网络互联层</li>\n<li>数据链路层、物理层 - 主机到网络层</li>\n</ul>\n<h4 id=\"1-3-1-网络层和传输层的区别\"><a href=\"#1-3-1-网络层和传输层的区别\" class=\"headerlink\" title=\"1.3.1 网络层和传输层的区别\"></a>1.3.1 网络层和传输层的区别</h4><p>网络层面向的是设备与设备之间的通信，而传输层面向的是设备与设备上运行的进程之间的通信。例如，IP 属于网络（互联）层，它负责定位一个网络中的各个设备，设备和设备之间的数据交互不一定使用 TCP 或 UDP，但需要知道 IP 地址。而 TCP、UDP 属于传输层，负责将数据从某个端口（也可以映射成一个进程）到另一端口（另一个进程），以区分不同的进程，实现不同的应用服务之间的数据传输服务。</p>\n<hr>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>UDP 是不可靠传输，没有流量控制和拥塞控制，UDP 支持单播（一对一）、多播（一对多和多对一）、广播（多对多），首部开销小（8 字节），适用于实时应用（IP 电话、视频会议、直播等）。</p>\n<p>远程视频流传输，可以分别利用 UDP 的可靠传输和不可靠传输。</p>\n<p>视频中的帧有关键帧和普通帧，关键帧是可以直接解码出帧图像的帧，它包含了一个帧所有的信息，而普通帧，是根据其依附的关键帧，只记录了与之相差的部分，不能直接解码出帧图像，这样做的好处，是大大缩小了视频的体积，因为每个关键帧之间的普通帧，只需要记录自己和所依附的关键帧之间的差别，然后在播放的时候只需要改变显示有差别的地方即可。因此，远程视频传输，可以在传输关键帧的时候，使用可靠传输，确保关键帧传输到位，而普通帧使用不可靠传输，这样即使普通帧丢包，也不会影响整体显示效果。</p>\n<p>UDP 如果想要实现可靠传输，可以在数据段手动添加 <code>ACK</code> 和 <code>SEQ</code> 机制，自行判断 <code>ACK</code> 和 <code>SEQ</code> 是否符合，并配合发送和接收缓冲区以及维护一个超时重传表来实现。</p>\n<p>已有的可靠 UDP 有：RUDP（实现了 TCP 中的流量控制）、RTP（）等。</p>\n","categories":["Network"],"tags":["Network","TCP","UDP"]},{"title":"ML入门-模型性能评价指标","url":"/post/machinelearning/ml-model/ml-model-performance/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-模型性能评价指标\"><a href=\"#ML入门-模型性能评价指标\" class=\"headerlink\" title=\"ML入门-模型性能评价指标\"></a>ML入门-模型性能评价指标</h1><p>前言：一个机器学习模型训练好后，需要采用一些度量准则评价模型预测的效果。根据任务的种类可以分为回归模型评价指标和分类模型评价指标。</p>\n<hr>\n<h2 id=\"1-回归模型性能评价指标\"><a href=\"#1-回归模型性能评价指标\" class=\"headerlink\" title=\"1. 回归模型性能评价指标\"></a>1. 回归模型性能评价指标</h2><h3 id=\"1-1-常见的-6-种评价指标\"><a href=\"#1-1-常见的-6-种评价指标\" class=\"headerlink\" title=\"1.1 常见的 6 种评价指标\"></a>1.1 常见的 6 种评价指标</h3><p>（1）开放均方误差（Rooted Mean Squared Error, RMSE）：</p>\n<p>$<br>RMSE(y, \\hat{y}) = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i, \\hat{y_i})^2}<br>$</p>\n<p>开放的目的在于使得 RMSE 的返回值与 $y$ 的单位一致。</p>\n<p>（2）平均绝对值误差（Mean Absolute Error, MAE）：</p>\n<p>$<br>MAE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} |y_i - \\hat{y_i}|<br>$</p>\n<p>（3）绝对误差中值（Median Absolute Error, MedAE）：</p>\n<p>$<br>MedAE(y, \\hat{y}) = median(|y_1 - \\hat{y_1}|, \\cdots, |y_N - \\hat{y_N}|)<br>$</p>\n<p>相对于均值，中值对噪声点较不敏感。</p>\n<p>（4）平均平方 $\\log$ 误差（Mean Squared Logarithmic Error, MSLE）：</p>\n<p>$<br>MSLE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} \\left( \\log (1 + y_i) - \\log (1 + \\hat{y_i}) \\right)^2<br>$</p>\n<p>当 $y$ 呈指数增长时可以使用，如计数、一年的平均销量、价格等。$1 + y_i$ 与 $1 + \\hat{y_i}$ 的目的是为了确保 $\\log$ 计算有意义（当 $y_i / \\hat{y_i} = 0$ 时，$\\log 0$ 无意义）。</p>\n<p>（5）$R^2$ 分数（$R^2$ Score）：</p>\n<p>$<br>\\begin{aligned}<br>&amp; SS_{res}(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2<br>\\\\<br>&amp; SS_{tot}(y) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\bar{y})^2<br>\\\\<br>&amp; R^2(y, \\hat{y}) = 1 - \\dfrac {SS_{res}(y, \\hat{y})} {SS_{tot}(y)}<br>\\end{aligned}<br>$</p>\n<p>$R^2$ 分数既考虑了预测值与真实值之间的差异，又考虑了问题本身针织之间的差异，是 Scikit-Learn 线性回归模型的默认评价准则。当 $SS_{res} = 0$ 时，$R^2 = 1$ 为最佳分数，分数越低则模型性能越差，可能为负值。</p>\n<p>（6）已解释的访查分数（Explained variance socre）：</p>\n<p>$<br>explained_variance(y, \\hat{y}) = 1 - \\dfrac {Var(y - \\hat{y})} {Var \\{ y \\} }<br>$</p>\n<h3 id=\"1-2-Scikit-Learn中的评价指标\"><a href=\"#1-2-Scikit-Learn中的评价指标\" class=\"headerlink\" title=\"1.2 Scikit-Learn中的评价指标\"></a>1.2 Scikit-Learn中的评价指标</h3><p>Scikit-Learn 中有三种评价模型性能的方式，但基本都是通过上述 6 种计算方式实现的。</p>\n<p>（1）每个学习器 Estimator 自己的 <code>score</code> 方法，提供一个默认的评估方法（回归为 $R^2$ 分数）。</p>\n<p>（2）Metric：<code>sklearn.metrics</code> 模块实现了一些函数，用来评估预测误差。</p>\n<p><code>sklearn.metrics</code> 中的回归评价指标：</p>\n<p>① <code>metrics.explained_variance_score(y_true, y_pred)</code>：Explained variance regression score function<br>② <code>metrics.mean_absolute_error(y_true, y_pred)</code>：Mean-Absolute-Error regression loss<br>③ <code>metrics.mean_squared_error(y_true, y_pred[, ...])</code>：Mean-Squared-Error regression loss<br>④ <code>metrics.mean_squared_log_error(y_true, y_pred)</code>：Mean-Squared-Logarithmic-Error regression loss<br>⑤ <code>metrics.median_absolute_error(y_true, y_pred)</code>：Median-Absolute-Error regression loss<br>⑥ <code>metrics.r2_score(y_true, y_pred[, ...])</code>：$R^2$ (coefficient of determination) regression score function.</p>\n<p>（3）Scoring 参数：使用交叉验证评估模型的工具有 Scoring 参数，与 Metrics 一一对应。</p>\n<p>① <code>explained_variance</code>；metrics.explained_variance_score<br>② <code>neg_mean_absolute_error</code>：metrics.mean_absolute_error<br>③ <code>neg_mean_squared_error</code>：metrics.mean_squared_error<br>④ <code>neg_mean_squared_log_error</code>：metrics.mean_squared_log_error<br>⑤ <code>neg_median_absolute_error</code>：metrics.median_absolute_error<br>⑥ <code>r2</code>：metrics.r2_score</p>\n<p>Scoring 越高代表模型性能越好，其中 explained_variance 和 $R^2$ 本来即越高越好，因此 Scoring 可直接使用。第 ②、③、④、⑤ 个参数取“error”对应 误差 / 损失，因此对 error 取负数“neg_”。</p>\n<hr>\n<h2 id=\"2-分类模型性能评价指标\"><a href=\"#2-分类模型性能评价指标\" class=\"headerlink\" title=\"2. 分类模型性能评价指标\"></a>2. 分类模型性能评价指标</h2>","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","评价指标"]},{"title":"ML入门-损失和正则的概率解释","url":"/post/machinelearning/ml-linear/ml-linear-loss-regular/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-损失和正则的概率解释\"><a href=\"#ML入门-损失和正则的概率解释\" class=\"headerlink\" title=\"ML入门-损失和正则的概率解释\"></a>ML入门-损失和正则的概率解释</h1><p>结论：最小 L2、L1 损失均等价于极大似然估计；带正则的回归等价于贝叶斯估计。</p>\n<hr>\n<h2 id=\"1-损失函数的概率解释\"><a href=\"#1-损失函数的概率解释\" class=\"headerlink\" title=\"1. 损失函数的概率解释\"></a>1. 损失函数的概率解释</h2><h3 id=\"1-1-L2损失与极大似然估计\"><a href=\"#1-1-L2损失与极大似然估计\" class=\"headerlink\" title=\"1.1 L2损失与极大似然估计\"></a>1.1 L2损失与极大似然估计</h3><p>对采用 L2 损失的模型，目标函数为：</p>\n<p>$$<br>J(W) = RSS(W) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>在回归任务重，令模型中的真实值 $y_i$ 和预测值 $\\hat{y_i}$ 之间的差异为白噪声 $\\varepsilon$，假设噪声（随机变量）$\\varepsilon$ 符合 0 均值的正态分布：$\\varepsilon \\sim N(0, \\sigma^2)$。</p>\n<p>用 $y | X$ 表示给定输入 $X$ 的情况下的输出 $y$，当输入$X$ 给定时，$f(X) = W^T X$ 是一个常数，因此 $y = f(X) + \\varepsilon$ 也是一个随机变量：$y | X \\sim N(f(X), \\sigma^2)$</p>\n<blockquote>\n<p>随机变量加上一个常数，只改变分布的均值，不改变分布的方差。</p>\n</blockquote>\n<p>对于正态分布，其概率密度函数为：</p>\n<p>$$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {\\left( y - f(X) \\right)^2} {2 \\sigma^2} \\right)<br>$$</p>\n<blockquote>\n<p>很多分布的概率密度函数为指数函数形式，因此通常取 log 运算，log 函数为单调函数，对似然函数取 log 不影响极值点位置。</p>\n</blockquote>\n<p>似然函数（Likelihood）为：$likelihood(f) = p(D)$，定义为数据出现的概率。在回归任务中，通常假定所有数据都是独立同分布的，因而对所有数据 $D$，其联合概率等于每个独立样本概率的积：</p>\n<p>$$<br>p(D) = \\prod^N_{i = 1} p(y_i | x_i)<br>$$</p>\n<p>对似然函数取 $\\log$ 运算（$\\log$ 是单调函数，不改变极值点位置，与似然函数等价）得到 $\\log$ 似然函数（积取 log 等于 log 再取和，）即为：</p>\n<p>$$<br>\\begin{aligned}<br>l(f) &amp;= \\log p(D) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ (2 \\pi)^{- \\dfrac {1} {2}} \\cdot \\sigma^{-1} \\cdot \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\left[ - \\dfrac {1} {2} \\log (2 \\pi) - \\log \\sigma - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right]<br>\\\\<br>&amp;= - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$$</p>\n<p>去掉 $l(f)$ 中常数项（不影响极值点位置），当 $l(f)$ 取最大值时可得 <strong>极大似然估计</strong>：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)<br>\\\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\dfrac {1} {2 \\sigma^2} \\min \\sum^N_{i = 1} (y_i - f(x_i))^2<br>\\end{aligned}<br>$$</p>\n<p>同样，去掉系数 $\\dfrac {1} {2 \\sigma^2}$ 不影响极值点位置，而其中的似然项</p>\n<p>$<br>\\sum^N_{i = 1} (y_i - f(x_i))^2 = RSS(f)<br>$</p>\n<p>恰好 是残差平方和 / 训练集上的 L2 损失和，因此：</p>\n<p>$$<br>\\begin{aligned}<br>\\max l(f) &amp;<br>\\\\<br>极大似然估计 &amp;<br>\\end{aligned}<br>\\begin{aligned}<br>\\Longleftrightarrow \\min \\sum^N_{i = 1} (y_i - f(x_i))^2 \\Longleftrightarrow<br>\\\\<br>\\quad<br>\\end{aligned}<br>\\begin{aligned}<br>&amp; \\min RSS(f)<br>\\\\<br>&amp; 最小二乘<br>\\end{aligned}<br>$$</p>\n<p><strong>极大似然估计等价于最小二乘。</strong></p>\n<p>又由于 log 似然即：$l(f)$，与极大似然有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)：极大似然估计<br>\\\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min - l(f)：负 log 似然最小<br>\\end{aligned}<br>$$</p>\n<p><strong>极大似然估计等价于负 log 似然最小。</strong></p>\n<p>因此负 log 似然也被成为一种损失函数：负 log 似然损失。</p>\n<ul>\n<li>L2 损失是负 log 似然损失。</li>\n<li>分类任务中的 Logistic 回归使用的也是负 log 似然损失。</li>\n</ul>\n<p>将上述极大似然估计推广为一般形式：</p>\n<p>$$<br>l(\\theta) = \\log (D | \\theta) = \\sum^N_{i = 1}\\log p(X_i | \\theta)<br>$$</p>\n<p>其中 $\\theta$ 为需要求解的分布的参数，$X$ 为每条样本。</p>\n<p>统计中需要根据观测数据 $D= \\{ X_i \\}^N_{i = 1}$ 估计分布的参数 $\\theta$，一种常用的参数估计即为 <strong>极大似然估计</strong>，即，使得 log 似然函数 $l(f)$ 最大时的 $\\theta$ 作为估计值：</p>\n<p>$$<br>\\hat{\\theta} = \\arg_{\\theta} \\max l(\\theta)<br>$$</p>\n<h3 id=\"1-2-L1-损失与极大似然估计\"><a href=\"#1-2-L1-损失与极大似然估计\" class=\"headerlink\" title=\"1.2 L1 损失与极大似然估计\"></a>1.2 L1 损失与极大似然估计</h3><p>L1 损失最小也等价于极大似然估计，此时噪声模型为 Laplace 分布：</p>\n<p>$$<br>\\varepsilon \\sim Laplace(\\mu, b) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|x - \\mu|} {b} \\right)<br>$$</p>\n<hr>\n<h2 id=\"2-正则项的概率解释\"><a href=\"#2-正则项的概率解释\" class=\"headerlink\" title=\"2. 正则项的概率解释\"></a>2. 正则项的概率解释</h2><h3 id=\"2-1-L2正则与正态分布先验\"><a href=\"#2-1-L2正则与正态分布先验\" class=\"headerlink\" title=\"2.1 L2正则与正态分布先验\"></a>2.1 L2正则与正态分布先验</h3><p>在损失函数的概率解释中已经推出：假设数据产生模型为</p>\n<p>$<br>y = f(X) + \\varepsilon, \\quad \\varepsilon \\sim N(0, \\sigma^2)<br>$</p>\n<p>则 $y | X \\sim N(f(X; W), \\sigma^2)$，即</p>\n<p>$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y - f(X; W))^2} {2 \\sigma^2} \\right)<br>$</p>\n<p><strong>似然函数为：</strong></p>\n<p>$$<br>似然 \\quad likelihood(f) = p(D | W) = \\prod^N_{i = 1} p(y_i | x_i) = \\prod^N_{i = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x_i; W))^2} {2 \\sigma^2} \\right)<br>$$</p>\n<p>为了模型不太复杂，增加一个参数的先验：$w_j$ 的值不能太大，也即 $w_j$ 取 0 附近的值概率更高，假设 $W$ 为独立同分布，此时可用正态分布来表示 $w_j$ 的取值分布：$w_j \\sim N(0, \\tau^2)$</p>\n<p><img data-src=\"./w_distribution.png\" alt=\"W 取值分布\" title=\"@ASSET\"></p>\n<p>则对每一个 $w_j$，其概率密度函数为：</p>\n<p>$<br>p(w_j) = \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$</p>\n<p>因此对 $W$，其联合概率密度函数即为 <strong>先验</strong>：</p>\n<p>$$<br>先验 \\quad p(W) = \\prod^D_{j = 1} p(w_j) = \\prod^D_{j = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$$</p>\n<p>根据 <a href=\"https://baike.baidu.com/item/贝叶斯公式\" title=\"@LINK\">贝叶斯公式</a>，参数的 <strong>后验分布</strong> 正比于 <strong>先验 x 似然</strong>：</p>\n<p>$$<br>后验 \\quad p(W | D) \\propto p(W) p(D | W)<br>$$</p>\n<p>去掉正比系数（不影响极值点位置）并两边同取 log 运算可得：</p>\n<p>$<br>\\begin{aligned}<br>&amp; \\log p(W | D) = \\log p(W) + \\log p(D | W)<br>\\\\<br>&amp;= - \\dfrac {D} {2} \\log (2 \\pi) - D \\log \\tau - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$</p>\n<p>贝叶斯最大后验估计（Maximun A Posteriori estimation, MAP）为</p>\n<p>$<br>\\hat{W} = \\arg_W \\max \\log p(W | D)<br>$</p>\n<p>将上述 $\\log p(W | D)$ 代入并去掉与 $W$ 无关的常数项（不影响极值点位置）后得：</p>\n<p>$<br>\\begin{aligned}<br>\\hat{W} &amp;= \\arg_W \\max \\log p(W | D)<br>\\\\<br>&amp;= \\arg_W \\max \\left( - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\\\<br>&amp;= \\arg_W \\min \\left( \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} + \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\\\<br>乘以 2 \\sigma^2 &amp;= \\arg_W \\min \\left( \\dfrac {\\sigma^2} {\\tau^2} \\sum^D_{j = 1} w^2_j + \\sum^N_{i = 1} (y_i - f(x_i; w))^2 \\right)<br>\\end{aligned}<br>$</p>\n<p>上式令 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 得：</p>\n<p>$$<br>\\hat{W} = \\arg_W \\min \\left( \\sum^N_{i = 1} (y_i - f(x_i; w))^2 + \\lambda \\sum^D_{j = 1} w^2_j \\right)<br>$$</p>\n<p><strong>等价于岭回归的目标参数</strong>，因此有结论：</p>\n<p><strong>L2 正则等价于正态分布先验 $N(0, \\tau^2)$。</strong></p>\n<p>由于 $\\sigma^2$ 控制了噪声分布，而 $\\tau^2$ 控制了先验，因此 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 实际上控制了先验的强度（$w_j$ 靠近 0 的程度）。</p>\n<h2 id=\"2-2-L1正则与Laplace分布先验\"><a href=\"#2-2-L1正则与Laplace分布先验\" class=\"headerlink\" title=\"2.2 L1正则与Laplace分布先验\"></a>2.2 L1正则与Laplace分布先验</h2><p>L1 正则等价于 Laplace 先验，此时先验分布为 Laplace 分布：</p>\n<p>$$<br>p(w_j) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|w_j|} {b} \\right)<br>$$</p>\n<p><img data-src=\"./laplace_distribution.png\" alt=\"Laplace 分布\" title=\"@ASSET\"></p>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-多类分类任务","url":"/post/machinelearning/ml-logistic/ml-logistic-multiclassify/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-多类分类任务\"><a href=\"#ML入门-多类分类任务\" class=\"headerlink\" title=\"ML入门-多类分类任务\"></a>ML入门-多类分类任务</h1>","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-类别样本不均衡问题","url":"/post/machinelearning/ml-logistic/ml-logistic-unbalanced/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-类别样本不均衡问题\"><a href=\"#ML入门-类别样本不均衡问题\" class=\"headerlink\" title=\"ML入门-类别样本不均衡问题\"></a>ML入门-类别样本不均衡问题</h1>","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"Android-Handler","url":"/post/android/android-handler/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Handler\"><a href=\"#Android-Handler\" class=\"headerlink\" title=\"Android-Handler\"></a>Android-Handler</h1><h2 id=\"1-Handler的实例化和初始化\"><a href=\"#1-Handler的实例化和初始化\" class=\"headerlink\" title=\"1. Handler的实例化和初始化\"></a>1. Handler的实例化和初始化</h2><p>Handler 在 Android 开发中还是相当相当常见的，其涉及到了很多 Android 和 Java 的数据结构。Handler 的源码并不复杂，原理也很有意思，常用的方法里实例化和初始化就占了很大一部分，消息 Message 的传递也占了很大一部分，本文主要也是分析这两点，剩下的用的不是太多，直接阅读源码也很快，在本文就不分析了。通过阅读 Handler 以及相关类的源码，可以深刻体会到 Android 的一些通用设计理念。</p>\n<h3 id=\"1-1-什么是Handler\"><a href=\"#1-1-什么是Handler\" class=\"headerlink\" title=\"1.1 什么是Handler\"></a>1.1 什么是Handler</h3><p>在 Handler 的源码中，有一段很长的注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A Handler allows you to send and process &#123;<span class=\"doctag\">@link</span> Message&#125; and Runnable</span></span><br><span class=\"line\"><span class=\"comment\"> * objects associated with a thread&#x27;s &#123;<span class=\"doctag\">@link</span> MessageQueue&#125;.  Each Handler</span></span><br><span class=\"line\"><span class=\"comment\"> * instance is associated with a single thread and that thread&#x27;s message</span></span><br><span class=\"line\"><span class=\"comment\"> * queue.  When you create a new Handler, it is bound to the thread /</span></span><br><span class=\"line\"><span class=\"comment\"> * message queue of the thread that is creating it -- from that point on,</span></span><br><span class=\"line\"><span class=\"comment\"> * it will deliver messages and runnables to that message queue and execute</span></span><br><span class=\"line\"><span class=\"comment\"> * them as they come out of the message queue.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and</span></span><br><span class=\"line\"><span class=\"comment\"> * runnables to be executed at some point in the future; and (2) to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * an action to be performed on a different thread than your own.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Scheduling messages is accomplished with the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #post&#125;, &#123;<span class=\"doctag\">@link</span> #postAtTime(Runnable, long)&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #postDelayed&#125;, &#123;<span class=\"doctag\">@link</span> #sendEmptyMessage&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessage&#125;, &#123;<span class=\"doctag\">@link</span> #sendMessageAtTime&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessageDelayed&#125; methods.  The &lt;em&gt;post&lt;/em&gt; versions allow</span></span><br><span class=\"line\"><span class=\"comment\"> * you to enqueue Runnable objects to be called by the message queue when</span></span><br><span class=\"line\"><span class=\"comment\"> * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * a &#123;<span class=\"doctag\">@link</span> Message&#125; object containing a bundle of data that will be</span></span><br><span class=\"line\"><span class=\"comment\"> * processed by the Handler&#x27;s &#123;<span class=\"doctag\">@link</span> #handleMessage&#125; method (requiring that</span></span><br><span class=\"line\"><span class=\"comment\"> * you implement a subclass of Handler).</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When posting or sending to a Handler, you can either</span></span><br><span class=\"line\"><span class=\"comment\"> * allow the item to be processed as soon as the message queue is ready</span></span><br><span class=\"line\"><span class=\"comment\"> * to do so, or specify a delay before it gets processed or absolute time for</span></span><br><span class=\"line\"><span class=\"comment\"> * it to be processed.  The latter two allow you to implement timeouts,</span></span><br><span class=\"line\"><span class=\"comment\"> * ticks, and other timing-based behavior.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When a</span></span><br><span class=\"line\"><span class=\"comment\"> * process is created for your application, its main thread is dedicated to</span></span><br><span class=\"line\"><span class=\"comment\"> * running a message queue that takes care of managing the top-level</span></span><br><span class=\"line\"><span class=\"comment\"> * application objects (activities, broadcast receivers, etc) and any windows</span></span><br><span class=\"line\"><span class=\"comment\"> * they create.  You can create your own threads, and communicate back with</span></span><br><span class=\"line\"><span class=\"comment\"> * the main application thread through a Handler.  This is done by calling</span></span><br><span class=\"line\"><span class=\"comment\"> * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from</span></span><br><span class=\"line\"><span class=\"comment\"> * your new thread.  The given Runnable or Message will then be scheduled</span></span><br><span class=\"line\"><span class=\"comment\"> * in the Handler&#x27;s message queue and processed when appropriate.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概翻译一下，这段注释基本也介绍清楚了 Handler 的工作流程：</p>\n<ul>\n<li>Handler 允许你发送和处理和线程的 MessageQueue 相关联的 Message 和 Runnable 对象。每个 Handler 实例对象都只和一个线程以及该线程的消息队列。当创建一个 Handler 实例时，这个 Handler 会与线程以及这个线程创建的消息队列绑定，这之后，这个 Handler 会负责给 MessageQueue 传送 Message 和 Runnable，或者负责处理从 MessageQueue 中取出的 Message 和 Runnable。</li>\n<li>Handler 有 2 个主要的用途：（1）给 Message 和 Runnable 安排一个未来执行的时间（可以是相差 0，表示立即执行）；（2）将一个事务提交到另一个不同的线程处理。</li>\n<li>Handler 通过 <code>post</code>，<code>postAtTime(Runnable, long)</code>，<code>postDelayed</code>，<code>sendEmptyMessage</code>，<code>sendMessage</code>，<code>sendMessageAtTime</code>，<code>sendMessageDelayed</code> 方法调度 Message。<code>post</code> 方式允许发送一个 Runnable 对象并在被 MessageQueue 接收后调用。<code>shendMessage</code> 方式允许发送一个包括了一个 Bundle 形式的数据的 Message，并且在 <code>Handler.handleMessage()</code> 方法中处理（要求实现一个 Handler 的子类）。</li>\n<li>不论使用 <code>post</code> 还是 <code>send</code> 方式发送消息，都可以让这些消息在 MessageQueue 可用时立即处理，或者指定一个延时间隔来延迟处理，或者指定一个具体的处理事件。后面二者可以通过：延迟、具体时间、或其他基于时间的行为来实现。</li>\n<li>当 App 的进程被创建时，它的主线程则专门用来运行一个管理顶层应用对象的 MessageQueue，这些顶层应用对象可以是例如：Activity，BroadcastReceiver 等等，或是他们创建的其他 Windows。你可以创建自己的子线程，并通过 Handler 与主线程通信，只需要在子线程中调用上述的 <code>send</code> 类型或 <code>post</code> 类型的方法即可，发送的 Message 或 Runnable 将在 Handler 的 MessageQueue 合适的时候被调度和处理。</li>\n</ul>\n<p>需要注意的几个重点：（1）Handler 可以用来发送消息也可以用来处理消息；（2）发送消息有两种类型的方式，处理消息可以跨进程；（3）Handler 的实例是和当前线程以及当前线程的 MessageQueue 绑定的；（4）MessageQueue 中维护的单链表只支持 Message 对象，因此 Runnable 是通过封装进 Message 来实现的。</p>\n<h3 id=\"1-2-Handler构造方法\"><a href=\"#1-2-Handler构造方法\" class=\"headerlink\" title=\"1.2 Handler构造方法\"></a>1.2 Handler构造方法</h3><p>Handler 内部有多个不同参数的构造方法，依次看看：</p>\n<p>（1）无参默认构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Default constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该构造方法会使得 Handler 与当前线程的 Looper 关联，如果当前线程没有 Looper，则 Handler 将无法接收消息，从而抛出异常。</p>\n<p>（2）1 个参数（<code>Callback</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread and takes a callback interface in which you can handle</span></span><br><span class=\"line\"><span class=\"comment\">  * messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过重写了接收消息后处理的回调方法 <code>handleMessage</code>。</p>\n<p>（3）1 个参数（<code>async</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过指定了通过这个 Handler 发送的消息为异步消息（Async）。</p>\n<p>（4）以上第 1、2、3 种构造方法最终均调用了 2 个参数（<code>Callback, async</code>）的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Looper.myLooper()</code> 就是返回了当前线程中的 Looper 实例对象，如果当前线程不具备处理消息的功能，也即没有 Looper 实例，则返回 <code>null</code>，接下来也就是当存在 Looper 实例对象时，获取并绑定其消息队列 MessageQueue，处理事件的回调 Callback，以及设置是否异步 async。</p>\n<p>（5）1 个参数（<code>Looper</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>手动指定这个 Handler 需要绑定的线程，当我们需要从子线程更新 UI 时，通常会使用如下方法来实例化一个 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Handler handler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure>\n\n<p>这其实就是调用的这个构造方法，而 <code>Looper.getMainLooper()</code> 返回的就是主线程的 Looper 实例对象。</p>\n<p>（6）2 个参数（<code>Looper, Callback</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时指定 Looper 和 Callback。</p>\n<p>（7）以上第 5、6 种构造方法最终均调用了 3 个参数的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.  Also set whether the handler</span></span><br><span class=\"line\"><span class=\"comment\">  * should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by conditions such as display vsync.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    mQueue = looper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个构造方法则是最详细的，可以同时指定 Looper，Callback，以及是否异步 async。</p>\n<p>通过查看以上 7 种构造方法，可以总结出 Handler 的实例化过程：如果没有显式传入任何参数，则默认绑定当前线程的 Looper，使用默认 Callback，发送同步消息，否则按照对应显式传入的参数手动指定。</p>\n<hr>\n<h2 id=\"2-Handler发送Message\"><a href=\"#2-Handler发送Message\" class=\"headerlink\" title=\"2. Handler发送Message\"></a>2. Handler发送Message</h2><h3 id=\"2-1-源码分析\"><a href=\"#2-1-源码分析\" class=\"headerlink\" title=\"2.1 源码分析\"></a>2.1 源码分析</h3><p>在平时开发中 Handler 最主要的用途就是在子线程中更新 UI，两种方式：</p>\n<ul>\n<li><p><code>send</code> 方式，包括：</p>\n<ul>\n<li><code>sendMessage</code> 或 <code>sendEmptyMessage</code></li>\n<li><code>sendMessageDelayed</code> 或 <code>sendEmptyMessageDelayed</code></li>\n<li><code>sendMessageAtTime</code> 或 <code>sendEmptyMessageAtTime</code></li>\n<li><code>sendMessageAtFrontOfQueue</code>（比较特殊，会在后面详细讲解）</li>\n</ul>\n</li>\n<li><p><code>post</code> 方式，包括：</p>\n<ul>\n<li><code>post</code></li>\n<li><code>postDelayed</code></li>\n<li><code>postAtTime</code></li>\n<li><code>postAtFrontOfQueue</code></li>\n</ul>\n</li>\n</ul>\n<p>其中，通过查看 <code>post</code> 方式的源码可以发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delayed</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@hide</span> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(Runnable r, <span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r).setWhat(what), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r, token), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtTime</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtFrontOfQueue</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上 <code>post</code> 方式最终都是通过 <code>send</code> 方式实现的。再看一下各个 <code>send</code> 方式的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> what)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendEmptyMessageDelayed(what, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageAtTime</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上源码中可以看到一个参数：<code>uptimeMillis</code>，这个参数是从开机到当前时刻的时间间隔（毫秒，当设备处于睡眠时不计算），表示消息需要被处理时的时间，任意不同时刻获取到的该值都是不同的，<code>uptimeMillis</code> 越小表示消息越早处理。<strong>消息在添加到消息队列中时，是按照实际处理的时间从先到后按顺序排列的</strong>，并且除了 <code>sendMessageAtFrontOfQueue</code> 方法之外，其他 <code>send</code> 方式本质都是通过这一个方法发送的：<code>sendMessageAtTime</code>，而这两个方法最终都调用了 <code>enqueueMessage</code>，看看这个方法内部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> MessageQueue queue, <span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法每一句都说明了 Message 的一个性质：</p>\n<ul>\n<li><code>msg.target = this;</code> 这句把 Message 和 Handler 绑定在了一起。</li>\n<li><code>msg.workSourceUid = ThreadLocalWorkSource.getUid();</code> 这句是获取到了当前线程的 Uid，也就是和当前线程绑定在了一起。</li>\n<li><code>msg.setAsynchronous(true);</code> 这句是设置为异步，<code>if</code> 也表示默认情况下的 Message 是同步的。</li>\n</ul>\n<p>最后调用了 <code>MessageQueue.enqueueMessage</code> 方法把 Message 插入到消息队列中。</p>\n<h3 id=\"2-2-流程总结\"><a href=\"#2-2-流程总结\" class=\"headerlink\" title=\"2.2 流程总结\"></a>2.2 流程总结</h3><p>通过以上源码分析，Handler 在发送一个消息后的流程也就清楚了：</p>\n<ol>\n<li>接收一个 Message，并根据设置的延时，设置 Message 的 <code>when</code></li>\n<li>根据情况设置 Message 的类型，默认情况下为同步消息</li>\n<li>将 Message 的 <code>target</code> 设置为自己</li>\n<li>调用 MessageQueue 的 <code>enqueueMessage</code> 方法</li>\n<li><code>MessageQueue.enqueueMessage</code> 方法中，根据 <code>when</code> 从小到大的顺序将 Message 插入到单链表对应位置</li>\n<li>根据条件唤醒 Native 层的消息队列</li>\n</ol>\n<hr>\n<h2 id=\"3-Handler机制总结\"><a href=\"#3-Handler机制总结\" class=\"headerlink\" title=\"3. Handler机制总结\"></a>3. Handler机制总结</h2><p>通过分析 Handler 的实例化和初始化，以及 Handler 发送消息的流程，可以总结出 Handler 的工作机制：</p>\n<ol>\n<li>Handler 默认和当前线程以及当前线程的 MessageQueue 绑定，默认发送同步消息。</li>\n<li>可以手动指定 Handler 的线程、重写接收消息后的回调方法 <code>Callback.handleMessage()</code>。</li>\n<li>可以手动指定发送的消息类型，但一个 Handler 只能发送一种消息，不能交替发送。</li>\n<li>Handler 所在线程由实例化时的 Looper 有关，且只能接收到与之绑定的线程中的消息，如果线程不具备处理消息的功能，则 Handler 无法接收消息且会抛出异常。</li>\n<li>Handler 有两种发送消息的方式，但本质上都是 <code>send</code> 方式。</li>\n<li>Handler 可以发送 Message，也可以发送 Runnable，但由于 MessageQueue 维护的单链表元素是 Message，因此 Runnable 实际上是封装在 message 中的。</li>\n</ol>\n","categories":["Android"],"tags":["Android","源码","Handler"]},{"title":"Android面试题","url":"/post/android/android-interview/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android面试题\"><a href=\"#Android面试题\" class=\"headerlink\" title=\"Android面试题\"></a>Android面试题</h1><h2 id=\"四大组件\"><a href=\"#四大组件\" class=\"headerlink\" title=\"四大组件\"></a>四大组件</h2><ul>\n<li><a href=\"/post/android/android-activity/\" title=\"@LINK\">Activity</a></li>\n<li><a href=\"/post/android/android-service/\" title=\"@LINK\">Service</a></li>\n<li><a href=\"/post/android/android-broadcast/\" title=\"@LINK\">Broadcast</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n</ul>\n<hr>\n<h2 id=\"五大存储\"><a href=\"#五大存储\" class=\"headerlink\" title=\"五大存储\"></a>五大存储</h2><ul>\n<li><a href=\"/post/android/android-sharedpreference/\" title=\"@LINK\">SharedPreferences</a></li>\n<li><a href=\"/post/android/android-sqlite/\" title=\"@LINK\">SQLite</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n<li>文件存储</li>\n<li>网络存储</li>\n</ul>\n<hr>\n<h2 id=\"六大布局\"><a href=\"#六大布局\" class=\"headerlink\" title=\"六大布局\"></a>六大布局</h2><ul>\n<li>LinearLayout</li>\n<li>RelativeLayout</li>\n<li>FrameLayout</li>\n<li>GridLayout</li>\n<li>TableLayout</li>\n<li>AbsoluteLayout</li>\n</ul>\n<hr>\n<h2 id=\"Android内部原理\"><a href=\"#Android内部原理\" class=\"headerlink\" title=\"Android内部原理\"></a>Android内部原理</h2><ul>\n<li><a href=\"/post/android/android-touch_event/\" title=\"TOOINKS\">Android-触摸事件</a></li>\n<li><a href=\"/post/android/android-render/\" title=\"TOOINKS\">Android渲染及绘制流程</a></li>\n<li><a href=\"/post/android/android-ndk/\" title=\"TOOINKS\">Android-NDK</a></li>\n<li>Android 有几种动画类型？</li>\n</ul>\n<h3 id=\"消息处理机制\"><a href=\"#消息处理机制\" class=\"headerlink\" title=\"消息处理机制\"></a>消息处理机制</h3><ul>\n<li><a href=\"/post/android/android-message/\" title=\"@LINK\">Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/\" title=\"@LINK\">MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/\" title=\"@LINK\">Looper</a></li>\n<li><a href=\"/post/android/android-handler/\" title=\"@LINK\">Handler</a></li>\n</ul>\n<p>Android 消息处理机制总结：</p>\n<p>Handler 处理消息所在的线程，和初始化该 Handler 时使用的 Looper 有关，Handler 的构造方法中调用了 <code>mLooper = Looper.myLooper();</code>，并在 <code>Looper.myLooper()</code> 内部通过 ThreadLocal 获取了与当前线程绑定的 Looper 实例对象。一个线程默认不具有处理消息的能力，需要通过调用 <code>Looper.prepare()</code> 来初始化线程的消息处理功能，并调用 <code>Looper.loop()</code> 开启消息循环。如果当前线程没有调用 <code>Looper.prepare()</code>，则发送消息会报错 RuntimeException。</p>\n<p>MessageQueue 是 Looper 的一个成员变量，消息队列的本质不是队列而是单链表，Handler 所有发送消息的方法最终都是调用的 <code>sendMessageAtTime</code>，并在内部调用了 <code>enqueueMessage()</code>，每个消息根据发送时设置的时间顺序添加到 MessageQueue 的单链表中。</p>\n<p>Handler 发送消息时，会赋值 <code>Message.targer = this;</code> 将自己与 Message 绑定，因此 Looper 在循环取出消息时，根据 <code>Message.target</code> 取出并发送给该 Handler 实例对象处理。</p>\n<p>Android 的主线程即 UI 线程在一个 App 进程中唯一，在 <code>ActivityThread.main()</code> 方法中调用了 <code>Looper.prepareMainLooper()</code>，因此在主线程在运行时已经开启了消息循环，因此在主线程中使用 Handler 不需要显示调用 <code>Looper.prepare()</code> 和 <code>Looper.loop()</code>，并且在子线程中更新 UI 时，如果使用 <code>Looper.getMainLooper()</code> 来实例化 Handler，则消息都会被发送到主线程。</p>\n<p>因此可以利用消息处理机制的特性，把接收线程的 Looper 传给发送线程并用来初始化 Handler，即可实现进程间通信。但使用该方法实现主线程向子线程通信时可能发生异常，这是因为主线程开启子线程后就向下执行，主线程的发送 Handler 初始化时，子线程的接收 Looper 可能还没有完成实例化或 <code>prepare()</code> 或 <code>loop()</code> 等初始化操作，导致空指针或 RuntimeException。为此可以使用 HandlerThread 类替代普通的子线程，实例化时只需传入一个 String 作为线程名即可。但 HandlerThread 不能重写 <code>run()</code> 方法，当然也无需手动调用 <code>prepare()</code> 和 <code>loop()</code> 初始化。</p>\n<hr>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><p><a href=\"/post/android/android-itc/\" title=\"@LINK\">Android-ITC</a></p>\n<hr>\n<h2 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h2><ul>\n<li><a href=\"/post/android/android-binder/\" title=\"@LINK\">Binder</a></li>\n<li><a href=\"/post/android/android-aidl/\" title=\"@LINK\">AIDL</a></li>\n<li><a href=\"/post/network/network-socket/\" title=\"@LINK\">Socket</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n<li><a href=\"/post/android/android-broadcast/\" title=\"@LINK\">Broadcast</a></li>\n<li><a href=\"/post/android/android-messenger/\" title=\"@LINK\">Messenger</a></li>\n<li>文件共享：多进程读写同一文件是难以控制、不安全的。</li>\n<li><del>SharedPrefernces：公共读（<code>MODE_WORLD_READABLE</code>）模式、公共写（<code>MODE_WORLD_WRITEABLE</code>）模式、跨进程（<code>MODE_MULTI_PROCESS</code>）模式均已弃用，多进程读写同一文件是难以控制、不安全的，Google 推荐使用基于 ContentProvider 的 FileProvider 来实现。</del></li>\n</ul>\n<hr>\n<h2 id=\"Android中的缓存\"><a href=\"#Android中的缓存\" class=\"headerlink\" title=\"Android中的缓存\"></a>Android中的缓存</h2><h3 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h3><h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><hr>\n<h2 id=\"Java原生框架\"><a href=\"#Java原生框架\" class=\"headerlink\" title=\"Java原生框架\"></a>Java原生框架</h2><ul>\n<li><p><a href=\"/post/java/java-hashmap/\" title=\"@LINK\">Java-HashMap</a></p>\n<blockquote>\n<p>HashMap, HasTable ConcurrentHashMap 的区别：</p>\n<ul>\n<li>HashTable 的 Key 和 Value 都不能为 Null，线程安全，在修改数据时给 <code>put()</code> 加锁锁住整个 HashTable。</li>\n<li>HashMap 的 Key 和 Value 都可以是 Null，线程不安全。</li>\n<li>ConcurrentHashMap 将整个 Map 分段为 N 个 Segment，每个 Segment 独立加锁，对于需要跨段的操作（如 <code>size()</code> 和 <code>containsValue()</code>）则按顺序锁住所有段，操作完毕后再按顺序释放所有段的锁。且 <code>Entry#value</code> 添加了 <code>volatile</code> 关键字，确保读操作获取到的是最新的数据，因此是线程安全的。</li>\n</ul>\n</blockquote>\n</li>\n<li><p><a href=\"/post/java/java-string/\" title=\"@LINK\">Java-String</a></p>\n</li>\n<li><p><a href=\"/post/java/java-lru/\" title=\"@LINK\">LRU算法及其优化</a></p>\n</li>\n<li><p><a href=\"/post/java/java-hashcode/\" title=\"@LINK\">Java-HashCode</a></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ul>\n<li><a href=\"/post/java/java-jvm/\" title=\"@LINK\">JVM内存模型和内存分区</a></li>\n<li><a href=\"/post/java/java-gc/\" title=\"@LINK\">JVM的GC策略</a></li>\n<li><a href=\"/post/java/java-reference/\" title=\"@LINK\">Java中的引用</a></li>\n<li><a href=\"/post/java/java-reflect/\" title=\"@LINK\">Java-反射</a></li>\n<li><a href=\"/post/java/java-lock/\" title=\"@LINK\">Java同步锁</a></li>\n</ul>\n<hr>\n<h2 id=\"Linux操作系统\"><a href=\"#Linux操作系统\" class=\"headerlink\" title=\"Linux操作系统\"></a>Linux操作系统</h2><ul>\n<li>Linux 是怎么知道 App 崩溃的？如果想要在被 Kill 前做一些耗时操作该怎么做？</li>\n<li>怎么定位 Native Crash？如果上报过程中再次产生 Crash 能不能捕捉到？</li>\n<li>如何设计一个 Crash 捕获模块？</li>\n<li><a href=\"https://blog.csdn.net/ljheee/article/details/53191397\" title=\"@LINK\">App 沙箱化</a></li>\n</ul>\n<hr>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ul>\n<li><a href=\"/post/android/android-architecture/\" title=\"@LINK\">Android-应用架构</a></li>\n<li><a href=\"/post/android/android-design_pattern/\" title=\"@LINK\">Android-设计模式</a></li>\n<li><a href=\"/post/android/android-router/android-router\" title=\"@LINKS\">Android-Router路由框架浅析</a></li>\n<li>Glide（虚拟碎片监视时间周期）</li>\n<li>EventBus</li>\n<li>Retrofit</li>\n<li>RXJava：<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">http://gank.io/post/560e15be2dca930e00da1083</a></li>\n<li>OKHttp、基于OKHttp二次封装（拦截器设计模式）</li>\n</ul>\n<hr>\n<h2 id=\"网络通信\"><a href=\"#网络通信\" class=\"headerlink\" title=\"网络通信\"></a>网络通信</h2><ul>\n<li><a href=\"/post/network/network-tcp_udp/\" title=\"@LINK\">TCP和UDP</a></li>\n<li><a href=\"/post/network/network-http_https/\" title=\"@LINK\">HTTP和HTTPS</a></li>\n<li><a href=\"/post/network/network-socket/\" title=\"@LINK\">Socket</a></li>\n<li>如何防止DNS劫持</li>\n</ul>\n<hr>\n<h2 id=\"性能和优化\"><a href=\"#性能和优化\" class=\"headerlink\" title=\"性能和优化\"></a>性能和优化</h2><ul>\n<li><a href=\"/post/android/android-anr/\" title=\"@LINK\">Android-ANR</a></li>\n<li><a href=\"/post/android/android-oom/\" title=\"@LINK\">Android-OOM</a></li>\n<li><a href=\"/post/android/android-memory/\" title=\"@LINK\">Android-内存优化</a></li>\n</ul>\n<hr>\n<h2 id=\"打包和发布\"><a href=\"#打包和发布\" class=\"headerlink\" title=\"打包和发布\"></a>打包和发布</h2><h3 id=\"App编译打包流程\"><a href=\"#App编译打包流程\" class=\"headerlink\" title=\"App编译打包流程\"></a>App编译打包流程</h3><h3 id=\"代码混淆\"><a href=\"#代码混淆\" class=\"headerlink\" title=\"代码混淆\"></a>代码混淆</h3><h3 id=\"App加固\"><a href=\"#App加固\" class=\"headerlink\" title=\"App加固\"></a>App加固</h3><h3 id=\"热更新和热修复\"><a href=\"#热更新和热修复\" class=\"headerlink\" title=\"热更新和热修复\"></a>热更新和热修复</h3><h3 id=\"MultiDex\"><a href=\"#MultiDex\" class=\"headerlink\" title=\"MultiDex\"></a>MultiDex</h3><p>（1）为什么方法数不能超过 65535？</p>\n<p>因为 Android 编译时会将字节码生成 Dex 文件，而用于优化 Dex 的工具 DexOpt 会给每个方法编号检索，但是编号用的是 short，只有 2 字节，所以最高只能表示 <code>2^16 - 1 = 65535</code></p>\n<p>（2）方法数超 65535 怎么办？</p>\n<p>使用 MultiDex，将不同类和不同方法编译到不同的 Dex 中，保证每一个 Dex 中的方法数小于 65535。</p>\n<p>（3）MultiDex 是哪个版本开始支持的？之前的版本不支持，如何加载 Dex 文件？</p>\n<h3 id=\"VersionCode和VersionName的区别\"><a href=\"#VersionCode和VersionName的区别\" class=\"headerlink\" title=\"VersionCode和VersionName的区别\"></a>VersionCode和VersionName的区别</h3><hr>\n<h2 id=\"常见算法\"><a href=\"#常见算法\" class=\"headerlink\" title=\"常见算法\"></a>常见算法</h2><ul>\n<li><a href=\"/post/algorithm/algorithm-find_from_series/\" title=\"@LINK\">算法-数列查找</a></li>\n<li><a href=\"/post/algorithm/algorithm-sum_of_numbers/\" title=\"@LINK\">算法-求和问题</a></li>\n<li><a href=\"/post/algorithm/algorithm-substring/\" title=\"@LINK\">算法-查找字串</a></li>\n<li>排序算法</li>\n<li>数组最大堆</li>\n<li>LCS</li>\n<li>洗牌功能</li>\n<li>二叉树遍历</li>\n<li>二叉树中两个节点的最近公共父节点</li>\n<li>大数相乘</li>\n<li>int 变量存 ip 地址</li>\n<li>10 亿数据找到出现最多次数的数字</li>\n<li>100 万个数字求 100 个最大值</li>\n<li>打印回环数组</li>\n<li>递归非递归反转链表</li>\n<li>找到一个字符串中出现最多的字母</li>\n<li>给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不使用 HashMap）：<a href=\"https://blog.csdn.net/suibianshen2012/article/details/51923477\">https://blog.csdn.net/suibianshen2012/article/details/51923477</a></li>\n<li>已知两条链表都是升序的，合并这两条链表，并保持升序状态（归并）</li>\n<li><a href=\"/post/algorithm/algorithm-find_pictures/\" title=\"@LINK\">算法-数据库中查找图片</a></li>\n<li><a href=\"/post/algorithm/algorithm-transport_and_consume/\" title=\"@LINK\">算法-运输和消耗最优解问题</a></li>\n</ul>\n<hr>\n<h2 id=\"Java设计思想\"><a href=\"#Java设计思想\" class=\"headerlink\" title=\"Java设计思想\"></a>Java设计思想</h2><h3 id=\"Java面向对象六大原则\"><a href=\"#Java面向对象六大原则\" class=\"headerlink\" title=\"Java面向对象六大原则\"></a>Java面向对象六大原则</h3><p>（1）单一职责原则</p>\n<ul>\n<li>两个完全不一样的功能不能放在一个类中，一个类应该是一组相关性很高的函数、数据的封装。</li>\n<li>如何划分一个类的职责因人而异，但要根据个人的经验、具体的业务来定，比如图片加载和缓存应该放在不同的类中。</li>\n</ul>\n<p>（2）开放关闭原则</p>\n<ul>\n<li>软件中的函数、对象，应该对于扩展是开放的，对于修改是封闭的。</li>\n<li>当软件需要变化时，应该尽量通过扩展的方式，而不是修改已有的代码。</li>\n</ul>\n<p>（3）里氏替换原则</p>\n<ul>\n<li>所有引用基类的地方，必须能透明地使用其子类的对象。</li>\n<li>只要父类出现的地方，子类就可以出现，替换为子类也不影响。但是反之不行。</li>\n<li>核心是抽象，抽象又依赖于继承。建立抽象，通过抽象建立规范，具体的实现在继承时替换掉。往往和开闭原则一起，通过接口和抽象的方式。</li>\n</ul>\n<p>（4）依赖倒置原则</p>\n<ul>\n<li>实现类直接不直接发生依赖关系，其依赖关系通过接口或抽象类产生，即：面向接口编程。</li>\n<li>Java 中抽象指接口或抽象类不能直接被实例化；细节是实现接口或继承抽象类的实现类，可以直接被实例化。</li>\n</ul>\n<p>（5）接口隔离原则</p>\n<ul>\n<li>类之间的依赖关系应该建立在最小接口上。让客户端依赖的接口尽可能小，解耦合。</li>\n</ul>\n<p>（6）迪米特原则</p>\n<ul>\n<li>最少知识原则：一个对象应该对其他对象有最少的了解。因为关系越密切，则耦合度越大。</li>\n<li>只与直接的朋友通信。</li>\n</ul>\n<h3 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h3><p>重写和重载？</p>\n<h3 id=\"Java泛型\"><a href=\"#Java泛型\" class=\"headerlink\" title=\"Java泛型\"></a>Java泛型</h3><p>泛型类在编译后其泛型信息会被擦除为 Object，泛型会被转移到实际使用了泛型的变量或方法中（如果没有则彻底丢失存根），所以编译后的类已经丢失了自己的泛型信息，无法通过反射获取自己的泛型，除非其继承自某个使用了泛型的父类，则 getClass().getGenericSuperclass() 才会保存父类的泛型信息。</p>\n<p>而接口则可以理解为一种特殊的父类，因为接口无法直接实例化为一个对象，匿名构造类也是编译时通过匿名类实现该接口后返回来实现的，因此对于实现了接口的类，可以通过 getClass().getGenericInterfaces() 来获取接口信息，因为接口实际上可以看作实现类的”父类”，所以获取接口信息时就能获取到接口的泛型信息。</p>\n<h3 id=\"Object方法\"><a href=\"#Object方法\" class=\"headerlink\" title=\"Object方法\"></a>Object方法</h3><ul>\n<li><code>Object()</code>：构造方法。</li>\n<li><code>clone()</code>：用来另存一个当前存在的对象。</li>\n<li><code>equals(Object)</code>：用于确认两个对象是否相同。</li>\n<li><code>finalize()</code>：这个函数在进行垃圾回收的时候会用到，匿名对象回收之前会调用到。</li>\n<li><code>getClass()</code>：返回一个当前类的 Class 全名。</li>\n<li><code>hashCode()</code>：用于获取对象的哈希值，这个值的作用是检索。</li>\n<li><code>notify()</code>：用于随机通知一个持有对象的锁的线程获取操作权限。</li>\n<li><code>notifyAll()</code>：用于通知所有持有对象的锁的线程获取操作权限。</li>\n<li><code>toString()</code>：返回一个String对象，用来标识自己。</li>\n<li><code>wait()</code>：用于让当前线程失去操作权限，当前线程进入等待序列。</li>\n<li><code>wait(long)</code>：用于设定下一次获取锁的距离当前释放锁的时间间隔。</li>\n<li><code>wait(long,int)</code>：用于设定下一次获取锁的距离当前释放锁的时间间隔。</li>\n</ul>\n<h3 id=\"抽象类和接口的区别\"><a href=\"#抽象类和接口的区别\" class=\"headerlink\" title=\"抽象类和接口的区别\"></a>抽象类和接口的区别</h3><p>（1）从使用上：</p>\n<ul>\n<li>抽象类使用abstract修饰；</li>\n<li>抽象类不能实例化，即不能使用new关键字来实例化对象；</li>\n<li>含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；</li>\n<li>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；</li>\n<li>如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类</li>\n</ul>\n<p>（2）从逻辑上：</p>\n<p>抽象类的本质还是一个类，可以为子类定义所需的逻辑，本质上是对子类的抽象，也能通过实际实现方法，直接统一子类的行为，而接口更像是预先安排一些功能，而对于实现了这个接口的类的外部而言，其他类并不需要关心这个类具体的功能或实现，只需要根据其实现的接口就能调用相关的功能。</p>\n<p>（3）抽象类的优缺点</p>\n<p>抽象类可以定义方法的默认实现，也即可以预定义其子类的主体功能。但一个类只能继承自一个父类，所以抽象类需要高度抽象才具有价值，但高度抽象又会降低对子类主体功能的控制性。</p>\n<p>（4）接口的优缺点</p>\n<p>一个类可以实现多个接口，接口可以定义一个类的行为。但实现一个接口时，就必须实现该接口内的所有方法。</p>\n<h3 id=\"自动装箱和自动拆箱\"><a href=\"#自动装箱和自动拆箱\" class=\"headerlink\" title=\"自动装箱和自动拆箱\"></a>自动装箱和自动拆箱</h3><ul>\n<li>自动装箱：<code>int i = 0; Integer n = i;</code> 内部调用：<code>n = Integer.valueOf(i);</code></li>\n<li>自动拆箱：<code>Integer i = 0; int n = i;</code> 内部调用：<code>n = i.intValue();</code></li>\n</ul>\n<hr>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"SparseArray的改进\"><a href=\"#SparseArray的改进\" class=\"headerlink\" title=\"SparseArray的改进\"></a>SparseArray的改进</h3><h3 id=\"getWidth和getMeasureWidth的区别\"><a href=\"#getWidth和getMeasureWidth的区别\" class=\"headerlink\" title=\"getWidth和getMeasureWidth的区别\"></a>getWidth和getMeasureWidth的区别</h3><p><code>getMeasureWidth</code> 是 View 自己测量自己的宽度，<code>getWidth</code> 是 View 的父布局测量的高度，当屏幕可显示范围小于 View 本身的宽高时，<code>getMeasureWidth</code> 得到的仍然是 View 本身的宽高，而 <code>getWidth</code> 得到的是屏幕实际显示的宽高</p>\n<h3 id=\"为什么View移动后点击事件还在原来的位置\"><a href=\"#为什么View移动后点击事件还在原来的位置\" class=\"headerlink\" title=\"为什么View移动后点击事件还在原来的位置\"></a>为什么View移动后点击事件还在原来的位置</h3><p><a href=\"https://www.jianshu.com/p/45e8efcd1f5d\">https://www.jianshu.com/p/45e8efcd1f5d</a><br><a href=\"https://blog.csdn.net/u011387817/article/details/80313184\">https://blog.csdn.net/u011387817/article/details/80313184</a></p>\n<p>因为补间动画 Animation 只改变了 View 的显示位置，也就是只是在绘制时通过改变 Matrix 增加了平移，并没有改变在父布局中的位置。</p>\n<p>可以使用属性动画，改变实际上的 View 的空间位置。</p>\n<h3 id=\"finally什么时候执行\"><a href=\"#finally什么时候执行\" class=\"headerlink\" title=\"finally什么时候执行\"></a>finally什么时候执行</h3><p><a href=\"/post/java/java-finally/\" title=\"@LINKS\">Java-finally关键字</a></p>\n<h3 id=\"为什么方法参数要加final才能在子线程内使用\"><a href=\"#为什么方法参数要加final才能在子线程内使用\" class=\"headerlink\" title=\"为什么方法参数要加final才能在子线程内使用\"></a>为什么方法参数要加final才能在子线程内使用</h3><p>局部变量在传递给内部类，实际上在编译时，是给内部类的构造方法增加了一个参数，并原来的将局部变量传入了构造方法，如果不加 final，可能会出现，原来的局部变量在传入之后，改变了引用，但因为内部类的构造方法接收到的是原来的变量的引用的拷贝，就会导致内部类使用的这个传进来的变量的引用和原本局部变量的引用不一样，则执行的结果就不是预期的，所以需要加上 final，强制使得其引用不可改变。而成员变量则不需要是因为，内部类会持有外部类的引用，外部类的成员变量，在内部类使用时，是通过所持有的外部类的引用对象来调用的，并没有创建引用的拷贝，所以和外部类成员变量的引用是一致的。</p>\n<ul>\n<li>final 修饰方法，则该方法不可被重写，例如 Handler 中所有的post和send方法</li>\n<li>final 修饰变量，则该变量的引用不可改变（但是值可以改变，例如final HashMap）</li>\n<li>final 修饰类，则该类不可被继承，例如System类</li>\n</ul>\n<h3 id=\"Fragment-懒加载\"><a href=\"#Fragment-懒加载\" class=\"headerlink\" title=\"Fragment 懒加载\"></a>Fragment 懒加载</h3><p>关键点在于 setUserVisibleHint()，会在 onCreateView 之前执行，当 Fragment 可见状态改变时调用，设置一个 boolean 成员变量，用于标志是否已经加载过，在setUserVisibleHint()中，如果没加载过且可见，则加载数据，并将boolean标志为已加载。再把实际加载 View 的部分放进加载的方法里面。</p>\n<h3 id=\"为什么静态内部类不会持有外部对象\"><a href=\"#为什么静态内部类不会持有外部对象\" class=\"headerlink\" title=\"为什么静态内部类不会持有外部对象\"></a>为什么静态内部类不会持有外部对象</h3><p>（1）非静态的内部类，在编译时，实际上会把外部类对象通过构造方法传递给内部类，这样内部类可以通过外部对象的引用调用外部类的属性。static字段使得该内部类可以直接通过类名调用，是线程共享的方法，因此不会传递外部对象的引用，也因此静态内部类无法调用外部类的非静态成员变量和非静态方法。</p>\n<p>（2）使用内部类需要注意：内部类可以访问外部类的数据，而且具有较好的封装性，而且多个内部类分别继承不同的父类，再由外部类调用，可以间接实现多继承的效果，某些情况下可以简化代码逻辑，但内部类有可能会因为执行耗时操作使得外部类无法回收导致内存溢出，这时可以考虑改用静态内部类实现。</p>\n<h3 id=\"断点下载\"><a href=\"#断点下载\" class=\"headerlink\" title=\"断点下载\"></a>断点下载</h3><h3 id=\"自己设计一个图片浏览器（图片加载器）\"><a href=\"#自己设计一个图片浏览器（图片加载器）\" class=\"headerlink\" title=\"自己设计一个图片浏览器（图片加载器）\"></a>自己设计一个图片浏览器（图片加载器）</h3><p>首先要考虑到会加载多图和大图的情况。</p>\n<p>（1）对于多图，采用预览图和本地缓存的形式，首次进入后，先从本地读取图片并加载预览小图，然后写入本地缓存，下次进入时，先从本地加载小图缓存，然后异步获取图片的更新，图片有更新时再重新缓存。并且在进入 App 后，根据显示的范围，缓存上下两行或者左右两列的图片，滑动时能提供更好的视觉效果，如果是纯粹的图片浏览器，其图片变动不大，则还可以将预览小图缓存到内存中。</p>\n<p>（2）对于大图，采用优化加载的方式，点击小图进入大图时，先预加载图片的宽高信息，如果图片和实际显示范围差别不大，则可以直接加载进来，如果图片远大于实际可显示范围，则首先压缩到当前可显示范围的大小，或者将 BitMap 裁剪到当前的显示范围再显示，然后用户双击放大的时候，利用 <code>BitmapRegionDecoder</code> 绘制实际原图的局部，并且配合 GestureDetector 监听手势滑动，来不断的绘制不同的位置，用户在缩小后，如果用户马上切换另一个大图，则将前一个大图的 Bitmap 清空，然后复用，否则设置一个定时方法，在一定时间内，保存前一个大图 Bitmap 的缓存，这样用户再次打开时就不用重复加载，如果超时，再回收该 Bitmap 对象。</p>\n<p>（3）对于 App 整体，还要有个队列或者链表，用来记录整体内存占用，例如在大图模式下，假如内存占用接近或超过了预期的最大值，则释放掉之前小图模式下的内存，用户再退出大图模式后再重新加载图片列表。</p>\n","categories":["Android"],"tags":["Android","Java","Network","网络","Interview","面试题"]},{"title":"Android-MessageQueue","url":"/post/android/android-messagequeue/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-MessageQueue\"><a href=\"#Android-MessageQueue\" class=\"headerlink\" title=\"Android-MessageQueue\"></a>Android-MessageQueue</h1><h2 id=\"1-认识MessageQueue\"><a href=\"#1-认识MessageQueue\" class=\"headerlink\" title=\"1. 认识MessageQueue\"></a>1. 认识MessageQueue</h2><p>在分析 MessageQueue 之前，首先要了解到一个消息队列的误区：MessageQueue 从名字上看来是一个“队列”，主要是其处理消息的方式比较像一个队列。实际上，因为会频繁地出现 Message 的插入和删除等操作，如果是用传统的“队列”来存放 Message，插入、删除的效率会很低，因此 MessageQueue 采用单链表的形式（单链表插入、删除只需要变动两个节点对象的连接目标即可）来管理 Message。</p>\n<p>MessageQueue 源码里的注释对其一些性质进行了说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Low-level class holding the list of messages to be dispatched by a</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper&#125;.  Messages are not added directly to a MessageQueue,</span></span><br><span class=\"line\"><span class=\"comment\">  * but rather through &#123;<span class=\"doctag\">@link</span> Handler&#125; objects associated with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;You can retrieve the MessageQueue for the current thread with</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper#myQueue() Looper.myQueue()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概意思是：</p>\n<blockquote>\n<p>MessageQueue 是一个持有 Message 的低等级类，它所持有的 Message 由 Looper 分发。Message 并不是直接被添加到 MessageQueue 中的，而是通过 Handler 的对象与 Looper 绑定起来。</p>\n<p>你可以通过 <code>Looper.myQueue()</code> 方法取回当前线程的 MessageQueue。</p>\n</blockquote>\n<p>这段注释特别关键，以至于我觉得已经足以说明整个 MessageQueue 的工作方式了，上半段概括了 MessageQueue 如何管理 Message，下半段概括了 MessageQueue、Looper 以及线程的关系。</p>\n<hr>\n<h2 id=\"2-MessageQueue管理Message\"><a href=\"#2-MessageQueue管理Message\" class=\"headerlink\" title=\"2. MessageQueue管理Message\"></a>2. MessageQueue管理Message</h2><h3 id=\"2-1-添加Message\"><a href=\"#2-1-添加Message\" class=\"headerlink\" title=\"2.1 添加Message\"></a>2.1 添加Message</h3><p>（1）当一个 Message 产生并且被发送时，通过 Handler 的对象将这个 Message 和当前线程绑定，再插入到 MessageQueue 单链表中。</p>\n<p>通过 Handler 源码可知，一个消息被发送后，Handler 最终会调用 <code>MessageQueue.enqueueMessage(Message msg, long when)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">&quot; This message is already in use.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这句也就是手动将 <code>Message.target</code> 设置为 <code>null</code> 会报异常的原因。其余部分也就是根据 Message 的 <code>when</code> 来将 Message 插入到 MessageQueue 的指定位置，并且根据情况唤醒 Native 层的消息队列。</p>\n<h3 id=\"2-2-移除Message\"><a href=\"#2-2-移除Message\" class=\"headerlink\" title=\"2.2 移除Message\"></a>2.2 移除Message</h3><p>移除消息有两个不同参数的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用自定义回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, Runnable r, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span> || r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.callback == r</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.callback == r</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实对应的是初始化 Handler 时，一个是使用默认回调，一个是使用自定义回调的情况，具体移除消息的过程几乎是一样的，都是单链表从中移除一个节点的逻辑。</p>\n<h3 id=\"2-3-移除BarrierMessage\"><a href=\"#2-3-移除BarrierMessage\" class=\"headerlink\" title=\"2.3 移除BarrierMessage\"></a>2.3 移除BarrierMessage</h3><p>源码是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@TestApi</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和发送一个障栅消息一样，这个方法也加了 <code>@hide</code> 注解，移除的过程和移除普通消息比较类似，也是单链表移除节点的逻辑。</p>\n<hr>\n<h2 id=\"3-MessageQueue和线程的交互\"><a href=\"#3-MessageQueue和线程的交互\" class=\"headerlink\" title=\"3. MessageQueue和线程的交互\"></a>3. MessageQueue和线程的交互</h2><p>MessageQueue 中有一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Callback interface for discovering when a thread is going to block</span></span><br><span class=\"line\"><span class=\"comment\">  * waiting for more messages.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">      * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">      * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">      * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">      * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过注释可以知道：</p>\n<ul>\n<li>这个接口的作用是：找出一个线程什么时候阻塞并等待更多（新的）消息。</li>\n<li><code>queueIdle()</code> 的作用是：当一个消息队列处理完全部消息，并且将进入等待的状态时调用。返回 <code>true</code> 则激活 Idle Handler，返回 <code>false</code> 则在执行完后将其移除。如果一个消息队列中还存在消息，但在当前时间之后的所有消息，均已经被计划好了分发的时间（也即这些消息都属于 Delay 型的消息，因此在执行到这些消息之前，线程也处在没有消息需要处理的状态），则该方法仍然可能被调用。</li>\n</ul>\n<p>具体的意义如下：</p>\n<p>Handler 本身除了可以用来发送消息之外，另一个很重要的功能就是去处理接收到的消息，也就是 <code>handleMessage</code> 方法，普通的 Handler 只会处理人为指定的消息，这些消息对应的事务优先级比较高，因此当消息队列中存在 Message 时，线程会优先处理。但是不论是 Dalvik 还是 JVM，都有一些自己的管理事务，这些事务的优先级不是特别高，或者是不可预期的，但依然需要占用线程才能处理（毕竟线程是 CPU 调度的基本单位），比如 GC，内存碎片整理等，这些事务在非紧急情况下，只会在线程中没有消息时处理，此时处理这些事务的就是 Idle Handler。Idle Handler 并不是一个独立的类型，只需要实现 <code>IdleHandler</code> 接口即可。</p>\n<h3 id=\"3-1-添加IdleHandler\"><a href=\"#3-1-添加IdleHandler\" class=\"headerlink\" title=\"3.1 添加IdleHandler\"></a>3.1 添加IdleHandler</h3><p>既然 <code>IdleHandler</code> 只是一个接口，那如何让 MessageQueue 在空闲时可以唤起呢？以下方法即可添加一个 IdleHandler 到 IdleHandler 的 ArrayList 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Add a new &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; to this message queue.  This may be</span></span><br><span class=\"line\"><span class=\"comment\">  * removed automatically for you by returning false from</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> IdleHandler#queueIdle IdleHandler.queueIdle()&#125; when it is</span></span><br><span class=\"line\"><span class=\"comment\">  * invoked, or explicitly removing it with &#123;<span class=\"doctag\">@link</span> #removeIdleHandler&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be added.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.add(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释的大致意思是：将一个 IdleHandler 添加到 MessageQueue 中，如果 <code>IdleHandler.queueIdle()</code> 返回 <code>false</code>，或者直接调用 <code>removeIdleHandler()</code> 方法，则会移除这个 IdleHandler。</p>\n<h3 id=\"3-2-移除IdleHandler\"><a href=\"#3-2-移除IdleHandler\" class=\"headerlink\" title=\"3.2 移除IdleHandler\"></a>3.2 移除IdleHandler</h3><p>移除 IdleHandler 的方法也很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Remove an &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; from the queue that was previously added</span></span><br><span class=\"line\"><span class=\"comment\">  * with &#123;<span class=\"doctag\">@link</span> #addIdleHandler&#125;.  If the given object is not currently</span></span><br><span class=\"line\"><span class=\"comment\">  * in the idle list, nothing is done.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be removed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.remove(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-调用IdleHandler\"><a href=\"#3-3-调用IdleHandler\" class=\"headerlink\" title=\"3.3 调用IdleHandler\"></a>3.3 调用IdleHandler</h3><p>添加和移除 Idle Handler 都已经清楚了，Idle Handler 具体使用的地方，在 MessageQueue 实际处理消息的方法 <code>next()</code> 里，在默认情况下，每一次调用 <code>next</code> 就会返回一个 Message，这个 Message 就是下一个需要分发的消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mPtr 是通过调用 nativeInit() 获取的返回值</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以认为这个是 Native 层 MessageQueue 初始化后的指针地址</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 重点是 msg.target == null，如果满足说明这个 msg 是一个障栅消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么就要阻塞这条消息之后的所有同步消息，而放行异步消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 循环结束后有两种情况：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 整个消息队列中都没有异步消息，则终止条件为：msg == null</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 找到了异步消息，则终止条件为：msg.isAsynchronous() == true</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// msg != null 有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 消息队列没阻塞，msg 是一条同步消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 消息队列被障栅消息阻塞了，但是找到了异步消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明还没到需要分发消息的时候，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 则计算到需要分发消息中间的间隔，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 在间隔时间后再唤醒消息队里进行分发</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明到了需要分发消息的时候</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 开始分发消息了，不是阻塞状态</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于将这条消息分发出去了，相当于要从链表里去掉这个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// 需要判断当前消息是不是第一个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// prevMsg 表示该 msg 的前一个消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于该消息即将被分发出去，因此该消息的下一条就没用了</span></span><br><span class=\"line\">                    <span class=\"comment\">// 置为空，去掉无用引用，防止内存溢出</span></span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 把该 msg 标识为“使用中”</span></span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回这条 msg 作为需要处理的消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 说明 msg == null，此时有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 已经没有消息需要分发</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 当前队列被障栅消息阻塞了，却又没有异步消息（不论是否有同步消息）</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前消息队列是正在退出的状态</span></span><br><span class=\"line\">                <span class=\"comment\">// 则调用 dispose() 销毁 Native 层的消息队列</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\">            <span class=\"comment\">// 以下为 IdleHandler 部分</span></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本的解读都在代码注释中了，还是比较通俗易懂的。重点注意专门加的这句注释：<code>// 以下为 IdleHandler 部分</code>，可以看看这句注释以上的部分，首先是判断了下一条消息，然后判断了当前消息队列是否正在退出，这个 <code>next()</code> 方法基本上要么返回了下一条需要分发的 Message，要么返回了 <code>null</code>，只有以下几种情况时才能执行到这句注释的地方：</p>\n<ol>\n<li>当前消息队列没有任何消息了，且不在退出状态。</li>\n<li>当前消息队列没有被障栅消息阻塞，且没有同步消息，也没有异步消息，且不在退出状态。</li>\n<li>当前消息队列没有被障栅消息阻塞，没有同步消息，虽然有异步消息，但还没有到需要分发的时间，且不在退出状态。</li>\n<li>当前消息队列被障栅消息阻塞了，但没有异步消息（不论是否有同步消息），且不在退出状态。</li>\n<li>当前消息队列被障栅消息阻塞了，虽然有异步消息（不论是否有同步消息），但还没有到需要分发的时间，且不在退出状态。</li>\n</ol>\n<p>以上几种情况中，（2）和（3）其实可以归到一起，（3）和（4）也可以归到一起，再进一步合并逻辑，其实就代表了这么一种状态：消息队列当前没有任务，而且也不在退出状态。只有这个状态下，才会调用 <code>IdleHandler.queueIdle</code>，具体的任务则由 <code>IdleHandler</code> 接口的具体实现决定了。消息队列中对 IdleHandler 的处理比较简单，注释也已经讲得比较详细，就不另行分析了。</p>\n<hr>\n<h2 id=\"4-MessageQueue总结\"><a href=\"#4-MessageQueue总结\" class=\"headerlink\" title=\"4. MessageQueue总结\"></a>4. MessageQueue总结</h2><p>通过以上的源码分析，MessageQueue 的工作流程也就清楚了：</p>\n<ol>\n<li>初始化 MessageQueue，同时初始化 Native 层的 MessageQueue。</li>\n<li>通过 Handler 添加或移除 Message。</li>\n<li>线程执行的过程中，不断调用 <code>next()</code> 方法来获取需要分发处理的消息。</li>\n<li>如果线程中有需要分发处理的消息，则正常分发。</li>\n<li>如果线程中已经没有或暂时没有需要分发处理的普通消息，则去处理 Idle 事务。</li>\n<li>如果既没有普通消息需要分发处理，也没有 Idle 事务，则阻塞消息队列，使其进入等待新消息的状态。</li>\n<li>如果需要退出消息队列，则调用 <code>dispose()</code> 方法同步销毁 Native 层的 MessageQueue。</li>\n</ol>\n","categories":["Android"],"tags":["Android","源码","MessageQueue","消息队列"]},{"title":"Android-Service","url":"/post/android/android-service/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Service\"><a href=\"#Android-Service\" class=\"headerlink\" title=\"Android-Service\"></a>Android-Service</h1><h2 id=\"1-Service的状态和种类\"><a href=\"#1-Service的状态和种类\" class=\"headerlink\" title=\"1. Service的状态和种类\"></a>1. Service的状态和种类</h2><p>Service 分为 <code>Started</code> 和 <code>Bound</code> 两种状态（可共存），以及 <code>Foreground</code> 和 <code>Background</code> 两种类型。</p>\n<h3 id=\"1-1-Service的启动和绑定状态\"><a href=\"#1-1-Service的启动和绑定状态\" class=\"headerlink\" title=\"1.1 Service的启动和绑定状态\"></a>1.1 Service的启动和绑定状态</h3><p>Service 可以通过 <code>start</code> 和 <code>bind</code> 两种方法启动。</p>\n<ul>\n<li><code>startService()</code> 后该 Service 即变为 <code>Stared</code> 状态，处于后台运行中，与启动它的 Activity 生命周期无关，除非手动 <code>stopService(Intent)</code> 或 Service 内部调用自己的 <code>stopSelf()</code> 终止，或被 Android 系统回收。</li>\n<li><code>bindService()</code> 后该 Service 为 <code>Bound</code> 状态，主要提供 C / S 接口，允许组件与 Service 通信或跨进程通信，生命周期与启动它的宿主绑定，宿主销毁时会自动解除与 Service 的绑定，当 <code>Bound</code> 状态的 Service 没有被任何宿主绑定时，就会销毁该 Service。</li>\n</ul>\n<p>Service 可以同时处于 <code>Started</code> 状态和 <code>Bound</code> 状态，也即 Service 通过一种方式启动后，仍然可以被其他宿主通过另一种方式连接（但不会重新启动）。当 Service 同时处于 <code>Started</code> 和 <code>Bound</code> 状态时，Service 的生命周期同时受到两种状态的影响，仅当两种状态都断开时，Service 才会销毁，也即：必须被 <code>stopService()</code> 并且被 <code>unbindService()</code> 后，Service 才会销毁。</p>\n<h3 id=\"1-2-Service的前台和后台\"><a href=\"#1-2-Service的前台和后台\" class=\"headerlink\" title=\"1.2 Service的前台和后台\"></a>1.2 Service的前台和后台</h3><p>Service 可以在后台执行长时间而无界面的操作，且默认处于主进程的主线程中。</p>\n<ul>\n<li><p>BackGround Service：用户不可感知的后台操作，如监控、轮询拉取等。</p>\n<ul>\n<li>默认情况下，不论通过 <code>start</code> 还是 <code>bind</code> 启动的 Service 都是后台 Service。后台 Service 对用户不可感知，但内存优先级较低，在内存不足时会被系统杀死（根据 Service 的参数可以指定是否需要在内存空闲后重新启动），最大允许 200 秒（<code>ActiveServices#SERVICE_BACKGROUND_TIMEOUT</code>）卡顿时间，超出则会抛出 ANR。</li>\n</ul>\n</li>\n<li><p>Foreground Service：执行一些用户可感知的操作，如 Audio 播放。</p>\n<ul>\n<li><p>可以通过调用 <code>Service#startForeground(int id, Notification notification)</code> 将一个 Service 设为前台 Service，其中 Notification 不能为 <code>null</code> 否则会抛出异常，因此 ForegroundService 强制要求在通知栏显示一个服务图标，但内存优先级高，即使内存不足也不会被系统杀死，最大允许 20 秒（<code>ActiveServices#SERVICE_TIMEOUT</code>）卡顿时间，超出则会抛出 ANR。</p>\n</li>\n<li><p>在 API 26 (Android 8.0) 以上可以直接通过 <code>startForegroundService()</code> 启动一个 ForegroundService，但在 ForegroundService 启动后需要在 10 秒（<code>ActiveServices#SERVICE_START_FOREGROUND_TIMEOUT</code>）内调用 <code>startForeground()</code>，否则会抛出 ANR。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-Service生命周期\"><a href=\"#2-Service生命周期\" class=\"headerlink\" title=\"2. Service生命周期\"></a>2. Service生命周期</h2><p>所有 Service 都必须在 Manifest 内声明注册：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;service</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoService&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:process=<span class=\"string\">&quot;:demo&quot;</span></span><br><span class=\"line\">    android:isolatedProcess=<span class=\"string\">&quot;false&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;service.DemoService&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/service&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>exported</code>: 是否能被其他 App 隐式启动（通过指定 Intent 的 ActionName 启动），当没有指定 <code>Intent-Filter</code> 时默认值为 <code>false</code>，指定了 <code>Intent-Filter</code> 时默认值为 <code>true</code>。</p>\n</li>\n<li><p><code>process</code>: 指定进程，默认情况下 Service 运行在主进程的主线程中，可以通过指定 <code>process</code> 属性分配独立进程。</p>\n</li>\n<li><p><code>isolatedProcess</code>: 是否运行在一个 <strong>没有任何权限</strong> 的特殊进程中，通常用于一些沙盒任务。</p>\n</li>\n<li><p><code>enabled</code>: 是否启用这个 Service (系统是否能实例化这个 Service)，默认为 <code>true</code>，当设置为 <code>false</code> 时，相当于在 Manifest 中移除该 Service 的标签。</p>\n<ul>\n<li>关于 <code>enabled</code> 属性有个很常见的问题就是：如果想要不启用这个 Service，为何要在 Manifest 中声明又禁用呢？直接不写这个 Service 或者不在 Manifest 中声明不就行了吗？实际上这个属性更多用在外部依赖上，例如项目依赖了一个 Module，但是又想禁用 Module 中的某个 Service，则可以在项目 Manifest 中禁用该 Service，然后 Manifest 合并后就会禁用该 Service，理论上四大组件都可以通过这个方式禁用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-Start方式启动Service\"><a href=\"#2-1-Start方式启动Service\" class=\"headerlink\" title=\"2.1 Start方式启动Service\"></a>2.1 Start方式启动Service</h3><p>以 start 方式启动 Service：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoService.class);</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\">stopService(intent);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意：</p>\n<ul>\n<li><code>Service#stopSelf()</code> 和 <code>Service#stopSelfResult(int startId)</code> 的效果等同于 <code>Context#stopService(Intent)</code>。</li>\n<li>仅被 Start 启动而没有被任何 Client Bind 的后台 Service，将在 App 进入后台 1 分钟后被 Kill。</li>\n</ul>\n<h3 id=\"2-2-Bind方式启动Service\"><a href=\"#2-2-Bind方式启动Service\" class=\"headerlink\" title=\"2.2 Bind方式启动Service\"></a>2.2 Bind方式启动Service</h3><p>如果通过 bind 方式绑定 Service，在 Service 中返回 IBinder 类的实例，则 Client 就能通过 Binder 的方式与 Service 通信。</p>\n<blockquote>\n<p>虽然默认情况下 Service 运行在主进程的主线程当中，但 Service 本身是支持跨进程的，所以 Android 选择了 Binder 作为通信方式。</p>\n</blockquote>\n<h3 id=\"2-3-Service生命周期\"><a href=\"#2-3-Service生命周期\" class=\"headerlink\" title=\"2.3 Service生命周期\"></a>2.3 Service生命周期</h3><p>Service 中常见的生命周期回调如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 只有当 Service 第一次被启动的时候才回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onCreate() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被调用 Start 时回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 运行过程中，被多次 Start 时会多次回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> intent 正常 Start 启动 Service 时，Intent 即为 Start 时传入的 Intent。</span></span><br><span class=\"line\"><span class=\"comment\">     *               当 Service 被系统杀死后，如果重新启动，则传入的 intent 与该方法的返回值有关。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> flags 该 Service 启动时的参数，通常用于判断该 Service 被 Start 的原因。</span></span><br><span class=\"line\"><span class=\"comment\">     *              - 0: 表示 Service 是正常启动；</span></span><br><span class=\"line\"><span class=\"comment\">     *              - START_FLAG_REDELIVERY: 表示 Service 是由于被系统杀死，并在内存充足后被系统重新启动。</span></span><br><span class=\"line\"><span class=\"comment\">     *                仅当该方法返回值为 START_REDELIVER_INTENT 时生效。</span></span><br><span class=\"line\"><span class=\"comment\">     *              - START_FLAG_RETRY: 表示 Service 是由于该方法没有正常返回，系统重试。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startId 表明一个启动 ID，通常与 stopSelfResult(int startId) 搭配使用，</span></span><br><span class=\"line\"><span class=\"comment\">                      在 Service 重启或重试后，避免早前的 stopSelfResult() 请求将后来启动的 Service 停止。</span></span><br><span class=\"line\"><span class=\"comment\">     *                例如：onStartCommand(intent, flags, 5) 启动的 Service，将无法被 stopSelfResult(4) 停止。</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 有三种典型取值，代表了 Service 被 Start 后，如果被系统杀死，后续的行为。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_STICKY: 表示内存充足后需要重新启动，但传入的 intent == null，除非有 Intent 队列，例如 PendingIntent。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_NOT_STICKY: 表示内存充足后也不重新启动。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_REDELIVER_INTENT: 表示内存充足后需要重新启动，并且把上一次 Start 时使用的 Intent 再重新传入。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被首次 Bind 时回调，被 Start 启动时不会回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onBind() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 在被销毁前，生命周期中只会在第一次被 Client 绑定时回调 onBind()，</span></span><br><span class=\"line\"><span class=\"comment\">     * 之后不论 Client 如何解绑并重新绑定，只要 Service 没有被销毁重启，都不会再次回调 onBind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被重新 Bind 时回调，仅当 onUnbind() 返回 true 时生效。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅当：</span></span><br><span class=\"line\"><span class=\"comment\">     * - Service 从 Bound 的状态下被所有 Client Unbind，</span></span><br><span class=\"line\"><span class=\"comment\">     * - 并且 onUnbind() 返回 true，</span></span><br><span class=\"line\"><span class=\"comment\">     * - 并且 Service 未被销毁（即同时处于 Started 状态），</span></span><br><span class=\"line\"><span class=\"comment\">     * 则下一次被 Bind 时才会回调 onRebind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onRebind(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被所有 Client Unbind，或者被最后一个 Context.BIND_AUTO_CREATE 模式的 Client Unbind 后回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要注意：</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果 Service 被多个 Client Bind，只要所有 Context.BIND_AUTO_CREATE 模式的 Client Unbind 就会回调 onUnbind()，</span></span><br><span class=\"line\"><span class=\"comment\">     *   此时其他模式的 Client 就会收到 ServiceConnection#onServiceDisconnected() 回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * - 否则当所有 Client Unbind 后才会触发该回调，且都不会收到 ServiceConnection#onServiceDisconnected() 回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当首次从 Bound 状态下被所有以 Context.BIND_AUTO_CREATE 模式 Bind 的 Client Unbind 时会回调，</span></span><br><span class=\"line\"><span class=\"comment\">     * 之后被重新 Bind 和 Unbind，是否回调依赖上一次 onUnbind() 的返回值：</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果上一次返回 false，则下一次被 Client Bind 时不会回调 onRebind()，且被所有 Client Unbind 后也不会回调 onUnbind()。</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果上一次返回 true，则下一次被 Client Bind 时会回调 onRebind()，且被所有 Clinet Unbind 后会也回调 onUnbind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onUnbind(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 真正被销毁时回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onDestroy() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时处于 <code>Started</code> 和 <code>Bound</code> 状态下的 Service，在被 Stop 并且 <code>onUnbind()</code> 后才会销毁。需要注意的是，Service 的 <code>onUnbind()</code> 有两种触发方式，只要满足其中任意一条就会触发 <code>onUnbind()</code> 回调：</p>\n<ul>\n<li><p>所有 <code>Context.BIND_AUTO_CREATE</code> 模式 Bind 的 Client 均已 Unbind。</p>\n<p>此时其他模式 Bind 的 Client 会收到 <code>ServiceConnection#onServiceDisconnected()</code> 回调，视为其他 Client 异常断开。</p>\n</li>\n<li><p>所有 Client 都不是 <code>Context.BIND_AUTO_CREATE</code> 模式，且都已 Unbind。</p>\n<p>此时所有 Client 都不会收到 <code>ServiceConnection#onServiceDisconnected()</code> 回调，视为正常断开。</p>\n</li>\n</ul>\n<p>一个 Service 不论是否已经启动，都可以被多次 Start、Stop 和 Bind，Start 和 Stop 的次数不必须匹配，但 Unbind 的次数必须匹配 Bind 的次数，如果 Client 与 Service 不存在绑定关系，则调用 Unbind 会抛出异常。</p>\n<hr>\n<h2 id=\"3-Client与Service通信\"><a href=\"#3-Client与Service通信\" class=\"headerlink\" title=\"3. Client与Service通信\"></a>3. Client与Service通信</h2><p>如果 Client 需要与 Service 通信，则必须通过 <code>bind</code> 方式与目标 Service 绑定连接。</p>\n<h3 id=\"3-1-通过Binder持有Service\"><a href=\"#3-1-通过Binder持有Service\" class=\"headerlink\" title=\"3.1 通过Binder持有Service\"></a>3.1 通过Binder持有Service</h3><p>Client 直接持有 Service 实例对象通信，原理是：</p>\n<ul>\n<li>利用 Binder 跨进程通信的方式，直接在 Client 中拿到 Service 的 Binder 对象。</li>\n<li>然后从 ServiceBinder 中获取 Service 实例对象，相当于把 Service 的实例对象跨进程传到了 Client 进程中。</li>\n<li>Client 持有了 Service 实例对象，即可直接操作 Service。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接操作 Binder 对象的方式。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoBinder</span> <span class=\"keyword\">extends</span> <span class=\"title\">Binder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Binder 返回 Service 实例，使得外部可以持有该 Service 对象并与之通信</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DemoService <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DemoService.<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DemoBinder(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以由外部调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        bindService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, DemoService.class), <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">                DemoBinder demoBinder = (DemoBinder) service;</span><br><span class=\"line\">                <span class=\"comment\">// 持有 DemoService 的实例对象，并调用 Service 的公有方法。</span></span><br><span class=\"line\">                demoBinder.getService().work(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123; <span class=\"comment\">/* 仅当异常 Unbind 时才回调 */</span> &#125;</span><br><span class=\"line\">        &#125;, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-通过Messenger发送消息\"><a href=\"#3-2-通过Messenger发送消息\" class=\"headerlink\" title=\"3.2 通过Messenger发送消息\"></a>3.2 通过Messenger发送消息</h3><p>Client 和 Service 通过互相持有对方的 Messenger 通信，原理是：</p>\n<ul>\n<li>Client 和 Service 各自通过 Handler 构造各自的 Messenger，则各自的 Messenger 都可以通过 Handler 接收消息。</li>\n<li>Service 在 <code>onBind()</code> 中返回 <code>serviceMessenger.getBinder()</code>，相当于返回 Service 进程的 Binder。</li>\n<li>然后 Client 在成功连接 Service 后，通过 Service 返回的 Binder 构造并持有 Service 的 Messenger，也就相当于能向 Service 的 Handler 发送消息。</li>\n<li>此时 Service 还不能向 Client 发送消息，所以 Client 需要首先向 Service 发送一条消息，在消息中指定 <code>replyTo</code> 为 Client 自己的 messenger。</li>\n<li>则 Service 收到这条消息后，就能通过消息的 <code>replyTo</code> 取出并持有 Client 的 Messenger，也就相当于能向 Client 的 Handler 发送消息。</li>\n<li>此时 Client 和 Service 都互相持有了对方的 Messenger，就可以互相发送消息。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过 Messenger 发送消息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_ON_BIND = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Service 自己的 Handler，用于处理来自 Client 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler serviceHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MSG_ON_BIND: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过接收 Client 发送过来的消息，从消息中获取 Client 的 Messenger。</span></span><br><span class=\"line\">                    clientMessenger = msg.replyTo;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Client 的 Messenger，用于向 Client 发送消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger clientMessenger;</span><br><span class=\"line\">    <span class=\"comment\">// Service 自己的 Messenger，用于接收来自 Client 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Messenger serviceMessenger = <span class=\"keyword\">new</span> Messenger(serviceHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回 Service 的 Messenger，持有方就能向 Service 发送消息。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> serviceMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 通过 Client 的 Messenger 向 Client 发送消息通信。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendToClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clientMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            clientMessenger.send(Message.obtain());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Client 自己的 Handler，用于处理来自 Service 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler clientHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理来自 Service 发送的消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Client 自己的 Messenger，用于接收来自 Service 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Messenger clientMessenger = <span class=\"keyword\">new</span> Messenger(clientHandler);</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Messenger，用于向 Service 发送消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger serviceMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        bindService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, DemoService.class), <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 通过 Service 的 Binder 来构造 Service 的 Messenger。</span></span><br><span class=\"line\">                serviceMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">                <span class=\"comment\">// 先向 Service 发送一条消息，通过 Msg.replyTo 把 Client 自己的 Messenger 传过去，</span></span><br><span class=\"line\">                <span class=\"comment\">// 这样 Service 才能拿到 Client 的 Messenger，才能向 Client 发送消息。</span></span><br><span class=\"line\">                Message onBindMsg = Message.obtain();</span><br><span class=\"line\">                onBindMsg.what = DemoService.MSG_ON_BIND;</span><br><span class=\"line\">                onBindMsg.replyTo = clientMessenger;</span><br><span class=\"line\">                serviceMessenger.send(onBindMsg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123; <span class=\"comment\">/* 仅当异常 Unbind 时才回调 */</span> &#125;</span><br><span class=\"line\">        &#125;, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Client 通过 Service 的 Messenger 向 Service 发送消息通信。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendOnBindToService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (serviceMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            serviceMessenger.send(Message.obtain());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-其他方式\"><a href=\"#3-3-其他方式\" class=\"headerlink\" title=\"3.3 其他方式\"></a>3.3 其他方式</h3><p>除了使用 Binder 方式以外，Activity 与 Service 之间的通信还能通过 BroadCastReceiver 以及 EventBus 的方式实现。</p>\n<hr>\n<h2 id=\"4-高版本Service的限制\"><a href=\"#4-高版本Service的限制\" class=\"headerlink\" title=\"4. 高版本Service的限制\"></a>4. 高版本Service的限制</h2><p>从 API 21 (Android 5.0) 开始，Google 全面禁止了隐式启动 Service，仅允许显式启动 Service，不论目标 Service 是否处于同一个 App 内，都需要指定目标 Service 所在 App 的包名以及该 Service 的全路径。隐式启动 Service 将会抛出异常，该限制主要是为了避免 App 恶意唤起后台服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Service Intent must be explicit</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>隐式启动 Service 是指仅通过 ActionName 启动 Service，即使可能存在多个 Service 的 ActionName 重复。API 21 之后，必须使用显式启动，否则会抛出异常，</p>\n</blockquote>\n<p>从 API 26 (Android 8) 开始，Google 针对资源控制限制了后台服务，处于后台的 App 将不允许后台 Service 再直接通过 <code>startService()</code> 方式启动另一个后台 Service。此前 Service 需要启动后再调用 <code>Service#startForeground()</code> 才能将 Service 设为前台服务，而不论通过 Start 还是 Bind 启动的 Service 默认都作为后台服务，因此 API 26 提供了一个新的 Api <code>startForgroundService()</code> 来直接启动一个默认前台服务。</p>\n<ul>\n<li>由于指定了启动的是前台服务，因此其会在内部调用 <code>ActiveServices.setServiceForegroundInnerLocked()</code> Post 了一个延时消息，必须在 10s 内调用 <code>Service#startForeground()</code>，其内部 Remove 了该延时消息，否则该延时消息就会抛出 ANR。</li>\n<li>并且如果 <code>Service#startForeground(int id, Notification notification)</code> 中 <code>id == 0</code> 或 <code>notification == null</code> 都会抛出 <code>Null Notification</code> 异常，因此启动前台服务一定会创建一个通知提醒用户。</li>\n</ul>\n<p>后台 Service 不能直接 Start 另一个后台 Service，这条规则受到 App 前后台策略的影响：</p>\n<ul>\n<li>处于前台的 App 可以自由启动前台或后台 Service。</li>\n<li>进入后台的 App 在一段时间窗内（数分钟）仍然可以自由启动创建前台或后台 Service，在时间窗结束后系统将会停止 App 的后台 Service。</li>\n</ul>\n<p>但 Android 对 App 是否前台的判断，并非是简单地判断是否存在前台 Activity。Google 文档中指出，一个 App 如果满足以下几点，则被视为处于前台：</p>\n<ul>\n<li>具有可见 Activity</li>\n<li>具有前台 Service</li>\n<li>被另一个前台 App 关联（被另一个前台应用 Bind Service 或使用了 ContentProvider），例如：<ul>\n<li>IME</li>\n<li>壁纸 Service</li>\n<li>通知监听</li>\n<li>语音或文本服务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-Service保活\"><a href=\"#4-1-Service保活\" class=\"headerlink\" title=\"4.1 Service保活\"></a>4.1 Service保活</h3><p>随着高版本 Android 对后台策略逐步收紧，理论上已经没有 100% 保活的方式，API 26 以上 Service 保活的思路主要就是两个 Service 互相启动并绑定；</p>\n<ul>\n<li>AService：<ul>\n<li>首先由某个前台 Activity Start 一个 AService。</li>\n<li>AService 的 <code>onStartCommand()</code> 返回 <code>START_STICKY</code>。</li>\n<li>AService Start 和 Bind BService。</li>\n<li>AService 在 <code>onDestroy()</code> 中再次 Start 和 Bind BService。</li>\n</ul>\n</li>\n<li>BService：<ul>\n<li>BService 的 <code>onStartCommand()</code> 同样返回 <code>START_STICKY</code>。</li>\n<li>BService 被启动后，Start 和 Bind AService。</li>\n<li>BService 在 <code>onDestroy()</code> 中再次 Start 和 Bind AService。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>AService 和 BService 都需要在 <code>onStartCommand()</code> 中返回 <code>START_STICKY</code>，这样其中一个 Service 由于内存被系统杀死后，仍有机会被重启并继续拉活对方。</p>\n<p>由于后台 Service 如果仅被 Start 而没有被 Bind，会在 App 置入后台 1 分钟后被 Kill，所以 Service 互相拉活时，需要同时 Start 和 Bind 对方。</p>\n<p>由于高版本禁止从后台启动任何后台服务，所以在 AService 和 BService 互相 Start 时需要判断版本，API 26 以上需要 <code>startForegroundService()</code>。</p>\n</blockquote>\n<h3 id=\"4-2-几乎不可见的Activity\"><a href=\"#4-2-几乎不可见的Activity\" class=\"headerlink\" title=\"4.2 几乎不可见的Activity\"></a>4.2 几乎不可见的Activity</h3><p>主要思路是在 <code>Activity#onCreate()</code> 中将 Activity 设置为只有一个像素大小的透明的背景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    Window activityWindow = getWindow();</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 不可点击：</span></span><br><span class=\"line\">    activityWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 不关心外界触摸事件：</span></span><br><span class=\"line\">    activityWindow.addFlags(WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 DecorView 为全屏状态</span></span><br><span class=\"line\">    View decorView = activityWindow.getDecorView();</span><br><span class=\"line\">    decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置状态栏透明不可见：</span></span><br><span class=\"line\">    activityWindow.setStatusBarColor(Color.TRANSPARENT);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 位于左上角：</span></span><br><span class=\"line\">    activityWindow.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">    WindowManager.LayoutParams params = activityWindow.getAttributes();</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 相对 Gravity 横纵坐标偏移均为 0：</span></span><br><span class=\"line\">    params.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    params.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 的宽和高均为 1 像素：</span></span><br><span class=\"line\">    params.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">    params.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">    activityWindow.setAttributes(params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Android"],"tags":["Android","四大组件","Service","前台服务","后台服务"]},{"title":"Android-Window机制","url":"/post/android/android-window/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Window机制\"><a href=\"#Android-Window机制\" class=\"headerlink\" title=\"Android-Window机制\"></a>Android-Window机制</h1><h2 id=\"1-Window的表现形式\"><a href=\"#1-Window的表现形式\" class=\"headerlink\" title=\"1. Window的表现形式\"></a>1. Window的表现形式</h2><h3 id=\"1-1-什么是Window\"><a href=\"#1-1-什么是Window\" class=\"headerlink\" title=\"1.1 什么是Window\"></a>1.1 什么是Window</h3><p>在大部分 PC 操作系统中，Window 指的是一个可视化的窗口区域。例如在 MacOS、Linux、Windows 系统中，可视化内容的 Window 通常包含（并非必须）「关闭按钮」、「最小化」、「最大化」，这个 Window 是由操作系统分配的且具有 UI（例如边框、按钮、标题等），限定了内容显示的区域，可视化的内容在渲染时只需要相对给定的 Window 渲染和绘制，因此提供给了用户自由操作的空间。</p>\n<h3 id=\"1-2-Android中的Window\"><a href=\"#1-2-Android中的Window\" class=\"headerlink\" title=\"1.2 Android中的Window\"></a>1.2 Android中的Window</h3><p>在 Android 中，Window 更多只是一种抽象的概念：<strong>一组 View 的集合</strong>，因为 Android 中的 Window 并没有实际的 UI。在源码中有 <code>Window</code>, <code>PhoneWindow</code>, <code>ViewManager</code>, <code>WindowManager</code>, <code>WindowManagerImpl</code>, <code>WindowManagerGlobal</code> 等与 Window 相关的类，但这些都不是 Window 实体。</p>\n<p>Android 中 Window 和 View 的关系就像「组织」和「个体」的关系，一群相似的个体可以组成一个集体并对外具有一定属性、功能，但「组织」只是一个概念上的集合，并不是一个实际存在的东西。</p>\n<hr>\n<h2 id=\"2-Window属性\"><a href=\"#2-Window属性\" class=\"headerlink\" title=\"2. Window属性\"></a>2. Window属性</h2><p>Window 有 3 个重要属性：</p>\n<ul>\n<li>type</li>\n<li>flags</li>\n<li>solfInputMode</li>\n</ul>\n<h3 id=\"2-1-Type\"><a href=\"#2-1-Type\" class=\"headerlink\" title=\"2.1 Type\"></a>2.1 Type</h3><p>由于 Android 中 Window 是对一组 View 集合的描述，不同应用有不同的 Window，同一个应用也可能有多个 Window，所以需要用一种优先级表示 Window 的显示层级，在 Android 中使用 <code>type</code> 表示 Window 的类型，实际上是通过 <code>type</code> 的大小表示 Window 的优先级，值越大则在屏幕上显示位置越上层，会覆盖低层级的 Window：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 应用的主窗口层级范围 1 ~ 99</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_APPLICATION_WINDOW = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_APPLICATION_WINDOW = <span class=\"number\">99</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 应用子窗口（例如 Dialog）层级范围 1000 ~ 1999</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_SUB_WINDOW = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_SUB_WINDOW = <span class=\"number\">1999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 系统窗口层级范围 2000 ~ 2999</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_SYSTEM_WINDOW     = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_SYSTEM_WINDOW      = <span class=\"number\">2999</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Flags\"><a href=\"#2-2-Flags\" class=\"headerlink\" title=\"2.2 Flags\"></a>2.2 Flags</h3><p>Flags 用于指定 Window 在不同场景下的处理方式，包括样式（全屏、背景等）、显示模式（是否允许锁屏、是否允许超出屏幕等）、触摸事件处理逻辑（是否接受触摸响应、是否将外部触摸事件传递到下层窗口等）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有 Flag 枚举</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_XXX = xxxxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-SoftInputMode\"><a href=\"#2-3-SoftInputMode\" class=\"headerlink\" title=\"2.3 SoftInputMode\"></a>2.3 SoftInputMode</h3><p>SoftInputMode 决定了 Window 在弹出软键盘时的逻辑，实际上软键盘也是一种 Window，但因为比较特殊所以专门用了一个属性来控制：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> softInputMode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有 SoftInputMode 枚举</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SOFT_INPUT_XXX = xxxxx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-创建Window\"><a href=\"#3-创建Window\" class=\"headerlink\" title=\"3. 创建Window\"></a>3. 创建Window</h2><h3 id=\"3-1-指定用于创建Window的View\"><a href=\"#3-1-指定用于创建Window的View\" class=\"headerlink\" title=\"3.1 指定用于创建Window的View\"></a>3.1 指定用于创建Window的View</h3><p>在创建一个 Window 时，例如在 Activity 手动调用 <code>getWindowManager().addView(...)</code>，或是 <code>Dialog#show</code>，本质上都是调用了 WindowManager 实现类的 <code>WindowManagerImpl#addView</code> 方法，实际上 <code>WindowManagerImpl</code> 内的方法都只是对入参做了一些校验和预处理，最终都是通过桥接模式调用单例的 <code>WindowManagerGlobal</code> 实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WindowManagerGlobal <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sDefaultWindowManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                sDefaultWindowManager = <span class=\"keyword\">new</span> WindowManagerGlobal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sDefaultWindowManager;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实际创建 Window</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        View panelParentView = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            mViews.add(view);</span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>WindowManagerGlobal#addView(...)</code> 主要做了五件事：</p>\n<ul>\n<li>校验入参；</li>\n<li>如果 <code>parentWindow != null</code> 说明需要创建 SubWindow，则 SubWindow 需要继承部分 parentWindow 的属性；</li>\n<li>创建 ViewRootImpl；</li>\n<li>把用于创建 Window 的 View、ViewRootImpl、应用到 Window 的 LayoutParams 分别存入三个列表，这三个列表总是等长的，三列表中同一下标对应的三个对象均指向了同一个 Window；</li>\n<li>将用于创建 Window 的 View 以及 LayoutParams 传入 ViewRootImpl，由 ViewRootImpl 实际创建 Window。</li>\n</ul>\n<p>这里也能看出，每次创建 Window 时都会先创建一个 ViewRootImpl，而真正创建 Window 的步骤其实就在 ViewRootImpl 内，并不是 WindowManager 也不是 PhoneWindow，ViewRootImpl 与创建的 Window 是一一对应的。</p>\n<h3 id=\"3-2-ViewRootImpl创建Window\"><a href=\"#3-2-ViewRootImpl创建Window\" class=\"headerlink\" title=\"3.2 ViewRootImpl创建Window\"></a>3.2 ViewRootImpl创建Window</h3><p>ViewRootImpl 在构造方法中通过单例的 WindowManagerGlobal 获取了一个单例的 IWindowSession 对象，用于在 <code>ViewRootImpl#setView(...)</code> 中真正创建 Window：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> IWindowSession mWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定了初始化时的线程</span></span><br><span class=\"line\">        mThread = Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 view 就是 DecorView。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mView = view;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 调用 WindowSession#addToDisplay(...)，才是真正创建了一个 Window。</span></span><br><span class=\"line\">                res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IWindowSession sWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IWindowSession <span class=\"title\">getWindowSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sWindowSession == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    IWindowManager windowManager = getWindowManagerService();</span><br><span class=\"line\">                    sWindowSession = windowManager.openSession(...);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sWindowSession;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这也能看出，WindowManagerGlobal 和 IWindowSession 都是应用内单例的；</p>\n<ul>\n<li><p>WindowManagerGlobal 是一个工具类，用于维护和提供一系列与 Window 相关的资源，例如在 <code>addView(...)</code> 中就创建并维护了 View、ViewRootImpl、LayoutParams，而 <code>getWindowSession(...)</code> 则维护并提供 IWindowSession 对象，但 WindowManagerGlobal 本身并不承担创建 Window 的责任，是一个纯粹的工具类。</p>\n</li>\n<li><p>IWindowSession 包含了一系列与 WindowManagerService 的交互逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> <span class=\"keyword\">extends</span> <span class=\"title\">IWindowSession</span>.<span class=\"title\">Stub</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBinder</span>.<span class=\"title\">DeathRecipient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> WindowManagerService mService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">addToDisplay</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mService.addWindow(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>所以，关于 Window、PhoneWindow、ViewManager、WindowManager、WindowManagerImpl、WindowManagerGlobal、ViewRootImpl 的关系可以总结如下：</p>\n<ul>\n<li>首先在 <code>Activity#attach(...)</code> 阶段先创建 <code>new PhoneWindow(...)</code>；</li>\n<li>然后通过 <code>PhoneWindow#setWindowManager(...)</code> 的内部创建出来一个 WindowManagerImpl；</li>\n<li>所有创建 Window 的地方，不论是 Activity、Dialog、还是 PopupWindow，最终都会调用 <code>WindowManagerImpl#addView(...)</code>；</li>\n<li>WindowManagerImpl 则调用单例的 <code>WindowManagerGlobal#addView(...)</code>；</li>\n<li>WindowManagerGlobal 创建 <code>new ViewRootImpl(...)</code>；</li>\n<li>ViewRootImpl 通过 <code>setView(...)</code> 持有了用于创建 Window 的 View，以及指定 Window 属性的 LayoutParams，因此 <strong>ViewRootImpl 负责连接 View 和 Window</strong>；</li>\n<li>ViewRootImpl 从 WindowManagerGlobal 中获取单例的 IWindowSession，调用 <code>IWindowSession#addToDisplay(...)</code>；</li>\n<li>IWindowSession 调用 WMS 完成最终的 Window 创建，因此 <strong>IWindowSession 负责连接 ViewRootImpl 和 WMS</strong>。</li>\n</ul>\n<blockquote>\n<p>除了创建窗口，WindowManagerImpl 还能通过 <code>updateView(...)</code> 和 <code>removeView(...)</code> 更新及移除 Window。</p>\n</blockquote>\n<hr>\n<h2 id=\"4-PhoneWindow\"><a href=\"#4-PhoneWindow\" class=\"headerlink\" title=\"4. PhoneWindow\"></a>4. PhoneWindow</h2><h3 id=\"4-1-PhoneWindow不是Window\"><a href=\"#4-1-PhoneWindow不是Window\" class=\"headerlink\" title=\"4.1 PhoneWindow不是Window\"></a>4.1 PhoneWindow不是Window</h3><p>通过上文分析会发现，创建 Window 最终都是通过 <code>WindowManagerImpl#addView(...)</code> 实现的，而 WindowManagerImpl 又是在 <code>PhoneWindow#setWindowManager(...)</code> 中创建的，那为什么 PhoneWindow 不是一个实际的 Window 呢？这个问题需要从两个方面考虑：</p>\n<p>（1）PhoneWindow 与 Window 并不是一一对应关系：</p>\n<p>首先，PhoneWindow 和实际显示在屏幕上的 Window 并不是一一对应的关系。尽管在 Activity 启动流程中创建了一个 <code>new PhoneWindow(...)</code>，但例如 PopupWindow、或是手动调用 <code>getWindowManager().addView(...)</code> 创建一个 Window 时，都并没有创建 PhoneWindow，而且它们最终都是用这个 Activity 的 WindowManagerImpl 来创建的，与 Activity 创建的 PhoneWindow 并没有直接关系。即便是 Dialog 在构造方法中创建了属于自己的 PhoneWindow 对象，但 <code>show()</code> 的时候用到的 WindowManagerImpl 也是通过 <code>mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</code> 从传入的 Context 中获取的，而创建 Dialog 传入的 Context 又几乎肯定是 Activity，所以实际上这些创建 Window 的过程，仅仅只和 WindowManagerImpl 有关，与 PhoneWindow 并没有什么关系。</p>\n<p>（2）PhoneWindow 并没有与 WMS 的交互：</p>\n<p>Android 对 Window 真正的创建、更新、和移除，都是通过 IWindowSession 调用 WindowManagerService 实现的；反之 WMS 也是通过 IWindowSession 来分配、调度、以及管理实际的 Window。而每个 App 只有一个单例的 IWindowSession，保存在同样单例的 WindowManagerGlobal 中，只有 ViewRootImpl 获取并操作了 IWindowSession，而 ViewRootImpl 又是 WindowManagerImpl 每次调用 <code>addView(...)</code> 时创建的，因此这个与 WMS 交互的过程同样与 PhoneWindow 无关。</p>\n<h3 id=\"4-2-PhoneWindow的意义\"><a href=\"#4-2-PhoneWindow的意义\" class=\"headerlink\" title=\"4.2 PhoneWindow的意义\"></a>4.2 PhoneWindow的意义</h3><p>上文中提到，Activity 在 <code>attach(...)</code> 时创建了自己的 PhoneWindow，而 Dialog 也在构造方法中创建了自己的 PhoneWindow，乍一看似乎 PhoneWindow 就是一个实际的 Window，当然通过上文也已经知道并非如此。PhoneWindow 与 Window 的关系，非常类似于 Socket 与 TCP / UDP 的关系：</p>\n<ul>\n<li>TCP / UDP 都是实际上的传输层协议，但 Socket 既不参与实际数据协议的转换（传输层）、又不负责维护设备之间的通信信道（会话层，Socket 虽然可以建立连接，但 Socket 只是帮忙发起了请求，本质上这条连接并不是 Socket 维护的，而是操作系统维护的）、也不负责传输数据的编解码（表示层），因为 Socket 并不属于 OSI 模型中的任何一层，Socket 只是对 TCP / UDP 的封装而并不参与到实际网络传输中的缓解，应该把 Socket 看成一个工具。</li>\n<li>而 PhoneWindow 与 Window 的关系也是同理，PhoneWindow 维护了与 Window 相关的资源（例如 WindowManager、Type 属性、Flags 属性、SoftInputMode 属性等）；并提供了一系列与 Window 相关的工具方法（例如加载 DecorView、设置 Title、获取实际 Window 的一些状态等）。当需要改变 Window 的属性时，实际上是把对应的属性设置到 PhoneWindow 中，然后由 ViewRootImpl 请求 WMS 后读取并按照对应的属性设置 Window。</li>\n</ul>\n<p>当然上文也提到，Dialog 会在构造方法中创建自己的 PhoneWindow，这是因为 Dialog 是一个很灵活的组件，本质上 Dialog 其实就是另一个 Window，但开发人员对 Dialog 的 Window 有很大的自定义需求，经常需要修改 Window 的属性，因此 Dialog 对创建出来的 Window 资源做了一层封装，放在自己的 PhoneWindow 中，而对于 PopupWindow 或手动调用 <code>getWindowManager().addView(...)</code> 创建的 Window，只是 Google 没有提供获取 Window 并修改属性的 API 而已。</p>\n<hr>\n<h2 id=\"5-Window加载时机\"><a href=\"#5-Window加载时机\" class=\"headerlink\" title=\"5. Window加载时机\"></a>5. Window加载时机</h2><h3 id=\"5-1-Activity的Window\"><a href=\"#5-1-Activity的Window\" class=\"headerlink\" title=\"5.1 Activity的Window\"></a>5.1 Activity的Window</h3><p>在 <a href=\"/post/android/android-activity/\" title=\"@LINK\">Activity 启动流程</a> 中对 Activity 的启动做了分析，Activity 的 Window 是在 <code>ActivityThread#handleResumeActivity(...)</code> 中调用 <code>wm.addView(decor, l);</code> 创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 先调用了 performResumeActivity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 然后才创建 Window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用到 Activity 内</span></span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调用了 <code>Activity#performResume(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">(<span class=\"keyword\">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步已经回调了 Activity 的 onResume() 生命周期</span></span><br><span class=\"line\">        mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码可以看出，Activity 在回调 <code>onResume()</code> 生命周期的时候，Window 以及 ViewRootImpl 是还没有创建的！</p>\n<h3 id=\"5-2-创建新Window\"><a href=\"#5-2-创建新Window\" class=\"headerlink\" title=\"5.2 创建新Window\"></a>5.2 创建新Window</h3><p>上文已经得出结论，Activity 在 <code>onResume()</code> 执行完返回之后，才会执行创建 Window 和 ViewRootImpl 的逻辑；</p>\n<ul>\n<li>这就带来了一个问题：在 Activity 生命周期的 <code>onResume</code> 回调中，可以创建 Window 吗？例如弹出一个 PopupWindow、或是调用 <code>getWindowManager().addView(...)</code>、或是弹出一个 Dialog？</li>\n<li>答案：<ul>\n<li>Dialog 可以。</li>\n<li>PopupWindow 默认情况下不能，需要指定某个范围内的 Type，否则抛出异常。</li>\n<li>手动调用 <code>getWindowManager().addView(...)</code> 只有在 Window 的 Type 属性在某个范围内才可以，否则抛出异常。</li>\n</ul>\n</li>\n</ul>\n<p>抛出的异常是：<code>android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</code>，抛出的地方位于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首先把 DecorView 存为成员变量 mView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mView = view;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过 IWindowSession 实际请求 WMS 创建 Window：</span></span><br><span class=\"line\">            res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (res) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class=\"line\">                    <span class=\"comment\">// 就是在这里抛出的异常，Token 为 null。</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WindowManager.BadTokenException(</span><br><span class=\"line\">                            <span class=\"string\">&quot;Unable to add window -- token &quot;</span> + attrs.token</span><br><span class=\"line\">                            + <span class=\"string\">&quot; is not valid; is your activity running?&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上文分析可知，创建一个 Window 的过程为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际创建 Window</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 parentWindow 不为空，说明当前已经存在一个 Window 了，</span></span><br><span class=\"line\">        <span class=\"comment\">// 就需要用 parentWindow 的属性对新 Window 的 LayoutParams 做预处理。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将 DecorView 传入 ViewRootImpl。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法的意义就在于，如果新的窗口是一个 SubWindow，则它需要继承一些父 Window 的属性，</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如 Token，SubWindow 会使用父 Window 的 Token 作为创建自己的授权。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">adjustLayoutParamsForSubWindow</span><span class=\"params\">(WindowManager.LayoutParams wp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里最外层的三个条件，对 Window 的 Type 做了判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class=\"line\">                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当 (1000 &lt;= Type &lt;= 1999) 时，也就是 SubWindow，则 Token 是通过 DecorView 获取的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wp.token == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                View decor = peekDecorView();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (decor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    wp.token = decor.getWindowToken();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;</span><br><span class=\"line\">                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当 (2000 &lt;= Type &lt;= 2999) 时，此时新 Window 是一个系统 Window，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因此不需要继承什么属性，生命周期也应该独立，源码注释也有说明。</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则此时新 Window 的 Type 范围就是：(1 &lt;= Type &lt;= 99)，属于 Application 类型，</span></span><br><span class=\"line\">            <span class=\"comment\">// 则 Token 直接复用当前 Window 的 Token。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wp.token == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                wp.token = mContainer == <span class=\"keyword\">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在 <code>Window#adjustLayoutParamsForSubWindow(LayoutParams)</code> 中对新 Window 的判断有三个大分支，按优先级顺序：</p>\n<ul>\n<li><code>1000 &lt;= Type &lt;= 1999</code></li>\n<li><code>2000 &lt;= Type &lt;= 2999</code></li>\n<li><code>1 &lt;= Type &lt;= 99</code></li>\n</ul>\n<h4 id=\"5-2-1-作为SubWindow时\"><a href=\"#5-2-1-作为SubWindow时\" class=\"headerlink\" title=\"5.2.1 作为SubWindow时\"></a>5.2.1 作为SubWindow时</h4><p>当新 Window <code>1000 &lt;= Type &lt;= 1999</code> 时，说明新 Window 是一个 SubWindow，SubWindow 的前提就是已经存在父 Window，因此 Token 就从父 Window 的 DecorView 里面获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getWindowToken() 其实是 View 的方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatchAttachedToWindow 存入 AttachInfo，</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchAttachedToWindow</span><span class=\"params\">(AttachInfo info, <span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        mAttachInfo = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// getWindowToken 就从存入的 AttachInfo 里面取出 Token</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getWindowToken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以看到返回的是 mAttachInfo.mWindowToken</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mAttachInfo != <span class=\"keyword\">null</span> ? mAttachInfo.mWindowToken : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DecorView#getWindowToken()</code> 获取的实际上是从 View 成员变量 <code>mAttachInfo</code> 获取的，因此就需要找到这个 <code>mAttachInfo</code> 是什么时候被存入 DecorView 的，也就是 <code>dispatchAttachedToWindow(...)</code> 是什么时候调用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Window 时传入的就是 DecorView</span></span><br><span class=\"line\">        wm.addView(decor, l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入参的 View 就是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将 DecorView 传入 ViewRootImpl。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首先把 DecorView 存为成员变量 mView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mView = view;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里 mView 就是 DecorView，用局部变量 host 持有：</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View host = mView;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 就是在这里把 AttachInfo 存入了 DecorView 中。</span></span><br><span class=\"line\">        host.dispatchAttachedToWindow(mAttachInfo, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以分析得出：</p>\n<ul>\n<li>WindowManagerGlobal 创建 ViewRootImpl 之后调用 <code>ViewRootImpl#setView(...)</code> 将 DecorView 存入 ViewRootImpl；</li>\n<li>ViewRootImpl 在实际开始渲染第一帧的时候才将 AttachInfo 存入 DecorView；</li>\n<li>这之后 <code>DecorView#getWindowToken()</code> 才不为空。</li>\n<li>因此当新建的 Window <code>1000 &lt;= Type &lt;= 1999</code> 时，只有在 DecorView 第一帧渲染之后才能获取到 Token。</li>\n</ul>\n<h4 id=\"5-2-2-作为SystemWindow时\"><a href=\"#5-2-2-作为SystemWindow时\" class=\"headerlink\" title=\"5.2.2 作为SystemWindow时\"></a>5.2.2 作为SystemWindow时</h4><p>当 <code>2000 &lt;= Type &lt;= 2999</code> 时，说明新 Window 是一个 SystemWindow，则不需要从其他 Window 继承任何属性，也不需要复用其他 Window 的 Token，Android 将以独立生命周期处理这个 Window，在源码中也没有做什么处理，这种情况下是不会抛出异常的。</p>\n<h4 id=\"5-2-3-作为ApplicationWindow时\"><a href=\"#5-2-3-作为ApplicationWindow时\" class=\"headerlink\" title=\"5.2.3 作为ApplicationWindow时\"></a>5.2.3 作为ApplicationWindow时</h4><p>当上述两个条件均不满足时，说明 <code>1 &lt;= Type &lt;= 99</code>，也即新 Window 是一个 ApplicationWindow，则新 Window 就直接复用当前 Window 的 Token，又因为 WindowManagerGlobal 中调用的是 <code>parentWindow.adjustLayoutParamsForSubWindow(LayoutParams)</code>，所以新 Window 就是复用的 <code>parentWindow</code> 的 Token，对应在 Activity 中就是 Activity 的 Window 的 Token，再进一步也就是 <code>Activity#attach(...)</code> 阶段从 AMS 传进来的 Token，因此新 Window 在这个阶段（只是预处理 LayoutParams 的阶段，还没有创建 ViewRootImpl）就已经具有了 Token，因此在后续创建 ViewRootImpl 并调用 <code>ViewRootImpl#setView(...)</code> 时也就不会抛出异常。</p>\n<h4 id=\"5-2-4-问题分析\"><a href=\"#5-2-4-问题分析\" class=\"headerlink\" title=\"5.2.4 问题分析\"></a>5.2.4 问题分析</h4><p>上文 3 个小节已经对新 Window 的 Type 取不同值时，对应 Token 的获取时机做了分析，因此对于 <code>Activity#onCreate()</code> 时是否能创建新 Window，就能通过新 Window 的 Type 取值做判断了：</p>\n<p>（1）PopupWindow：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopupWindow</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际取值：1000，属于 SubWindow 的范围</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWindowLayoutType</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutType)</span> </span>&#123;</span><br><span class=\"line\">        mWindowLayoutType = layoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWindowLayoutType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mWindowLayoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAtLocation</span><span class=\"params\">(IBinder token, <span class=\"keyword\">int</span> gravity, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p = createPopupLayoutParams(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAsDropDown</span><span class=\"params\">(View anchor, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff, <span class=\"keyword\">int</span> gravity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p =</span><br><span class=\"line\">                createPopupLayoutParams(anchor.getApplicationWindowToken());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> WindowManager.<span class=\"function\">LayoutParams <span class=\"title\">createPopupLayoutParams</span><span class=\"params\">(IBinder token)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p = <span class=\"keyword\">new</span> WindowManager.LayoutParams();</span><br><span class=\"line\">        p.type = mWindowLayoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，PopupWindow 在成员变量中已经指定了默认的 <code>Type == 1000</code>，因此默认情况下的 PopupWindow 在 <code>Activity#onResume()</code> 阶段无法通过 DecorView 获取到 Token，会抛出异常，但可以通过手动设置 <code>popupWindow.setWindowLayoutType(1 ~ 99)</code> 直接复用 Activity 的 Window 的 Token 解决问题。</p>\n<p>（2）手动调用 <code>getWindowManager.addView(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">getWindowManager().addView(textView, <span class=\"keyword\">new</span> WindowManager.LayoutParams(</span><br><span class=\"line\">        <span class=\"number\">100</span>,              <span class=\"comment\">// 宽</span></span><br><span class=\"line\">        <span class=\"number\">100</span>,              <span class=\"comment\">// 高</span></span><br><span class=\"line\">        TYPE_APPLICATION, <span class=\"comment\">// Type 值，手动指定在 1 ~ 99 即可</span></span><br><span class=\"line\">        <span class=\"number\">0</span>,                <span class=\"comment\">// Flags</span></span><br><span class=\"line\">        <span class=\"number\">0</span>                 <span class=\"comment\">// Bitmap 的像素格式</span></span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>由于可以手动指定 Type 属性，因此指定在 1 ~ 99 范围内即可。</p>\n<p>（3）Dialog：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dialog</span> </span>&#123;</span><br><span class=\"line\">    Dialog(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@StyleRes</span> <span class=\"keyword\">int</span> themeResId, <span class=\"keyword\">boolean</span> createContextThemeWrapper) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Window w = <span class=\"keyword\">new</span> PhoneWindow(mContext);</span><br><span class=\"line\">        mWindow = w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Window 的 LayoutParams 有默认值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManager.LayoutParams mWindowAttributes =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> WindowManager.LayoutParams();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class=\"line\">            <span class=\"comment\">// WindowManager.LayoutParams 的默认 Type 就是 TYPE_APPLICATION</span></span><br><span class=\"line\">            type = TYPE_APPLICATION;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，Dialog 在构造方法中创建了自己的 PhoneWindow，而 Window 默认的 LayoutParams 中 <code>Type == TYPE_APPLICATION == 2</code>，所以 Dialog 也是直接复用了当前 Window 的 Token。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/weixin_43766753/article/details/108350589\" title=\"@LINK\">Android全面解析之Window机制（作者：weixin_43766753）</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Window","PhoneWindow","WindowManager","ViewRootImpl"]},{"title":"Hexo自定义-问题及方案","url":"/post/hexodiy/hexodiy-solutions/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo自定义-问题及方案\"><a href=\"#Hexo自定义-问题及方案\" class=\"headerlink\" title=\"Hexo自定义-问题及方案\"></a>Hexo自定义-问题及方案</h1><h2 id=\"1-Low-Severity-Vulnerability\"><a href=\"#1-Low-Severity-Vulnerability\" class=\"headerlink\" title=\"1. Low Severity Vulnerability\"></a>1. Low Severity Vulnerability</h2><p>有时，在通过 <code>npm install</code> 或 <code>npm install xxx</code> 安装完包以后，终端会出现大致如下的信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">audited 6879 packages <span class=\"keyword\">in</span> 2.402s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br></pre></td></tr></table></figure>\n\n<p>提示“有一个低严重性的漏洞”，根据提示输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix</span><br><span class=\"line\"></span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.185s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br></pre></td></tr></table></figure>\n\n<p>很明显并没有用，反馈大致意思是「有 1 个漏洞需要人工检查，且无法更新」，使用强制修复试试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix --force</span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN using --force I sure hope you know what you are doing.</span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.242s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br></pre></td></tr></table></figure>\n\n<p>强制修复也无效，只好手动修复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit</span><br><span class=\"line\"></span><br><span class=\"line\">                       === npm audit security report ===</span><br><span class=\"line\">                                                                                </span><br><span class=\"line\">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│                                Manual Review                                 │</span><br><span class=\"line\">│            Some vulnerabilities require your attention to resolve            │</span><br><span class=\"line\">│                                                                              │</span><br><span class=\"line\">│         Visit https://go.npm.me/audit-guide <span class=\"keyword\">for</span> additional guidance          │</span><br><span class=\"line\">└──────────────────────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">┌───────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│ Low           │ Regular Expression Denial of Service                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Package       │ marked                                                       │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Patched <span class=\"keyword\">in</span>    │ &gt;=0.7.0                                                      │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Dependency of │ hexo-renderer-marked                                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Path          │ hexo-renderer-marked &gt; marked                                │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ More info     │ https://npmjs.com/advisories/1076                            │</span><br><span class=\"line\">└───────────────┴──────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">found 1 low severity vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability requires manual review. See the full report <span class=\"keyword\">for</span> details.</span><br></pre></td></tr></table></figure>\n\n<p>这些信息似乎是和版本号有关，顺手打开给出来的网址：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">More info</a>，看到如下信息：</p>\n<p><img data-src=\"./more_info.png\" alt=\"More info 网页信息\" title=\"@ASSET\"></p>\n<p>果然给出的解决方案也是升级 marked 版本到 0.7.0，先看看当前的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（1）发现确实是因为旧版本的问题，所以先尝试更新后再次查看版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm update</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（2）发现无法手动更新，那就手动把这个 <code>Blog/node_modules/marked</code> 目录删掉：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── UNMET DEPENDENCY marked@0.6.3 </span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! missing: marked@0.6.3, required by hexo-renderer-marked@1.0.1</span><br></pre></td></tr></table></figure>\n\n<p>（3）提示依赖包 marked 被删除了，然后再重新安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor and audited 6879 packages <span class=\"keyword\">in</span> 2.442s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（4）仍然是 0.6.3 版本！内心是崩溃的，干脆直接覆盖安装一次 marked，再查看版本信息。执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save marked</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">├─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">│ └── marked@0.6.3</span><br><span class=\"line\">└── marked@0.7.0</span><br></pre></td></tr></table></figure>\n\n<p>（5）现在问题来了，从层级结构上来看，手动执行安装后 Hexo 装了两个 marked，手动安装的这个 marked 是最新的 0.7.0 版本，被放在了原来老版本的目录下：<code>Blog/node_modules/marked</code>，而原本隶属于 <code>hexo-renderer-marked</code> 下面的老版本依赖包，由于被 <code>hexo-renderer-marked</code> 依赖，且手动安装了另一版本，导致其位置被自动放到：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code> 目录下。</p>\n<p><strong>也就是说，这个老版本的 marked，其版本并不是由站点主目录管理的，所以 update 和 删掉重新 install 都无法更新，而手动安装的 marked 是直接由站点主目录管理的，因此默认会安装最新版。这也说明被依赖的 marked 的版本号是在 hexo-renderer-marked 渲染引擎中控制的。</strong></p>\n<p>（6）为了防止冲突，先卸载手动安装的 marked：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm uninstall --save marked</span><br></pre></td></tr></table></figure>\n\n<p>现在 <code>Blog/node_modules/</code> 下已经没有 <code>marked</code> 目录了，同时也手动删掉老版本的 marked 目录：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code>。</p>\n<p>（7）然后 再到之前的网页：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">点击这里</a> 内点击 <code>Versions</code> 栏查看最新的 marked 版本：</p>\n<p><img data-src=\"./marked_newest_version.png\" alt=\"marked 最新版本\" title=\"@ASSET\"></p>\n<p>（8）接着找到 <code>Blog/node_modules/hexo-renderer-marked/package.json</code>，修改其中的依赖部分：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;hexo-util&quot;: &quot;^0.6.2&quot;,</span><br><span class=\"line\">  &quot;marked&quot;: &quot;^0.6.1&quot;,</span><br><span class=\"line\">  &quot;strip-indent&quot;: &quot;^2.0.0&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>&quot;marked&quot;</code> 字段后面的 <code>&quot;^0.6.1&quot;</code> 强制改为 <code>&quot;^0.7.0&quot;</code>，，最后再次执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor, removed 1 package and audited 6879 packages <span class=\"keyword\">in</span> 3.168s</span><br><span class=\"line\">found 0 vulnerabilities</span><br></pre></td></tr></table></figure>\n\n<p>看到这个结果说明已经没有报“低严重性漏洞”了，再查看一下版本号，发现成功更新到 0.7.0 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 /Users/luis/Downloads/Temp</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.7.0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假如执行这两步的时候依然报之前的信息，如果可以确保之前的步骤都是对的，可以暂时不管，通常是缓存信息还没有更新的缘故，把这两步执行完之后，退出并重新打开终端再查看 <code>npm ls marked</code> 即可看到已经更新。假如出现错误信息显示被删除，再执行一次 <code>npm install</code> 即可。</p>\n<p>由于已经卸载了之前手动安装的 marked，因此这个依赖包的位置又回到了：<code>Site/node_modules/marked</code> 下。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-FontAwesome不显示\"><a href=\"#2-FontAwesome不显示\" class=\"headerlink\" title=\"2. FontAwesome不显示\"></a>2. FontAwesome不显示</h2><p>某些情况下，在构建博客后，会出现图标不显示的问题，同时在页面上检查元素会出现一个报错信息：</p>\n<p><img data-src=\"./fontawesome_error_info.png\" alt=\"FontAwesome 显示异常\" title=\"@ASSET\"></p>\n<p>原因是没找到目录下 FontAwesome 的 CSS 文件，但其实并不需要手动下载，Next 主题在生成部署时会动态到 FontAwesome 网站上下载相关样式，这时就考虑可能是 FontAwesome 的某个 CDN 连接挂了，可以在 Next 的主题配置文件 <code>next/_config.yml</code> 中切换一下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Internal version: 4.6.2</span></span><br><span class=\"line\"><span class=\"comment\"># See: https://fontawesome.com</span></span><br><span class=\"line\"><span class=\"comment\"># Example:</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"attr\">fontawesome:</span> <span class=\"string\">https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure>\n\n<p>重新部署，恢复正常。</p>\n<hr>\n<h2 id=\"3-Valine评论\"><a href=\"#3-Valine评论\" class=\"headerlink\" title=\"3. Valine评论\"></a>3. Valine评论</h2><p>Valine 评论和 LeanCloud 阅读统计同时开启会有冲突（2019-12-04 无意间发现已经不会冲突了），解决方案是关掉 LeanCloud 独立的阅读统计，并在 Valine 设置项中开启统计功能即可，Valine 设置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppID</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppKey</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-Valine支持邮箱信息\"><a href=\"#3-1-Valine支持邮箱信息\" class=\"headerlink\" title=\"3.1 Valine支持邮箱信息\"></a>3.1 Valine支持邮箱信息</h3><p>默认情况下 Valine 只支持用户输入昵称评论，不能自己输入邮箱、网址等等，效果如下：</p>\n<p><img data-src=\"./valine_only_nick.png\" alt=\"Valine 只能输入昵称\" title=\"@ASSET\"></p>\n<p>而官网提供的评论框可以同时输入昵称、邮箱、链接：</p>\n<p><img data-src=\"./valine_nick_email_link.png\" alt=\"官网 Valine 可输入全部信息\" title=\"@ASSET\"></p>\n<p>通过查看官网的配置信息，以及查看了 Next 主题源码之后发现是 Next 源码直接限制了只能输入昵称。找到 <code>next/layout/_third-party/comments/valine.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">  guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">    verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">    notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">    appId: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    appKey: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    placeholder: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    avatar: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    guest_info:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br><span class=\"line\">    meta: guest,</span><br><span class=\"line\">    pageSize: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">    visitor: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">    lang: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>重点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">guest_info:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是这里写死了只能输入昵称，到底是否需要设置其他信息可以自行决定。在 NexT 主题配置文件中 Valine 有这么个配置项：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># custom comment header</span></span><br></pre></td></tr></table></figure>\n\n<p>这个属性对应在源码 <code>next/layout/_third-party/comments/valine.swig</code> 中传递给了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">meta: guest,</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用也就是从主体配置文件中获取 <code>guest_info</code> 属性，然后以 ‘,’ 分隔开，再从 <code>[&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]</code> 中分别获取对应的字符串并组成数组，然后传给 <code>meta</code>。查看 Valine 官网资料可知，这个 <code>meta</code> 属性是 LeanCloud 存储评论的头部信息，这里定义几个属性，在 Valine 写入 LeanCloud 存储时，就会写入几个属性。</p>\n<h4 id=\"3-1-1-直接修改写入属性\"><a href=\"#3-1-1-直接修改写入属性\" class=\"headerlink\" title=\"3.1.1 直接修改写入属性\"></a>3.1.1 直接修改写入属性</h4><p>如果希望输入框有几个属性，Valine 就固定向 LeanCloud 存储几个属性，则可以简单添加其他信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 guest_info 重新赋值为 guest 遍历到的所有属性，否则默认只有上面 JS 中定义的 guest_info:[&#x27;nick&#x27;]</span></span><br><span class=\"line\">guest_info: guest,</span><br><span class=\"line\">meta: guest,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1-2-自定义存储信息\"><a href=\"#3-1-2-自定义存储信息\" class=\"headerlink\" title=\"3.1.2 自定义存储信息\"></a>3.1.2 自定义存储信息</h4><p>如果希望评论时读者写入的属性和实际存储到 LeanCloud 中的属性不一致，例如读者评论时只需要填写：昵称、邮箱，但 Valine 实际上存储时会存储：昵称、邮箱、链接，这样的好处是如果未来有一天新增了链接属性，原有的统计表不需要扩展，则需要自定义一个属性。首先在主题配置文件的 Valine 设置部分添加一个自定义属性（命名可自定义）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\">  <span class=\"attr\">guest_header:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># 用户可以自定义输入的信息</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># Valine 实际会向 LeanCloud 写入的信息</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在 Next 的 Valine 部署源码 <code>next/layout/_third-party/comments/valine.swig</code> 中修改这一部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新定义一个变量 guest_header，用来存实际需要展示在评论区的属性列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> guest_header = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_header &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest_header = guest_header.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">  verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">  notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">  appId: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  appKey: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  placeholder: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  avatar: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 guest_info 重新赋值为 guest_header 定义的属性，否则默认只有上面 JS 中定义的 guest_info:[&#x27;nick&#x27;]</span></span><br><span class=\"line\">  guest_info: guest_header,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但是 Valine 写入到 LeanCloud 的还是站点配置文件中配置的所有项</span></span><br><span class=\"line\">  meta: guest,</span><br><span class=\"line\"></span><br><span class=\"line\">  pageSize: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">  visitor: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">  lang: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>主要就是获取主题配置文件中设置的 <code>guest_header</code> 然后组合成数组再传给 <code>guest_info</code> 即可。重新部署，效果如下：</p>\n<p><img data-src=\"./valine_guest_info_custom.png\" alt=\"Valine 自定义用户可输入信息\" title=\"@ASSET\"></p>\n<h3 id=\"3-2-隐藏Valine系统信息\"><a href=\"#3-2-隐藏Valine系统信息\" class=\"headerlink\" title=\"3.2 隐藏Valine系统信息\"></a>3.2 隐藏Valine系统信息</h3><p>常规配置好 Valine 后，会发现评论时自动读取了用户的系统信息等不太美观：</p>\n<p><img data-src=\"./valine_show_system_info.png\" alt=\"Valine 显示系统信息\" title=\"@ASSET\"></p>\n<p>想要隐藏系统信息可修改 <code>next/source/css/_custom/custom.styl</code>，在末尾添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Valine 隐藏系统信息</span></span><br><span class=\"line\">.vsys&#123;</span><br><span class=\"line\">  display:none !important;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>custom.styl</code> 这个文件会在 <code>next/source/css/main.styl</code> 中被引入：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom Layer</span></span><br><span class=\"line\"><span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">&quot;_custom/&quot;</span> + $custom_styles;</span><br></pre></td></tr></table></figure>\n\n<p>隐藏后的效果：</p>\n<p><img data-src=\"./valine_hide_system_info.png\" alt=\"Valine 隐藏系统信息\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"4-本地搜索框\"><a href=\"#4-本地搜索框\" class=\"headerlink\" title=\"4. 本地搜索框\"></a>4. 本地搜索框</h2><p>在使用搜索功能时，有时可能会遇到：点击搜索后一直处于加载中的状态，无法正确显示搜索框；点击搜索后不弹出搜索框或搜索框无法点击输入等，可以按照以下内容排查。</p>\n<h3 id=\"4-1-搜索Json格式不对\"><a href=\"#4-1-搜索Json格式不对\" class=\"headerlink\" title=\"4.1 搜索Json格式不对\"></a>4.1 搜索Json格式不对</h3><p>老版本的 Hexo 站点，记录搜索内容的文件是 <code>search.xml</code>，但新版本改为了 <code>search.json</code>，如果使用新版 Hexo 但参考旧版本的文章配置，可能导致无法解析搜索内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The following content is not recommended to modify</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索数据文件路径设置，不建议改动：</span></span><br><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.json</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br></pre></td></tr></table></figure>\n\n<p>该文件的实际路径为：<code>url/search.json</code>，直接访问这个链接如果可以正确显示 Json 内容，则说明文件生成正常，生成目录为 <code>site/public/search.json</code>。</p>\n<h3 id=\"4-2-特殊字符问题\"><a href=\"#4-2-特殊字符问题\" class=\"headerlink\" title=\"4.2 特殊字符问题\"></a>4.2 特殊字符问题</h3><p>有一个特殊字符 <code>\\u8</code> 会导致本地搜索无法正常编码。</p>\n<p>（1）如果直接访问网站的本地搜索载体页（直接在首页网址后面接上 <code>/search.json</code>）如果能正常显示出很多文字就说明没有特殊字符：</p>\n<p><img data-src=\"./search_json_normal.png\" alt=\"正常的 search.json 样式\" title=\"@ASSET\"></p>\n<p>（2）否则会出现报错，由于我无法重现，因此从 <a href=\"https://www.sqlsec.com/2017/12/hexosearch.html\" title=\"@LINK\">这篇文章（作者：国光）</a>内找了一个图片：</p>\n<p><img data-src=\"./search_json_error.png\" alt=\"有特殊字符的 search.json 样式\" title=\"@ASSET\"></p>\n<blockquote>\n<p>Sublime Text3 和 VS Code 都可以看到这个字符，因此可以使用这两个编辑器查看并删除字符。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-3-不显示搜索结果\"><a href=\"#4-3-不显示搜索结果\" class=\"headerlink\" title=\"4.3 不显示搜索结果\"></a>4.3 不显示搜索结果</h3><p>如果已经开启搜索功能，直接进入搜索内容文件 <code>xxx.github.io/search.json</code> 也能打开并且没有异常，搜索框可以正确弹出，但是无论你搜索什么内容，下面的搜索结果栏都是空白的：</p>\n<p><img data-src=\"./search_error_no_result.png\" alt=\"搜索没有结果\" title=\"@ASSET\"></p>\n<p>这种情况很可能是因为某一篇文章没有标题。例如这个网站首页有一个置顶的通知栏，是通过设置 <code>header: false</code> 隐藏的标题，但在这篇文章依然需要设置 <code>title</code> 属性，否则就会导致无法搜索。</p>\n<hr>\n<h3 id=\"4-4-搜索框显示异常\"><a href=\"#4-4-搜索框显示异常\" class=\"headerlink\" title=\"4.4 搜索框显示异常\"></a>4.4 搜索框显示异常</h3><p>如果发现点击搜索后，博客页面有变暗的效果、但搜索框根本显示不出来也没有加载中的图标（Safari），或者能显示出来但无法获取焦点、无法输入文字（Chrome），就像这样：</p>\n<p><img data-src=\"./search_error_not_show.png\" alt=\"搜索框显示异常\" title=\"@ASSET\"></p>\n<p>出现这个情况的，很可能博客个性化比较丰富，很大可能是因为自己调整了博客整体的透明度，也就是修改了这个文件：<code>next/source/css/_custom/custom.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改主体透明度</span></span><br><span class=\"line\">.main-inner &#123;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改侧栏透明度</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网上有不少 DIY 的文章里面都有提到，给博客加了一个自定义的背景图片以后，为了让博客具有一定的半透明效果给整体设置一个透明度。</p>\n<p><strong>但是由于 Next 主题中，搜索是基于固定侧栏（也就是 header-inner）的一个弹窗 Popup，而 <code>opacity</code> 这个属性设置的是整个界面控件的不透明度，所以会导致弹窗的绘制在后，使得弹窗被覆盖在了博客显示界面的底下。</strong></p>\n<p>如果既想保留搜索功能还想要带点不透明度，可以换一个透明度方案，从直接设置控件的透明度改为给背景设置一个本身带有透明度的 ARGB 颜色：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意修改的是 header-inner 部分</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 后两位代表透明度</span></span><br><span class=\"line\">  background: #ddddddcc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-LaTeX转义问题\"><a href=\"#5-LaTeX转义问题\" class=\"headerlink\" title=\"5. LaTeX转义问题\"></a>5. LaTeX转义问题</h2><p>Hexo 的渲染引擎会自动转义部分特殊字符，但在 LaTeX 公式中这部分不应该被转义，问题详情可参考：<a href=\"https://segmentfault.com/a/1190000007261752\" title=\"@LINK\">Hexo下mathjax的转义问题</a>。</p>\n<p>目前网上普遍的做法是更换渲染引擎，老版本的 Hexo 尚不清楚，不过目前 <code>hexo: 3.9.0</code> <code>hexo-cli: 2.0.0</code> 原生渲染引擎 <code>hexo-renderer-marked</code> 已经支持 LaTeX 了，如果更换为 <code>hexo-renderer-kramed</code>，会遇到的一个很 X 蛋的事是和各种 Html 标签冲突，比如 <code>&lt;center&gt;</code> 之类的，甚至 MarkDown 的原生图片语法 <code>![]()</code> 都会被转义，通常还会建议修改渲染的语法，跳过指定的符号，因此可以直接修改默认的 <code>marked</code> 引擎的语法，默认在：<code>Blog/node_modules/marked/lib/marked.js</code>，如果有手动另外安装过 marked，则修改：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked/lib/marked.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inline = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//escape: /^\\\\([!&quot;#$%&amp;&#x27;()*+,\\-./:;&lt;=&gt;?@\\[\\]\\\\^_`&#123;|&#125;~])/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  <span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//em: /^_([^\\s_])_(?!_)|^\\*([^\\s*&lt;\\[])\\*(?!\\*)|^_([^\\s&lt;][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_&lt;][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s&lt;&quot;][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*&quot;&lt;\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>最新版本的 <a href=\"mailto:hexo-renderer-marked@2.0.0\">hexo-renderer-marked@2.0.0</a>^ 语法配置文件有修改，上述方法已不再适用，暂未找到修改方案，因此将 Marked 降级到了 0.7.0 版本。</p>\n</blockquote>\n","categories":["HexoDIY"],"tags":["Hexo","自定义","Low Severity Vulnerability","FontAwesome","Valine"]},{"title":"JVM内存模型和内存分区","url":"/post/java/java-jvm/","content":"<span id=\"more\"></span>\n\n<h1 id=\"JVM内存模型和内存分区\"><a href=\"#JVM内存模型和内存分区\" class=\"headerlink\" title=\"JVM内存模型和内存分区\"></a>JVM内存模型和内存分区</h1><p>前言：Java 和 Android 面试中，堆、栈、JVM 内存模型等几乎是必问题，但其实平时口头上，对堆、栈、堆栈、堆区、栈区、内存模型等等的概念是混淆的，因此专门用一篇文章来记录总结。</p>\n<hr>\n<h2 id=\"1-堆、栈和队列\"><a href=\"#1-堆、栈和队列\" class=\"headerlink\" title=\"1. 堆、栈和队列\"></a>1. 堆、栈和队列</h2><p>首先需要明确的是，堆、栈、队列是数据结构，堆是一种优先队列，可以采用二叉树实现；栈是一种线性表，其特点是：后进先出（Last In First Out，LIFO）；队列也是一种线性表，其特点是：先进先出（First In First Out，FIFO）。</p>\n<h3 id=\"1-1-堆（Heap）\"><a href=\"#1-1-堆（Heap）\" class=\"headerlink\" title=\"1.1 堆（Heap）\"></a>1.1 堆（Heap）</h3><p>堆（Heap）总是一颗完全二叉树，且某个节点的值总是不大于或不小于父节点的值。若某节点总是不大于父节点的值（即父节点大于等于子节点），称为最大堆或大根堆（Max Heap）；反之称为最小堆或小根堆（Min Heap）。常见的堆有：二叉堆、斐波那契堆等。</p>\n<blockquote>\n<p>完全二叉树可以这么理解：如果有一棵二叉树，只有最末端的节点可以有 0、1、2 个子节点，倒数第二层的节点要么没有子节点，要么必须有 2 个子节点，并且末端的节点都集中在左侧若干位置上，则该树称为完全二叉树。完全二叉树如下图所示：</p>\n</blockquote>\n<p><img data-src=\"./complete_binary_tree.jpg\" alt=\"完全二叉树图示\" title=\"@ASSET\"></p>\n<p>完全二叉树的详细解释可参考：<a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" title=\"@LINK\">《百度百科——完全二叉树》</a> 或 <a href=\"https://blog.csdn.net/qq_22642239/article/details/80774013\" title=\"@LINK\">《完美二叉树, 完全二叉树和完满二叉树》</a>。</p>\n<h3 id=\"1-2-栈（Stack）\"><a href=\"#1-2-栈（Stack）\" class=\"headerlink\" title=\"1.2 栈（Stack）\"></a>1.2 栈（Stack）</h3><p>栈（Stack）是一种运算受限的线性表，其限制在于：仅允许从表的一端进行插入和删除操作。插入到栈中（入栈）的操作叫压栈（Push），从栈中删除（出栈）的操作叫弹出（Pop）。后入栈的数据先出栈（LIFO），类似于枪械弹匣，最后一颗压进弹匣的子弹在最上面，是第一发被打出去的。</p>\n<h3 id=\"1-3-队列（Queue）\"><a href=\"#1-3-队列（Queue）\" class=\"headerlink\" title=\"1.3 队列（Queue）\"></a>1.3 队列（Queue）</h3><p>队列（Queue）和栈类似，都是线性表，不同的是数据存取的顺序。队列中插入数据和取出数据分别在表的两端，且先插入的数据最先被取出。</p>\n<hr>\n<h2 id=\"2-JVM内存模型\"><a href=\"#2-JVM内存模型\" class=\"headerlink\" title=\"2. JVM内存模型\"></a>2. JVM内存模型</h2><p>首先需要强调一点：<strong>JVM 的内存模型和 JVM 的内存分区（内存结构）不是一回事</strong>！</p>\n<p>JVM 内存模型描述了 Java 程序各类型变量的访问规则，以及在 JVM 中将变量从内存中存储或读取的底层标准。</p>\n<p>JVM 内存模型有两个重要准则：</p>\n<ul>\n<li>所有的变量都存储在主内存中。</li>\n<li>每个线程都有自己的工作内存，里面保存了该线程使用到的变量在主内存中的一个副本。</li>\n</ul>\n<p>并且 JVM 的内存模型还规定：</p>\n<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n<p>为了在多个线程访问同一个共享变量时，能保证共享变量具有实时性，JVM 内存模型还遵循：缓存一致性协议。该协议规定，如果一个线程将共享变量回写进主内存，该动作会导致其他线程中的该共享变量的 Cache 失效，但线程在修改完一个共享变量时，并不一定会马上将其回写进主内存，而 <code>volatile</code> 修饰符即是用来声明，一个变量在被修改（写入）后，立即回写进主内存，并更新到其他线程中。</p>\n<p>可参考：<a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"TOLINSK\">什么是Java内存模型</a></p>\n<hr>\n<h2 id=\"3-JVM中的5个区\"><a href=\"#3-JVM中的5个区\" class=\"headerlink\" title=\"3. JVM中的5个区\"></a>3. JVM中的5个区</h2><p>在 JDK 1.8（不含）之前，JVM 的内存分为 5 个区：堆区、栈区、方法区、本地方法区、程序计数器。</p>\n<p>堆区（Heap）和栈区（Stack）是内存模型，虽然英文一样，而且也常常被简称为堆和栈，但实际上他们和数据结构中的堆、栈是完全不一样的概念，底层也并不是直接使用数据结构中的堆和栈的存储方式来实现，只是比较类似。</p>\n<p>堆区是存储的单位，而栈区是运行时的单位。通俗地说：堆区解决程序数据存储的问题，负责管理数据怎么放、放在哪；而栈区解决程序运行的问题，负责管理程序怎么运行、怎么处理堆中的数据。</p>\n<h3 id=\"3-1-堆区（Heap-Area）\"><a href=\"#3-1-堆区（Heap-Area）\" class=\"headerlink\" title=\"3.1 堆区（Heap Area）\"></a>3.1 堆区（Heap Area）</h3><p>堆区通常和进程相关，进程建立初始化时会分配默认堆区，运行过程中也可以申请额外的堆区空间，但在需要手动释放，否则会导致内存泄漏，未释放的内存在进程结束时由 OS 回收。堆区分为全局堆和局部堆，全局堆就是所有未分配的堆区空间，局部堆则是用户分配的堆区空间。多个线程可以访问同一个堆区，当然也可以申请额外的堆区空间。</p>\n<p>在 Android 中，堆是 Dalvik 的内存数据区，用于存储：对象实例数据、方法内部的复杂类型变量、动态属性。</p>\n<ul>\n<li>对象实例数据：包括对象实例的属性、属性类型、对象本身的类型标记等，但是并不会保存对象实例的方法（类方法），实例方法属于数据指令，保存在方法区中。</li>\n<li>方法内部的复杂类型变量：例如方法内使用了自定义类的实例对象等。</li>\n<li>动态属性：没有使用 <code>static</code> 修饰的类成员属性，因为这些属性可能是自定义类的实例对象，这些对象的内存大小是不可预估、动态变化的。需要注意的是，类成员的基本数据类型，也是存放在堆中。</li>\n</ul>\n<p>堆区的内存是不连续且无序的，分配和释放内存的成本都比较高。例如在分配堆内存时，可能需要在堆区搜索多个空间，如果内存碎片（多次分配和释放后，会造成占用内存和可用内存互相掺杂）太多，则会消耗较长时间来搜索可用内存区，甚至需要向 OS 申请分配新的堆区空间，因此堆区的效率较低，但是内存分配更加自由，内存的分配和释放可以手动控制。</p>\n<blockquote>\n<p>实际上，如果 JVM 开启了 <strong>逃逸分析（Escape Analysis）</strong>，会在满足一定条件时，将本应存在堆区中的变量存在栈区，便于内存的释放。例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本来，<code>demoClass.demoData</code> 虽然是基本数据类型 int，但由于它是一个类成员动态属性，因此随所属对象 <code>demoClass</code> 被分配在堆区。如果 JVM 开启了逃逸分析，则优化后会将该段代码转换为如下的形式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> demoData = <span class=\"number\">5</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就将 <code>demoData</code> 存在了栈区，提高了内存分配和回收的效率。但是逃逸分析优化有一定的前提：原本存在堆区的对象，仅在方法体内部有效。如果该对象与方法体外部有交互（即逃逸），则不会优化。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> demoClass.demoData;  <span class=\"comment\">// 逃逸到外部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，堆区本身又有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n<h3 id=\"3-2-栈区（Stack-Area）\"><a href=\"#3-2-栈区（Stack-Area）\" class=\"headerlink\" title=\"3.2 栈区（Stack Area）\"></a>3.2 栈区（Stack Area）</h3><p>栈区和线程相关，每个线程有自己独立的栈区且不共享，因此栈区是线程安全的。OS 在切换线程时会自动切换栈区（即切换 SS / ESP 寄存器）。栈区内存不需要手动分配和释放。</p>\n<p>在 Android 中，栈是 Dalvik 的内存指令区，用于存储：基本数据类型、方法内部的简单类型变量、对象地址。</p>\n<ul>\n<li>基本数据类型：包括 byte，short，int，long，float，double，char，boolean，需要注意的是，直接在类成员变量中声明的基本数据类型属性，依然随对象实例一起存放在堆中。</li>\n<li>方法内部的简单类型变量：例如基本数据类型。</li>\n<li>对象地址：通常大多数对象都会存在堆区中，而把对象的引用（即对应在堆中的地址）存在栈区，当调用一个对象时，就可以快速地从栈区找到该对象的引用，并通过引用找到堆区中的实例。</li>\n</ul>\n<p>栈区存放的是多个栈帧，每个栈帧对应了可以被线程调用的一个方法，栈帧中包括：局部变量表（Local Variables）、操作数栈（Operand Stack）、指向当前方法所属类的运行时常量池的引用（Reference to Runtime Constant Pool，当方法内有 String 类型变量时，用于查询常量池中是否已经存在常量）、方法返回地址（Return Address）、以及一些额外的附加信息。当线程执行一个方法时，就会创建对应的栈帧，并将其压栈。方法执行完毕后即弹出。因此，线程当前执行的方法一定在栈区的顶部，而递归方法时，也相对更容易出现栈区内存溢出的情况。</p>\n<p>由于栈区中存储的都是内存占用较小，且固定长度的变量，例如基本数据类型、对象的引用（仅仅只是一个地址，通常为 4 位，指向堆区或常量池中实际存放的对象），因此栈区的内存是连续、且在创建栈帧时就提前分配好的，所以栈区的内存不需要也无法手动管理，当调用所需变量时，仅需将指针按预定义的长度移动即可，因此分配和释放内存的效率都比堆区快得多。</p>\n<blockquote>\n<p>Java 中，对于 byte、short、char 这些基本数据类型，本来比 int 占用的内存更少，对一些标志位、临时变量等，使用这些代替 int 似乎应该效率更高，实际上 JVM 中，在处理这些数据的加法操作时，会先隐式转换成 int 类型再操作。例如以下代码会编译报错：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> c = a + b;  <span class=\"comment\">// 编译报错：Type mismatch: cannot convert from int to byte</span></span><br></pre></td></tr></table></figure>\n\n<p>这么做的意义其实是在于，Java 中 int 和 float 是 4 字节 32 位，long 和 double 是 8 字节 64 位，这些类型都能以 4 字节为单位，位移 1 倍或 2 倍得到，而 byte、short、char 分别只有 1、2、2 字节，如果先统一转为 4 字节 int 类型，寻址的时候就能极大提高效率。当然选择 int 作为标准的原因主要也是因为 int 的长度在中间，如果选择 8 字节的 long 或 double，则会大量浪费内存空间，选择 2 字节的 char 或 short，则很多变量都需要不止一个内存块来存储，降低效率。</p>\n<h3 id=\"3-3-方法区（Method-Area）\"><a href=\"#3-3-方法区（Method-Area）\" class=\"headerlink\" title=\"3.3 方法区（Method Area）\"></a>3.3 方法区（Method Area）</h3><p>方法区和堆一样，是线程间共享的。方法区用于存放：类的信息、静态成员变量、运行时常量池等。</p>\n<ul>\n<li>类的信息：包括类名、方法信息、字段信息等，调用 <code>Class.getName()</code> 和 <code>Class.isInterface</code> 等方法时返回的数据都是来自方法区。</li>\n<li>静态成员变量：Java 局部变量没有静态的概念，只有成员变量、成员方法可以设置为静态。</li>\n<li>运行时常量池：类和接口被记载到 JVM 时，就会创建对应的运行时常量池。</li>\n</ul>\n<p>不论是否静态，方法都存放在方法区，非静态的方法，Dalvik 会将其对象实例在 Stack 中的引用地址（指向了 Heap 中存储的实例），作为隐含的参数传入，这样在非静态方法在需要调用其实例对象的其他数据时，可以确保总能找到在 Heap 中存放的实例数据。因此，调用一个非静态方法，必须首先 new 一个实例对象，也即创建一个实例对象在 Stack 中的引用地址，然后再调用。而静态方法不需要传入隐含参数，因为方法区是线程间公开共享的，而且存放的都是相对唯一、不变的数据，因此静态方法可以直接通过 <code>Class.method()</code> 的形式调用。当然，由于没有传入隐含的 Stack 引用地址，也就无法找到 Heap 中存放的实例数据，静态方法内部是无法获取到实例对象的其他非静态数据的，这也是为什么静态方法中不能调用非静态方法、非静态成员变量，而非静态方法可以直接调用静态方法、静态成员变量的原因。</p>\n<p>静态成员变量只在 JVM 第一次载入类时加载，也因此内存中只会保留一份数据，因此也是存放在方法区中的，这也是为什么作用域比较小、使用频率比较低的一些标志位等等不建议设置成 <code>public static</code> 的形式，因为这会导致很多临时才使用的变量被加载进了方法区而不释放（JDK 1.7 之后在满足一定条件下，方法区也会 GC，但是相比栈区和堆区，方法区 GC 的频率很低，因此仍然不建议大量使用静态成员变量）。</p>\n<p>运行时常量池并不一定质保函 Class 文件常量池中的内容，也即并非只有代码中显示定义了 <code>final</code> 的成员变量才会进入常量池。例如 <code>String.intern()</code> 方法，其作用就是：如果一个字符串存在常量池中，则直接返回常量池中的引用，否则将该字符串存入常量池，再返回其引用。</p>\n<p>常量池的意义非常重要，之所以 String 内部都要做成常量，主要是因为字符串的重复率特别高，因此如果字符串不可变，常量池才便于管理。而且由于 String 的不可变性，HashMap、HashTable 等使用 String 作为 Key 时，JVM 可以在缓存 String 对象时缓存其 HashCode，极大提高执行效率。</p>\n<p>在 JDK 1.8 以前，HotSpot 虚拟机的方法区是用永久代实现的，<strong>但方法区同样有可能发生 OOM！</strong> 因为方法区的内存是固定，因此如果频繁调用 <code>String.intern()</code> 方法，或者一次性加载太多类，仍然会导致OOM。JDK 1.8 之后，虽然用元数据取代了方法区，直接使用本地内存，支持扩容，也取消了永久代，但并不是无限扩容的，所以仍然有可能，只是几率会小一些。</p>\n<h3 id=\"3-4-本地方法栈（Native-Method-Stack）\"><a href=\"#3-4-本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"3.4 本地方法栈（Native Method Stack）\"></a>3.4 本地方法栈（Native Method Stack）</h3><p>本地方法区和方法栈（也即栈区）比较类似，区别在于栈区是针对普通方法的，而本地方法栈是针对 Native 方法的。JVM 规范中没有强行规定本地方法栈的实现方式和数据结构，虚拟机可以自由实现，HotSpot 虚拟机就直接把栈区和本地方法栈合二为一。</p>\n<h3 id=\"3-5-程序计数器（Program-Counter-Register）\"><a href=\"#3-5-程序计数器（Program-Counter-Register）\" class=\"headerlink\" title=\"3.5 程序计数器（Program Counter Register）\"></a>3.5 程序计数器（Program Counter Register）</h3><p>JVM 中的程序计数器和汇编中的程序计数器（CPU 中的寄存器）概念类似，都是用于指示下一条需要执行的指令，只不过 JVM 中的程序计数器并不是指向物理意义上的真实 CPU 内存地址。JVM 中的程序计数器是线程独有的，指向的是当前线程正在执行的字节码代码的行号，如果当前线程执行的是 Native 方法，则值为 <code>null</code>。</p>\n<hr>\n<h2 id=\"4-JVM中的4个Segment\"><a href=\"#4-JVM中的4个Segment\" class=\"headerlink\" title=\"4. JVM中的4个Segment\"></a>4. JVM中的4个Segment</h2><p>如果在网上查阅 JVM 分区的内容，会出现两种回答：</p>\n<ol>\n<li>JVM 内存模型分为 4 个区：Heap、Stack、Data Segment、Code Segment</li>\n<li>JVM 内存模型分为 5 个区：Heap、Stack、Method、Native Method、Program Counter Register</li>\n</ol>\n<p>其实这两种分法都对，只不过是针对不同的场景分的，个人认为分为 5 个区的更加全面一些。两种分类中，Heap 和 Stack 都是一一对应的，关键是其他部分，方法区是一个特例。在 HotSpot 虚拟机中，由于早期（JDK 1.8（不含）之前）是直接将方法区设置为永久代（Permanent Generation），也即方法区内的所有数据都不会被 GC，因此方法区也被习惯称为永久代。而方法区同时对应了 Data Segment 和 Code Segment，方法区中存储字节码的位置称为 代码段（Code Segment），存储静态常量和字符串常量的位置称为数据段（Data Segment）。</p>\n<hr>\n<h2 id=\"5-JDK8内存分区的变化\"><a href=\"#5-JDK8内存分区的变化\" class=\"headerlink\" title=\"5. JDK8内存分区的变化\"></a>5. JDK8内存分区的变化</h2><p>在 JDK 1.8 中，对之前 5 个内存区的划分做了一些改变。</p>\n<p>首先是使用 <strong>元数据区</strong> 取代了方法区，但实际上元数据区的作用和原来方法区的作用是几乎一样的，只不过不再是永久代（针对 HotSpot 虚拟机，其他虚拟机例如 Oracle 的 JRockit 和 IDM 的 J9 本来就没有永久代）。</p>\n<p>其次，元数据区不再存放在虚拟机内存中了，而是直接使用本地内存（由 OS 管理的内存）。</p>\n<p>另外，原来的字符串常量池存放在方法区中，新版 JDK 放到了堆区。</p>\n<hr>\n<h2 id=\"附录-参考指导\"><a href=\"#附录-参考指导\" class=\"headerlink\" title=\"附录[参考指导]\"></a>附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"TOLINSK\">【1】什么是Java内存模型（作者：占小狼）</a></li>\n</ul>\n</blockquote>\n","categories":["Java"],"tags":["Java","数据结构","内存模型","JVM内存区"]},{"title":"Linux-IO的阻塞和非阻塞","url":"/post/linux/linux-io_block/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Linux-IO的阻塞和非阻塞\"><a href=\"#Linux-IO的阻塞和非阻塞\" class=\"headerlink\" title=\"Linux-IO的阻塞和非阻塞\"></a>Linux-IO的阻塞和非阻塞</h1><p>通常，对于进程间的通信有两对常见的概念：同步和异步、阻塞和非阻塞，但实际上对于通信过程中的发送进程和接收进程而言，这两对概念是同义词，只有站在一个完整的进程间通信流程的角度，才会具有不同性质。</p>\n<h2 id=\"1-同步异步及阻塞非阻塞\"><a href=\"#1-同步异步及阻塞非阻塞\" class=\"headerlink\" title=\"1. 同步异步及阻塞非阻塞\"></a>1. 同步异步及阻塞非阻塞</h2><p>从《操作系统概念》中节选出有关进程通信的部分：</p>\n<blockquote>\n<p>3.4.2.2 Synchronization</p>\n<p>Communication between processes takes place through calls to send() and receive() primitives. There are different design options for implementing each primitive. Message passing may be either <strong>blocking</strong> or <strong>nonblocking</strong> – also known as <strong>synchronous</strong> and <strong>asynchronous</strong>. (Throughout this text, you will encounter the concepts of synchronous and asynchronous behavior in relation to various operating-system algorithms.)</p>\n<ul>\n<li>Blocking send. The sending process is blocked until the message is received by the receiving process or by the mailbox.</li>\n<li>Nonblocking send. The sending process sends the message and resumes operation.</li>\n<li>Blocking receive. The receiver blocks until a message is available.</li>\n<li>Nonblocking receive. The receiver retrieves either a valid message or a null.</li>\n</ul>\n<p>Different combinations of send() and receive() are possible. When both send() and receive() are blocking, we have a rendezvous between the sender and the receiver. The solution to the producer-consumer problem becomes trivial when we use blocking send() and receive() statements. The producer merely invokes the blocking send() call and waits until the message is delivered to either the receiver or the mailbox. Likewise, when the consumer invokes receive(), it blocks until a message is available. This is illustrated in Figures 3.15 and 3.16.</p>\n</blockquote>\n<p>大致含义为：</p>\n<p>进程间通信通过 <code>send()</code> 发送和 <code>receive()</code> 接收两种操作完成，这两种操作可能存在多种实现方案。消息在进程间传递时有可能是 <strong>阻塞</strong> 或 <strong>非阻塞</strong> 的，也被称为 <strong>同步</strong> 和 <strong>异步</strong>。</p>\n<ul>\n<li>Blocking Send 阻塞发送：发送方发送消息后将一直阻塞，直到接收方收到消息。</li>\n<li>Nonblocking Send 非阻塞发送：发送方将消息发出后就处理其他任务，不论消息是否被接收方收到。</li>\n<li>Blocking Receive 阻塞接收：接收方调用 <code>receive()</code> 后将一直阻塞，直到收到一条可用消息。</li>\n<li>Nonblocking Receive 非阻塞接收：接收方调用 <code>receive()</code> 后将立即获得一条可用消息，或是一个空值，而不会阻塞。</li>\n</ul>\n<p>因此进程间通信时，站在进程的角度是对「发送方 / 接收方」与「阻塞 / 非阻塞」的自由组合，而「阻塞 / 非阻塞」与「同步 / 异步」是同义词。</p>\n<hr>\n<h2 id=\"2-进程切换\"><a href=\"#2-进程切换\" class=\"headerlink\" title=\"2. 进程切换\"></a>2. 进程切换</h2><p>当 Linux 从一个进程切换到另一个进程时通常包含一下几个步骤：</p>\n<ul>\n<li>对于运行中的进程，<strong>中断（Interrupt）</strong> 或 <strong>系统调用（System Call）</strong> 都可以将 CPU 的控制转移到内核。<ul>\n<li>中断（Interrupt）：CPU 有一个中断信号位，CPU 在每个时钟周期的末尾都会检测中断信号位是否有中断信号到达，如果有则会根据中断的优先级决定是否要暂停当前执行的指令，转而去执行处理中断的指令。</li>\n<li>时钟中断（Clock Interrupt）：一个硬件时钟每隔一段时间就会向 CPU 发送一个中断信号，CPU 在响应这个中断时就会去执行操作系统内核的指令，继而将 CPU 的控制转移给了内核，由内核决定下一个要被执行的指令。</li>\n<li>系统调用（System Call）：操作系统提供给应用程序的接口。用户态通过 System Call 来完成那些需要内核才能执行的操作，例如硬盘、网络接口设备的 IO 等。</li>\n</ul>\n</li>\n<li>内核会将原进程在 CPU 中的上下文（程序计数器、寄存器等）信息保存在分配给该进程的内存区域 PCB 中。</li>\n<li>内核从另一个进程的 PCB 中取出其上下文信息，将 CPU 的控制转移给新进程，开始执行新进程的指令。</li>\n</ul>\n<p>当 CPU 在进程间切换时，由于需要在用户态和内核态之间切换，并且需要对进程的 PCB 做读写，所以会带来一定的开销，对于运行着 Unix 系统的现代 PC 而言，进程切换通常至少需要花费 300 us。</p>\n<p>因此，当进程间需要通信时，CPU 需要一定的时间做数据的 IO 和进程切换，并且由于进程间内存默认不可共享，所以往往还伴随着数据的拷贝，这就导致发送进程和接收进程在这段等待时间内可以有不同的策略，也即是否阻塞。</p>\n<hr>\n<h2 id=\"3-进程间通信的模型\"><a href=\"#3-进程间通信的模型\" class=\"headerlink\" title=\"3. 进程间通信的模型\"></a>3. 进程间通信的模型</h2><p>在实际的进程间通信案例中，阻塞通信会使得进程的执行是顺序的，开发人员可以预知进程的执行情况。而非阻塞通信则可以提高 CPU 的利用率，换言之也就是提高性能。但在实际的进程间通信过程中，通常会考虑一个完整的进程间通信流程，此时「阻塞 / 非阻塞」更多是指通信过程中数据的流动，才会与「同步 / 异步」搭配定义。</p>\n<p>但是需要明确，「同步」一定意味着「阻塞」，反之「阻塞」也一定意味着「同步」，「异步」一定意味着「非阻塞」，但「非阻塞」不一定「异步」，根据进程的执行策略而有所区别。</p>\n<h3 id=\"3-1-同步阻塞BIO\"><a href=\"#3-1-同步阻塞BIO\" class=\"headerlink\" title=\"3.1 同步阻塞BIO\"></a>3.1 同步阻塞BIO</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 挂起，等待内核将消息发送给 B，处理完后内核重新唤醒 A，A 再将返回的数据从内核拷贝到进程内。</p>\n<ul>\n<li>A 在发送数据后挂起等待 B 接收数据，这个过程是阻塞的。</li>\n<li>B 成功接收数据后，A 继续挂起等待 B 处理数据完成，这个过程也是阻塞的。</li>\n<li>B 处理完成返回数据后，内核唤醒 A，A 仍然需要等待从内核将数据拷贝回用户进程，这个过程也是阻塞的。</li>\n</ul>\n<p>由于整个过程中，A 都处于阻塞状态，直到被唤醒后执行吓一条指令，所以从整个通信过程来看也是同步的。</p>\n<h3 id=\"3-2-同步非阻塞NIO\"><a href=\"#3-2-同步非阻塞NIO\" class=\"headerlink\" title=\"3.2 同步非阻塞NIO\"></a>3.2 同步非阻塞NIO</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 立即执行其他指令，但每个一段时间就会主动发起请求，查询 B 是否成功接收数据，以及是否处理完毕返回数据，如果有返回数据，则继续执行原来的指令，并将数据从内核拷贝到进程内。</p>\n<ul>\n<li>A 发送数据后立即执行其他指令，不论 B 是否成功接收数据，这个过程是非阻塞的。</li>\n<li>A 周期性请求内核，查询 B 是否成功接收数据，以及是否在执行完毕后返回了数据，这个过程是非阻塞的。</li>\n<li>B 成功接收数据后，将状态同步给内核。B 处理完成返回后，将数据拷贝到内核空间，A 查询到后，再将返回的数据从内核拷贝到 A 进程中，这个过程是阻塞的。</li>\n</ul>\n<p>由于 B 返回数据后，A 需要从内核拷贝数据，这个过程仍然是阻塞的，所以从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-3-同步信号驱动\"><a href=\"#3-3-同步信号驱动\" class=\"headerlink\" title=\"3.3 同步信号驱动\"></a>3.3 同步信号驱动</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 立即执行其他指令，直到 B 处理完毕并返回数据后，由内核通知进程 A，然后 A 再从内核将数据拷贝到进程内。</p>\n<ul>\n<li>A 发送数据后立即执行其他指令，不论 B 是否成功接收，这个过程是非阻塞的。</li>\n<li>B 处理完并返回数据后，内核通知 A，这个过程是非阻塞的。</li>\n<li>A 从内核中拷贝数据到进程内，这个过程是阻塞的。</li>\n</ul>\n<p>虽然信号驱动模型不再需要 A 频繁主动查询 B 的数据返回状态，但由于最终仍然需要将数据从内核拷贝到 A 进程，这个过程依然是阻塞的，所以从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-4-同步IO多路复用\"><a href=\"#3-4-同步IO多路复用\" class=\"headerlink\" title=\"3.4 同步IO多路复用\"></a>3.4 同步IO多路复用</h3><p>多个发送进程向同一个管道注册，由管道完成和内核的交互。当一个进程通过 <code>select</code> 函数从管道获取数据时，如果所有被监听的 IO 的数据都没有准备好，则调用 <code>select</code> 的当前进程会进入阻塞状态，直到「任意一个」被监听的 IO 数据已准备好并返回，然后通知对应的监听进程，监听进程再从内核中将数据拷贝到进程内。</p>\n<p>由于 IO 多路复用在调用 <code>select</code> 时会进入阻塞状态，并且监听进程在收到数据已准备好的通知后，仍需从内核拷贝数据到进程内，因此从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-5-异步非阻塞AIO\"><a href=\"#3-5-异步非阻塞AIO\" class=\"headerlink\" title=\"3.5 异步非阻塞AIO\"></a>3.5 异步非阻塞AIO</h3><p>进程 A 发起一个 <code>aio_read</code> 指令，将自己的「描述符」、「缓冲区指针」、「缓冲区大小」、「回调函数 / 回调信号」信息发送给内核，内核 <code>aio_read</code> 指令会立即返回，进程 A 即可执行其他指令。当 A 指令所需的数据准备好后，再由内核负责把数据拷贝到 A 的用户内存，然后再通过回调信号或基于线程的回调的方式，通知进程 A，此时 A 已经可以直接操作所需数据而不需要拷贝，是真正的异步 IO。</p>\n<hr>\n<h2 id=\"4-Java中的IO\"><a href=\"#4-Java中的IO\" class=\"headerlink\" title=\"4. Java中的IO\"></a>4. Java中的IO</h2><h3 id=\"4-1-BIO\"><a href=\"#4-1-BIO\" class=\"headerlink\" title=\"4.1 BIO\"></a>4.1 BIO</h3><p>BIO 面向「流」<code>Stream</code>，<code>Stream</code> 只能单项传输，Java 中对应的就是输入流 <code>InputStream</code> 和输出流 <code>OutputStream</code>。最普通的 Socket 和 ServerSocket 就基于 BIO，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketBIO</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Server</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startService();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 Client</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startClient();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定 8888 端口，最大同时连接数为 5，超出的请求会被拒绝。</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接受一个连接，accept 是阻塞的</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket client = serverSocket.accept()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从客户端读取数据</span></span><br><span class=\"line\">                BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readLength = bufferedReader.read();</span><br><span class=\"line\">                bufferedReader.close();</span><br><span class=\"line\">                <span class=\"comment\">// 向客户端发送数据</span></span><br><span class=\"line\">                BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">                bufferedWriter.write(<span class=\"string\">&quot;Output Content&quot;</span>);</span><br><span class=\"line\">                bufferedWriter.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 连接本地 8888 端口。</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从服务端读取数据</span></span><br><span class=\"line\">                BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readLength = bufferedReader.read();</span><br><span class=\"line\">                bufferedReader.close();</span><br><span class=\"line\">                <span class=\"comment\">// 向服务端写入数据</span></span><br><span class=\"line\">                BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">                bufferedWriter.write(<span class=\"string\">&quot;Output Content&quot;</span>);</span><br><span class=\"line\">                bufferedWriter.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然上例中 Socket 和 ServerSocket 都用了 <code>BufferedWriter</code> 和 <code>BufferedReader</code>，但 Socket 本身提供的是输入流和输出流 <code>client#getXXXStream</code>，只是业务上再封装了一层 Buffer，所以 BIO 本质上是「流式传输」。</p>\n<h3 id=\"4-2-NIO\"><a href=\"#4-2-NIO\" class=\"headerlink\" title=\"4.2 NIO\"></a>4.2 NIO</h3><p>NIO 面向「通道」<code>Channel</code>，<code>Channel</code> 支持双向传输，Java 中常见的 Channel 有：</p>\n<ul>\n<li><code>FileChannel</code></li>\n<li><code>DatagramChannel</code></li>\n<li><code>SocketChannel</code></li>\n<li><code>ServerSocketChannel</code></li>\n</ul>\n<p><code>Channel</code> 只是一种双向通信模型，因此通常搭配 <code>Buffer</code> 一起使用，由 <code>Buffer</code> 充当实际数据的载体，Java 中常见的 Buffer 有：</p>\n<ul>\n<li><code>ByteBuffer</code></li>\n<li><code>CharBuffer</code></li>\n<li><code>ShortBuffer</code></li>\n<li><code>IntBuffer</code></li>\n<li><code>FloatBuffer</code></li>\n<li><code>LongBuffer</code></li>\n<li><code>DoubleBuffer</code></li>\n</ul>\n<p>SocketChannel 和 ServerSocketChannel 就基于 NIO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketNIO</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启 Server</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                startService();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 开启 Client</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            startClient();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定本地 8888 端口，最大同时连接数 5，超出后连接将被拒绝。</span></span><br><span class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8888</span>), <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置 accept 时为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接受一个客户端连接</span></span><br><span class=\"line\">            SocketChannel clientChannel = serverSocketChannel.accept();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clientChannel == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由于 serverSocketChannel.configureBlocking(false) 使得 accept 变为非阻塞，</span></span><br><span class=\"line\">                <span class=\"comment\">// 因此需要对 accept 返回的 SocketChannel 判空，为空说明没有客户端连接，可以执行其他指令。</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 用 ByteBuffer 缓冲读取字节数据，缓冲区大小设置为 48 字节，</span></span><br><span class=\"line\">            <span class=\"comment\">// Buffer 默认的起始指针 start 和当前指针 current 指向 0 下标，终止指针 limit 指向末位，</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示接下来的操作从 start 开始，当 current 指向 limit 时说明 Buffer 存满了。</span></span><br><span class=\"line\">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从通道中读取字节数据并写入缓冲区，此时对 Buffer 的操作是「写入」，</span></span><br><span class=\"line\">            <span class=\"comment\">// 每次都向 Buffer 的 current 指向的位写入一个字节，并把 current 指向下一位。</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> readLength = clientChannel.read(byteBuffer);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (readLength &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果原本 Buffer 用于「写入」，则需要「读取」之前需要先将 Buffer 翻转，</span></span><br><span class=\"line\">                <span class=\"comment\">// 使得新 start 指向原 current，新 limit 指向原 start，</span></span><br><span class=\"line\">                <span class=\"comment\">// 表示接下来的操作从 Buffer 原先的 current 位置开始反向进行。</span></span><br><span class=\"line\">                byteBuffer.flip();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Read: &quot;</span> + byteBuffer.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重置 Buffer 的 start 和 current 到 0 下标，limit 到末位，</span></span><br><span class=\"line\">                <span class=\"comment\">// 相当于标记这个 Buffer 又可以从头重新操作。</span></span><br><span class=\"line\">                byteBuffer.clear();</span><br><span class=\"line\">                <span class=\"comment\">// 继续从通道中读取数据，直到通道中没有数据为止。</span></span><br><span class=\"line\">                readLength = clientChannel.read(byteBuffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启通道</span></span><br><span class=\"line\">        SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 连接到本地 8888 端口。</span></span><br><span class=\"line\">        clientChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置缓冲区大小 48 字节。</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向 Buffer 写入数据</span></span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">&quot;Output Content&quot;</span>.getBytes());</span><br><span class=\"line\">        <span class=\"comment\">// 为了读取 Buffer 中的数据并通过 Socket 发送，需要先翻转 Buffer</span></span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            clientChannel.write(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/19732473/answer/241673170\" title=\"@LINK\">IO 概念区分（作者：萧萧）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zMGt19ae0UP7NhNhBX7QUw\" title=\"@LINK\">漫话：如何给女朋友解释什么是Linux的五种IO模型？（作者：漫话编程）</a></li>\n<li><a href=\"https://blog.csdn.net/m0_38109046/article/details/89449305\" title=\"@LINK\">ava面试常考的 BIO，NIO，AIO 总结（作者：有梦想的小树）</a></li>\n<li><a href=\"https://blog.csdn.net/oMaoYanEr/article/details/79976359\" title=\"@LINK\">Java NIO总结（一）：Channel、Buffer、Selector（作者：冒烟儿）</a></li>\n<li><a href=\"https://blog.csdn.net/u013096088/article/details/78638245\" title=\"@LINK\">Java NIO学习笔记二（Buffer的flip()方法详解）（作者：拿笔小星_）</a></li>\n<li><a href=\"https://blog.csdn.net/he_jiawang/article/details/84792619\" title=\"@LINK\">Java——SocketChannel（作者：赫家旺）</a></li>\n</ul>\n","categories":["Linux"],"tags":["Linux","IO","同步","异步","阻塞","非阻塞"]},{"title":"Linux云服务器远程任务随笔","url":"/post/note/note-cloud-server/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Linux云服务器远程任务随笔\"><a href=\"#Linux云服务器远程任务随笔\" class=\"headerlink\" title=\"Linux云服务器远程任务随笔\"></a>Linux云服务器远程任务随笔</h1><p>前言：由于本地设备的性能限制，通常一些大型科学计算都会用到云服务器来解决算力问题。不过在使用过程中遇到了不少问题比如内存不够、断连、jupyter notebook 启动失败等，都将记录在本文。</p>\n<hr>\n<h2 id=\"1-云服务器的选择\"><a href=\"#1-云服务器的选择\" class=\"headerlink\" title=\"1. 云服务器的选择\"></a>1. 云服务器的选择</h2><p>国内比较知名的几个云服务器大概有：腾讯云、阿里云、百度云、华为云，还有比较知名的亚马逊和谷歌，但总觉得有点水土不服。其他的一些云服务器我也没有每个都探索一遍，如果发现有更实惠的选择再更新进来吧。</p>\n<p>先说说这四个国内云服务器给我的第一感吧。总体来说，BAT 三家云服务器还是让我感觉到了作为国内互联网三巨头的一股气势，单从我个人感受而言，似乎给我一种“你爱用就用”的态度，当然，文档详尽、自定义性高等各方面条件都是相当优秀的，不过在用户引导这个方面仍然感觉略有不足，其中腾讯云要稍微好一些，阿里次之，当然我不是有意黑百度。最开始我已经准备入坑阿里云，资料、认证都已经完成，但是在选配置的时候遇到一个很尴尬的问题：阿里云的按需计费模式，需要预充 50 元以上，但是对于首次使用的我来说，我其实只是想花个几块钱，就用一个小时尝试一下预期配置的效果，尽管四大云都提供了免费试用，但免费提供的服务器配置并达不到我的要求，所以基于这一点，我 Pass 了阿里云（当然我认为就服务器整体实力而言，阿里云应是最强的）。如果要长期使用并且对维护要求比较高的，我个人还是更推荐阿里云一些，可能质量上而言这几个服务器差别都不会太大，但是阿里云的应用量是远超其他几个云的，从服务案例、维护参考等角度出发，使用阿里云，至少出了问题你能在网上搜到最多的答案。</p>\n<p>第二次我搜索云服务器的时候，度娘给我推荐的第一条搜索结果居然是 <strong>华为云</strong>，抱着试试看的心态点进去看了看，惊喜的发现：华为云按需计费是不需要预充金额（其他两家没有尝试）的！这直接导致了我后续选择华为云作为服务器的结果。</p>\n<p>说完第一感，再来浅略谈谈这几个云服务器的选择。首先，腾讯云和百度云是没有 <strong>ECS 弹性云服务器</strong> 这么个独立选项的，最后在腾讯找到了 <em>云服务器 CVM</em>，在百度找到了 <em>云服务器 BCC</em>，看起来跟配置 ECS 差不多，也就权当是不同叫法了。此外，还有一点需要提一下，只有阿里云里面选择配置的时候，是有详细配置参数的，包括 CPU 主频等：</p>\n<p><img data-src=\"./ali_ecs_detail.png\" alt=\"阿里云详细配置参数\" title=\"@ASSET\"></p>\n<p>而且整体配置选择界面一目了然，各种搭配方案覆盖面也很广，用起来给我个人感觉是最好的。其次是华为云，虽然没有标出主频参数，但至少还能看出 CPU 的规格信息，还能直接搜出来具体的参数：</p>\n<p><img data-src=\"./huawei_ecs_detail.png\" alt=\"华为云详细配置参数\" title=\"@ASSET\"></p>\n<p>其他两家就差了一些，只告诉我这是几核的，配多大内存，虽然也对 CPU 根据用途做了分类，但终归不直观：</p>\n<p><img data-src=\"./other_ecs_detail.png\" alt=\"其他云详细配置参数\" title=\"@ASSET\"></p>\n<p>此外，在价格上各家也有差异，由于我自己的需求是约 8 核以上 CPU + 约 32G 以上内存，再加上只是临时跑一下数据，所以选择按需计费，并且都转换成以下标准配置再进行价格对比：</p>\n<ul>\n<li>地区：广州（华南地区）</li>\n<li>CPU：8核 2xlarge.4（3.1GHz 高性能计算型）</li>\n<li>内存：32G</li>\n<li>硬盘：50G 普通硬盘</li>\n<li>带宽：5Mbps</li>\n<li>系统：Ubuntu</li>\n<li>公网：无</li>\n<li>时长：1小时</li>\n</ul>\n<p>各个云的价格计算器链接：<a href=\"https://buy.cloud.tencent.com/price/cvm/calculator\" title=\"@LINK\">腾讯云</a>、<a href=\"https://cloud.baidu.com/calculator.html#/bcc/price\" title=\"@LINK\">百度云</a>、<a href=\"https://tco.aliyun.com/tco/ecs/calculator\" title=\"@LINK\">阿里云</a>、<a href=\"https://www.huaweicloud.com/pricing.html#/ecs\" title=\"@LINK\">华为云</a>。</p>\n<p>根据这个选择，得到费用表如下（单位：元 / 小时）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">腾讯云</th>\n<th align=\"center\">百度云</th>\n<th align=\"center\">阿里云</th>\n<th align=\"center\">华为云</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">无公网</td>\n<td align=\"center\">6.58</td>\n<td align=\"center\">3.6721</td>\n<td align=\"center\">4.7874</td>\n<td align=\"center\">2.73</td>\n</tr>\n<tr>\n<td align=\"center\">有公网</td>\n<td align=\"center\">6.58</td>\n<td align=\"center\">3.6721</td>\n<td align=\"center\">4.7874</td>\n<td align=\"center\">3.05</td>\n</tr>\n</tbody></table>\n<p>当看到腾讯云价格的时候，我有一点吃惊，但是仔细看了一下，我确定我选择的是 SkyLake 架构 3.2GHz 规格的 CPU，应该是 Xeon E5-2667v4，这款在阿里云的价格平均下来要 7.11 元 / 小时，所以这个价格也还差不多，不过相比标准配置，相同架构，提高 0.1 主频就要贵这么多，还是略不值得。另外，阿里云原本是支持按小时计费，但是这次没找到，因此按照月费用除以 31 天计算。</p>\n<p>从价格表也基本可以看出来，华为云的价格优势还是很大的，综合不需要预充值、引导友好等特点，最终入了华为云的坑。</p>\n<hr>\n<h2 id=\"2-连接远程服务器\"><a href=\"#2-连接远程服务器\" class=\"headerlink\" title=\"2. 连接远程服务器\"></a>2. 连接远程服务器</h2><p>云服务器给的 Linux 系统通常是命令行形式的，也就是所有的操作都使用 Linux 命令完成，当然有些云也提供支持视图模式的选项，但通常伴随着较高的价格。</p>\n<p>连接远程服务器有两种方式：（1）用远程连接工具、（2）用系统自带工具</p>\n<ol>\n<li><p>远程连接工具有很多</p>\n<ul>\n<li>Mac 下有 <a href=\"https://www.ssh.com/ssh/cyberduck\" title=\"@LINK\">CyberDuck</a>、<a href=\"http://www.openssh.com/portable.html\" title=\"@LINK\">OpenSSH</a> 等</li>\n<li>Win 下有 <a href=\"https://www.netsarang.com/zh/xshell/\" title=\"@LINK\">XShell</a>、<a href=\"https://www.ssh.com/ssh/winscp/\" title=\"@LINK\">WinSCP</a> 等</li>\n<li>跨平台的有 <a href=\"https://www.vandyke.com/products/securecrt/\" title=\"@LINK\">SecureCRT</a>、<a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/\" title=\"@LINK\">PuTTY</a>、<a href=\"https://www.ssh.com/products/tectia-ssh/\" title=\"@LINK\">Tectia</a> 等</li>\n</ul>\n</li>\n<li><p>系统自带工具不依赖额外的软件，因此更适合仅需要建立连接而不需要集群管理等高级功能的情况</p>\n<ul>\n<li>Mac 下的“终端”</li>\n<li>Win 下的 CMD 和 PowerShell</li>\n</ul>\n</li>\n</ol>\n<p>由于我只是为了利用云 ECS 的算力和持续运行，因此不需要什么高级功能，选择系统自带工具就足够了。命令格式为：<code>ssh [用户名]@[服务器地址]</code>，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh root@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n<p>对于新建的云 ECS，通常都有一个内网 ip 地址，但仅有这个地址的时候是无法远程访问的，还需要购买一个 弹性公网ip，华为云在默认情况下会选择购买，阿里云默认情况下不购买，需要自己区分。以下是华为云在购买 ECS 时弹性公网 IP （红圈所标）的设置部分：</p>\n<p><img data-src=\"./buy_ip.png\" alt=\"购买弹性公网 IP\" title=\"@ASSET\"></p>\n<p>关于 ECS 的内网 IP 和公网 IP，可以这么粗略理解：公网 IP 是通过远程连接等利用公网访问云、或从云访问公网时必须用到的，内网 IP 通常是集群服务器间，某些云没有联网需求，但需要和其他同属一个网段的云（例如都是华为云，或都是阿里云等）交互数据，那么这些云就可以不购买公网 IP 而仅通过内网 IP 通信。</p>\n<p>有了公网 IP 后，就能同过命令行进行远程连接了。如果设置了连接密码，则会在下一条命令中提示输入，注意输入该密码时屏幕上不会显示输入过程，输完回车即可，密码也即在购买服务器时设置登录账户时输入的密码：</p>\n<p><img data-src=\"./set_login_user.png\" alt=\"远程连接密码\" title=\"@ASSET\"></p>\n<p>在 Mac 下，如果不想每次都手输这个命令，可以右键“终端”，选择“新建远程连接”：</p>\n<p><img data-src=\"./new_ssh_connection.jpg\" alt=\"新建远程连接\" title=\"@ASSET\"></p>\n<p>然后在弹出窗口内左侧选择服务为 <strong>SSH</strong>，在下面输入连接用户，并输入服务器的地址：</p>\n<p><img data-src=\"./add_ssh.png\" alt=\"添加 SSH 服务\" title=\"@ASSET\"></p>\n<p>通常连接用户是 root，如果想减少权限以防意外操作，要先以 root 用户登录一次，再在 Linux 系统内新建一个普通用户，下一次即可选择新用户登录。</p>\n<hr>\n<h2 id=\"3-配置服务器环境\"><a href=\"#3-配置服务器环境\" class=\"headerlink\" title=\"3. 配置服务器环境\"></a>3. 配置服务器环境</h2><p>到这一步，云服务器已是可用状态，通过 SSH 登录后，会新开一个 SSH 终端用于操作云上的 Linux 系统，就和自己手动操作时时一样的。不过需要注意的是，SSH 云服务器的终端只有一个，当然还有一些别的技巧可以达到类似多开终端的效果，会在后面介绍。</p>\n<p>既然是要在云上跑训练集，当然 Python 环境、各种科学计算工具包是必不可少的，我个人更推荐直接使用 Anaconda 一次性集成开发环境。</p>\n<h3 id=\"3-1-下载安装Anaconda\"><a href=\"#3-1-下载安装Anaconda\" class=\"headerlink\" title=\"3.1 下载安装Anaconda\"></a>3.1 下载安装Anaconda</h3><p>首先在任何一个可以联网的设备上进入 <a href=\"https://repo.continuum.io/archive/index.html\" title=\"@LINK\">Anaconda 安装包归档</a>，并找到自己想要安装的版本，以 Linux 下 64 位集成 Python3 环境的最新版本为例，其安装包名称为：<code>Anaconda3-2019.03-Linux-x86_64.sh</code>，在 SSH 终端中输入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装包（默认在用户目录下，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">wget https://repo.continuum.io/archive/Anaconda3-2019.03-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 Anaconda（默认在用户目录内，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">bash Anaconda3-5.0.1-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量：</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .bashrc</span><br></pre></td></tr></table></figure>\n\n<p>完成后，在 SSH 终端内输入 <code>python</code>，正确进入 Python 编辑环境则表示安装成功。某些情况下，可能需要手动配置环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑环境变量（所有用户有效）：</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 编辑环境变量（仅当前用户有效）：</span></span><br><span class=\"line\"><span class=\"comment\"># vim .bash_profile</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件末尾添加一行（用户名和安装目录请按实际路径填写）：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/home/root/anaconda3/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存并使其生效（所有用户有效）：</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 保存并使其生效（仅当前用户有效）：</span></span><br><span class=\"line\"><span class=\"comment\"># source .bash_profile</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-配置Jupyter-Notebook\"><a href=\"#3-2-配置Jupyter-Notebook\" class=\"headerlink\" title=\"3.2 配置Jupyter Notebook\"></a>3.2 配置Jupyter Notebook</h3><p>使用命令 <code>pip install jupyter</code> 安装 Jupyter 到当前环境中，如果需要切换环境，可以先在 Anaconda 中新建环境并切换至新环境后执行命令。</p>\n<p>安装好 Jupyter 后，像往常一样输入 <code>jupyter notebook</code> 启动，结果却发现连不上 Jupyter 服务，这是因为服务器上的 Jupyter 还没有配置外网访问。配置方式如下：</p>\n<ol>\n<li><p>生成 Jupyter 配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config --allow-root</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开ipython，创建一个登录jupyter的密码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 ipython 环境</span></span><br><span class=\"line\">ipython</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入 password 模块</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> notebook.auth <span class=\"keyword\">import</span> passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改密码</span></span><br><span class=\"line\">passwd()</span><br></pre></td></tr></table></figure>\n\n<p>然后会要求输入一次密码和一次确认密码，同样，输入过程屏幕上不会有任何显示。正确输入密码后，会输出一个哈希值（省略后半部分），请复制或记录这个值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 Jupyter 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">vi ~/.jupyter/jupyter_notebook_config.py</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># vi /root/.jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>\n\n<p>在打开的配置中添加以下参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.NotebookApp.ip=<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">c.NotebookApp.password = u<span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>password</code> 项输入上一步复制的哈希值，<code>port</code> 项推荐使用默认的 8888 端口，也可以自己定义。</p>\n</li>\n</ol>\n<h3 id=\"3-3-配置服务器端口\"><a href=\"#3-3-配置服务器端口\" class=\"headerlink\" title=\"3.3 配置服务器端口\"></a>3.3 配置服务器端口</h3><p>至此服务器上的环境均已配置就绪，但如果这时候在 SSH 终端使用命令打开 Jupyter Notebook：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">jupyter notebook</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># jupyter notebook --allow-root</span></span><br></pre></td></tr></table></figure>\n\n<p>或是在浏览器通过：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://公网ip:端口</span><br><span class=\"line\"><span class=\"comment\"># 例：http://127.0.0.1:8888</span></span><br></pre></td></tr></table></figure>\n\n<p>仍然会出现无法连接的情况，这是因为 ECS 的安全组还没有配置，8888 端口（或自己设置的端口号）还没有开放给公网。设置安全组的过程如下：</p>\n<ol>\n<li>进入云服务器控制台</li>\n<li>进入安全组设置</li>\n<li>添加安全组规则</li>\n<li>选择协议类型为 <strong>自定义 TCP</strong>，输入端口号为 8888（或自定义端口号），授权 IP 设置为 0.0.0.0（即不限访问 IP，不论哪里的网络都可以连接访问云服务器的 Jupyter）</li>\n</ol>\n<p>配置完成后，即可通过 SSH 终端或浏览器输入地址的方式进入服务器的 Jupyter Notebook 了！如果仍旧提示无法访问，且云服务器所选的 Linux 系统为 Ubuntu（其他系统没试过），或许是因为防火墙的缘故，通过以下方式关闭：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ufw <span class=\"built_in\">disable</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来尽情享受云服务器带来的快感吧！</p>\n<h3 id=\"3-4-保持SSH会话\"><a href=\"#3-4-保持SSH会话\" class=\"headerlink\" title=\"3.4 保持SSH会话\"></a>3.4 保持SSH会话</h3><p>在使用云服务器的过程中，有时去做别的事了过了一段时间后再看 SSH 终端，发现先是没反应，无法输入，再过一会儿就提示连接已断开，这是因为默认情况下 SSH 会话有一个连接时间，一段时间后就会断开会话。如果需要处理一个耗时很长的事件，这可不是什么好事。为此，可以通过以下方式修改时间，以达到 SSH  会话保活的目的：</p>\n<ol>\n<li><p>登陆远程服务器后在 SSH 终端输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">TMOUT=0</span><br></pre></td></tr></table></figure>\n\n<p>该方式方便、快捷，但缺点是仅对本次登陆有效，退出 SSH 后重新登录则需要再次设置。</p>\n</li>\n<li><p>修改ssh配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打开配置文件</span></span><br><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveInterval，该参数指定了服务器端向客户端请求消息的时间间隔。默认是0，不发送</span></span><br><span class=\"line\"><span class=\"comment\"># 修改 ClientAliveInterval 的值，单位为秒。如设置 600，即每 10 分钟发送一次请求保持会话。</span></span><br><span class=\"line\">ClientAliveInterval = 600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveCountMax，该参数表示允许超时的次数。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果发现客户端没有响应，则判断一次超时，请根据实际需要进行设置。比如设置为10，表示允许超时6000 秒 = 100 分钟。</span></span><br><span class=\"line\">ClientAliveCountMax = 10</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"3-5-本地与云的文件传输\"><a href=\"#3-5-本地与云的文件传输\" class=\"headerlink\" title=\"3.5 本地与云的文件传输\"></a>3.5 本地与云的文件传输</h3><p>为了使用云服务器跑数据，还需要在云服务器上准备一份数据文件。由于提高网络带宽的价格并不便宜，而且使用云跑数据本身对带宽并没有什么要求，因此我比较推荐在将数据上传至云或从云上下载时，临时提高 ECS 的带宽，并在完成之后重新恢复较低带宽以节省成本。数据文件比较大时，临时提高带宽更划算一些。文件总量比较大时，临时购买流量更划算一些。本地与服务器的文件拷贝指令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本地文件复制到服务器：</span></span><br><span class=\"line\">scp [本地文件路径] [服务器登录用户名]@[服务器地址]:[服务器文件存储路径]</span><br><span class=\"line\"><span class=\"comment\"># 例如将本地用户目录下的 test.txt 复制到服务器 root 用户目录下并重命名为 db.txt：</span></span><br><span class=\"line\">scp /Users/user/test.txt root@127.0.0.1:/root/db.txt</span><br><span class=\"line\"><span class=\"comment\"># 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r /Users/user/<span class=\"built_in\">test</span> root@127.0.0.1:/root/db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务器复制到本地：</span></span><br><span class=\"line\">scp [服务器登录用户名]@[服务器地址]:[服务器文件存储路径] [本地文件路径]</span><br><span class=\"line\"><span class=\"comment\"># 例如将服务器 root 用户目录下的 db.txt复制到本地用户目录下并重命名为 test.txt ：</span></span><br><span class=\"line\">scp root@127.0.0.1:/root/db.txt /Users/user/test.txt</span><br><span class=\"line\"><span class=\"comment\"># 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r root@127.0.0.1:/root/db /Users/user/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-服务器后台运行Jupyter\"><a href=\"#3-6-服务器后台运行Jupyter\" class=\"headerlink\" title=\"3.6 服务器后台运行Jupyter\"></a>3.6 服务器后台运行Jupyter</h3><p>在选择云服务器训练数据时，除了考虑到算力的问题，当然也有持续运行的问题。尽管通过设置 SSH 的会花时间已经可以使得服务器的 Jupyter 一直在激活状态，但如果是自己的工作电脑，甚至办公本，平时还有大量的工作需要使用电脑，，一直在本地挂着一个 SSH 会话不能关机不能断开，总还是不妥，更何况如果遇到突然断网、突然死机等问题时，会话一关就中断运行，想想就让人抓狂。为此，给服务器的当前任务配置一个后台运行就显得尤为必要了。</p>\n<p>通常，在 Linux 中，可以用 <code>nohup [command]</code> 来保持一项任务不被挂起，使用 <code>nohup [command] &amp;</code> 来将任务转至后台并保持不被挂起。指令执行后，Linux 会立即将任务转至后台运行，且返回输出一个进程号：PID，当我们需要手动停止该进程时，可以通过 <code>kill -TRM [PID]</code> 来终止该进程。同时，该进程的所有输出均会默认存储至当前目录下的 <code>nohup.out</code> 文件中，使用命令 <code>tail -f nohup.out</code> 来实时查看动态输出，或者也可以使用：<code>nohup [command] &gt; out.log &amp;</code> 命令将输出重定向至自定义的文件（本例为out.log）并查看。</p>\n<p>这对于 Jupyter 任务来说也是一样的，我们可以通过将 Jupyter 任务转至后台持续运行来释放本地电脑的工作压力：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">nohup jupyter notebook &amp;</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># nohup jupyter notebook --allow-root &amp;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，当我们在 Jupyter 开始一项耗时任务后，即可直接断开 SSH 会话。<strong>注意：在本地需要离线时，不能终止 Jupyter 的进程，而应该直接断开 SSH 连接。</strong></p>\n<p>另外还有一点，由于 Jupyter 本身的局限性，当一个正在运行任务的 Jupyter 页面被关闭（而没有关闭服务）后，再次打开，只能保留前一次的结果，而不能恢复任务运行过程，因此，使用 nohup 命令转至后台的 Jupyter 任务应当是具有完整结果的，而不能再带有需要交互的部分，例如：</p>\n<ol>\n<li>将某个数据集预先确定好的特征进行哈希编码，并将编码完的数据重新输出存储。</li>\n<li>将某个数据集预先确定好的特征进行哈希编码，并询问我是否存储，根据选择完成相应任务。</li>\n</ol>\n<p>假设在任务开始后，本地立即断开 SSH 连接，并等待任务完成后再重新连接。那么：<br>任务 1 是合理的，因为任务过程不需要交互，重新连接后，可以在服务器的本地找到输出的已完成哈希编码的数据集。<br>任务 2 是不合理的，因为任务执行完编码后，不能完成交互因此任务将直接运行结束，重新连接后相当于白费力气。</p>\n<p>另外，除了基本的后台防挂起 nohup 外，还有一些工具也可以用来保持任务现场并恢复，例如：screen 和 tmux，可参考附录【7】、【8】，但终究因为 Jupyter 本身的原因，还是不太适合这种长时间可恢复的后台运行模式，我的建议是通过 Python 脚本进行长时间的后台操作，并尽量减少交互部分，及时将后续可能要用的数据保存成文件，而在 Jupyter 上仅作为一些可视化或测试、调整等的工具使用。</p>\n<h3 id=\"3-7-调整服务器的虚拟内存\"><a href=\"#3-7-调整服务器的虚拟内存\" class=\"headerlink\" title=\"3.7 调整服务器的虚拟内存\"></a>3.7 调整服务器的虚拟内存</h3><p>终于可以随心所欲折腾服务器的算力了，但在运行大量数据集的时候，很有可能报这个错：<code>Memory Error</code>，这个错在 Python 里面也不算罕见了，一般表示瞬间内存占用超过了可用内存总和导致代码崩了，但同样的代码，在本地运行成功，在配置更高的服务器却反而失败？后来通过 <code>free -m</code> 命令查看内存时发现原因其实很简单，就是因为 ECS 给我们的系统太纯净、太初始化了，以至于连交换内存都没有，所以即便是选购了 32G 的服务器，当进行一些编码、训练等大数据量任务时，瞬时内存占用会一下飙升，导致内存不足。好在现在的 ECS 大多都使用了固态硬盘，即便默认非固态硬盘的，升级成本也比较低，因此可以拿出一部分硬盘作为交换内存使用（参考附录【9】）。</p>\n<ol>\n<li><p>创建swap文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 /usr 目录下创建交换内存文件</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr</span><br><span class=\"line\">mkdir swap</span><br><span class=\"line\"><span class=\"built_in\">cd</span> swap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看目前总用量</span></span><br><span class=\"line\">ll</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个循环，每次复制 1024 字节，共复制 1024000 次（10G）并输出为 swapfile1 文件</span></span><br><span class=\"line\">dd <span class=\"keyword\">if</span>=/dev/zero of=/usr/swap/swapfile1 bs=1024 count=1024000</span><br></pre></td></tr></table></figure>\n\n<p>最后的 <code>dd</code> 命令中，if 表示 infile，of 表示 outfile，bs=1024 表示写入的每个块的大小为 1024B，即 1KB。</p>\n</li>\n<li><p>查看刚才创建的 swap 文件大小即路径：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -sh /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将目标文件设置为 swap 分区文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkswap /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>激活 swap，立即启用交换分区文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapon /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<p>至此交换内存已经设置好了，并已激活可用，但仅限本次开机可用，想要每次开机都自动加载这个交换内存，则需要修改 <code>/etc/fstab</code> 文件</p>\n</li>\n<li><p>编辑文件 <code>/etc/fstab</code> 中的 <code>swap</code> 行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/fstab</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>/etc/fstab</code> 编辑状态下（UUID 省略后半部分），添加下面这段的最后一行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/dev/mapper/vg_localhost-lv_root   /         ext4    defaults        1 1</span><br><span class=\"line\">UUID=cef520a0-df77-4........       /boot     ext4    defaults        1 2</span><br><span class=\"line\"><span class=\"comment\"># /dev/mapper/vg_localhost-lv_swap   swap      swap    defaults        0 0</span></span><br><span class=\"line\"><span class=\"comment\"># 下面这行是关键：</span></span><br><span class=\"line\">/usr/swap/swapfile1                swap      swap    defaults        0 0</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>保存并重启系统生效。</p>\n<h3 id=\"3-8-验证服务器\"><a href=\"#3-8-验证服务器\" class=\"headerlink\" title=\"3.8 验证服务器\"></a>3.8 验证服务器</h3><p>重启系统后，再次输入 <code>free -m</code> 命令，发现多了一个 <code>swap</code> 内存，大小为 10G，设置成功，服务器的基本配置已全部完成！</p>\n<hr>\n<h2 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/mypath/articles/7877493.html\" title=\"@LINK\">【1】linux下安装Anaconda（作者：猪啊美）</a></li>\n<li><a href=\"https://blog.csdn.net/m0_37748303/article/details/78764625\" title=\"@LINK\">【2】阿里云连接jupyter notebook的步骤（作者：半监督）</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/25475.html?spm=a2c4e.11153940.blogcont98527.62.4d126b80ucvIpF#h2-url-6\" title=\"@LINK\">【3】安全组应用案例六：允许公网远程连接实例（作者：阿里云）</a></li>\n<li><a href=\"https://support.huaweicloud.com/trouble-ecs/zh-cn_topic_0138293301.html\" title=\"@LINK\">【4】怎样长时间保持SSH会话连接不断开？（作者：华为云）</a></li>\n<li><a href=\"https://blog.csdn.net/ludongdong/article/details/78524653\" title=\"@LINK\">【5】mac 本地文件与服务器Linux文件之间的相互传输（作者：binary101010）</a></li>\n<li><a href=\"https://www.jianshu.com/p/6d1a48cc6ce2\" title=\"@LINK\">【6】如何不挂起后台，继续运行jupyter（作者：aoaocool）</a></li>\n<li><a href=\"https://help.aliyun.com/knowledge_detail/42523.html\" title=\"@LINK\">【7】云服务器 ECS Linux SSH 客户端断开后保持进程继续运行配置方法（作者：阿里云）</a></li>\n<li><a href=\"https://www.jianshu.com/p/300333a3f2ba\" title=\"@LINK\">【8】使用tmux保持远程ssh连接（作者：步晓德）</a></li>\n<li><a href=\"https://www.cnblogs.com/llkmst/p/4684097.html\" title=\"@LINK\">【9】Linux 修改swap虚拟内存大小（作者：L.L.K）</a></li>\n</ul>\n</blockquote>\n","categories":["Note"],"tags":["Linux","Server","Cloud","云服务器","远程连接"]},{"title":"HashingEncoder-多进程支持","url":"/post/python/python-hashingencoder-optimization/","content":"<span id=\"more\"></span>\n\n<h1 id=\"HashingEncoder-多进程支持\"><a href=\"#HashingEncoder-多进程支持\" class=\"headerlink\" title=\"HashingEncoder-多进程支持\"></a>HashingEncoder-多进程支持</h1><p>前言：HashingEncoder 对大数据量编码时速度很慢且 CPU 利用率并不高，瞎研究半天写了一个多 <strong>进程</strong> 版的 HashingEncoder，记录一下踩坑历史。本文代码均为伪代码，改进和源码已收录于 Github 上 scikit-learn 工具包，详情参考 <a href=\"https://github.com/scikit-learn-contrib/categorical-encoding\" title=\"@LINK\">scikit-learn-contrib</a>，建议先阅读：<a href=\"https://github.com/liushulun/MPHashingEncoder\" title=\"@LINK\">使用文档</a>。</p>\n<hr>\n<h2 id=\"1-源码\"><a href=\"#1-源码\" class=\"headerlink\" title=\"1. 源码\"></a>1. 源码</h2><p>有一次在做哈希编码的时候，因为数据量比较大，试了好几种方案，最快都要十二个小时才仅能编码完一个特征，还有 8 个嗷嗷待哺的小特征在后面排队等着我 <em><del>鞭挞</del></em> 编码，电脑已经能烤猪蹄了，这可如何是好。<br>正愁着莫非要升级一波配置，转头监视器一看，CPU 利用率才 16% 上下，这我可就。。。服务器搞起！阿里云太贵，亚马逊麻烦，TinyMind <em><del>辣鸡</del></em> 真辣鸡！华为云好像还不错（我的配置才 3+ 元每小时，不要求最低账内金额），8x3.1GHz + 32G 走你！但是第二个特征依然耗费了 10 个小时才编码完。</p>\n<p>受困于编码时间过长。迫于无奈找了找 sklearn 中 HashingEncoder 的 api，没有类似于 n_thread 之类的参数，又看了看源码，从 Pycharm 中一级级往上点，找到了 HashingEncoder 的核心源码部分如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hashing_trick</span>(<span class=\"params\">X_in, hashing_method=<span class=\"string\">&#x27;md5&#x27;</span>, N=<span class=\"number\">2</span>, cols=<span class=\"literal\">None</span>, make_copy=<span class=\"literal\">False</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A basic hashing implementation with configurable dimensionality/precision</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Performs the hashing trick on a pandas dataframe, `X`, using the hashing method from hashlib</span></span><br><span class=\"line\"><span class=\"string\">    identified by `hashing_method`.  The number of output dimensions (`N`), and columns to hash (`cols`) are</span></span><br><span class=\"line\"><span class=\"string\">    also configurable.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Parameters</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    X_in: pandas dataframe</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    hashing_method: string, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    N: int, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    cols: list, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    make_copy: bool, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Returns</span></span><br><span class=\"line\"><span class=\"string\">    -------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    out : dataframe</span></span><br><span class=\"line\"><span class=\"string\">        A hashing encoded dataframe.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    References</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\">    Cite the relevant literature, e.g. [1]_.  You may also cite these</span></span><br><span class=\"line\"><span class=\"string\">    references in the notes section above.</span></span><br><span class=\"line\"><span class=\"string\">    .. [1] Kilian Weinberger; Anirban Dasgupta; John Langford; Alex Smola; Josh Attenberg (2009). Feature Hashing</span></span><br><span class=\"line\"><span class=\"string\">    for Large Scale Multitask Learning. Proc. ICML.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hashing_method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> hashlib.algorithms_available:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Available. Please use one from: [%s]&#x27;</span> % (</span><br><span class=\"line\">                hashing_method,</span><br><span class=\"line\">                <span class=\"string\">&#x27;, &#x27;</span>.join([<span class=\"built_in\">str</span>(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> hashlib.algorithms_available])</span><br><span class=\"line\">            ))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            _ = hashlib.new(hashing_method)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Found.&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> make_copy:</span><br><span class=\"line\">        X = X_in.copy(deep=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        X = X_in</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cols <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        cols = X.columns.values</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hash_fn</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">        tmp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> x.values:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> val <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                hasher = hashlib.new(hashing_method)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sys.version_info[<span class=\"number\">0</span>] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">str</span>(val))</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">bytes</span>(<span class=\"built_in\">str</span>(val), <span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">                tmp[<span class=\"built_in\">int</span>(hasher.hexdigest(), <span class=\"number\">16</span>) % N] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pd.Series(tmp, index=new_cols)</span><br><span class=\"line\"></span><br><span class=\"line\">    new_cols = [<span class=\"string\">&#x27;col_%d&#x27;</span> % d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X.loc[:, cols]</span><br><span class=\"line\">    X_num = X.loc[:, [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> X.columns.values <span class=\"keyword\">if</span> x <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> cols]]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X_cat.apply(hash_fn, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">    X_cat.columns = new_cols</span><br><span class=\"line\"></span><br><span class=\"line\">    X = pd.concat([X_cat, X_num], axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> X</span><br></pre></td></tr></table></figure>\n\n<p>好吧，还真是一个 for 循环往下读啊。这十个小时才跑一个特征，服务器的成本有点担不起啊！看来只好曲线救国了。虽然 Python 本身在执行的时候对 CPU 就有个动态调度，但因为 GIL全局锁 的原因，大多数情况下 Python 都是在单核模式运行的。我对 GIL 有一点点自己的理解，从我的角度出发，个人认为 GIL 还是利大于弊的，何况在 Python3 中已经对对线程/多进程提供了挺不错的额外支持，不过本文不深入探讨 GIL 的内容。</p>\n<hr>\n<h2 id=\"2-改进思路\"><a href=\"#2-改进思路\" class=\"headerlink\" title=\"2. 改进思路\"></a>2. 改进思路</h2><h3 id=\"2-1-理论支持\"><a href=\"#2-1-理论支持\" class=\"headerlink\" title=\"2.1 理论支持\"></a>2.1 理论支持</h3><p>关于什么是哈希编码的内容网上有很多了，在一开始做这个之前，我考虑过一个问题：按顺序依次编码，和多进程分别编码再按原序拼接，最后的结果是一样的吗？如果多进程编码会导致结果变化，那一切都是白费功夫。之所以对此担心，有一个原因是 <code>我曾经把哈希编码当成了“集合操作”，如果一开始输入的集合不一致就会导致最后的编码结果不一致</code>。当然，事后证明我的想法是错误的，为此我找了一些哈希编码的文章来看，幸运的是，只要规定好输入特征和输出维度，最后的结果和编码的顺序并没有关系。许多篇文章都对哈希编码做了很详尽的说明，我选出来五篇自己看完最有心得的放在附录【12】~【16】中。</p>\n<p>再经过他人文章的点拨后，我认为多进程实现是可能且符合要求的。把其核心思想总结一下大致可以这么理解：</p>\n<blockquote>\n<ol>\n<li>哈希表把输入散列到指定的输出范围内</li>\n<li>对于不在训练数据的散列表中的输入，依然可以通过同样的哈希算法计算出散列值</li>\n<li>只要指定了相同的散列范围，新的输入也会具有相同的输出特征维度</li>\n<li>新输入可以直接进行哈希编码，而不需要再对整体数据重新处理，因此支持在线学习</li>\n<li>只有原始值非零，哈希编码才有效，因此可以保持编码前后的稀疏性</li>\n</ol>\n</blockquote>\n<p>也就是说，每一次送去编码的进程，其数据都是独立的，并且完全可以分开编码而不需要考虑别的数据，只要给每个进程设置相同的编码算法和输出维度，最后再将每个独立的数据块按照原数据的顺序重新排列即可。</p>\n<h3 id=\"2-2-代码思想\"><a href=\"#2-2-代码思想\" class=\"headerlink\" title=\"2.2 代码思想\"></a>2.2 代码思想</h3><p>既然是多核性能没发挥出来，那就从并行的角度出发，大致的实现逻辑如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multithreading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashingEncoder</span>:</span></span><br><span class=\"line\">    self.multi_data = []</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 每个线程调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">        get_data() <span class=\"comment\"># 每个线程都从整体数据中获取一部分数据</span></span><br><span class=\"line\">        hashing_data = hashing() <span class=\"comment\"># 每个线程都单独进行哈希编码</span></span><br><span class=\"line\">        self.multi_data.append(hashing_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> multi_num</span><br><span class=\"line\">            multithreading.Thread.Thread(target=work).start</span><br><span class=\"line\"></span><br><span class=\"line\">        data = pandas.concat(multi_data, ignore_index=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>省略了大量代码，单从逻辑来看，我的需求就是：</p>\n<ol>\n<li>允许用户自定义并行线程数以及每个线程每次编码的样本数</li>\n<li>根据参数创建 n 个进程</li>\n<li>每个线程都依次从所有数据中不重复地顺序取出参数定义数量的数据</li>\n<li>每个线程都独立对自己取到的数据进行哈希编码</li>\n<li>每个线程哈希编码完后将返回数据存储进一个列表内</li>\n<li>将列表内的数据拼接成回一个整体。</li>\n</ol>\n<hr>\n<h2 id=\"3-过程中的坑\"><a href=\"#3-过程中的坑\" class=\"headerlink\" title=\"3. 过程中的坑\"></a>3. 过程中的坑</h2><p>以下每个小节都是一个记录的坑，为了文章更有逻辑，有些坑我合并成了一节来写。</p>\n<h3 id=\"3-1-多线程和多进程问题\"><a href=\"#3-1-多线程和多进程问题\" class=\"headerlink\" title=\"3.1 多线程和多进程问题\"></a>3.1 多线程和多进程问题</h3><p>最早第一次改进时，我仅仅只是用多线程式：multithreading 模块，在一个小型计算 Demo 上尝试过，表面上来看似乎确实是并行处理，所以我想当然地认为多线程可以解决多核 CPU 利用率的问题，因此我写出了第一个版本的改进代码后，欣喜若狂，然而上数据一测编码时间几乎没有什么缩减，后来再看监视器，发现 CPU 利用率依然还处在单核上，这个结果一度让我差点放弃，好在研究了一下 multiprocessing 的内容，由此进而了解到了 multiprocessing 模块，这两者非常类似，调用方式也几乎一样，最大的区别就是：①multithreading 本质是 threading 线程、②multiprocessing 本质是 processing 进程。<br>进程和线程的关系想必大家都知道，一个进程可以包括多个线程，而<a href=\"https://baike.baidu.com/item/进程/382503?fr=aladdin\" title=\"@LINK\">进程</a>是 CPU 资源分配和调度的基本单位，因此从通俗的话来讲，是进程向 CPU 申请资源，然后再提供给线程使用，对于常见的 CPU 而言，通常一个物理核心就对应了一个（支持超线程的 CPU 则对应多个，但 CPU 的线程和应用的线程不是一回事） <strong>可并行处理的</strong> 进程，因此想要发挥出 <strong>多核</strong> 的优势，就要调用 <strong>多进程</strong>。还好，正如上文所说，multiprocessing 和 multithreading 的 API 还是基本类似的，因此下文的坑将直接按照多进程的实现模式举例。</p>\n<h3 id=\"3-2-并行顺序读取数据问题\"><a href=\"#3-2-并行顺序读取数据问题\" class=\"headerlink\" title=\"3.2 并行顺序读取数据问题\"></a>3.2 并行顺序读取数据问题</h3><p>首先，Python 中多进程有两种常用方式，第一个是生成多个进程并分别执行，第二个是利用进程池的方式，在很多时候进程池其实是更好的方案，因为进程池可以不必手动管理每个进程的周期，也不用手动安排进程的工作流程，只需要指定最大进程数即可，而且还支持异步获取每个进程执行完后的返回值，<strong>但是！</strong> 进程池方式比手动方式稍慢一些，由于追求速度，因此最终采取手动管理方式。<br>现在假设我们开启 4 个进程同时执行一个任务，代码应该大致如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">    get_data() <span class=\"comment\"># 每个线程都从整体数据中获取第 index 部分的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">process_list = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br></pre></td></tr></table></figure>\n\n<p>由于多进程是并行的，因此尽管循环是依次添加并开启进程，实际上仍然会发生后创建的进程先取数据的情况。有两个思路可以避免这个情况：（1）在创建进程前就先计算好该进程需要选择的数据范围、（2）在进程执行任务时自行选择需要选择的数据范围。<br>方式（1）其实也就是提前限定，因此不需要判断进程获取数据的先后顺序。但由于使用的多进程方案为手动管理方式，而限定数据范围对“需求 1：用户调用时自定义参数”并不友好。例如：当 100 条样本设置了 3 个进程，且每个进程单次编码 13 条数据时，编码的过程则应该是：0 ~ 13; 13 ~ 26; …; 91 ~ 100 共 8 轮。但因为采用了手动管理方式，意味着在开启新进程时，要么①使用多个循环：每个循环开启三个进程，直到所有样本均被遍历，且还需要在循环内判断当前样本是否已经全部遍历完（在本例中，第三个循环只需要循环两次即遍历完所有样本）而跳过，要么②创建进程时给每个进程传递参数，用来告知每个进程分别需要取几次值，每次又分别取什么范围的数据…不论哪种方式，我想都非常不优雅，所以最终我选择了使用方式（2）实现。</p>\n<p>而为了确保每个进程能自己判断所需的数据范围，就需要一个变量用于存放已被读取的范围，则每个进程只需要从还未被读取的数据内选择指定量的数据即可。为此，还需要一个进程锁来确保每个进程在计算数据范围的时候不会因为进程的先后顺序导致重复选择、漏选等情况。这里有一个要注意的点：加锁操作应当只锁住获取起始下标和计算读取范围的部分，其他不会引起冲突的耗时操作例如取出数据和进行编码，则应当在锁释放后执行，否则会导致锁住非冲突耗时操作引起效率降低甚至变成单线程模式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, done_index</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():</span><br><span class=\"line\">        start = done_index</span><br><span class=\"line\">        end = done_index + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        done_index = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">done_index = <span class=\"number\">0</span>  <span class=\"comment\"># 初始化下标为从 0 开始</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=(done_index)))</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>省略了一些判断、具体实现，下同。事实上这里的 <code>done_index</code> 一点作用都没有，每一个进程执行到 <code>start = done_index</code> 时获取到的值都是 0。因为进程被创建时，直接传进去的值属于每个子进程自己的独立空间，如果加上一条 <code>print(id(done_index))</code> 就会发现所有子进程的 done_index 都不一样，同理，无论是用成员变量的方式 <code>self.done_index</code> 也好，还是全局变量的方式 <code>global done_index</code> 也好，结果都是一样的。为了在进程间共享一个数据，可以使用 <code>multiprocessing.Value()</code> 来实现，搭配进程锁起到共享数据且不冲突的作用。另外，当子进程编码完了当前分配的任务数据后，还有未处理的数据，那么就自己再调用一次分配任务，由于锁和共享数据的存在，也不用担心会出现重复读取的问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\">    self.done_index = multiprocessing.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    self.data_lines = <span class=\"built_in\">len</span>(data)  <span class=\"comment\"># 样本总数目</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():  <span class=\"comment\"># 加锁，已确保自己获取到的 done_index 是最新的</span></span><br><span class=\"line\">        start = self.done_index.value</span><br><span class=\"line\">        end = start + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        self.done_index.value = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release() <span class=\"comment\"># 释放锁，允许其他进程操作更新 done_index</span></span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end &lt; self.data_lines:  <span class=\"comment\"># 尚有未完成的数据，再次调用分配</span></span><br><span class=\"line\">            self.work()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-编码后数据的保存问题\"><a href=\"#3-3-编码后数据的保存问题\" class=\"headerlink\" title=\"3.3 编码后数据的保存问题\"></a>3.3 编码后数据的保存问题</h3><p>现在，并行也跑起来了，子进程也能正确获取到数据了，编码也顺利完成后，主进程怎么收集这个数据呢？毕竟手动管理模式并没有返回值，借鉴上面的方法，想使用一个共享变量来存放，但查了一下 Api，发现 Value() 只支持几种基本类型，但需要收集的数据类型复杂（图片来源：附录【1】）：</p>\n<p><img data-src=\"./multiprocessing_value_type.png\" alt=\"multiprocessing_value_type\" title=\"@ASSET\"></p>\n<p>实际上，multiprocessing 提供了一个非常好的内置方案：队列 Queue。Queue 允许进程按先进先出的顺序使用 <code>put()</code> 存、使用 <code>get()</code> 取对象，且允许设置读、写超时，一旦读、写超过超时时间，则中断锁并放弃操作。Queue 在读取完当前对象后会将其从队列中删除，既能保证数据读取的不重复，还能缩减内存：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    self.hashing_parts.put(data)</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主线程等待所有子线程执行完毕</span></span><br><span class=\"line\">list_data = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.append(hashing_parts.get())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-结果数据顺序问题\"><a href=\"#3-4-结果数据顺序问题\" class=\"headerlink\" title=\"3.4 结果数据顺序问题\"></a>3.4 结果数据顺序问题</h3><p>到这一步，已经可以顺利获取到所有编码完成后的返回值了，都存在 <code>list_data</code> 列表里面，只需要使用 <code>pandas.concat(list_data, ignore_index = 0)</code> 就能把所有数据拼起来成为完整的编码后数据，<strong>但是！</strong> 并行编码进程完成的顺序并不能预先确定，很可能后开始的进程先编码完并存进 list_data 内，直接拼接会导致与源数据样本顺序不一致，导致的后果是在一开始提交 PR 时管理员告诉我的：</p>\n<blockquote>\n<p>With return_df=False, a different ordering of the samples could lead into nasty surprises, because numpy.ndarray doesn’t preserve index -&gt; the training data would not be aligned with the labels anymore.</p>\n</blockquote>\n<p>意思就是，如果 HashingEncoder 设置参数 <code>return_df=False</code>, 其返回值是一个 numpy 的 ndarray 类型数据，和 DataFrame 不同，ndarray 是不保留索引的，因此特征哈希后顺序与源数据不一致会导致和标签 y 的对应关系被打乱。</p>\n<p>确实一开始我没有想到这个问题，Queue 本身其实是顺序存储，但在这里，它保障的是编码完成的顺序，而不是编码的数据的顺序，如果对数据顺序有要求，使用字典是一个很好的办法，用 key 来存放当前数据的索引位置，用 value 存放每一组数据，最后主进程获取所有的字典数据，并按照键值顺序排序后再拼接：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    start = ...  <span class=\"comment\"># 当前数据块起始下标</span></span><br><span class=\"line\">    end = ...  <span class=\"comment\"># 当前数据块结束下标</span></span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    part_index = <span class=\"built_in\">int</span>(math.ceil(end_index / self.max_sample))</span><br><span class=\"line\">    self.return_data.put(&#123;part_index: data&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">list_data = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.update(hashing_parts.get())  <span class=\"comment\"># 取出所有的代码块（无序状态）</span></span><br><span class=\"line\">sort_data = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> part_index <span class=\"keyword\">in</span> <span class=\"built_in\">sorted</span>(list_data):  <span class=\"comment\"># 将所有字典型数据块按照 key 排序后把 value 取出</span></span><br><span class=\"line\">    sort_data.append(list_data[part_index])</span><br><span class=\"line\">data = pandas.concat(sort_data, ignore_index=<span class=\"literal\">True</span>)  <span class=\"comment\"># 拼接数据</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>part_index</code> 的算法是用当前已完成的下标除以每个进程单次处理的下标，并向上取整（为了让结果更直观地从 1 开始），来作为当前数据块的定位。</p>\n<h3 id=\"3-5-子进程调用问题\"><a href=\"#3-5-子进程调用问题\" class=\"headerlink\" title=\"3.5 子进程调用问题\"></a>3.5 子进程调用问题</h3><p>到了这一步，整体逻辑已经和最终版本差异不大了，从 Demo 测试的结果来看也没有什么问题，不过毕竟这是一个面向公众的平台，不能只是写个 Demo 编译通过就了事，还得通过一定的测试验证。sklearn-category_encoders 采用的是 CI 测试部署方案，在本地可以用 nose 进行单元测试。但是在单元测试中报了这么一个错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime Error: Lock objects should only be shared between processes through inheritance.</span><br></pre></td></tr></table></figure>\n\n<p>单从报错信息来看，是提醒我们：<code>进程锁只能通过继承的方式在进程间共享</code>，好吧，helpful hah?</p>\n<p>后来我在附录【2】文中找到了有用的答案：</p>\n<blockquote>\n<p>进程锁作为一个不可直接打包的资源是没有办法作为一个参数直接给Pool的map方法里的函数传参的</p>\n</blockquote>\n<p>虽然问题并不完全一样，而且就目前来说，直接在代码中引用是可以运行的，不过我认为这是一个启发点。根据作者提供的解决方案，由于没有采用 Pool 的多进程方式，因此选择了使用 Manager 来管理共享变量：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-深拷贝问题\"><a href=\"#3-6-深拷贝问题\" class=\"headerlink\" title=\"3.6 深拷贝问题\"></a>3.6 深拷贝问题</h3><p>OK！完成了上面这些步骤，可以说，最本质的代码层和逻辑层已经完成，CI 测试也已经通过，不过命运就是这么反复无常——category_encoders 的管理员告诉我，使用这套 HashingEncoder 运行一个大数据量的基准测试时，multiprocessing 的 Manager 报错了（省略部分信息）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">180</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = _reconstruct(x, memo, *rv)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">280</span>, <span class=\"keyword\">in</span> _reconstruct</span><br><span class=\"line\">        state = deepcopy(state, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">150</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = copier(x, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">240</span>, <span class=\"keyword\">in</span> _deepcopy_dict</span><br><span class=\"line\">        y[deepcopy(key, memo)] = deepcopy(value, memo)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">multiprocessing.managers.RemoteError:</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">Unserializable message: Traceback (most recent call last):</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/managers.py&quot;</span>, line <span class=\"number\">289</span>, <span class=\"keyword\">in</span> serve_client</span><br><span class=\"line\">        send(msg)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/connection.py&quot;</span>, line <span class=\"number\">206</span>, <span class=\"keyword\">in</span> send</span><br><span class=\"line\">        self._send_bytes(_ForkingPickler.dumps(obj))</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/reduction.py&quot;</span>, line <span class=\"number\">51</span>, <span class=\"keyword\">in</span> dumps</span><br><span class=\"line\">        cls(buf, protocol).dump(obj)</span><br><span class=\"line\">TypeError: can<span class=\"string\">&#x27;t pickle _thread.lock objects</span></span><br></pre></td></tr></table></figure>\n\n<p>下栏中的 Traceback 真是让我一头雾水！点进源码里面看了半天也不知所以然，不过我注意到了上面一栏中，有一个非常关键的错误信息：<strong>deepcopy！</strong> 为了验证是不是深拷贝带来的问题写个小测试：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\">he = HashingEncoder()</span><br><span class=\"line\">he_cp = deepcopy(he)</span><br></pre></td></tr></table></figure>\n\n<p>报错复现！看来主要问题就出在深拷贝上了！从网上找了找，发现这个报错的内容比较少，不过参考的附录【3】和【4】中都指出了一个关键因素：</p>\n<blockquote>\n<ul>\n<li>进程池内部处理使用了 pickle 模块(用于 python 特有的类型和 python 的数据类型间进行转换)中的 dump(obj, file, protocol=None,) 方法对参数进行了封装处理</li>\n<li>在实现多进程的参数中，初始化了自定义类对象</li>\n</ul>\n</blockquote>\n<p>有共性就好找原因，虽然从这两篇文章来看和我本身的情况又是如此不一致，不过我似乎联想到了什么：</p>\n<p>既然造成这个错误的原因是开启子进程时，参数带有自定义类对象（通常是不可被 pickle 的），那我就从子进程的参数开始入手：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock ...</span><br><span class=\"line\">    self.hashing_parts ...</span><br><span class=\"line\">    self.done_index ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我好像发现了什么：进程锁 <code>lock</code>，数据队列 <code>hashing_parts</code>，完成下标 <code>done_index</code>，都是在 HashingEncoder 初始化时定义的，虽然这些都不是我的自定义类对象，但回顾参考一下报错信息的最后一行：</p>\n<blockquote>\n<p>TypeError: can’t pickle _thread.lock objects</p>\n</blockquote>\n<p>明确指出：进程锁 Lock 是不能被 pickle 转化的，事实上，另外两种 Value 和 Queue 都不可以，只不过因为执行到 pickle Lock 的时候就报错中断了而已。因此，把这些 Manager() 下的对象都放到创建子进程之前，并通过参数传递进去即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, _lock, _hashing_parts, _done_index</span>):</span></span><br><span class=\"line\">    _lock ...</span><br><span class=\"line\">    _hashing_parts ...</span><br><span class=\"line\">    _done_index ...</span><br><span class=\"line\"></span><br><span class=\"line\">lock = multiprocessing.Manager.Lock()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">hashing_parts = multiprocessing.Manager.Queue()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(</span><br><span class=\"line\">        <span class=\"comment\"># 通过参数传递</span></span><br><span class=\"line\">        multiprocessing.Process(target=work,</span><br><span class=\"line\">                                args=(lock, hashing_parts, done_index)))</span><br></pre></td></tr></table></figure>\n\n<p>大功告成！至此，目前所踩的坑都已解决，提交 PR，回家睡觉！</p>\n<p>另外，在查找 multiprocessing 相关内容的时候，无意间看到一个因为 <code>logging</code> 导致多进程死锁的问题，出现概率较低，记录在附录【10】。作者自己的解答为：</p>\n<blockquote>\n<p>由于主进程中使用了thread+mutiprocessing(fork)，导致logging出现死锁，现象就是遇到子进程里第一句logging就hang住。问题只会发生在Linux下。</p>\n</blockquote>\n<p>以及在本地进行单元测试时通常使用 nose 模块测试，但在提交 PR 时测试是部署在 CI 上进行的，这里面也遇到了一些问题，例如代码文件内的 example 的输入和输出必须是真实运行结果，CI 检测时会真实运行 example 的输入，并且所写的输出也要和 CI 运行结果一致。又或者由于最终提交的工具包需要面向各种环境的使用者，所以 CI 上还部署了 Python2 环境下的测试，这就使得代码必须要做兼容，例如 <code>print(Str, flush=boolean)</code> 这个简单常见的方法是基于 Python3 的，在提交的 CI 检测中就会报错，因此在本地也需要添加对应的环境自行检测，等等。对于单元测试这一部分，通过<a href=\"https://www.jianshu.com/p/8978aceac3b6\" title=\"@LINK\">基于travis-ci的单元自测（作者：lewzylu）</a>这篇文章亦获得了不少帮助，记录在附录【11】中供参考。</p>\n<hr>\n<h2 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/chenyulancn/article/details/77836593\" title=\"@LINK\">【1】python多进程共享变量Value使用tips（作者：chenyulancn）</a></li>\n<li><a href=\"https://blog.csdn.net/qq_27292549/article/details/78929296\" title=\"@LINK\">【2】python中的multiprocessing在map函数中的加锁lock处理方式（作者：qq_27292549）</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_41935140/article/details/81153611\" title=\"@LINK\">【3】使用进程池时遇到的坑…（作者：Kepner）</a></li>\n<li><a href=\"https://blog.csdn.net/qq_38765321/article/details/88376031\" title=\"@LINK\">【4】TypeError: can’t pickle _thread.lock objects（作者：voyagerlll）</a></li>\n<li><a href=\"https://www.cnblogs.com/SuKiWX/p/8804974.html\" title=\"@LINK\">【5】python中的GIL详解（作者：背着吉他的王小可）</a></li>\n<li><a href=\"https://www.cnblogs.com/kaituorensheng/p/4445418.html\" title=\"@LINK\">【6】Python多进程编程（作者：jihite）</a></li>\n<li><a href=\"https://www.cnblogs.com/gengyi/p/8647950.html\" title=\"@LINK\">【7】python学习笔记——multiprocessing 多进程组件-队列Queue（作者：耕毅）</a></li>\n<li><a href=\"https://blog.csdn.net/u013066730/article/details/82763115\" title=\"@LINK\">【8】python多进程（multiprocessing）中的Queue，Pipe（作者：mjiansun）</a></li>\n<li><a href=\"https://www.cnblogs.com/sch01ar/p/8215042.html\" title=\"@LINK\">【9】Python多进程-进程间数据的传递（作者：Sch01aR#）</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000005919174\" title=\"@LINK\">【10】使用multiprocessing.Process调用start方法后，有较小的几率子进程中run方法未执行（作者：从星空仰望地球）</a></li>\n<li><a href=\"https://www.jianshu.com/p/8978aceac3b6\" title=\"@LINK\">【11】基于travis-ci的单元自测（作者：lewzylu）</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33762321/article/details/88275111\" title=\"@LINK\">【12】数据特征处理之特征哈希（Feature Hashing）（作者：weixin_33762321）</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1593454269874725931&wfr=spider&for=pc&isFailFlag=1\" title=\"@LINK\">【13】人工智能之机器学习篇——哈希学习learning to hash（作者：人工智能产业研究院）</a></li>\n<li><a href=\"http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html\" title=\"@LINK\">【14】特征哈希（Feature Hashing）（作者：Breezedeus）</a></li>\n<li><a href=\"https://www.datalearner.com/blog/1051537932880901\" title=\"@LINK\">【15】数据特征处理之特征哈希（Feature Hashing）（作者：小木）</a></li>\n<li><a href=\"https://blog.csdn.net/laolu1573/article/details/79410187\" title=\"@LINK\">【16】Feature hashing(特征哈希)（作者：大师鲁）</a></li>\n<li><a href=\"https://blog.csdn.net/vim_wj/article/details/78300239\" title=\"@LINK\">【17】github—-向开源框架提交pr的过程（作者：vim_wj）</a></li>\n</ul>\n</blockquote>\n","categories":["Python"],"tags":["AI","SKLearn","HashingEncoder","哈希编码","多线程"]},{"title":"Python中的下划线与函数的花式调用","url":"/post/python/python-underline/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Python中的下划线与函数的花式调用\"><a href=\"#Python中的下划线与函数的花式调用\" class=\"headerlink\" title=\"Python中的下划线与函数的花式调用\"></a>Python中的下划线与函数的花式调用</h1><p>前言：今天在看一个 TF 程序的时候，发现很多例程都喜欢把 main 函数定义为：<code>main(_)</code>，而不是 <code>main(argv=None)</code>，当然对于一个 Python 程序而言，一切皆为对象，用下划线当做参数变量并没什么好奇怪的（毕竟连 <code>...</code> 都是一个 Ellipsis 对象，甚至可以修改其默认值），但如此广泛应用，应当是有一定原因的，找了找论坛和 SOF，简略看了一下 TF 中 <code>run()</code> 函数的源码（主要是复杂的看不懂），算是初步了解了 Python 中下划线的应用，而且还无意间看到了一篇关于 Python 函数“花式”调用的文章，受益匪浅。</p>\n<hr>\n<h2 id=\"1-来源\"><a href=\"#1-来源\" class=\"headerlink\" title=\"1. 来源\"></a>1. 来源</h2><p>最开始有这个疑问是因为今天 <del>突发奇想心血来潮自我膨胀差点上天的</del> 看了看 TinyMind 里面的云平台，进去还送了 2 点平台点数，本着不用白不用的心态，想想亚马逊和阿里比较昂贵的价格，准备试试看这里效果怎么样，然后点开官方文档就看到了一个巨经典的例程：mnist 手写识别，虽然写是写过，不过自己是基于 C++ 写的，Python 的代码还是可以好好看看，这一看就发现了简介中的现象，作为一个码（fei）农（zhai），遇到问题当然是问。。哦对了，千万不要再汤很凉上搜索“_”这个关键词。</p>\n<hr>\n<h2 id=\"2-Python基础语法中的下划线\"><a href=\"#2-Python基础语法中的下划线\" class=\"headerlink\" title=\"2. Python基础语法中的下划线\"></a>2. Python基础语法中的下划线</h2><p>如果写过 Python，其他下划线不多说，至少 <code>__name__</code> 和 <code>__init__</code> 是见过的，以前只想过这是语法规定以及一点都不优雅，这回是好好整理了一把，先列出 Python 中可能存在的 5 种下划线的情况：</p>\n<ol>\n<li>单前下划线：<code>_sample</code></li>\n<li>单后下划线：<code>sample_</code></li>\n<li>双前下划线：<code>__sample</code></li>\n<li>前后双下划线：<code>__sample__</code></li>\n<li>单独下划线：<code>_</code></li>\n</ol>\n<h3 id=\"2-1-单前下划线：-sample\"><a href=\"#2-1-单前下划线：-sample\" class=\"headerlink\" title=\"2.1 单前下划线：_sample\"></a>2.1 单前下划线：_sample</h3><p>单前下划线的写法非常“约定俗成”——纯粹只是一种习惯和写法的延续，用于表示该变量是个 函数/类 的内部变量，写不写完全看个人习惯。但在一种特殊情况下，单前下划线是有特殊作用的，下面用代码说明。<br>首先定义一个类 ClassA，重写构造方法并定义两个变量：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.normal + <span class=\"string\">&quot; | &quot;</span> + a._pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal | PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>运行输出也很正常，这说明单前下划线并不影响一个变量被访问，这时我们考虑一种情况，假设在一个 module：im_module.py 中有两个函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># im_module.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normal_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pre_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;PreUnderline&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接着在别的地方把这个 module 导入并调用其函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> im_module <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">NameError: <span class=\"string\">&quot;name &#x27;_pre_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一种虽然不好但很常见的导入方式，但结果呢？是的，在使用通配符 <em> 导入的时候，解释器会过滤掉单前下划线的成员。 <em>*但！</em></em> 前文也说了，通配符导入并不是良好的编码习惯，这种导入方式非常容易导入 无关/冲突/未知/… 的部分，因此通常还是应该手动选择需要导入的部分，如果需要导入全体，则应该使用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> im_module</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>这次的输出结果一切正常。</p>\n<p>也就是说，除非使用通配符 <code>*</code> 的方式进行导入，会导致单前下划线修饰的成员被忽略，否则与不带下划线的成员没有区别。</p>\n<p>除了这种特殊情况之外，就像 Java 中喜欢用 m 前缀来表示成员变量一样，这仅仅只是一种提醒功能，具体好不好、对不对、有没有用呢，那就仁者见仁了，一般是根据团队项目最初定的标准来决定，个人项目就纯粹看习惯了。顺便提一句，在 Google 官方的 <a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">Java Style Guide</a> 中并不推荐这种写法，当然这也跟如今 IDE 的智能有关，如果使用的编辑器没有代码高亮或者提示功能，还是建议加上吧，这篇文档的中译版可参考附录【2】。</p>\n<h3 id=\"2-2-单后下划线：sample\"><a href=\"#2-2-单后下划线：sample\" class=\"headerlink\" title=\"2.2 单后下划线：sample_\"></a>2.2 单后下划线：sample_</h3><p>单后下划线相对而言可能使用场景还比较多，它的主要功能是“规避”关键字冲突。Python 中有许多关键字，例如 <code>class</code>，<code>sum</code>，<code>len</code>，<code>type</code> 等，但在许多时候，我们自己定义的变量、方法等，很难找到更适合的表示单词，或是改变写法又太麻烦/不直观，例如学校、师生类中的“班级属性 class”，商品的“种类 type”，这时候如果我们不想费时间写出像 class_num 或者 type_name 这样的标识符，或许可以直接用 <code>class_</code> 和 <code>type_</code> 代替，这样既避免了和关键字的冲突，又能很直观地表示其含义。</p>\n<h3 id=\"2-3-双前下划线：-sample\"><a href=\"#2-3-双前下划线：-sample\" class=\"headerlink\" title=\"2.3 双前下划线：__sample\"></a>2.3 双前下划线：__sample</h3><p>这个就有点意思了，用双前下划线标识的属性，解释器会重写名称，以避免子类中的命名冲突，其效果对属性和函数是一样的，以下代码仅用属性举例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;DoublePreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用 dir() 函数查看 ClassA 对象的属性</span></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">dir</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>, <span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ge__&#x27;</span>, <span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init__&#x27;</span>, <span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__module__&#x27;</span>, <span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce_ex__&#x27;</span>, <span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__str__&#x27;</span>, <span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在输出的结尾，<code>_pre</code> 和 <code>normal</code> 都在，唯独不见了 <code>__double_pre</code>？其实并不是没有，而是解释器自动改变了其内部形式，就在输出的第一个：<code>_ClassA__double_pre</code>，解释器自动为这个属性增加了一个当前所属类的类名标识 <code>_ClassA</code>。</p>\n<p>这也意味着，即使在 ClassA 所在的当前 module 内，如果需要调用这个属性，用 <code>ClassA().__double_pre</code> 也会报错 <code>AttributeError: &quot;&#39;ClassA&#39; object has no attribute &#39;__double_pre&#39;&quot;</code> ，而应该使用 <code>ClassA()._ClassA__double_pre</code> 的方式调用。</p>\n<p>为什么要这样，又有什么用呢，用下面的代码就可以说明：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span>(<span class=\"params\">ClassA</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 继承自 ClassA</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>(ClassB, self).__init__()</span><br><span class=\"line\">        <span class=\"comment\"># 也可以直接覆写</span></span><br><span class=\"line\">        <span class=\"comment\"># super().__init__()</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;_ClassB__double_pre&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>, <span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>, <span class=\"string\">&#x27;__ge__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>, <span class=\"string\">&#x27;__init__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>, <span class=\"string\">&#x27;__module__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>, <span class=\"string\">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>, <span class=\"string\">&#x27;__str__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>不论是继承自 ClassA 也好，还是直接覆写也好，其最终的输出中都既有 <code>_ClassA__double_pre</code>，也有 <code>_ClassB__double_pre</code>，同样，也是因为解释器自动给 <code>__double_pre</code> 增加了一个当前所属类的类名标识 <code>_ClassB</code>，因此父类 ClassA 中的 <code>__double_pre</code> 并不会被重写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(b.normal)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassA__double_pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassB__double_pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Override</span><br><span class=\"line\">Override</span><br><span class=\"line\">DoublePreUnderline</span><br><span class=\"line\">Override</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，被前双下划线标识的属性是不会被重写的</p>\n<p>此外，还有一个特别有意思的应用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ClassC__double_pre = <span class=\"string\">&quot;DoublePreinClassC&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassC</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> __double_pre</span><br><span class=\"line\"></span><br><span class=\"line\">ClassC.call()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">DoublePreinClassC</span><br></pre></td></tr></table></figure>\n\n<p>乍一看在 ClassC 的 <code>call()</code> 方法中返回的 <code>__double_pre</code> 根本没有定义啊，应该报 NameError 错误才对，实际上，因为在上面手动定义的 <code>_ClassC__double_pre</code> 具有 <code>_ClassC</code> 前缀，因此程序调用 call 方法的时候，解释器会自动给 <code>__double_pre</code> 加上 <code>_ClassC</code> 前缀，而又恰好存在这么个变量，因此可以正常输出。</p>\n<p>这也说明，如果某个类内有属性/方法是以双前下划线修饰，则解释器会自动给双前下划线的成员添加其所属类的前缀，这种转换适用于整个类内所有以双前下划线开头的任何名称，而不论它是一个变量还是方法还是其他。</p>\n<h3 id=\"2-4-前后双下划线：-sample\"><a href=\"#2-4-前后双下划线：-sample\" class=\"headerlink\" title=\"2.4 前后双下划线：__sample__\"></a>2.4 前后双下划线：__sample__</h3><p>这个就好解释多了，也常见的多了，Python 保留了许多用前后双下划线修饰的属性/方法，像 __name__ 或是 __init__()，当然只要我们愿意，并且命名不冲突，我们也可以自行定义前后双下划线修饰的成员，这本身是没有错的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">__test__ = <span class=\"string\">&quot;Test&quot;</span></span><br><span class=\"line\">__test__</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Test</span><br></pre></td></tr></table></figure>\n\n<p>但不太推荐这么做，主要原因是 Python 官方保留了这么命名的做法，因此可能现在没有发生冲突的一些命名，在未来 Python 经过更新后由于官方加入了对应的保留成员而导致冲突。</p>\n<p>因此，干脆就不要使用自定的前后双下划线成员，并且记住这样修饰的都是 Python 保留命名就好了。</p>\n<p>不过我觉得一般也没什么人愿意如此麻烦的加上四个下划线吧，说不定 Python 当年就是考虑到这个才这么设计呢（逃）。</p>\n<h3 id=\"2-5-单下划线：\"><a href=\"#2-5-单下划线：\" class=\"headerlink\" title=\"2.5 单下划线：_\"></a>2.5 单下划线：_</h3><p>说实话我第一次见到这个写法的时候还以为是源码写错了，不过其实通俗的讲，既然 Python 一切皆为对象，当然也就可以把 <code>_</code> 当做很普通的成员使用，事实也确实如此：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ = <span class=\"string\">&quot;Underline&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">_ = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a + b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Underline</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\">ab</span><br></pre></td></tr></table></figure>\n\n<p>玩上瘾了，我相信如果你在团队项目里面大量使用 <code>_</code> 作为变量/方法名，明年就该有坟头草了。<br>正经的解释：如果某个变量、方法、参数没有实际用途，可以使用 <code>_</code> 来代替，以表明这是个可以忽略的部分。说起来好像没什么用，其实在真正的源码中，这个用法可以大幅提高阅读感，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">user = (<span class=\"string\">&#x27;ZhangSan&#x27;</span>, <span class=\"string\">&#x27;20岁&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>, <span class=\"string\">&#x27;80分&#x27;</span>, <span class=\"string\">&#x27;野鸡大学&#x27;</span>, <span class=\"string\">&#x27;计算机专业&#x27;</span>, <span class=\"string\">&#x27;物联网工程&#x27;</span>)</span><br><span class=\"line\">name, _, _, _, college, _, _ = user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(college)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ZhangSan</span><br><span class=\"line\">野鸡大学</span><br><span class=\"line\">物联网工程</span><br></pre></td></tr></table></figure>\n\n<p>这么写出来的代码，阅读时可以非常直观地看出来，这些消息里面我关注的只有 name 和 college，其中 <code>_</code> 被多次赋值，因此输出的值是最后一次赋值“物联网工程”。</p>\n<p>另外，<code>_</code> 还是大多数 Python REPL 中的一个特殊变量，它不仅可以当做普通的变量、方法正常调用，还会自动保存你最后一次计算的结果，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;ABCD&quot;</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">list</span>()</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">_.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>但请注意</strong>：如果你已经手动给 <code>_</code> 赋值，则它在当前上下文范围内不会再自动保存你的计算结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">a</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ = <span class=\"string\">&quot;A&quot;</span></span><br><span class=\"line\">a += <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，<code>_</code> 在未被手动赋值前，当前上下文内每次计算的记过都会赋值给 <code>_</code>，直到你手动给 <code>_</code> 赋值使其称为一个常规成员。</p>\n<h3 id=\"2-6-name-的应用\"><a href=\"#2-6-name-的应用\" class=\"headerlink\" title=\"2.6 __name__的应用\"></a>2.6 __name__的应用</h3><p>__name__ 可以说是 Python 中的一大常客了，最常见的形式就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>通常这个语句会作为一个程序的入口，但为什么会有这么奇怪的一个条件语句呢？用代码一下就能解释明白。首先创建一个 module：rate.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">LEARNING_RATE = <span class=\"number\">1.005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call_rate</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Rate is :&quot;</span>, LEARN_RATE)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Value of __name__ :&quot;</span>, __name__)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    call_rate()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果：</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : __main__</span><br><span class=\"line\">Rate <span class=\"keyword\">is</span> : <span class=\"number\">1.005</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到此时 <code>__name__ == &quot;__main__&quot;</code>，如果再新建一个 module：test.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> rate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(rate.LEARNING_RATE * <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : rate</span><br><span class=\"line\"><span class=\"number\">2.01</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，rate.py 中的 <code>__name__</code> 变成了 “rate”，因此条件语句没有执行。</p>\n<p>因此，<code>__name__</code> 可以用来判断该 module 是直接执行的还是被其他 module 引入后执行的。</p>\n<h3 id=\"2-7-TensorFlow中的run-方法\"><a href=\"#2-7-TensorFlow中的run-方法\" class=\"headerlink\" title=\"2.7 TensorFlow中的run()方法\"></a>2.7 TensorFlow中的run()方法</h3><p>先来看看 TF 中 run() 方法的源码：</p>\n<p><img data-src=\"./code_of_run_in_tf.png\" alt=\"TF 中 run() 方法源码\" title=\"@ASSET\"></p>\n<p>从图中可以看出来，当传的参数 main 为空时，跳过执行，如果不为空，则调用 main 函数，因此想要调用 <code>tf.app.run()</code> 方法，则需要在模型程序中定义 <code>main(argv)</code> 函数，并且接收参数 args，如果模型不需要使用这些参数，就可以用 <code>main(_)</code> 来表示，也就回答了最开始的问题。</p>\n<hr>\n<h2 id=\"3-Python中方法的花式调用\"><a href=\"#3-Python中方法的花式调用\" class=\"headerlink\" title=\"3. Python中方法的花式调用\"></a>3. Python中方法的花式调用</h2><p>首先，几乎在所有的程序中，调用函数/方法的步骤无非就两个：① 定义，② 调用。在 Python 中也是如此，使用关键字 def 来声明一个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n<p>似乎我们所熟知的函数/方法调用也就只有这一种，但 Python 还有一种很好玩的调用方式：根据名称调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_a</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function A&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_b</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function B&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_c</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function C&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;func_a&quot;</span>)()</span><br><span class=\"line\"><span class=\"built_in\">locals</span>()[<span class=\"string\">&quot;func_b&quot;</span>]()</span><br><span class=\"line\"><span class=\"built_in\">globals</span>()[<span class=\"string\">&quot;func_c&quot;</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Method function A</span><br><span class=\"line\">Method function B</span><br><span class=\"line\">Method function C</span><br></pre></td></tr></table></figure>\n\n<p>eval() 函数可以直接转换成函数调用，而 <code>locals()</code> 和 <code>globals()</code> 可以通过字典的方式访问局部、全局变量。之所以 Python 支持这种形式的调用，是因为 Python 使用 <strong>名字空间</strong> 来记录变量的变化。每个函数都有自已的名字空间，称为局部名字空间，其记录了函数的变量，包括函数的参数和局部定义的变量；每个 module 也都有自已的名字空间，称为全局名字空间，其记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量；还有一个内置名字空间，任何 module 均可访问，其存放了内置的函数和异常。名字空间是一个字典，键 key 就是变量名，值 value 就是变量的值，名字空间就像 Python 的普通字典一样可以进行访问。当某行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：</p>\n<ol>\n<li>局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python 将使用这个变量，然后停止搜索。</li>\n<li>全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用这个变量然后停止搜索。</li>\n<li>内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。</li>\n</ol>\n<p>如果Python在这些名字空间找不到 x，就会放弃查找并引发一个 NameError 的异常，同时传递 “There is no variable named ‘x’” 错误信息。</p>\n<p>在 Java 或 C/C++ 等编译语言中，编译器会将代码编译为二进制文件执行，在程序内部，是没有“变量名”这个概念的，所以我们的代码只能通过变量名取值，而不能通过具体的变量获得变量名（当然可以用 Map 的方式手动保存，但这本身脱离了原意），但在 Java 中，有一种很类似的样例就是 <a href=\"/post/android/android-objectanimator/android-objectanimator\" title=\"@LINK\">ObjectAnimator</a> 中的属性名 Attr，调用该方法会通过设置的属性名去获取对应控件下的 setAttr() 方法，和此处的命名空间有着异曲同工之妙。</p>\n<hr>\n<h2 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h2><blockquote>\n<ul>\n<li><a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">【1】Google Java Style Guild（作者：Google）</a></li>\n<li><a href=\"https://blog.csdn.net/harrytsz/article/details/63328086\" title=\"@LINK\">【2】Google Java Style Guide中文版（作者：Harrytsz）</a></li>\n<li><a href=\"https://www.cnblogs.com/amou/p/9530932.html\" title=\"@LINK\">【3】18式优雅你的Python（作者：梁云）</a></li>\n</ul>\n</blockquote>\n","categories":["Python"],"tags":["Python","Underline","下划线","同名函数"]},{"title":"ML入门-交叉验证与模型选择","url":"/post/machinelearning/ml-model/ml-model-selection/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-交叉验证与模型选择\"><a href=\"#ML入门-交叉验证与模型选择\" class=\"headerlink\" title=\"ML入门-交叉验证与模型选择\"></a>ML入门-交叉验证与模型选择</h1><h2 id=\"1-模型的交叉验证\"><a href=\"#1-模型的交叉验证\" class=\"headerlink\" title=\"1. 模型的交叉验证\"></a>1. 模型的交叉验证</h2><h3 id=\"1-1-划分校验集\"><a href=\"#1-1-划分校验集\" class=\"headerlink\" title=\"1.1 划分校验集\"></a>1.1 划分校验集</h3><p>模型的评估不能在训练集上进行，而应该在新的测试数据上检验其 推广能力 / 泛化能力。但在实际任务中，测试数据往往是需要用来预测的数据，其标签是未知的，因此可以选择从全体训练数据中分离出一部分作为校验数据，不参与模型的训练：</p>\n<p><img data-src=\"./check_data.png\" alt=\"校验数据\" title=\"@ASSET\"></p>\n<p>当训练样本足够多时，划分剩下的训练样本仍足以训练出较好的模型时，即可采用这个方式。Scikit-Learn 中提供了划分校验集的功能：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.train_test_split</span></span><br><span class=\"line\"></span><br><span class=\"line\">X_train, X_test, y_train, y_test = train_test_split(*arrays, **options)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X, y = np.arange(<span class=\"number\">10</span>).reshape((<span class=\"number\">5</span>, <span class=\"number\">2</span>)), <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X</span><br><span class=\"line\">array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(y)</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class=\"line\">         X, y, test_size=<span class=\"number\">0.33</span>, random_state=<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train</span><br><span class=\"line\">array([[<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_train</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_test</span><br><span class=\"line\">array([[<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_test</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>train_test_split(y, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\">[[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>*arrays</code>: 需要划分的数据 (X, y)。sequence of indexables with same length / shape[0].</p>\n<p>Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.</p>\n</li>\n<li><p><code>test_size</code>: 校验集大小。float, int or None, optional (default=None)</p>\n<p>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If train_size is also None, it will be set to 0.25.</p>\n</li>\n<li><p><code>train_size</code>: 训练集大小。float, int, or None, (default=None)</p>\n<p>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.</p>\n</li>\n<li><p><code>random_state</code>: 随机种子。int, RandomState instance or None, optional (default=None)</p>\n<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.</p>\n</li>\n<li><p><code>shuffle</code>: 划分数据前是否洗牌。boolean, optional (default=True)</p>\n<p>Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.</p>\n</li>\n<li><p><code>stratify</code>: 分层抽样。array-like or None (default=None)</p>\n<ul>\n<li><p>If not None, data is split in a stratified fashion, using this as the class labels.</p>\n</li>\n<li><p>分层抽样主要用在分类数据类别样本不均衡的时候，如正负样本比例为 1 : 9，假设划 20% 作为校验数据，则分别对正样本和负样本各自划分 20% 作为校验数据再合并。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>train_test_split</code> 还能在数据集较大时，用来分隔出小部分数据进行 EDA。</p>\n</blockquote>\n<h3 id=\"1-2-交叉验证\"><a href=\"#1-2-交叉验证\" class=\"headerlink\" title=\"1.2 交叉验证\"></a>1.2 交叉验证</h3><p>当训练数据比较少，或模型训练需要更多数据时（训练样本越多越好），直接分离校验集就不太好了，这时可使用 K 折交叉验证。</p>\n<p>K 折交叉验证即：将全体训练样本等分为 K 份（若无法完全等分，多出来的部分都放进最后一份中），每次用 1 份数据作为校验集，余下 (K - 1) 份作为训练数据，重复 K 次：</p>\n<p><img data-src=\"./k_fold.png\" alt=\"K 折交叉验证\" title=\"@ASSET\"></p>\n<blockquote>\n<p>该方法计算代价很高，但不会浪费太多数据，当样本数据集较少时有优势，K 常取 [3, 5, 10]。</p>\n</blockquote>\n<p>Scikit-Learn 中实现了 K 折交叉验证 <code>KFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.KFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">KFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">      shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>n_splits</code>: 交叉验证的折数 K，默认为 3。</p>\n</li>\n<li><p><code>shuffle</code>: 是否在划分数据之前对全体数据进行洗牌（打乱顺序）。</p>\n</li>\n<li><p><code>random_state</code>: 由随机数产生器产生的随机种子。当参数 <code>shuffle == True</code> 时用到。</p>\n</li>\n</ul>\n<p>当数据是分类数据时（标签 y 为类别），为保证每折中各个类别样本比例一致，Scikit-Learn 实现了分层（Stratified）的 K 折交叉验证 <code>StratifiedKFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.StratifiedKFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">                shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                random_state=<span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> StratifiedKFold</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf = StratifiedKFold(n_splits=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf.get_n_splits(X, y)  <span class=\"comment\"># 得到划分结果</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf</span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">2</span>, random_state=<span class=\"literal\">None</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> train_index, test_index <span class=\"keyword\">in</span> skf.split(X, y):</span><br><span class=\"line\">    <span class=\"comment\"># split() 取出每折训练和校验数据的索引</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;TRAIN:&quot;</span>, train_index, <span class=\"string\">&quot;TEST:&quot;</span>, test_index)</span><br><span class=\"line\">        X_train, X_test = X[train_index], X[test_index]</span><br><span class=\"line\">        y_train, y_test = y[train_index], y[test_index]</span><br><span class=\"line\"></span><br><span class=\"line\">TRAIN: [<span class=\"number\">1</span> <span class=\"number\">3</span>] TEST: [<span class=\"number\">0</span> <span class=\"number\">2</span>]</span><br><span class=\"line\">TRAIN: [<span class=\"number\">0</span> <span class=\"number\">2</span>] TEST: [<span class=\"number\">1</span> <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>StratifiedKFold</code> 参数含义与 <code>KFold</code> 相同。</p>\n<p>假设有一训练数据集如下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">样本索引</th>\n<th align=\"center\">$x_1$</th>\n<th align=\"center\">$x_2$</th>\n<th align=\"center\">y</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>K 折交叉验证中，校验验证通常用于 模型选择 / 超参数调优（评价不同超参数对应模型的性能）。交叉验证的步骤流程如下图：</p>\n<p><img data-src=\"./k_fold_detail.png\" alt=\"K 折交叉验证流程\" title=\"@ASSET\"></p>\n<p>Scikit-Learn 中实现两个了采用 K 折交叉验证评估模型性能的函数：<code>cross_val_score</code> 和 <code>cross_validate</code>：</p>\n<h4 id=\"1-2-1-cross-val-score\"><a href=\"#1-2-1-cross-val-score\" class=\"headerlink\" title=\"1.2.1 cross_val_score\"></a>1.2.1 cross_val_score</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_val_score</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_val_score(estimator,</span><br><span class=\"line\">                X,</span><br><span class=\"line\">                y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_val_score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(cross_val_score(lasso, X, y, cv=<span class=\"number\">3</span>))</span><br><span class=\"line\">[<span class=\"number\">0.33150734</span> <span class=\"number\">0.08022311</span> <span class=\"number\">0.03531764</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>estimator</code>: 要训练的模型</p>\n</li>\n<li><p><code>X, y</code>: 全体训练数据</p>\n</li>\n<li><p><code>groups</code>: 数据的分组标识。</p>\n<p>通常假设数据是独立同分布（Independent Identical Distribution, IID），但在有些应用中如果数据生成过程依赖于样本的 groups，（如从多个患者收集医学数据，从每个患者身上采集多个样本。则每个样本的患者 ID 是其分组标识）。在这种情况下，想知道在一组特定的 groups 上训练的模型是否能很好地适用于未见过的 group 。因此，要确保验证数据的所有样本与对应的训练折中的数据没有相同的组。（Scikit-Learn 中有一整套与 groups 有关的校验验证实现）。</p>\n</li>\n<li><p><code>scoring</code>: 评价指标。</p>\n</li>\n<li><p><code>cv</code>: 交叉校验划分策略。可为整数（交叉验证的折数 K）、交叉验证生成器的对象、产生 train / test 划分的迭代器对象。默认为 <code>None</code>，采用3折交叉验证。输入类别数据时，自动采用分层抽样。</p>\n</li>\n<li><p><code>n_jobs</code>: 使用CPU的数目，-1 表示使用所有的CPU资源（与设置为 CPU 核的数目效果相同）。</p>\n</li>\n<li><p><code>verbose</code>: 日志冗长度。</p>\n<ul>\n<li>0：不输出训练过程</li>\n<li>1：偶尔输出</li>\n<li>$&gt; 1$：对每个子模型都输出</li>\n</ul>\n</li>\n<li><p><code>fit_params</code>: estimator 的 <code>fit()</code> 函数需要的参数。</p>\n</li>\n<li><p><code>pre_dispatch</code>: 控制并行计算中预派遣的任务数。</p>\n<p>根据设备条件（内存大小）设置。例如 12 折 CV 任务，且 <code>n_jobs = 3</code>。</p>\n<ol>\n<li>当该参数不设置时，程序一次性将所有并行任务派遣给 CPU，则 3 个 CPU 各获得 4 份 CV 训练数据集和 4 份 测试数据集，并存放在内存中，各个 CPU 则按顺序训练，此时内存占用最高，但由于提前一次性将所有数据分配完毕，开始训练后的等待时间最小。</li>\n<li>当设置 <code>pre_dispatch=&#39;1*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 3</code>，则程序每次只为 3 个 CPU 各分配一份数据，分配后 CPU 立即开始训练，训练完成后再次分配，此时内存占用最低，但由于每次训练完后才分配数据，开始训练后的等待时间最长。</li>\n<li>当设置 <code>pre_dispatch=&#39;2*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 6</code>，则 3 个 CPU 各获得两份 CV 训练数据（一份即时训练，另一份在队列中等待）并存储在内存中，当某个 CPU 训练完一份 CV 数据后，程序再分配下一份数据，直到所有数据均被分配完毕。通常这种设置的综合效果最佳。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-2-cross-validate\"><a href=\"#1-2-2-cross-validate\" class=\"headerlink\" title=\"1.2.2 cross_validate\"></a>1.2.2 cross_validate</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_validate(estimator,</span><br><span class=\"line\">               X,</span><br><span class=\"line\">               y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">               verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">               fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">               return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_validate</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics.scorer <span class=\"keyword\">import</span> make_scorer</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> confusion_matrix</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.svm <span class=\"keyword\">import</span> LinearSVC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Single metric evaluation using cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(cv_results.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;fit_time&#x27;</span>, <span class=\"string\">&#x27;score_time&#x27;</span>, <span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cross_validate 可以得到每折的训练和校验得分，此处仅查看校验得分。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results[<span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\">array([<span class=\"number\">0.33150734</span>, <span class=\"number\">0.08022311</span>, <span class=\"number\">0.03531764</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiple metric evaluation using cross_validate</span></span><br><span class=\"line\"><span class=\"comment\"># (please refer the scoring parameter doc for more information)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scores = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                        scoring=(<span class=\"string\">&#x27;r2&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                                 <span class=\"string\">&#x27;neg_mean_squared_error&#x27;</span>),</span><br><span class=\"line\"><span class=\"meta\">... </span>                        return_train_score=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多种评价指标：&#x27;r2&#x27;, &#x27;neg_mean_squared_error&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;test_neg_mean_squared_error&#x27;</span>])</span><br><span class=\"line\">[-<span class=\"number\">3635.5</span>... -<span class=\"number\">3573.3</span>... -<span class=\"number\">6114.7</span>...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;train_r2&#x27;</span>])</span><br><span class=\"line\">[<span class=\"number\">0.28010158</span> <span class=\"number\">0.39088426</span> <span class=\"number\">0.22784852</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>return_train_score</code>: 是否包含训练得分。</p>\n<p>默认 ‘warn’ 表示真，包含训练得分。计算训练得分可以通过训练得分和校验得分查看模型在过拟合状态还是欠拟合状态。但是训练得分较慢，且不计算也不影响模型 的最佳参数选取（最佳参数只看校验得分），后续版本可能将缺省值设为 <code>False</code>。</p>\n</li>\n<li><p>其他参数与 <code>cross_val_score</code> 相同。</p>\n</li>\n</ul>\n<p>使用 <code>cross_validate</code> 可以输出训练集和校验集上的分数，从而判断是否处于欠拟合或过拟合的状态。</p>\n<h3 id=\"1-3-特殊的交叉验证\"><a href=\"#1-3-特殊的交叉验证\" class=\"headerlink\" title=\"1.3 特殊的交叉验证\"></a>1.3 特殊的交叉验证</h3><h4 id=\"1-3-1-留一交叉验证\"><a href=\"#1-3-1-留一交叉验证\" class=\"headerlink\" title=\"1.3.1 留一交叉验证\"></a>1.3.1 留一交叉验证</h4><p>特别地，当交叉验证的折数与样本数相等时（$K = N$），因为每次仅留出一个样本做校验，因此称为留一交叉验证。由于折数更多，通常进行时间也更长，一般仅在样本数非常少的时候使用。</p>\n<p>但对于线性模型，可以采用广义交叉验证（Generalized Cross Validation, GCV）来近似留一交叉验证，极大降低交叉验证的计算量。Scikit-Learn 中实现了基于 GCV 的线性模型，如：<code>RidgeCV</code>, <code>LassoCV</code>, <code>LogisticRegressionCV</code> 等。其流程大致如下图：</p>\n<p><img data-src=\"./leave_one_cv.png\" alt=\"留一交叉验证\" title=\"@ASSET\"></p>\n<h4 id=\"1-3-2-自助法（Bootstrap）\"><a href=\"#1-3-2-自助法（Bootstrap）\" class=\"headerlink\" title=\"1.3.2 自助法（Bootstrap）\"></a>1.3.2 自助法（Bootstrap）</h4><p>交叉验证（包括留一交叉验证）均为无放回采样，一个实例仅能被选择一次。而 Bootstrap 是有放回采样，假设数据集中有 N 个样本，每次有放回地从数据集中抽取一个样本，共采样 N 次。一个 Bootstrap 样本有 N 个样本，其中很可能存在重复数据。由于每个样本被采样的概率为 $\\dfrac {1} {N}$，则不被采样的概率为 $1 - \\dfrac {1} {N}$，因此一个 Bootstrap 的 N 个样本中，某个样本点不被采样的概率为 $(1 - \\dfrac{1} {N})^N \\approx 0.368$，也即一个 Bootstrap 样本中只包含了全体训练集中约 $63.2 \\%$ 的数据（K 折交叉验证每次包含 $1 - \\dfrac {1} {K}$ 的训练数据），因此也称为“0.632 自助法”。</p>\n<h4 id=\"1-3-3-特殊的校验验证\"><a href=\"#1-3-3-特殊的校验验证\" class=\"headerlink\" title=\"1.3.3 特殊的校验验证\"></a>1.3.3 特殊的校验验证</h4><p>通常，训练数据假设是独立同分布的（Independent Identical Distribution, IID）。</p>\n<p>但在实际任务中，有时样本时使用与时间相关的过程生成的，也即样本间存在时序关系，样本与各自的时序强相关，例如股票的价格等，此时使用 time-series aware cross-validation scheme 更安全。</p>\n<p>同样，如果知道数据生成过程中具有分组结构（group structure），例如从不同 subjects、不同实验、不同测量设备收集的样本等，则使用 group-wise cross-validation 更安全。</p>\n<hr>\n<h2 id=\"2-超参数调优\"><a href=\"#2-超参数调优\" class=\"headerlink\" title=\"2. 超参数调优\"></a>2. 超参数调优</h2><p>Scikit-Learn 中实现了基于交叉验证的模型超参数调优方法 <code>GridSearchCV</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.GridSearchCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">GridSearchCV(estimator,</span><br><span class=\"line\">             param_grid,</span><br><span class=\"line\">             scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">             iid=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             refit=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">             error_score=<span class=\"string\">&#x27;raise&#x27;</span>,</span><br><span class=\"line\">             return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> svm, datasets</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> GridSearchCV</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>iris = datasets.load_iris()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parameters = &#123;<span class=\"string\">&#x27;kernel&#x27;</span>:(<span class=\"string\">&#x27;linear&#x27;</span>, <span class=\"string\">&#x27;rbf&#x27;</span>), <span class=\"string\">&#x27;C&#x27;</span>:[<span class=\"number\">1</span>, <span class=\"number\">10</span>]&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>svc = svm.SVC(gamma=<span class=\"string\">&quot;scale&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf = GridSearchCV(svc, parameters, cv=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fit 过程可能较慢，若有 M 个参数需搜索，采用 K 折交叉验证，则需训练 M x K 次。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf.fit(iris.data, iris.target)</span><br><span class=\"line\">GridSearchCV(cv=<span class=\"number\">5</span>,</span><br><span class=\"line\">             error_score=...,</span><br><span class=\"line\">             estimator=SVC(C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                           cache_size=...,</span><br><span class=\"line\">                           class_weight=...,</span><br><span class=\"line\">                           coef0=...,</span><br><span class=\"line\">                           decision_function_shape=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                           degree=...,</span><br><span class=\"line\">                           gamma=...,</span><br><span class=\"line\">                           kernel=<span class=\"string\">&#x27;rbf&#x27;</span>,</span><br><span class=\"line\">                           max_iter=-<span class=\"number\">1</span>,</span><br><span class=\"line\">                           probability=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                           shrinking=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                           tol=...,</span><br><span class=\"line\">                           verbose=<span class=\"literal\">False</span>),</span><br><span class=\"line\">             iid=...,</span><br><span class=\"line\">             n_jobs=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             param_grid=...,</span><br><span class=\"line\">             pre_dispatch=...,</span><br><span class=\"line\">             refit=...,</span><br><span class=\"line\">             return_train_score=...,</span><br><span class=\"line\">             scoring=...,</span><br><span class=\"line\">             verbose=...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出的结果都保存在字典 cv_results_ 中。</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳超参数：best_params_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳得分：best_score_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳模型：best_estimator_，仅在设置 refit=true 时适用</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(clf.cv_results_.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;mean_fit_time&#x27;</span>, <span class=\"string\">&#x27;mean_score_time&#x27;</span>, <span class=\"string\">&#x27;mean_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;param_C&#x27;</span>, <span class=\"string\">&#x27;param_kernel&#x27;</span>, <span class=\"string\">&#x27;params&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;rank_test_score&#x27;</span>, <span class=\"string\">&#x27;split0_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;split2_test_score&#x27;</span>, ...</span><br><span class=\"line\"> <span class=\"string\">&#x27;std_fit_time&#x27;</span>, <span class=\"string\">&#x27;std_score_time&#x27;</span>, <span class=\"string\">&#x27;std_test_score&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>param_grid</code>: 待评价参数（可以多个超参数一起调优：grid）。</p>\n</li>\n<li><p><code>X, y</code>: 全体训练数据。</p>\n</li>\n<li><p><code>iid</code>: 样本是否是独立同分布。</p>\n</li>\n<li><p><code>refit</code>: 评价指标。</p>\n<p>是否在找到最佳超参数后用全体训练数据再次训练模型参数。</p>\n</li>\n<li><p><code>error_score</code>: 训练失败的处理</p>\n</li>\n</ul>\n<p><strong>总结来说，K 折交叉验证可以检验超参数对应的模型的性能，配合网格搜索 <code>GridSearchCV</code> 可以遍历一段取值范围内的超参数 $\\lambda$ 并找到模型效果最好时的超参数 $\\lambda^{\\ast}$，再选定该超参数，使用全体训练数据再次训练模型，得到最佳模型参数 $W$，最终模型为 $f(X;W, \\lambda^{\\ast})$ 。</strong></p>\n","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","交叉验证"]},{"title":"ML入门-线性回归简介","url":"/post/machinelearning/ml-linear/ml-linear-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-线性回归简介\"><a href=\"#ML入门-线性回归简介\" class=\"headerlink\" title=\"ML入门-线性回归简介\"></a>ML入门-线性回归简介</h1><h2 id=\"1-什么是回归\"><a href=\"#1-什么是回归\" class=\"headerlink\" title=\"1. 什么是回归\"></a>1. 什么是回归</h2><p>假设有一数据集 $D = \\{ X_i, y_i \\}^N_{i = 1}$，其中 N 为训练样本数目，i 为样本索引，$X_i$ 为第 i 个样本的输入特征，$y_i$ 为第 i 个样本的输出/响应，那么：</p>\n<p><strong>根据训练样本 D，学习一个从输入 $X$ 到输出 $y$ 的映射 $f$，使得 $y_i = f(X_i)$，且 $y_i \\in R$，这就是回归任务。</strong></p>\n<blockquote>\n<p>没有特殊说明的情况下，$W$、$X$、$y$ 等均为矩阵（一维矩阵有时作为向量使用）形式，在强调向量性质时使用 $\\vec{X}$、$\\vec{W}$、$\\vec{y}$ 表示。</p>\n</blockquote>\n<p>回归任务的一个重要特征即为 $y_i \\in R$，当 $y_i$ 取类别型数值时，就变成了分类任务。</p>\n<p>当学习到回归任务的映射 f 后，即可对新的输入数据 $X$ 预测其输出 $\\hat{y} = f(X)$。</p>\n<hr>\n<h2 id=\"2-什么是线性回归\"><a href=\"#2-什么是线性回归\" class=\"headerlink\" title=\"2. 什么是线性回归\"></a>2. 什么是线性回归</h2><p>线性回归是最简单的回归模型之一：即从输入 $X$ 到输出 $y$ 的映射 $f$ 为线性关系：</p>\n<p>$<br>\\begin{aligned}<br>y &amp;= f(X) = W^T X<br>\\\\ &amp;= [w_0, w_1, …, w_D] \\begin{bmatrix} 1 \\\\ x_1 \\\\ … \\\\ x_D \\end{bmatrix} = w_0 + \\sum^D_{j = 1} w_j x_j<br>\\end{aligned}<br>$</p>\n<p>$X = (1, x_1, …, x_D)^T$</p>\n<p>其中，$w_0$ 为截距项/偏置（bias），$w_j$ 为第 j 维特征的权重/回归系数，$x_j$ 为第 j 维特征，D 为特征维数，j 为特征索引，$X$ 为特征向量。</p>\n<p>$X$ 在 D 维特征的基础上，再增加一个常数项1，与 $w_0$ 相乘作为截距项，是为了表达式更简洁。也即，$b（bias）= w_0$。</p>\n<p>假设有这么一个例子：根据在线广告投入费用预测每月电子商务销售量，其数据分布和预测直线如下图所示：</p>\n<p><img data-src=\"./linear_predict.png\" alt=\"线性回归模型例\" title=\"@ASSET\"></p>\n<p>在 Scikit-Learn 中，线性回归模型的建立过程大致如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用默认参数初始化</span></span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 训练</span></span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>\n\n<p>在图例中，所有的广告费用构成了 <code>X_train</code>，所有的销售量构成了 <code>y_train</code>，将数据对应输入到 <code>fit()</code> 方法中即可，以例中的数据解得最后的直线方程为：</p>\n<p>$$<br>y = 123.94 + 167.89 \\cdot x<br>$$</p>\n<p>其中 $w_0 = 123.94$，将需要预测的的输入 <code>2.8</code> 代入 x 即可求得 $\\hat{y} = 593.78$。</p>\n<p>不过需要注意的一点是，Scikit-Learn 中训练数据 $X$ 是一个二维数组，在本例中，输入只是长度为 6 的一维数组，因此需要先转换成 n 行 m 列的形式，使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">X_train = X_train.reshape(-<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>来指定列数为 1，行数自动调整。</p>\n<p><code>fit()</code> 完后，<code>lr</code> 这个实例化的线性回归模型对象内就会具有一个默认配置的线性回归参数 $W$，这些参数在经过 <code>fit()</code> 训练后就存在了 <code>lr</code> 对象内部，根据这些参数生成的直线即为图中绿色直线，这就是一个简单的线性回归模型了。</p>\n<hr>\n<h2 id=\"3-线性回归损失函数\"><a href=\"#3-线性回归损失函数\" class=\"headerlink\" title=\"3. 线性回归损失函数\"></a>3. 线性回归损失函数</h2><p>仍然以 “广告投入 - 销售量” 为例，在上文使用默认配置训练后得到了绿色的直线，假设通过手动配置，训练出了另一条蓝色直线：</p>\n<p><img data-src=\"./two_predict_lines.png\" alt=\"两条回归直线\" title=\"@ASSET\"></p>\n<p>显然，蓝色直线也是符合线性回归的定义的，因此需要使用预测残差来评价哪个线性模型更优。</p>\n<h3 id=\"3-1-预测残差\"><a href=\"#3-1-预测残差\" class=\"headerlink\" title=\"3.1 预测残差\"></a>3.1 预测残差</h3><p>根据例中表格数据可以求得：</p>\n<ul>\n<li>绿色直线在训练集上的预测残差为：-41.20, -35.64, 33.92, -8.92, -11.08, 62.91</li>\n<li>蓝色直线在训练集上的预测残差为：14, 10, 70, 204, 25, 142</li>\n</ul>\n<p><img data-src=\"./two_lines_residual.png\" alt=\"两条直线预测残差\" title=\"@ASSET\"></p>\n<p>由于绿色直线的预测残差有负值，在计算残差总和时会发生抵消，因此考虑使用平方计数，也就得到残差平方：</p>\n<p>$$<br>r^2 = (y - \\hat{y})^2<br>$$</p>\n<p>用残差平方来计算残差总和，就得到残差平方和 RSS（Residual Sum of Squares），根据定义显然可得其表达式为：</p>\n<p>$$<br>RSS = \\sum^N_{i = 1} r^2_i = \\sum^N_{i = 1} (y_i - \\hat{y}_i)^2<br>$$</p>\n<p>根据定义求得：</p>\n<ul>\n<li>绿色直线 RSS = 8277.32</li>\n<li>蓝色直线 RSS = 67601</li>\n</ul>\n<p>RSS 可以表示模型预测的整体性能，RSS 最小亦称为为最小二乘 OLS（Ordinary Least Square）。RSS 越小的直线预测越准确，因此显然，绿色直线比蓝色直线要好得多。</p>\n<h3 id=\"3-2-三种损失函数\"><a href=\"#3-2-三种损失函数\" class=\"headerlink\" title=\"3.2 三种损失函数\"></a>3.2 三种损失函数</h3><p>在机器学习中，用 <strong>损失函数 L（Loss Function）</strong> 来 <strong>度量</strong> 样本真实值与模型预测值之间的差异，该差异用预测残差 r（Residual）来表示：$r = y - \\hat{y}$。</p>\n<p>常见的损失函数有三种：</p>\n<ul>\n<li>L2 损失</li>\n<li>L1 损失</li>\n<li>Huber 损失</li>\n</ul>\n<p>损失函数的意义在于，使得模型趋向于<strong>最小训练集上的损失（经验风险最小）</strong>，也即在模型训练时给予一个训练目标，使得训练出来的模型在训练集上的损失总和最小。由于模型的参数即为 $W$，因此定义一个目标函数：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i)<br>$$</p>\n<p>则模型训练的目标也就是求：$J(W)$ 最小。</p>\n<h4 id=\"3-2-1-L2损失\"><a href=\"#3-2-1-L2损失\" class=\"headerlink\" title=\"3.2.1 L2损失\"></a>3.2.1 L2损失</h4><p>在前面的例中，当损失函数采用 RSS 时，损失函数为二次函数，范数为 2，因此也称为 L2 损失（差的平方即为距离的 L2 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = (y - \\hat{y})^2 = r^2<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} r^2_i<br>$$</p>\n<p>L2 损失是二次函数，因此最大的优点就是：处处可导，优化计算方便。但缺点也很明显：对噪声敏感。若数据中某点的预测残差 r 特别大（下图红点），经过平方放大后 $ r^2 $ 会更大，则会在模型中占主导作用，由于模型的训练目标是使得目标函数最小，在 L2 损失的模型中，也即使得 RSS 最小，因此会导致模型向该噪声点偏移（变为下图橙线）：</p>\n<p><img data-src=\"./noise_in_l2.png\" alt=\"L2 损失对噪声敏感\" title=\"@ASSET\"></p>\n<p>Scikit-Learn 中使用 L2 损失的线性回归模型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 L2 损失（线性回归默认使用 L2 损失）</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_lr = lr.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-L1损失\"><a href=\"#3-2-2-L1损失\" class=\"headerlink\" title=\"3.2.2 L1损失\"></a>3.2.2 L1损失</h4><p>为了减弱噪声点对模型的影响，同时保留损失函数“避免抵消正负”的特性，除了采用平方之外，还可以采用绝对值。当损失函数采用绝对值计量预测误差总和时，损失函数为绝对值函数，范数为 1，因此也称为 L1 损失（差的绝对值即为距离的 L1 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = |y - \\hat{y}| = |r|<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} |r|_i<br>$$</p>\n<p>L1 函数是绝对值函数，因此最大的有点是：对噪声不敏感：</p>\n<p><img data-src=\"./l2_l1_residual.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n<p>但缺点同样明显：在零点处左右导数不相等，因此不可导，不便于优化计算。</p>\n<h4 id=\"3-2-3-Huber损失\"><a href=\"#3-2-3-Huber损失\" class=\"headerlink\" title=\"3.2.3 Huber损失\"></a>3.2.3 Huber损失</h4><p>为了结合 L2 和 L1 损失的优点，同时规避二者的缺点，可以考虑选择一个新的损失函数：其在靠近零点处表达式为 L2 损失，具有“可导”的优点，在远离零点处表达式为 L1 损失，具有“抗噪声”的优点，得到如下表达式：</p>\n<p>$$<br>L_{\\delta} (r) = \\left \\{<br>\\begin{aligned}<br>&amp; \\frac {1} {2} r^2 &amp;&amp; {|r| \\le \\delta}<br>\\\\<br>\\delta |r| &amp; - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>或代入预测残差：</p>\n<p>$$<br>L_{\\delta} (r) = \\left \\{<br>\\begin{aligned}<br>&amp; \\frac {1} {2} (y - \\hat{y})^2 &amp;&amp; {|r| \\le \\delta}<br>\\\\<br>\\delta |y &amp; - \\hat{y}| - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>Huber 损失的图像如下：</p>\n<p><img data-src=\"./l1_l2_huber_lines.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n<p>Huber 表达式中对 L2 和 L1 损失部分均有变形：</p>\n<ul>\n<li>取 L2 损失的部分，添加系数 $\\frac {1} {2}$ 的目的是抵消 $r^2$ 在求导时产生的系数 2。</li>\n<li>取 L1 损失的部分，添加一项 $- \\frac {1} {2} \\delta^2$ 的目的是使得函数在交点 δ 处（图中黑点标识）连续（当取 $|r| = \\delta$ 时，代入函数两段函数值相等）。</li>\n</ul>\n<p>Scikit-Learn 中实现了采用 Huber 损失的回归模型：HuberRegressor，其调用接口几乎相同：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 Huber 损失</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> HuberRegressor</span><br><span class=\"line\">huber = HuberRegressor()</span><br><span class=\"line\">huber.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_huber = huber.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-Scikit-Learn中的线性回归\"><a href=\"#4-Scikit-Learn中的线性回归\" class=\"headerlink\" title=\"4. Scikit-Learn中的线性回归\"></a>4. Scikit-Learn中的线性回归</h2><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只考虑了模型对训练样本的拟合程度：</p>\n<p>$$<br>J(W = \\sum^N_{i = 1} L(y_i, f(X_i; W))^2 = ||y - X W||^2_2<br>$$</p>\n<p>其中 $f(X_i; W) = \\hat{y}$</p>\n<p>Scikit-Learn 中的线性回归模型 <code>LinearRegression</code> 就是最小二乘线性回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LinearRegression</span></span><br><span class=\"line\">LinearRegression(fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                 copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-LinearRegression类参数\"><a href=\"#4-1-LinearRegression类参数\" class=\"headerlink\" title=\"4.1 LinearRegression类参数\"></a>4.1 LinearRegression类参数</h3><p><code>fit_intercept</code>：<br>模型是否包含截距项。<br>如果数据在预处理时已经中心化（训练样本集 y 均值为0，则训练结果 $W_0$ 即为0），则可设置为 <code>False</code>。</p>\n<p><code>normalize</code>：<br>是否对输入特征 $X$ 做归一化。<br>对每一条样本，减去均值并除以 L2 模，使得模长变为 1，因此对数据归一化处理会使得超参数学习更加 Robust，且几乎和样本数目没有关系。但在回归中对样本归一化用的比较少，通常对特征标准化。</p>\n<p><code>copy_X</code>：<br>是否拷贝数据 $X$。<br>当设置为 <code>False</code> 时，对 $X$ 的操作会在原始数据集上完成从而覆盖原始数据。当原始数据后续不再需要使用时可以设置为 <code>False</code> 节省内存。</p>\n<p><code>n_jobs</code>：<br>并行计算时使用 CPU 的数目。<br>设置为 -1 表示使用所有 CPU 核，与显示设置为 CPU 核数目的效果相同。</p>\n<h3 id=\"4-2-LinearRegression类属性\"><a href=\"#4-2-LinearRegression类属性\" class=\"headerlink\" title=\"4.2 LinearRegression类属性\"></a>4.2 LinearRegression类属性</h3><p><code>coef_</code>：<br>回归系数，与特征维数相同。<br>也即特征权重 $\\hat{W}_0$，如果是多任务回归，则与标签 y 的维度相同。</p>\n<p><code>intercept_</code>：<br>截距项。<br>也即偏置（bias）：$b = \\hat{W}_0$</p>\n<h3 id=\"4-3-LinearRegression类方法\"><a href=\"#4-3-LinearRegression类方法\" class=\"headerlink\" title=\"4.3 LinearRegression类方法\"></a>4.3 LinearRegression类方法</h3><p><code>fit(X, y[, sample_weight])</code>：<br>训练模型。<br>X, y 为训练特征和标签，可通过 sample_weight 设置每个样本的权重。例如某个数据由多个设备采集，则高精度设备采集到的数据可以提高权重。</p>\n<p><code>predict(X)</code>：<br>使用已训练完成的模型进行预测。<br>输出即为预测值 $\\hat{y}$</p>\n<p><code>score(X, y[, sample_weight])</code>：<br>评估模型性能，返回模型预测的 $R^2$ 分数（y 与 $\\hat{y}$ 的差异）。<br>根据输入 X 利用模型计算出预测值 $\\hat{y}$ 并和真实值 y 比较。详见回归模型评价指标部分。</p>\n<blockquote>\n<p>关于归一化、标准化、中心化的参考理解：</p>\n<ul>\n<li>归一化：（1）把数据映射到区间 (0, 1) 或 (-1, 1)，主要为了数据处理方便。（2）把有量纲表达式转换为无量纲表达式，便于不同量级或单位的指标能进行比较和加权。</li>\n<li>标准化：将数据转换为均值为 0（每个特征都减掉原始数据中该特征的均值），且标准差为 1。</li>\n<li>中心化：将样本数据的输出 y 转换为均值为 0。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"5-欠拟合与过拟合\"><a href=\"#5-欠拟合与过拟合\" class=\"headerlink\" title=\"5. 欠拟合与过拟合\"></a>5. 欠拟合与过拟合</h2><p>OLS 中，目标函数只考虑了模型对 <strong>训练样本</strong> 的拟合程度：</p>\n<p>$$<br>J(f) = RSS(f) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>因此在训练样本集上残差和可以接近甚至等于零。原则上，任意复杂的模型，若能完全拟合训练数据，则称为过拟合。反之若模型连训练样本都无法较好的拟合，则称为欠拟合：</p>\n<ul>\n<li>过拟合（Overfitting）：过于复杂的模型与训练数据拟合的太好，导致推广性和扩展性较差，因此和测试数据拟合的较差。</li>\n<li>欠拟合（Underfitting）：过于简单的模型与训练数据尚且拟合的较差，更加不足以拟合测试数据。</li>\n</ul>\n<blockquote>\n<p>线性回归采用的线性模型比较简单，因此当特征维数不太高时，线性回归的过拟合现象通常不太严重。</p>\n</blockquote>\n<h3 id=\"5-1-sin-函数曲线实例\"><a href=\"#5-1-sin-函数曲线实例\" class=\"headerlink\" title=\"5.1 $\\sin$函数曲线实例\"></a>5.1 $\\sin$函数曲线实例</h3><p>假设数据产生模型为：$y = \\sin (2 \\pi x) + \\varepsilon$，其中 $\\sin$ 函数如下：</p>\n<p><img data-src=\"./sin_function.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n<p>$\\varepsilon$ 为白噪声（随机噪声），假设方差为 0.03：</p>\n<p>$<br>\\varepsilon \\sim N (0, 0.03^2)<br>$</p>\n<p>通常，$\\sin$ 函数需要使用无穷多阶多项式拟合，在此给定 $N = 10$ 共 10 个样本点，如上图中蓝点所示，采用 M 阶多项式拟合数据：</p>\n<p>$<br>y = \\sum^M_{j = 0} w_j x^j<br>$</p>\n<p>当有 10 个样本时，最多可以解出 10 个未知数（$M = 9$ 时可取 $w_0, …, w_9$ 共 10 个系数），分别取 $M = 0, 1, 3, 9$ 并绘制图形如下：</p>\n<p><img data-src=\"./different_m_in_sin.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n<p>（1）当 $M = 0$ 时，$y = w_0$，此时为了使 RSS 最小，则训练结果 $w_0 = \\bar{y}$。</p>\n<p>（2）当 $M = 9$ 时，可看出函数已经完全拟合了所有 10 个样本（函数通过每个样本点），此时训练集上 $RSS = 0$，但显然，该多项式并没有较好地表达数据的分布。</p>\n<h3 id=\"5-2-训练误差与测试误差\"><a href=\"#5-2-训练误差与测试误差\" class=\"headerlink\" title=\"5.2 训练误差与测试误差\"></a>5.2 训练误差与测试误差</h3><p>评价模型性能不能在训练集上评估，而应该在新的测试数据集上评估其 <strong>推广性</strong> / <strong>泛化能力（Generalization）</strong>。理论上，随着模型训练的进行，训练误差总是会越来越小，直到为零。根据如下误差计算公式：</p>\n<p>$$<br>E_{RMS} = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2}<br>$$</p>\n<p>统计各样本点的训练误差和测试误差：</p>\n<p><img data-src=\"./loss_of_train_and_test.png\" alt=\"训练误差和测试误差\" title=\"@ASSET\"></p>\n<p>从 $M = 3$ 开始，当模型复杂度继续增加时，训练误差继续下降，甚至为 0，而测试误差反而增大，此时发生了过拟合。在本例中，取 $M = 3$ 时的模型最理想，当 $M \\in [4, 8]$ 时，虽然测试误差没有增加，但模型复杂度增加，这是没有必要的（奥卡姆剃刀原理）。</p>\n<h3 id=\"5-3-过拟合时的模型参数\"><a href=\"#5-3-过拟合时的模型参数\" class=\"headerlink\" title=\"5.3 过拟合时的模型参数\"></a>5.3 过拟合时的模型参数</h3><p>统计当 $M$ 分别取 $0 \\sim 9$ 时训练出来的模型系数 $w_0 \\sim w_M$：</p>\n<p><img data-src=\"./all_w_in_sin.png\" alt=\"所有 W 取值\" title=\"@ASSET\"></p>\n<p>可以看到，随着阶数的增加，系数 $W$ 的绝对值越来越大，发生过拟合时，回归系数的 绝对值 / 平方值 很大，即使输入 $x$ 变化很小也可能带来 $y$ 很大的变化，函数的抖动很剧烈。</p>\n<h3 id=\"5-4-抑制过拟合\"><a href=\"#5-4-抑制过拟合\" class=\"headerlink\" title=\"5.4 抑制过拟合\"></a>5.4 抑制过拟合</h3><p>（1）增加训练样本数</p>\n<p>当训练数据增多时，同样使用九阶多项式拟合，也不会产生明显的过拟合现象：</p>\n<p><img data-src=\"./add_train_data_set.png\" alt=\"增加训练样本\" title=\"@ASSET\"></p>\n<p>通常，样本数 N 为系数数量（特征维度）D 的 5 ~ 10 倍时训练效果比较好。</p>\n<p>（2）目标函数增加正则项</p>\n<p>在给定有限训练样本数时，可通过在目标增加正则项减弱过拟合现象。同样 10 个样本，使用 9 阶多项式拟合，但加入 <strong>L2 正则项</strong>，即可得到 <strong>岭回归（Ridge Regression）</strong>：</p>\n<p>$$<br>J_{Ridge} (W, \\lambda) = \\sum^N_{i = 0} \\left( y_i - \\sum^M_{j = 0} w_j, x^j_i \\right)^2 + \\lambda \\sum^M_{j = 1} w^2_j<br>$$</p>\n<p>得到的拟合结果如下：</p>\n<p><img data-src=\"./add_r_function.png\" alt=\"增加正则项\" title=\"@ASSET\"></p>\n<p>统计模型系数 W 随正则参数 $\\lambda$ 的变化表：</p>\n<p><img data-src=\"./change_of_w_with_lambda.png\" alt=\"W 随 $\\lambda$ 变化表\" title=\"@ASSET\"></p>\n<p>当 $\\ln \\lambda = - \\infty$ 时，$\\lambda = 0$，此时相当于没有正则项。从表格可以看出，$\\ln \\lambda$ 越大，也即 $\\lambda$ 越大，对模型复杂度惩罚越多，回归系数的 绝对值 / 平方值 越小，模型越简单。训练误差及测试误差与正则参数的关系如下图：</p>\n<p><img data-src=\"./loss_with_lambda.png\" alt=\"训练误差和测试误差与 $\\lmabda$ 的关系\" title=\"@ASSET\"></p>\n<p>常用的正则项如下：</p>\n<p>① L2 正则（L2 范数：平方距离）：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>② L1 正则（L1 范数：绝对值距离）：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。<strong>这里需要注意，正则项求和中，只对 $1 \\sim D$ 求和，也即不惩罚截距项（Bias）$b = w_0$，因此在实际任务中，通常需要先对数据作中心化处理，去掉截距项的影响。</strong></p>\n<p>还有一种 L0 正则（L0 范数：向量中非零元素数目）：$R(W) = ||W||_0$，但因为 L0 正则是 NP 问题，优化计算不方便，且 L1 范数是 L0 范数的最优凸近似，更方便优化计算，因此常用 L1 正则去近似 L0 正则。</p>\n<p>L1 / L0 正则可以得到稀疏解，因此可以起到特征选择的作用，这是因为当确定某个系数 $w_j = 0$ 时，对应的特征 $x_j$ 是无用的，在某些场景（如医学等）下，下一次采样可考虑去掉该特征。</p>\n<p>（3）减少噪声</p>\n<p>另一种抑制过拟合的方法是减少噪声，但在实际面对的任务中，大部分情况下训练数据是给定的，因此增加或调整正则项是抑制过拟合最常用的手段。</p>\n<blockquote>\n<p><strong>正则项发挥作用的理解：对于目标函数 $J(W, \\lambda) = Loss + \\lambda R(W)$，若模型过拟合，由于模型的训练目标是目标函数最小，过拟合时虽然 $Loss$ 可能较小，但模型过于复杂，回归系数的 绝对值 / 平方值 过大，导致目标函数整体较大，则增大 $\\lambda$，为了使得目标函数最小，模型会趋于减小 $W$，从而减小模型复杂度（$W$ 元素的值减小或非零元素减少都是减小模型复杂度）。当处于欠拟合状态，则 $Loss$ 较大，模型复杂度尚且不够拟合训练数据，此时减小 $\\lambda$，以增加模型复杂度。通常，训练的过程分为系数 $W$ 的训练和超参数 $\\lambda$ 的训练，使用某个超参数训练出系数后，模型复杂度即确定下来，再去搜索最优的超参数即可。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"6-带正则的线性回归\"><a href=\"#6-带正则的线性回归\" class=\"headerlink\" title=\"6. 带正则的线性回归\"></a>6. 带正则的线性回归</h2><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只包括训练集上的损失和（经验风险），也即仅考虑了模型对训练样本的拟合程度，因此可能会导致模型太过于复杂，甚至训练误差为0，产生过拟合。为此可在原目标函数中加入正则项，使得模型不会太复杂。则目标函数变为损失和 + 正则项：</p>\n<p>$$<br>J(W, \\lambda) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>其中 R 为 Risk，表示 $W$ 复杂度的风险，新的目标函数也称为 <strong>结构风险</strong>。正则项的加入使目标函数符合奥拉姆剃刀（Occam’s Razor）原理：简单有效，选择能解释数据的模型中最简单的一个。</p>\n<p>常用的正则项有：L2 正则、L1 正则。</p>\n<p>（1）L2 正则：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>（2）L1 正则：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。</p>\n<h3 id=\"6-1-岭回归\"><a href=\"#6-1-岭回归\" class=\"headerlink\" title=\"6.1 岭回归\"></a>6.1 岭回归</h3><p>岭回归（Ridge）：L2 损失 + L2 正则 + LinearRegression。</p>\n<p>岭回归正则项对截距项不施加惩罚，也即：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} w^2_j，（j 从 1 开始）<br>$$</p>\n<p>线性模型中增加常数项 $x_0 = 1$ 用于表示截距项：</p>\n<p>$$<br>f(X; W) = W^T X = \\sum^D_{j = 0} w_j x_j，（j 从 0 开始）<br>$$</p>\n<p>当 j = 0 时，$x_0 = 1 \\rightarrow w_0 x_0 = w_0$ 作为截距项。因此而得岭回归目标函数（目标函数的损失和部分不惩罚截距项，所以目标函数不需要从 0 开始）：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\\\ &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\\\ &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的岭回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=<span class=\"string\">&#x27;auto&#x27;</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-1-1-Ridge类参数\"><a href=\"#6-1-1-Ridge类参数\" class=\"headerlink\" title=\"6.1.1 Ridge类参数\"></a>6.1.1 Ridge类参数</h4><p><code>alpha</code>：<br>正则参数，也即正则项中的 λ。<br>目标：求 $\\arg_W \\min (||X W - y||^2_2 + \\alpha ||W||^2_2)$</p>\n<p>部分参数与 LinearRegression 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-1-2-Ridge类属性\"><a href=\"#6-1-2-Ridge类属性\" class=\"headerlink\" title=\"6.1.2 Ridge类属性\"></a>6.1.2 Ridge类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-1-3-Ridge类方法\"><a href=\"#6-1-3-Ridge类方法\" class=\"headerlink\" title=\"6.1.3 Ridge类方法\"></a>6.1.3 Ridge类方法</h4><p>与 LinearRegression 相同。</p>\n<h3 id=\"6-2-Lasso\"><a href=\"#6-2-Lasso\" class=\"headerlink\" title=\"6.2 Lasso\"></a>6.2 Lasso</h3><p>Lasso（Least <strong>Absolute</strong> <strong>Shrinkage</strong> and <strong>Selection</strong> Operator）：L2 损失 + L1 正则 + LinearRegression。</p>\n<p>Lasso 有三个关键点：</p>\n<ul>\n<li>Absolute：表示用的是 L1 正则，绝对值的模。</li>\n<li>Shrinkage：相比普通的线性回归，L1 正则会使得 $W$ 有一定收缩。</li>\n<li>Selection：L1 正则可能使得 $W$ 中某些元素变为 0 得到稀疏解，从而起到特征选择的作用。</li>\n</ul>\n<p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\\\<br>&amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |w_j|<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的 Lasso：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-1-Lasso类参数\"><a href=\"#6-2-1-Lasso类参数\" class=\"headerlink\" title=\"6.2.1 Lasso类参数\"></a>6.2.1 Lasso类参数</h4><p>大部分与 Ridge 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-2-2-Lasso类属性\"><a href=\"#6-2-2-Lasso类属性\" class=\"headerlink\" title=\"6.2.2 Lasso类属性\"></a>6.2.2 Lasso类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-2-3-Lasso类方法\"><a href=\"#6-2-3-Lasso类方法\" class=\"headerlink\" title=\"6.2.3 Lasso类方法\"></a>6.2.3 Lasso类方法</h4><p>与 LinearRegression 相同。</p>\n<h3 id=\"6-3-弹性网络\"><a href=\"#6-3-弹性网络\" class=\"headerlink\" title=\"6.3 弹性网络\"></a>6.3 弹性网络</h3><p>弹性网络：L2 损失 + （L1 正则 + L2 正则） + LinearRegression。</p>\n<p>在 性网络中，使用 ρ 表示 L1 正则所占比例，$\\dfrac {(1 - \\rho)} {2}$ 表示 L2 正则所占比例：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} \\left( \\rho |w_j| + \\dfrac {(1 - \\rho)} {2} w^2_j \\right)<br>$$</p>\n<p>弹性网络的目标函数：</p>\n<p>$$<br>J(W; \\lambda; \\rho) = \\dfrac {1} {2N} ||y - X W||^2_2 + \\lambda \\left( \\rho ||W||_1 + \\dfrac {(1 - \\rho)} {2} ||W||^2_2 \\right),\\ \\ \\ \\ \\ 0 \\le \\rho \\le 1<br>$$</p>\n<p>Scikit-Learn 中使用 ElasticNet 实现弹性网络：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.ElasticNet</span></span><br><span class=\"line\">ElasticNet(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">           l1_ratio=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">           fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">           warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           postive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-1-ElasticNet类参数\"><a href=\"#6-3-1-ElasticNet类参数\" class=\"headerlink\" title=\"6.3.1 ElasticNet类参数\"></a>6.3.1 ElasticNet类参数</h4><p><code>l1_ratio</code>：<br>即正则比例参数 ρ。</p>\n<p>大部分参数与 Lasso 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-3-2-ElasticNet类属性\"><a href=\"#6-3-2-ElasticNet类属性\" class=\"headerlink\" title=\"6.3.2 ElasticNet类属性\"></a>6.3.2 ElasticNet类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-3-3-ElasticNet类方法\"><a href=\"#6-3-3-ElasticNet类方法\" class=\"headerlink\" title=\"6.3.3 ElasticNet类方法\"></a>6.3.3 ElasticNet类方法</h4><p>与 LinearRegression 相同。</p>\n<p>当取 ρ = 0 时，正则项仅为 L2 正则，当取 ρ = 1 时，正则项仅为 L1 正则。弹性网络的正则项有如下效果：</p>\n<ul>\n<li>L2 正则使得线性回归系数 $W$ 收缩，模型稳定。</li>\n</ul>\n<p>当输入特征之间存在共线性时，使用 L2 正则。</p>\n<ul>\n<li>L1 正则也会收缩回归系数 $W$。当正则参数取合适值时，L1 正则使得有些回归系数为 0，得到稀疏模型。</li>\n</ul>\n<p>当输入特征比较多，优先特征和目标便梁志坚相关性很弱时，L1 正则可能只选择强相关的特征，模型解释性较好。若 $\\lambda_{max}$ 为某临界值，当取 $\\lambda \\ge \\lambda_{max}$ 时，$W = 0$。</p>\n<p><strong>注意</strong>：由于正则项中对不同维度的 $W_j$ 同等对待，对输入特征 $X$ 最好做去量纲（Scaling）处理，使得不同维度的特征取值范围大致相同（如标准化：<code>sklearn.preprocessiong.StandardScaler</code>）。</p>\n<blockquote>\n<p>去量纲的常用方法：</p>\n<ul>\n<li>归一化（Normalization）：例如 Min-Max Scaler</li>\n<li>标准化（Standardization）：例如 Z-Score</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-线性回归三种求解","url":"/post/machinelearning/ml-linear/ml-linear-solutions/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-线性回归三种求解\"><a href=\"#ML入门-线性回归三种求解\" class=\"headerlink\" title=\"ML入门-线性回归三种求解\"></a>ML入门-线性回归三种求解</h1><h2 id=\"1-解析法\"><a href=\"#1-解析法\" class=\"headerlink\" title=\"1. 解析法\"></a>1. 解析法</h2><p>在给定正则参数（超参数）λ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W)$，满足最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W)} {\\partial W} = 0$。</p>\n<h3 id=\"1-1-OLS最优解析解\"><a href=\"#1-1-OLS最优解析解\" class=\"headerlink\" title=\"1.1 OLS最优解析解\"></a>1.1 OLS最优解析解</h3><h4 id=\"1-1-1-正规方程组\"><a href=\"#1-1-1-正规方程组\" class=\"headerlink\" title=\"1.1.1 正规方程组\"></a>1.1.1 正规方程组</h4><p>对 OLS 目标函数矩阵形式展开：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 = (y - X W)^T (y - X W)<br>\\\\<br>&amp;= y^T y - y^T X W - W^T X^T y + W^T X^T X W<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的转置运算有：$A^T B = B^T A$，也即 $y^T X W = W^T X^T y$，因此上式等价于：</p>\n<p>$$<br>J(W) = y^T y - 2 W^T X^T y + W^T X^T X W<br>$$</p>\n<p>因此满足 OLS 最优解即：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;\\dfrac {\\partial J(W)} {\\partial W} = 0<br>\\\\<br>\\Longrightarrow \\quad &amp;\\dfrac { \\partial (y^T y - 2 W^T X^T y + W^T X^T X W)} { \\partial W } = 0 \\quad（0 矩阵）<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的微分运算有：</p>\n<p>$<br>\\begin{aligned}<br>&amp;① \\quad \\dfrac {\\partial (A^T B)} {\\partial A} = B<br>\\\\<br>&amp;② \\quad \\dfrac {\\partial (A^T B A)} {\\partial A} = (B^T + B) A<br>\\end{aligned}<br>$</p>\n<p>进而得到下式：</p>\n<p>$$<br>0 - 2 X^T y + [ (X^T X)^T + (X^T X) ] W = 0<br>$$</p>\n<p>根据矩阵的运算法则有：</p>\n<p>$<br>\\begin{aligned}<br>\\because \\quad &amp;X^T X = (X)^T (X^T)^T = (X^T X)^T<br>\\\\<br>\\therefore \\quad &amp;X^T X 为对称矩阵<br>\\\\<br>\\Longrightarrow \\quad &amp;X^T X = (X^TX)^T<br>\\end{aligned}<br>$</p>\n<p>进一步合并得：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;-2 X^T y + 2 X^T X W = 0<br>\\\\<br>&amp;\\Longrightarrow X^T X W = X^T y \\quad （正规方程组）<br>\\\\<br>&amp;\\Longrightarrow \\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>\\end{aligned}<br>$$</p>\n<p>这种求解方式也称为用正规方程组解析求解最小二乘线性回归。但在解析 $ \\hat{W}_{OLS} $ 的过程中涉及到了逆矩阵的计算，应当避免。</p>\n<h3 id=\"1-1-2-Moore-Penrose广义逆\"><a href=\"#1-1-2-Moore-Penrose广义逆\" class=\"headerlink\" title=\"1.1.2 Moore-Penrose广义逆\"></a>1.1.2 Moore-Penrose广义逆</h3><p>通常，训练的目标是 OLS 目标函数 $J(W) = ||y - XW||^2_2$ 最小，通俗来讲也即 $y$ 与 $X W$ 越接近越好，最好的情况即求解：$y = X W$。</p>\n<p>（1）假如 $X$ 为方阵，则可以求其逆：$W = X^{-1} y$，</p>\n<p>（2）假如 $X$ 不为方阵，则求其逆矩阵无意义，可求 Moore-Penrose 广义逆：$W = X^+ y$</p>\n<blockquote>\n<p>广义逆的符号为：</p>\n<p><img data-src=\"./pseudoinverse.png\" alt=\"广义逆符号\" title=\"@ASSET\"> </p>\n<p>LaTeX 代码为 <code>X^&#123;\\dag&#125;</code>，但 Hexo 不支持引入宏包无法显示，因此使用 $X^+$ 代替。</p>\n</blockquote>\n<p>Moore-Penrose 广义逆可采用奇异值分解（Singular Value Decomposition, SVD）实现：</p>\n<p>$<br>\\begin{aligned}<br>&amp;若有：X = U \\Sigma V^T,<br>\\\\<br>&amp;其中 U, V 为正交阵，\\Sigma 为对角阵（不一定为方阵）<br>\\\\<br>&amp;则：X^+ = V \\Sigma^+ V^T<br>\\end{aligned}<br>$</p>\n<p>对角阵 $\\Sigma$ 求伪逆，则将非零元素求倒数即可：</p>\n<p>$$<br>\\Sigma = \\left(<br>\\begin{matrix}<br> \\lambda_1 &amp; 0         &amp; \\cdots &amp; 0<br> \\\\<br> 0         &amp; \\lambda_2 &amp; \\cdots &amp; 0<br> \\\\<br> \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots<br> \\\\<br> 0         &amp; 0         &amp; \\cdots &amp; 0<br> \\\\<br>\\end{matrix}<br>\\right),<br>\\Sigma^+ = \\left(<br>\\begin{matrix}<br> \\dfrac 1 \\lambda_1 &amp; 0                  &amp; \\cdots &amp; 0<br> \\\\<br> 0                  &amp; \\dfrac 1 \\lambda_2 &amp; \\cdots &amp; 0<br> \\\\<br> \\vdots             &amp; \\vdots             &amp; \\ddots &amp; \\vdots<br> \\\\<br> 0                  &amp; 0                  &amp; \\cdots &amp; 0<br> \\\\<br>\\end{matrix}<br>\\right),<br>$$</p>\n<p>这也是 Scikit-Learn 中 LinearRegression 推荐的求解方式。</p>\n<h3 id=\"1-2-Ridge最优解析解\"><a href=\"#1-2-Ridge最优解析解\" class=\"headerlink\" title=\"1.2 Ridge最优解析解\"></a>1.2 Ridge最优解析解</h3><p>Ridge 比 OLS 多一个 L2 正则，目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\\\<br>&amp;= (y - X W)^T (y - X W) + \\lambda W^T W<br>\\end{aligned}<br>$$</p>\n<p>其最优解也采用 SVD 分解的方式实现。求解偏导数等于零：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial J(W)} {\\partial W} &amp;= -2 X^T y + 2 (X^T X) W + 2 \\lambda W = 0<br>\\\\<br>\\Longrightarrow \\hat{W}_{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\\\<br>&amp;（其中 I 为 D \\times D 的单位阵）<br>\\end{aligned}<br>$$</p>\n<p>对比 OLS 的解：</p>\n<p>$$<br>\\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>$$</p>\n<p>对 Ridge 的解进行变形，配出一个 $\\hat{W}_{OLS}$：</p>\n<p>$$<br>\\begin{aligned}<br>\\hat{W}_{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) (X^T X)^{-1} X^T y<br>\\\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) \\hat{W}_{OLS}<br>\\end{aligned}<br>$$</p>\n<p>将 $(X^T X + \\lambda I)^{-1}$ 看成是分母，将 $(X^T X)$ 看成分子，由于 $(X^T X + \\lambda I) &gt; (X^T X)$，因此有 $\\hat{W}_{Ridge} &lt; \\hat{W}_{OLS}$。</p>\n<p>因此 $\\hat{W}_{Ridge} $ 在 $ \\hat{W}_{OLS}$ 的基础上进行了收缩，L2 正则也称为权重收缩。</p>\n<h3 id=\"1-3-总结\"><a href=\"#1-3-总结\" class=\"headerlink\" title=\"1.3 总结\"></a>1.3 总结</h3><p>（1）OLS 的解为：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，需要对矩阵 $X^T X$ 求逆。</p>\n<ul>\n<li>当输入特征存在共线性（某些特征可以用其他特征的线性组合表示），矩阵 X 是接近不满秩，矩阵 $X^T X$ 接近奇异，求逆不稳定。</li>\n</ul>\n<p>（2）Ridge 的解为：$\\hat{W}_{Ridge} = (X^T X + \\lambda I)^{-1} X^T y$，需要对矩阵 $(X^T X + \\lambda I)$ 求逆。</p>\n<ul>\n<li>即使输入特征存在共线性，矩阵 $X$ 不满秩，矩阵 $X^T X$ 对角线存在等于 0 或接近于 0 的元素，但 $0 + \\lambda \\ne 0$，$(X^T X + \\lambda I)$ 求逆仍可得到稳定解。因此岭回归 Ridge 在输入特征存在共线性的情况仍然能得到稳定解。</li>\n</ul>\n<p>（3）Lasso 无法无法求得解析解，可以用迭代求解。</p>\n<hr>\n<h2 id=\"2-梯度下降法\"><a href=\"#2-梯度下降法\" class=\"headerlink\" title=\"2. 梯度下降法\"></a>2. 梯度下降法</h2><h3 id=\"2-1-梯度下降法思想\"><a href=\"#2-1-梯度下降法思想\" class=\"headerlink\" title=\"2.1 梯度下降法思想\"></a>2.1 梯度下降法思想</h3><p>解析求解法对 N x D 维矩阵 X 进行 SVD 分解的复杂度为：$O(N^2 D)$。</p>\n<ul>\n<li>当样本数 N 很大或特征维度 D 很大时，SVD 计算复杂度高，或机器的内存根本不够。</li>\n<li>可采用迭代求解的方法：梯度下降法、随机梯度下降法、次梯度法、坐标轴下降法等。</li>\n<li>梯度下降法（Gradient Descent）是求解无约束优化问题最常采用的方法之一。</li>\n</ul>\n<p>在微积分中，一元函数 $f(x)$ 在 $x$ 处的梯度为函数在该点的导数 $\\dfrac {df} {dx}$。</p>\n<p>对应在多元函数 $f(x_1, …, x_D)$ 中，在点 $x = (x_1, …, x_D)$ 处共有 D 个偏导数：$\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D}$。将这 D 个偏导数组合成一个 D 维的矢量 $(\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D})^T$，即称为函数 $f(x_1, …, x_D)$ 在点 $x$ 处的梯度，一般记为 $\\nabla$ 或 $grad$，即：</p>\n<p>$$<br>\\nabla f(x_1, …, x_D) = grad \\ f(x_1, …, x_D) = (\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D})^T<br>$$</p>\n<p>（1）从几何意义上讲，某点的梯度是函数在该点变化最快的地方。</p>\n<p>（2）沿着梯度方向，函数增加最快，更容易找到函数的最大值</p>\n<p>（3）沿负梯度方向，函数减少最快，更容易找到函数的最小值。</p>\n<blockquote>\n<p>$\\nabla$ 发音为 nabla，表示微分，不属于希腊字符，只是一个记号。</p>\n</blockquote>\n<p>正负梯度的例子如下：</p>\n<p><img data-src=\"./gradient_demo.png\" alt=\"梯度示意图\" title=\"@ASSET\"></p>\n<p>在计算 $f(x)$ 的最小值时，当函数形式比较简单且数据量小，可用解析计算 $ f’(x) = 0 $，否则可用迭代法求解：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $x^{t = 0}$ 为初始值；</p>\n<p>（2）找到下一个点 $x^{t + 1}$，使得函数值越来越小，即 $f(x^{t + 1}) &lt; f(x^t)$；</p>\n<p>（3）重复，直到函数值不再见小，则已经找到函数的 <strong>局部极小值</strong>。</p>\n<blockquote>\n<p>该方法仅能找到局部极小值。</p>\n</blockquote>\n<p>为此，可以对该迭代方案进行改进：</p>\n<ul>\n<li>随机寻找初始值时，初始化多个点；</li>\n<li>最后从多个局部极小值中取最小的作为最终的极小值。</li>\n</ul>\n<h3 id=\"2-2-梯度下降法数学解释\"><a href=\"#2-2-梯度下降法数学解释\" class=\"headerlink\" title=\"2.2 梯度下降法数学解释\"></a>2.2 梯度下降法数学解释</h3><p>对函数 $f(x)$ 进行一节泰勒展开得到：</p>\n<p>$$<br>f(x + \\Delta x) \\approx f(x) + \\Delta x \\nabla f(x)<br>$$</p>\n<p>要找到函数的最小值，也即每一次步进 $\\Delta x$ 后的函数值均小于原函数值，因此有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; f(x + \\Delta x) &lt; f(x)<br>\\\\<br>\\Longrightarrow &amp; \\Delta x \\nabla f(x) &lt; 0<br>\\end{aligned}<br>$$</p>\n<p>假设令 $\\Delta x = - \\eta \\nabla f(x), \\ \\ (\\eta &gt; 0)$，其中步长 $\\eta$ 为一个较小的正数，从而有：</p>\n<p>$$<br>\\Delta x \\nabla f(x) = - \\eta \\left( \\nabla f(x) \\right)^2 &lt; 0<br>$$</p>\n<p>令 $\\Delta x = - \\eta \\nabla f(x)$ 即可确保 $\\left( \\nabla f(x) \\right)^2 &gt; 0$。</p>\n<p>因此，对 $x$ 的更新为：$x^{t + 1} = x + \\Delta x = x^t - \\eta \\nabla f(x)$，也即 $x$ 向负梯度方向 $- \\eta \\nabla f(x)$ 移动步长 $\\eta$，会使得$f(x^{t + 1}) &lt; f(x^t)$，$\\eta$ 也称为学习率。</p>\n<p>由于只对 $f(x)$ 进行一阶泰勒展开，因此梯度下降法是一阶最优化算法。</p>\n<h3 id=\"2-3-OLS的梯度下降\"><a href=\"#2-3-OLS的梯度下降\" class=\"headerlink\" title=\"2.3 OLS的梯度下降\"></a>2.3 OLS的梯度下降</h3><p>OLS 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\\\<br>&amp;= ||y - X W||^2_2<br>\\\\<br>&amp;= (y - X W)^T (y - X W)<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W = -2 X^T (y - X W)<br>$$</p>\n<p>梯度下降：</p>\n<p>$$<br>\\begin{aligned}<br>W^{t + 1} &amp;= W^t - \\eta \\nabla J(W^t)<br>\\\\<br>&amp;= W^t + 2 \\eta X^T (y - X W^T)<br>\\end{aligned}<br>$$</p>\n<p>其中 $(y - X W^T)$ 即为预测残差 r，说明参数的更新量与输入 X 和预测残差 r 的相关性有关。$X^T$ 与 r 的相关性较强时需要把 $\\eta$ 调大一些，则 r 逐渐与输入 $X^T$ 无关，直到无需再更新 W。</p>\n<p>OLS 的梯度下降过程：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $W^{t = 0}$ 为初始值（或 0）；</p>\n<p>（2）计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$；</p>\n<p>（3）根据学习率 $\\eta$，更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$；</p>\n<p>（4）判断是否满足迭代终止条件。若满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t + 1})$，否则跳转至第 2 步。</p>\n<p>迭代终止条件有：</p>\n<p>（1）迭代次数达到预设的最大次数。</p>\n<p>（2）迭代过程中目标函数的变化值小于预设值：$\\dfrac{J(W^t) - J(W^{t + 1})}{J(W^t)} \\le \\varepsilon$。</p>\n<h3 id=\"2-4-Ridge的梯度下降\"><a href=\"#2-4-Ridge的梯度下降\" class=\"headerlink\" title=\"2.4 Ridge的梯度下降\"></a>2.4 Ridge的梯度下降</h3><p>Ridge 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W + 2 \\lambda W<br>$$</p>\n<p>Ridge 的梯度下降过程与 OLS 的相同。</p>\n<h3 id=\"2-5-Lasso次梯度法\"><a href=\"#2-5-Lasso次梯度法\" class=\"headerlink\" title=\"2.5 Lasso次梯度法\"></a>2.5 Lasso次梯度法</h3><p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |W_j|<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>绝对值函数 &amp;||W||_1&amp; 在原点 $W = 0$ 处不可导，无法使用梯度下降求解。</p>\n<p>（1）可用次梯度概念替换梯度，得到次梯度法。</p>\n<p>（2）或用坐标轴下降求解。</p>\n<h3 id=\"2-6-梯度下降的实用Tips\"><a href=\"#2-6-梯度下降的实用Tips\" class=\"headerlink\" title=\"2.6 梯度下降的实用Tips\"></a>2.6 梯度下降的实用Tips</h3><p>（1）梯度下降中的学习率 η 需要小心设置。太大可能引起目标函数震荡，太小收敛速度过慢，可以采用自适应学习率的方案：</p>\n<p><img data-src=\"./different_eta.png\" alt=\"不同 η 的影响\" title=\"@ASSET\"></p>\n<p>（2）梯度下降对特征的取值范围敏感，建议对输入特征 X 做去量纲处理（可用 sklearn.preprocessing.StandardScaler 实现）：</p>\n<p>$$<br>W^{t + 1} = W^t + 2 \\eta X^T (y - X W^t) \\ \\ \\ \\ （与输入 X 的取值有关）<br>$$</p>\n<p>梯度下降算法延伸阅读：<a href=\"https://www.analyticsvidhya.com/blog/2017/03/introduction-to-gradient-descent-algorithm-along-its-variants/\" title=\"@LINK\">Introduction to Gradient Descent Algorithm (along with variants) in Machine Learning</a></p>\n<h3 id=\"2-7-随机梯度下降\"><a href=\"#2-7-随机梯度下降\" class=\"headerlink\" title=\"2.7 随机梯度下降\"></a>2.7 随机梯度下降</h3><p>在机器学习模型中，目标函数形式为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>梯度形式为：</p>\n<p>$$<br>\\nabla J(W^t) = \\sum^N_{i = 1} \\nabla L \\left( y_i, f(X_i; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>当样本中存在信息冗余（正负抵消或梯度相似）时效率不高，因此可以使用随机梯度下降，即每次梯度下降更新时只计算一个样本上的梯度：</p>\n<p>$$<br>\\nabla J(W^t) = \\nabla L \\left( y_t, f(X_t; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>通俗而言，每一次迭代时，随机选择一个样本，向该样本的负梯度方向移动一步。梯度下降法每一次迭代都需要计算所有样本的梯度，随机梯度下降每一次迭代仅需计算单个样本的梯度：</p>\n<p>（1）为了确保收敛，相比于同等条件下的梯度下降，随机梯度下降需要采用更小的步长和更多的迭代轮数。</p>\n<p>（2）相比于非随机算法，随机梯度下降在前期的迭代效果卓越。</p>\n<p>小批量梯度下降法：介于一次使用所有样本（批处理梯度下降）和一次只是用一个样本（随机梯度下降）之间，也即在随机梯度下降中，每次使用一个小批量的样本代替单个样本。实践中常采用小批量样本（mini-batch）下降。</p>\n<blockquote>\n<p>随机梯度下降参考文章：</p>\n<p>① “Stochastic Gradient Descent” L. Bottou - Website, 2010<br>② “The Tradeoffs of Large Scale Machine Learning” L. Bottou - Website, 2011</p>\n</blockquote>\n<h2 id=\"2-8-Ridge和SGDRegressor\"><a href=\"#2-8-Ridge和SGDRegressor\" class=\"headerlink\" title=\"2.8 Ridge和SGDRegressor\"></a>2.8 Ridge和SGDRegressor</h2><h3 id=\"2-8-1-Ridge\"><a href=\"#2-8-1-Ridge\" class=\"headerlink\" title=\"2.8.1 Ridge\"></a>2.8.1 Ridge</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=’auto’,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>（1）其中与优化计算有关的参数如下：</p>\n<ul>\n<li><p><code>max_iter</code>: 共轭梯度求解器的最大迭代次数。</p>\n<p>对于优化算法 solver 为 ‘sparse_cg’ 和 ‘lsqr’，则默认值由 <code>scipy.sparse.linalg</code> 确定，对于 ‘sag’ 求解器，默认值为 1000。</p>\n</li>\n<li><p><code>tol</code>: 解的精度，判断迭代收敛与否的阈值。</p>\n<p>当（loss &gt; previous_loss - tol）时迭代终止。</p>\n</li>\n<li><p><code>solver</code>: 求解最优化问题的算法。</p>\n<p>可取：’auto’，’svd’，’cholesky’，’lsqr’，’sparse_cg’，’sag’，’saga’。</p>\n</li>\n<li><p><code>random_state</code>: 数据洗牌时的随机种子。</p>\n<p>仅用于 ‘sag’ 求解器。</p>\n</li>\n</ul>\n<p>（2）其中求解器 <code>solver</code> 可选的算法如下：</p>\n<ul>\n<li><p><code>auto</code>: 根据数据类型自动选择求解器。</p>\n<p>默认算法。</p>\n</li>\n<li><p><code>svd</code>: 使用 X 的奇异值分解来计算 Ridge 系数。</p>\n<p>对于奇异矩阵，比 ‘cholesky’ 更稳定。</p>\n</li>\n<li><p><code>cholesky</code>: 使用标准的 <code>scipy.linalg.solve</code> 函数获得解析解。</p>\n</li>\n<li><p><code>sparse_cg</code>: 使用 <code>scipy.sparse.linalg.cg</code> 中的共轭梯度求解器。</p>\n<p>对大规模数据，比“cholesky”更合适。</p>\n</li>\n<li><p><code>lsqr</code>: 使用专用的正则化最小二乘常数 <code>scipy.sparse.linalg.lsqr</code>。</p>\n<p>速度最快。</p>\n</li>\n<li><p><code>sag</code>: 使用随机平均梯度下降。</p>\n<p>当样本数 n_samples 和特征维数 n_feature 都很大时，通常比其他求解器更快。</p>\n</li>\n<li><p><code>saga</code>: ‘sag’ 的改进算法。</p>\n<p>当 <code>fit_intercept</code> 为 <code>True</code> 时，’sag’ 和 ‘saga’ 只支持稀疏输入。’sag’ 和 ‘saga’ 快速收敛仅在具有近似相同尺度的特征上被保证，因此数据需要标准化。</p>\n</li>\n</ul>\n<h4 id=\"2-8-2-SGDRegressor\"><a href=\"#2-8-2-SGDRegressor\" class=\"headerlink\" title=\"2.8.2 SGDRegressor\"></a>2.8.2 SGDRegressor</h4><p>Scikit-Learn 中实现了随机梯度下降回归：SGDRegressor，其对大数据量训练集（n_sample &gt; 10000）的回归问题合适。</p>\n<p>SGDRegressor 的目标函数为：</p>\n<p>$$<br>J(W) = \\dfrac {1} {N} \\sum^N_{i = 1} L \\left( y_i, f(X_i) \\right) + \\alpha R(W)<br>$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDRegressor</span></span><br><span class=\"line\">SGDRegressor(loss=<span class=\"string\">&#x27;squared_loss&#x27;</span>,</span><br><span class=\"line\">             penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">             alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">             l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">             fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">             random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             learning_rate=<span class=\"string\">&#x27;invscaling&#x27;</span>,</span><br><span class=\"line\">             eta0=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">             power_t=<span class=\"number\">0.25</span>,</span><br><span class=\"line\">             warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>（1）参数 <code>loss</code> 支持的损失函数包括：</p>\n<ul>\n<li><code>squared_loss</code>: L2 损失。</li>\n<li><code>huber</code>: Huber 损失。</li>\n<li><code>epsilon_insensitive</code>: ɛ 不敏感损失 (如：SVM)</li>\n<li><code>squared_epsilon_insensitive</code></li>\n</ul>\n<p>（2）参数 <code>penalty</code> 支持的正则函数包括：</p>\n<ul>\n<li><code>none</code>: 无正则</li>\n<li><code>l2</code>: L2正则</li>\n<li><code>l1</code>: L1正则</li>\n<li><code>elasticnet</code>: L1 正则 + L2 正则（配合参数 <code>l1_ratio</code> 为 L1 正则的比例）</li>\n</ul>\n<p>（3）参数 <code>epsilon</code> 是某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）需要的额外参数。</p>\n<p>（4）参数 <code>alpha</code> 是正则惩罚系数，也用于学习率计算。</p>\n<p>（5）优化算法有关的参数包括：</p>\n<ul>\n<li><p><code>max_iter</code>: 最大迭代次数（访问训练数据的次数，Epoches 的次数），默认值 5。</p>\n<p>一个迭代循环只使用一个随机样本的梯度，并且循环所有的样本，则称为一个 Epoches。SGD 在接近 $10^6$ 的训练样本时收敛。因此可将迭代数设置为 np.ceil($10^6$ / 𝑁)，其中 𝑁 是训练集的样本数目。参数 <code>n_iter</code> 意义相同，已被抛弃。</p>\n</li>\n<li><p><code>tol</code>: 停止条件。</p>\n<p>如果不为 ‘None’，则当（loss &gt; previous_loss - tol）时迭代终止。</p>\n</li>\n<li><p><code>shuffle</code>: 每轮 SGD 之前是否重新对数据进行洗牌。</p>\n</li>\n<li><p><code>random_state</code>: 随机种子，Scikit-Learn 中与随机有关的算法均有此参数，含义相同。</p>\n<p>当参数 <code>shuffle == True</code> 时使用。如果随机种子相同，每次洗牌得到的结果一样。可设置为某个整数以复现结果。</p>\n</li>\n<li><p><code>learning_rate</code>: 学习率。</p>\n<p>支持 3 种选择：</p>\n<ol>\n<li>‘constant’：$\\eta = \\eta_0$。</li>\n<li>‘optimal’：$\\eta = 1.0 / \\alpha * (t + t_0)$，分类任务中随机梯度下降默认值。</li>\n<li>‘invscaling’：$\\eta = \\eta_0 / pow(t, \\ power_t)$，回归任务重随机梯度下降默认值。</li>\n</ol>\n</li>\n<li><p><code>warm_start</code>: 是否从之前的结果继续。</p>\n<p>随机梯度下降中初始值可以是之前的训练结果，支持在线学习，即可以在原来的学习基础上继续学习新加入的样本并更新模型参数（输出）。初始值可在 <code>fit</code> 函数中作为参数传递。</p>\n</li>\n<li><p><code>average</code>: 是否采用平均随机梯度下降法（ASGD）。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-次梯度法\"><a href=\"#3-次梯度法\" class=\"headerlink\" title=\"3. 次梯度法\"></a>3. 次梯度法</h2><h3 id=\"3-1-什么是次梯度法\"><a href=\"#3-1-什么是次梯度法\" class=\"headerlink\" title=\"3.1 什么是次梯度法\"></a>3.1 什么是次梯度法</h3><p>当函数可导时，梯度下降法是非常有效的优化算法。但 Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$，其中正则项 $||W||_1$ 为绝对值函数，在 $W_j = 0$ 处不可导，无法计算梯度，也无法用梯度下降法求解。因此需要将梯度扩展为次梯度，用次梯度法求解该问题。</p>\n<p>为了处理不平滑函数，扩展导数的表示。定义一个凸函数 $f$ 在点 $x_0$ 处的 <strong>次导数</strong> 为一个标量 g，使得：</p>\n<p>$<br>f(x) - f(x_0) \\ge g(x - x_0), \\forall x \\in \\mathrm{I}<br>$</p>\n<p>其中 $\\mathrm{I}$ 为包含 $x_0$ 的某个区间。如下图所示，对于定义域中的任何 $x_0$，总可以做一条直线通过点 $(x_0, f(x_0))$，且直线要么接触 $f$，要么在其下方：</p>\n<p><img data-src=\"./subderivative.png\" alt=\"次导数\" title=\"@ASSET\"></p>\n<p>上式等价于：</p>\n<p>$<br>\\Delta f(x) \\ge g \\Delta x \\Rightarrow g \\le \\dfrac {\\Delta f(x)} {\\Delta x}<br>$</p>\n<p>从该直线方程可知，$g$ 也就是在直线 $y = f(x_0)$ 下方的直线的斜率，所有 $g$ 的解（斜率）都称为函数的次导数（Subderivative），所有次导数（$g$ 的解）的集合称为函数 $f$ 在 $x_0$ 处的次微分（Subdifferential），记为 $\\partial f(x_0)$。</p>\n<p>次微分是次导数的集合，定义该集合为区间 $[a, b]$：</p>\n<p>$$<br>a = \\lim_{x \\rightarrow x^-_0} \\dfrac {f(x) - f(x_0)} {x - x_0}, \\quad b = \\lim_{x \\rightarrow x^+_0} \\dfrac {f(x) - f(x_0)} {x - x_0}<br>$$</p>\n<p>也即 $x_0$ 点的次微分的集合左边界 $a$ 是从点 $x_0$ 的左侧逼近函数值，右边界 $b$ 是从点 $x_0$ 的右侧逼近函数值。<strong>当函数在 $x_0$ 处可导时，该点的次微分只有一个点组成，也就是函数在该点的导数。</strong></p>\n<p>例如求凸函数 $f(x) = |x|$ 的次微分，由于 $f(x)$ 在点 $x = 0$ 处不可导，因此该点的次微分区间左边界为 $f(0^-) = -1$，右边界为 $f(0^+) = 1$：</p>\n<p>$$<br>\\partial f(x) = \\left \\{<br>\\begin{aligned}<br>\\{ -1 \\}, &amp;&amp; {x &lt; 0}<br>\\\\<br>[-1, +1], &amp;&amp; {x = 0}<br>\\\\<br>\\{ +1 \\}, &amp;&amp; {x &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>若求解多维点的次微分，则分别求解每个分量的次微分并组成向量，即作为函数在该点的次梯度。</p>\n<h3 id=\"3-2-梯度法与次梯度法的区别\"><a href=\"#3-2-梯度法与次梯度法的区别\" class=\"headerlink\" title=\"3.2 梯度法与次梯度法的区别\"></a>3.2 梯度法与次梯度法的区别</h3><p>对可导函数，最优解的条件为 $f(x) = 0$，对此类仅局部可导，需要使用次微分的函数，最优解的条件为：</p>\n<p>$<br>0 \\in \\partial f(x^<em>) \\Longleftrightarrow f(x^</em>) = \\min_x f(x)<br>$</p>\n<p>当且仅当 0 属于函数 $f$ 在点 $x^<em>$ 处次梯度集合时，$x^</em>$ 为极值点。当然，因为函数在可导的点的次微分等于其导数，因此该条件可扩展到全局可导函数。</p>\n<blockquote>\n<p>Python 可用 <code>numpy.sign</code> 函数实现绝对值函数的次梯度。</p>\n</blockquote>\n<p>将梯度下降法中的梯度换成次梯度就得到次梯度法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">梯度下降法</th>\n<th align=\"left\">次梯度法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n</tr>\n<tr>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$</td>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的次梯度：$\\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$</td>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">4. 判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n<td align=\"left\">判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n</tr>\n</tbody></table>\n<p><strong>结论：</strong></p>\n<p>与梯度下降算法不同，次梯度算法并不是下降算法（每次对参数的更新，并不能保证目标函数单调递减）。因此一般情况下会从多个点同时应用次梯度法，最后选择最小值：</p>\n<p>$$<br>f(x^*) = \\min_{1, …, t} f(x^t)<br>$$</p>\n<p>虽然次梯度法不能保证迭代过程中目标函数保持单调下降，但可以证明，满足一定条件的凸函数，次梯度法可以保证收敛，只是收敛速度比梯度下降法慢。因此 Lasso 通常使用 <strong>坐标轴下降法</strong> 求解。</p>\n<hr>\n<h2 id=\"4-坐标轴下降法求解\"><a href=\"#4-坐标轴下降法求解\" class=\"headerlink\" title=\"4. 坐标轴下降法求解\"></a>4. 坐标轴下降法求解</h2><p>次梯度法收敛速度慢，Lasso 求解推荐使用坐标轴下降法。</p>\n<p>坐标轴下降法即：沿着坐标轴方向搜索。和梯度下降法与随机梯度下降法的概念类似，例如对 D 维样本参数 $W_0, …, W_D$，坐标轴下降法是每次仅对其中一个 $W_j$ 搜索最优值。循环使用不同的坐标轴（不同维度），一个周期的以为搜索迭代过程相当于一个梯度迭代。</p>\n<p>坐标轴下降发利用当前坐标系统进行搜索，无需计算目标函数的导数，只按照某一坐标方向进行搜索最小值，而梯度下降法验目标函数的负梯度方向搜索，因此梯度方向通常不与任何坐标轴平行。</p>\n<p>坐标轴下降法在系数矩阵上的计算速度非常快。</p>\n<h3 id=\"4-1-Lasso坐标轴下降的数学解释\"><a href=\"#4-1-Lasso坐标轴下降的数学解释\" class=\"headerlink\" title=\"4.1 Lasso坐标轴下降的数学解释\"></a>4.1 Lasso坐标轴下降的数学解释</h3><p>Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$。</p>\n<p>将 Lasso 目标函数中的损失和及正则项分别应用坐标轴下降法搜索，每次仅搜索一个维度。定义 $w_{-j}$ 为 $W$ 去掉 $w_j$ 后的剩余 $(D - 1)$ 维向量。</p>\n<p>（1）对 RSS 的第 j 维坐标轴下降（可导，直接计算梯度）：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - (W^T_{-j} X_{i, -j} + w_j x_{ij}))^2<br>\\\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_j x_{ij})^2<br>\\\\<br>（复合函数求导） &amp;= -2 \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_i x_{ij}) \\cdot x_{ij}<br>\\\\<br>&amp;= 2 \\sum^N_{i = 1} x^2_{ij} w_j - 2 \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\\\ \\\\<br>令：a_j &amp;= 2 \\sum^N_{i = 1} x^2_{ij}, \\quad c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\\\ \\\\<br>\\Longrightarrow \\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= a_j w_j - c_j<br>\\end{aligned}<br>$$</p>\n<p>（2）再对 $R(W)$ 的第 j 维坐标轴下降（计算次梯度）：</p>\n<p>$$<br>\\dfrac {\\partial} {\\partial w_j} R(W) = \\dfrac {\\partial} {\\partial w_j} \\lambda |w_j| =<br>\\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} (- w_j \\lambda) = \\{ - \\lambda \\}, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; [- \\lambda, + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; \\dfrac {\\partial} {\\partial w_j} (w_j \\lambda) = \\{ \\lambda \\}, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>（3）合并为对 $J(W, \\lambda)$ 的第 j 维坐标轴下降：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda) = \\dfrac {\\partial} {\\partial w_j} (RSS + R(W))<br>\\\\<br>&amp;= \\left \\{<br>\\begin{aligned}<br>&amp; \\{ a_j w_j - c_j - \\lambda \\}, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; [a_j w_j - c_j - \\lambda, a_j w_j - c_j + \\lambda] = [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; \\{ a_j w_j - c_j + \\lambda \\}, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>\\end{aligned}<br>$$</p>\n<p>（4）最优解需满足：$0 \\in \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$，对于可导部分，则为 $0 = \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$：</p>\n<p>$$<br>\\Longrightarrow \\left \\{<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; 0 = a_j w_j - c_j + \\lambda, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>其中：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda]<br>\\\\<br>&amp; \\Longrightarrow \\left \\{<br>\\begin{aligned}<br>0 \\ge - c_j - \\lambda<br>\\\\<br>0 \\le - c_j + \\lambda<br>\\end{aligned}<br>\\right.<br>\\\\<br>&amp; \\Longleftrightarrow c_j \\in [- \\lambda, \\lambda]<br>\\end{aligned}<br>$</p>\n<p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij} &gt; 0$，</p>\n<p>① 当 $w_j &lt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda<br>\\\\<br>&amp; w_j = \\dfrac {c_j + \\lambda} {a_j} &lt; 0<br>\\\\<br>&amp; \\Longrightarrow c_j &lt; - \\lambda<br>\\end{aligned}<br>$</p>\n<p>② 同理，当 $w_j &gt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j + \\lambda<br>\\\\<br>&amp; w_j = \\dfrac {c_j - \\lambda} {a_j} &gt; 0<br>\\\\<br>&amp; \\Longrightarrow c_j &gt; \\lambda<br>\\end{aligned}<br>$</p>\n<p>因此可以转换为下式：</p>\n<p>$$<br>\\hat{w_j}(c_j) = \\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<h3 id=\"4-2-Lasso坐标轴下降步骤\"><a href=\"#4-2-Lasso坐标轴下降步骤\" class=\"headerlink\" title=\"4.2 Lasso坐标轴下降步骤\"></a>4.2 Lasso坐标轴下降步骤</h3><p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$ 对于已知的输入 $X$ 是可以预计算的，因此 Lasso 坐标轴下降的步骤如下：</p>\n<p>① 预计算 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$</p>\n<p>② 初始化参数 $W$（全 0 或随机）</p>\n<p>③ 选择变化幅度最大的维度、或随机选择、或轮流选择需要更新的参数 $w_j$</p>\n<p>④ 计算 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$</p>\n<p>⑤ 计算 $\\hat{w_j}(c_j) = \\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.$</p>\n<p>⑥ 重复第 3 ~ 5 步直到收敛</p>\n<p>⑦ 根据训练好的 $W$ 调整 $\\lambda$ 的取值。</p>\n<p><strong>注意：</strong></p>\n<p>$c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$，其中的 $W^T_{-j} X_{i, -j}$ 本质上是分别从 $W$ 和 $X$ 中各去掉了一维后的向量/矩阵相乘，但从另一方面理解，也可以认为是去掉了第 j 维特征后用剩下的特征计算出来的预测值，因此 $y_i - W^T_{-j} X_{i, -j}$ 实际上也是第 i 个样本的预测残差 $r_i$，而 $c_j = X_j \\cdot r$ 可以表示输入特征 $X$ 和预测残差 $r$ 的相关性。</p>\n<p><strong>（1）当特征与预测残差强相关时，表示该输入特征的取值（实际上由权重 $w_j$ 控制）对预测结果（残差）有很大影响（例如 $r_j$ 下降很快），则说明这个特征很重要（即权重 $w_j$ 是必须的）。</strong></p>\n<p><strong>（2）当特征与预测残差弱相关时，则表示有没有该特征对预测结果没有什么影响，因此直接使得 $w_j = 0$，这也是 L1 正则起到特征选择作用的原理。</strong></p>\n<p><strong>（3）这也印证了目标函数 $J(W, \\lambda) = \\sum Loss + \\lambda R(W)$ 中正则参数 $\\lambda$ 的理解：$\\lambda$ 为正则项的惩罚，$\\lambda$ 越大，对应的 $[ -\\lambda, \\lambda]$ 区间也越宽，则 $w_j = 0$ 的可能性越大，因此得到的解越稀疏，从而 $W$ 的复杂度越低。</strong></p>\n<p><strong>（4）是否 $c_j \\in [- \\lambda, \\lambda]$ 决定了 $w_j$ 是否为 0，而 $c_j$ 同样表示输入特征和预测残差之间的相关性。当 $\\lambda$ 大于某个最值时，会导致所有的权重均为零 $w_j = 0$。这个最大值同样是可以预计算的：当 $\\lambda$ 取最大值时，所有权重均为零，因此每条样本的预测值全为 0，对应的每条样本的预测残差即为真实值本身：$r_i = y_i$，因此 $c_j$ 即可用输入特征和真实值的相关性来代替：$c_j = X^T_{: j} y$，其中 $X_{: j}$ 表示所有样本的第 j 维特征值，因此当 $\\lambda \\ge \\max_j (X^T_{: j} y)$ 时，可得所有 $w_j = 0$。</strong></p>\n<h3 id=\"4-3-Scikit-Learn中的Lasso\"><a href=\"#4-3-Scikit-Learn中的Lasso\" class=\"headerlink\" title=\"4.3 Scikit-Learn中的Lasso\"></a>4.3 Scikit-Learn中的Lasso</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X =<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"number\">1000</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      positive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>precompute</code>: 是否使用预计算的 Gram 矩阵来加速计算。</p>\n<p>可取值：’True’, ‘False’, ‘auto’ 或数组（array-like）。若设置为 ‘auto’ 则由机器决定。</p>\n</li>\n<li><p><code>max_iter</code>: 最大迭代次数。</p>\n</li>\n<li><p><code>tol</code>: 解的精度，判断迭代收敛与否的阈值。</p>\n<p>当更新量小于tol时，优化代码检查优化的 dual gap 并继续直到小于 tol 为止。</p>\n</li>\n<li><p><code>warm_start</code>: 是否从之前的结果继续。</p>\n<p>初始值可以是之前的训练结果，支持在线学习。初始值可在 fit 函数中作为参数传递。</p>\n</li>\n<li><p><code>positive</code>: 是否强制使系数 $W$ 为正。</p>\n</li>\n<li><p><code>random_state</code>: 随机选择特征的权重进行更新的随机种子。</p>\n<p>仅当参数 <code>selection == &#39;random&#39;</code> 时有效。</p>\n</li>\n<li><p><code>selection</code>: 选择特征权重更新的方式。</p>\n<p>可选项有：</p>\n<ol>\n<li>‘cyclic’：循环更新</li>\n<li>‘random’：随机选择特征进行更新，通常收敛更快，尤其当参数 tol &gt; (10 - 4) 时。</li>\n</ol>\n</li>\n</ul>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-Logistic回归简介","url":"/post/machinelearning/ml-logistic/ml-logistic-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-Logistic回归简介\"><a href=\"#ML入门-Logistic回归简介\" class=\"headerlink\" title=\"ML入门-Logistic回归简介\"></a>ML入门-Logistic回归简介</h1><h2 id=\"1-Logistic回归简介\"><a href=\"#1-Logistic回归简介\" class=\"headerlink\" title=\"1. Logistic回归简介\"></a>1. Logistic回归简介</h2><p>回归任务和分类任务都属于有监督学习（Supervised Learning），其训练数据的格式为：$D = \\{ X_i, y_i \\}^N_{i = 1}$。回归任务中 $y_i \\in R$，而分类任务中 $y_i \\in C, C = \\{ 1, \\cdots c \\}$，任务目标都为：学习一个从输入 $X$ 到输出 $y$ 的映射 $f$。分类任务的图示如下：</p>\n<p><img data-src=\"./classify_demo.png\" alt=\"分类任务图示\" title=\"@ASSET\"></p>\n<p>典型的分类任务有：垃圾邮件过滤、手写数字/文本识别、语音识别、人脸识别、医疗诊断、金融风控等。</p>\n<p>贝努力（Bernoulli）分布：$y \\sim Bernoulli(\\mu)$，其中 $\\mu$ 为分布的期望，表示 $y = 1$ 的概率。则该分布的概率密度函数为：</p>\n<p>$<br>p(y; \\mu) = \\mu^y (1 - \\mu)^{(1 - y)}<br>$</p>\n<p>以两类分类为例。两类分类任务中，假设样本的输出为 $y_i \\in \\{ 0, 1 \\}$，当给定输入 $X$ 的情况下，输出 y 符合贝努力分布：</p>\n<p>$<br>y | X \\sim Bernoulli(\\mu (X))<br>$</p>\n<p>其中期望 $\\mu (X)$ 表示在给定 $X$ 的情况下，$y = 1$ 的概率。则其概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu) = \\mu (X)^y (1 - \\mu (X))^{1 - y}<br>$</p>\n<p>$<br>p(y = 1) = \\mu(X), \\quad p(y = 0) = 1 - \\mu (X)<br>$</p>\n<h3 id=\"1-1-Sigmoid函数\"><a href=\"#1-1-Sigmoid函数\" class=\"headerlink\" title=\"1.1 Sigmoid函数\"></a>1.1 Sigmoid函数</h3><p>当选择最简单的线性模型来表示期望 $\\mu (X)$ 时，即 $\\mu (X) = W^T X$，期望 $\\mu(X)$ 表示 $y = 1$ 的概率，因此 $\\mu (X) \\in [0, 1]$，而 $W^T X \\in (- \\infty, + \\infty)$，因此需要把 $(- \\infty, + \\infty)$ 缩放到 $[0, 1]$：Sigmoid 函数。</p>\n<p>Sigmoid 函数表达式为：$\\sigma (z) = \\dfrac {1} {1 + e^{-z}}$，其图形如下：</p>\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n<p><strong>Sigmoid 函数亦被称为 Logistic 函数或 Logit 函数，Logistic 回归亦被称为 Logit 回归。</strong></p>\n<blockquote>\n<p>LogisticRegression 虽然名字上用了“回归”，但实际上是分类算法。</p>\n</blockquote>\n<p>使用 Sigmoid 函数对 $W^T X$ 缩放后得到：</p>\n<p>$<br>p(y = 1 | X) = \\mu (X) = \\sigma (W^T X)<br>$</p>\n<p>$<br>p(y = 0 | X) = 1 - \\mu (x) = 1 - \\sigma (W^T X)<br>$</p>\n<p>定义一个事件的几率（Odd，与概率 Probability 不是一个概念）为该事件发生的概率与不发生的概率的比值：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\dfrac {\\sigma (W^T X)} {1 - \\sigma (W^T X)} = \\dfrac {\\dfrac {1} {1 + e^{- W^T X}}} {\\dfrac {e^{- W^T X}} {1 + e^{- W^T X}}} = e^{W^T X}<br>$</p>\n<p>两边同取 $\\log$ 运算，得到 <strong>对数几率</strong>：$\\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\log (e^{W^T X}) = W^T X$。</p>\n<p>当 $p(y = 1 | X) &gt; p(y = 0 | X)$ 时，如果取最大后验概率，即输入 $X$ 的类别取 $y = 1$，则有：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} &gt; 0, \\Longrightarrow \\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = W^T X &gt; 0<br>$</p>\n<p>  ① 当 $W^T X &gt; 0$ 时，$p(y = 1 | X) &gt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 1$。</p>\n<p>  ② 当 $W^T X &lt; 0$ 时，$p(y = 1 | X) &lt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 0$。</p>\n<p>  ③ 当 $W^T X = 0$ 时，$p(y = 1 | X) = p(y = 0 | X)$，输入 $X$ 对应的类别可以是 1 或 0，此时 $X$ 位于决策面上，可以将 $X$ 分类到任意类别，或拒绝作出判断。</p>\n<p>令决策函数 $f(X) = W^T X$，其根据 $W^T X$ 的符号将输入控件 $X$ 分出两个区域。由于 $W^T X$ 为线性函数，因此 Logistic 回归模型是一个线性分类器。一个线性分类模型实例如下：</p>\n<p><img data-src=\"./linear_classify.png\" alt=\"线性分类实例\" title=\"@ASSET\"></p>\n<h3 id=\"1-2-决策边界\"><a href=\"#1-2-决策边界\" class=\"headerlink\" title=\"1.2 决策边界\"></a>1.2 决策边界</h3><p>更一般地：根据需要划分的类别，分类器将输入控件 $X$ 划分为一些互不相交的区域。这些区域的边界叫决策边界（Decision Boundaries）。根据预测函数 $f$ 的不同，会使得决策面或光滑、或粗糙。</p>\n<p>当决策面是输入 $X$ 的线性函数时，称为线性决策面，对应的分类器就是线性分类器。</p>\n<p>分类器为每个类别分配一个判别函数，根据判别函数来判断一个新样本属于该类别的可能性，然后将新样本归类为可能性最大的一类。假设有 C 个类别，则对应有 C 个判别函数：$\\delta_c (X), c \\in \\{ 1, \\cdots, C \\}$。</p>\n<p>对一个新样本 $X$，通常是找到最大的 $\\delta_c (X)$，即该样本的类别为：</p>\n<p>$$<br>\\hat{y} = \\arg_c \\max \\delta_c (X)<br>$$</p>\n<p>判别函数 $\\delta_c (X)$ 和  $\\delta_k (X)$ 相等的点的集合，就是分类 C 和分类 K 之间的决策面：</p>\n<p><img data-src=\"./decision_separating_hyperplane.png\" alt=\"分类决策面\" title=\"@ASSET\"></p>\n<p>例如两类分类问题中，决策函数 $f_1 = p(y = 1 | X)$ 即为类别 $y = 1$ 的判别函数，决策函数 $f_0 = p(y = 0 | X)$ 即为类别 $y = 0$ 的判别函数。若对一新样本 $X$，有 $f_1 (X) &gt; f_0 (X)$，则新样本 $X$ 被分入类别 $y = 1$。</p>\n<hr>\n<h2 id=\"2-Logistic损失函数\"><a href=\"#2-Logistic损失函数\" class=\"headerlink\" title=\"2. Logistic损失函数\"></a>2. Logistic损失函数</h2><h3 id=\"2-1-负log似然损失\"><a href=\"#2-1-负log似然损失\" class=\"headerlink\" title=\"2.1 负log似然损失\"></a>2.1 负log似然损失</h3><p>以两类分类问题为例，直观地，可以定义一种损失：0 / 1 损失，预测类别正确时预测损失为 0，否则为 1。记为：</p>\n<p>$<br>L(y, \\hat{y}) = \\left \\{<br>\\begin{aligned}<br>0, &amp;&amp; {y = \\hat{y}}<br>\\\\<br>1, &amp;&amp; {y \\ne \\hat{y}}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>但 0 / 1 损失不连续，优化计算不方便。因此需要寻找其他 <strong>替代损失函数（Surrogate Loss Function）</strong>。替代损失函数应当符合几个特征：</p>\n<ul>\n<li>通常是凸函数，计算方便。</li>\n<li>与 0 / 1 损失函数具有等效性。</li>\n</ul>\n<p>下图列举了几种不同的损失函数：</p>\n<p><img data-src=\"./some_loss_functions.png\" alt=\"多种损失函数图\" title=\"@ASSET\"></p>\n<p>图中横轴为 $y \\hat{y}$ 取值，纵轴为损失。</p>\n<p>定义两类分类中，真值 $y$ 只有两种取值：$y \\in \\{ 1, -1 \\}$，而预测值可取连续值：$\\hat{y} \\in \\{ - \\infty, + \\infty \\}$，以符号区分预测值的预测类别（正数对应类别 1，负数对应类别 -1），当 $y$ 和 $\\hat{y}$ 符号相同时（即 $y \\hat{y} &gt; 0$，对应图中横坐标右半部分）表示预测正确，此时损失为 0。反之亦然。</p>\n<p>可以看出，浅蓝色曲线 L2 损失并不能很好地代替 0 / 1 损失，因此优化 L2 损失并不能很好地优化模型的准确度。</p>\n<p>整理 Logistic 回归模型：$y | X \\sim Bernoulli (\\mu (X))$，对应的概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu (X)) = \\mu (X)^y (1 - \\mu (X))^{(1 - y)}<br>$</p>\n<p>其中，$\\mu (X)$ 是线性模型经过 Sigmoid 变化而来：$\\mu (X) = \\sigma (W^T X)$。</p>\n<p>Logistic 的似然函数为：$likelihood (f) = p(D) = \\prod^N_{i = 1} p(y_i | x_i)$，则 $\\log$ 似然函数为：</p>\n<p>$<br>\\begin{aligned}<br>l(\\mu) &amp;= \\log p(D) = \\log \\prod^N_{i = 1} p(y_i | x_i) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left( \\mu (X_i)^{y_i} (1 - \\mu (X_i))^{(1 - y_i)} \\right)<br>\\\\<br>&amp;= \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p>取极大似然估计        ：</p>\n<p>$<br>\\begin{aligned}<br>\\max l(\\mu) &amp;= - \\min l(\\mu)<br>\\\\<br>&amp;= \\min - \\left( \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i)) \\right)<br>\\\\<br>&amp;= \\min \\sum^N_{i = 1} - y_i \\log (\\mu (X_i)) - (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p><strong>因此极大似然估计等价于最小训练集上的负 $\\log$ 损失。而负 $\\log$ 似然损失亦被称为 Logistic 损失。</strong></p>\n<h3 id=\"2-2-交叉熵损失\"><a href=\"#2-2-交叉熵损失\" class=\"headerlink\" title=\"2.2 交叉熵损失\"></a>2.2 交叉熵损失</h3><p>Logistic 损失亦被称为 <strong>交叉熵损失（Corss Entropy Loss, CE）</strong>。</p>\n<p>交叉熵损失：两个分布之间的差异（已知真实分布的情况下，预测分布与真实分布之间的差异）。定义交叉熵 $H(p, q)$ 如下：</p>\n<p>$$<br>\\begin{aligned}<br>H(p, q) &amp;= \\sum_x p(x) \\log (\\dfrac {1} {q(x)})<br>\\\\<br>&amp;= - \\sum_x p(x) \\log (q(x))<br>\\end{aligned}<br>$$</p>\n<p>假设预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，即 $\\hat{y} \\sim Bernoulli (\\mu (X))$，则预测值 $\\hat{y} = 0$ 的概率为 $1 - \\mu (X)$。</p>\n<p>（1）假设已知真值 $y = 1$，即 $y | X \\sim Bernoulli (1)$，即在已知真值 $y = 1$ 的情况下，$y$ 取 1 的概率 $\\mu = p(y = 1) = 1$，因此 $y = 0$ 的概率 $p(y = 0) = 0$。则这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 1, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\\\<br>&amp;= - \\log \\mu (X)<br>\\end{aligned}<br>$</p>\n<p>（2）同理，假设已知真值 $y = 0$，即 $y | X \\sim Bernoulli (0)$，因此 $\\mu = p(y = 1) = 0$，$p(y = 0) = 1$，此时这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 0, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\\\<br>&amp;= - \\log (1 - \\mu (X))<br>\\end{aligned}<br>$</p>\n<p>整理合并得：</p>\n<p>$<br>CE(y, \\hat{y}) = \\left \\{<br>\\begin{aligned}<br>&amp; - \\log \\mu (X), &amp;&amp; {y = 1}<br>\\\\<br>&amp; - \\log (1 - \\mu (X)), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>定义 $p_t$（Probability of Ground Truth Class）为：</p>\n<p>$<br>p_t = \\left \\{<br>\\begin{aligned}<br>&amp; \\mu (X), &amp;&amp; {if (y = 1)}<br>\\\\<br>&amp; 1 - \\mu (X), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>则可得到交叉熵损失简洁表达式：</p>\n<p>$$<br>CE(y, \\hat{y}) = - \\log (p_t)<br>$$</p>\n<p>交叉熵损失与 $p_t$ 的关系曲线如下：</p>\n<p><img data-src=\"./cross_entropy_and_pt.png\" alt=\"交叉熵损失曲线\" title=\"@ASSET\"></p>\n<blockquote>\n<p><strong>对 $p_t$ 的理解：根据 $p_t$ 的表达式，当真实值 $y = 1$ 时，$p_t = \\mu (X)$。由于 $\\mu (X)$ 表示的是预测值 $\\hat{y} = 1$ 的概率，因此 $p_t$ 即表示预测分布接近真实分布的概率。因此 $p_t$ 越大，表示预测越准确，同时对应的交叉熵损失 $Loss = - \\log (p_t)$ 也就越小，与图中曲线含义相同。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"3-Logistic正则项\"><a href=\"#3-Logistic正则项\" class=\"headerlink\" title=\"3. Logistic正则项\"></a>3. Logistic正则项</h2><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失，由于预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，因此可使用 $\\mu (X)$ 表示 $\\hat{y}$：</p>\n<p>$<br>\\begin{aligned}<br>&amp; L(y, \\mu(X)) = -y \\log (\\mu (X)) - (1- y) \\log (1 - \\mu (X))<br>\\\\<br>&amp; \\mu (X) = \\sigma (W^T X)<br>\\end{aligned}<br>$</p>\n<p>Logistic 回归的目标函数同样包括训练集上的损失和与正则项，正则项同样可选 L1 正则、L2 正则、或 L1 + L2 正则。</p>\n<p>假设有一个两类分类任务，且训练样本完全可分（即所有同类样本均可被分对），为了使 Logistic 损失和最小（完全可分时最小损失和即为 0），则对每个样本有：$L(y_i, \\mu (x_i)) = 0$。当想要使得每个样本损失均为 0 时，即：</p>\n<blockquote>\n<p>① 对于每个真实值 $y_i = 1$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 1（必定预测分类为 1），也即 $\\mu (X) = 1$。</p>\n<p>② 而对于每个真实值 $y_i = 0$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 0（不可能预测分类为 1），也即 $\\mu (X) = 0$。</p>\n</blockquote>\n<p>由于 $\\mu (X) = \\sigma (W^T X)$ 是将线性模型 $W^T X$ 经过 Sigmoid 变化而来，Sigmoid 图形如下：</p>\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n<p><strong>当 $\\mu (X)$ 取 $\\pm 1$ 时，$W^T X$ 取 $\\pm \\infty$，也即 $|W_j| = \\infty$，这样的模型是无意义的。</strong></p>\n<p><strong>因此 Logistic 回归必须加正则！</strong></p>\n<blockquote>\n<p>Scikit-Learn 中实现的 Logistic 回归 <code>LogisticRegression</code> 默认为 L2 正则。</p>\n</blockquote>\n<p>与 SVM 类似的是，Logistic 回归的超参数 $C$ 加在损失函数上：</p>\n<p>$$<br>J(W; \\lambda) = C \\sum^N_{i = 1} L(y_i, \\mu (x_i; W)) + R(W)<br>$$</p>\n<hr>\n<h2 id=\"4-Scikit-Learn中的Logistic\"><a href=\"#4-Scikit-Learn中的Logistic\" class=\"headerlink\" title=\"4. Scikit-Learn中的Logistic\"></a>4. Scikit-Learn中的Logistic</h2><p>Scikit-Learn 中实现了 3 种 Logistic 回归：</p>\n<ul>\n<li><code>LogisticRegression</code>: 最原始的 Logistic 回归模型，超参数调优时需要手动搭配 <code>GridSearchCV</code> 使用。</li>\n<li><code>LogisticRegressionCV</code>: Scikit-Learn 提供的已集成了交叉验证的 Logistic 回归模型，可以直接使用内置的交叉验证对超参数调优。</li>\n<li><code>SGDClassifier</code>: 随机梯度下降分类，则是在样本数很大（样本数 $N &gt; 10^5$，特征数 $M &gt; 10^5$）时效果更好。</li>\n</ul>\n<h3 id=\"4-1-LogitsicRegression\"><a href=\"#4-1-LogitsicRegression\" class=\"headerlink\" title=\"4.1 LogitsicRegression\"></a>4.1 LogitsicRegression</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegression</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegression(penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                   dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                   C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                   fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                   intercept_scaling=<span class=\"number\">1</span>,</span><br><span class=\"line\">                   class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   solver=<span class=\"string\">&#x27;liblinear&#x27;</span>,</span><br><span class=\"line\">                   max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                   multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                   verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                   warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-1-LogitsicRegression的参数\"><a href=\"#4-1-1-LogitsicRegression的参数\" class=\"headerlink\" title=\"4.1.1 LogitsicRegression的参数\"></a>4.1.1 LogitsicRegression的参数</h4><ul>\n<li><p><code>penalty</code>: 惩罚函数 / 正则函数，默认：’L2’。</p>\n<p>支持 L2 正则和 L1 正则。选择 L1 正则时优化器可选 ‘liblinear’ 和 ‘saga’。</p>\n</li>\n<li><p><code>dual</code>: 是否是对偶问题求解，默认：<code>False</code>。</p>\n<p>是原问题（primal）还是对偶问题（dual）求解。对偶问题只支持 L2 正则和 ‘liblinear’ 优化器。</p>\n</li>\n<li><p><code>tol</code>: 迭代终止判据的误差范围，默认：$10^{-4}$。</p>\n</li>\n<li><p><code>C</code>: 交叉熵损失函数系数，默认：1。</p>\n</li>\n<li><p><code>fit_intercept</code>: 是否在决策函数中加入截距项。默认：<code>True</code>。</p>\n<p>如果数据已经中心化，则不需要拟合截距项。</p>\n</li>\n<li><p><code>intercept_scaling</code>: 截距缩放因子。</p>\n<p>当 <code>fit_intercept</code> 为 <code>True</code> 且优化器 <code>solver</code> 设置为 <code>liblinear</code> 时有效。输入为 <code>[X, self.intercept_scaling]</code>，即对输入特征插入 1 维常数项。由于增加的常数项系数也受到 L1 / L2 正则的惩罚，因此要适当增大常数项。</p>\n</li>\n<li><p><code>class_weight</code>: 不同类别样本的权重。默认：<code>None</code>。</p>\n<p>可指定每类样本权重，或设置为 ‘balanced’，则每类样本权重与该类别样本数比例成反比。</p>\n</li>\n<li><p><code>random_state</code>: 随机种子，默认：<code>None</code>。</p>\n</li>\n<li><p><code>solver</code>: 优化求解算法，默认：’liblinear’。</p>\n<p>可选：’newton-cg’，’lbfgs’，’liblinear’，’sag’，’saga’。</p>\n<ul>\n<li>L1 正则优化器仅可选 ‘liblinear’ 和 ‘saga’，L2 正则可使用所有优化器。</li>\n</ul>\n</li>\n<li><p><code>max_iter</code>: 最大迭代次数，默认：100。</p>\n<p>仅当 <code>solver</code> 设置为 ‘newton-cg’，’sag’，或 ‘lbfgs’ 时有效。</p>\n</li>\n<li><p><code>multi_class</code>: 多类分类处理策略，默认：’ovr’。</p>\n<p>可选：’ovr’，’multinomial’。</p>\n<ul>\n<li><p>‘ovr’：One-Versus-Rest，一对多。将 C 类分类问题转化为 C 个两类分类问题，每一次分类当前类别样本为正样本，其余样本视为负样本。</p>\n</li>\n<li><p>‘multinomial’：即 softmax 分类器。使用 ‘multinomial’ 时，优化器仅可选 ‘newton-cg’，’lbfgs’，’sag’。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>OVO：One-Versus-One，一对一。</p>\n</blockquote>\n<p>OVR 相对简单但分类效果相对略差。MVM 分类相对精确，但分类速度比 OVR 慢。</p>\n<ul>\n<li><p><code>verbose</code>: 是否详细输出。</p>\n</li>\n<li><p><code>warm_start</code>: 是否热启动，默认：<code>False</code>。</p>\n<ul>\n<li><code>solver</code> 设置为 ‘liblinear’ 时无效。</li>\n</ul>\n</li>\n<li><p><code>n_jobs</code>: 多线程控制，默认：-1.</p>\n<p>取 -1 时算法自动检测可用 CPU 核，并使用全部核。</p>\n</li>\n</ul>\n<h4 id=\"4-1-2-LogitsicRegression的属性\"><a href=\"#4-1-2-LogitsicRegression的属性\" class=\"headerlink\" title=\"4.1.2 LogitsicRegression的属性\"></a>4.1.2 LogitsicRegression的属性</h4><ul>\n<li><p><code>coef</code>: 回归系数 / 权重。</p>\n<p>与特征的维数相同。如果是多任务回归，标签 $y$ 为 m 维数组，则回归系数也为 m 维数组。</p>\n</li>\n<li><p><code>intercept_</code>: 截距项。</p>\n</li>\n<li><p><code>n_iter_</code>: 每个类的迭代此时。</p>\n</li>\n</ul>\n<h4 id=\"4-1-3-LogitsicRegression的方法\"><a href=\"#4-1-3-LogitsicRegression的方法\" class=\"headerlink\" title=\"4.1.3 LogitsicRegression的方法\"></a>4.1.3 LogitsicRegression的方法</h4><ul>\n<li><p><code>fit(X, y[, sample_weight])</code>: 模型训练。</p>\n<p>参数 X，y 为训练数据，也可以通过 <code>sample_weight</code> 设置每个样本的权重。</p>\n</li>\n<li><p><code>predict(X)</code>: 返回 X 对应的预测值（类别标签）。</p>\n</li>\n<li><p><code>predict_log_proba(X)</code>: 返回 X 对应的预测值（每个类别对应的概率的 $log$ 值）。</p>\n</li>\n<li><p><code>predict_proba(X)</code>: 返回 X 对应的预测值（每个类别对应的概率）。</p>\n</li>\n<li><p><code>score(X, y[, sample_weight])</code>: 评估模型预测性能，返回模型预测的正确率。</p>\n</li>\n<li><p><code>decision_function(X)</code>: 预测的置信度（样本到分类超平面的带符号距离）。</p>\n<p>在分对的情况下，正样本得到的应为正值，负样本得到的应为负值。</p>\n</li>\n<li><p><code>densify()</code>: 如果之前将系数矩阵变成了稀疏模式，再将其变回稠密模式（<code>fit</code> 函数要求系数矩阵为稠密模式）。</p>\n</li>\n<li><p><code>sparsify()</code>: 将系数矩阵变成了稀疏模式。</p>\n</li>\n</ul>\n<h3 id=\"4-2-LogisticRegressionCV\"><a href=\"#4-2-LogisticRegressionCV\" class=\"headerlink\" title=\"4.2 LogisticRegressionCV\"></a>4.2 LogisticRegressionCV</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegressionCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegressionCV(Cs=<span class=\"number\">10</span>,</span><br><span class=\"line\">                     fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                     cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                     penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                     scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     solver=<span class=\"string\">&#x27;lbfgs&#x27;</span>,</span><br><span class=\"line\">                     tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                     max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                     class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                     verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                     refit=<span class=\"literal\">True</span>, i</span><br><span class=\"line\">                     ntercept_scaling=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                     multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                     random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-1-LogisticRegressionCV的参数\"><a href=\"#4-2-1-LogisticRegressionCV的参数\" class=\"headerlink\" title=\"4.2.1 LogisticRegressionCV的参数\"></a>4.2.1 LogisticRegressionCV的参数</h4><ul>\n<li><p><code>Cs</code>: 超参数调优范围。</p>\n<p>在区间 $[10^{-4}, 10^4]$ 的 $log$ 域均匀取 Cs 个值作为正则参数 C 的搜索空间。</p>\n</li>\n<li><p><code>cv</code>: 交叉校验划分策略。</p>\n</li>\n<li><p><code>solver</code>: 与 <code>LogisticRegression</code> 相同，但默认为 ‘lbfgs’。</p>\n</li>\n<li><p><code>multi_class</code>: 对多类分类问题，采用的是 ‘ovr’ 的方式，用交叉验证得到每个类的最佳正则参数。</p>\n</li>\n<li><p>其余参数与 <code>LogisticRegression</code> 相同。</p>\n</li>\n</ul>\n<h4 id=\"4-2-2-LogisticRegressionCV的属性\"><a href=\"#4-2-2-LogisticRegressionCV的属性\" class=\"headerlink\" title=\"4.2.2 LogisticRegressionCV的属性\"></a>4.2.2 LogisticRegressionCV的属性</h4><p>与 <code>LogisticRegression</code> 相同。</p>\n<h4 id=\"4-2-3-LogisticRegressionCV的方法\"><a href=\"#4-2-3-LogisticRegressionCV的方法\" class=\"headerlink\" title=\"4.2.3 LogisticRegressionCV的方法\"></a>4.2.3 LogisticRegressionCV的方法</h4><p>与 <code>LogisticRegression</code> 相同。</p>\n<h3 id=\"4-3-SGDClassifier\"><a href=\"#4-3-SGDClassifier\" class=\"headerlink\" title=\"4.3 SGDClassifier\"></a>4.3 SGDClassifier</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDClassifier</span></span><br><span class=\"line\"></span><br><span class=\"line\">SGDClassifier(loss=<span class=\"string\">&#x27;hinge&#x27;</span>,</span><br><span class=\"line\">              penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">              alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">              l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">              fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">              epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">              n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">              random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              learning_rate=<span class=\"string\">&#x27;optimal&#x27;</span>, </span><br><span class=\"line\">              ta0=<span class=\"number\">0.0</span>,</span><br><span class=\"line\">              power_t=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">              class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-1-SGDClassifier的参数\"><a href=\"#4-3-1-SGDClassifier的参数\" class=\"headerlink\" title=\"4.3.1 SGDClassifier的参数\"></a>4.3.1 SGDClassifier的参数</h4><ul>\n<li><p><code>lose</code>: 损失函数。</p>\n<p>可选：’hinge’（合页损失，SVM 中常用），’log’（负 $log$ 似然损失，即 Logistic 回归使用的损失），’modified_huber’（对噪声不损失），’squared_hinge’，’perceptron’，还有回归中使用的损失函数：’squared_loss’，’huber’，’epsilon_insensitive’，’squared_epsilon_insensitive’。</p>\n<p>使用回归的方式也可以实现分类。在分类中，$f(X)$ 表示样本输入 $X$ 取某个类别的概率，当使用回归的方式进行分类时，$f(X)$ 为一具体数值，可通过数值判断分类。例如二分类任务中，对 $f(X) &gt; 0.5$，分为类别 1，对 $f(X) &lt; 0.5$，分为类别 0。</p>\n</li>\n<li><p><code>epsilon</code>: 额外参数项。</p>\n<p>某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）所需要的额外参数。</p>\n</li>\n<li><p><code>penalty</code>: 正则项。</p>\n<p>可选：’none’，’l2’，’l1’，’elasticnet’（弹性网络，L1 + L2）。</p>\n</li>\n<li><p><code>alpha</code>: 正则惩罚系数。</p>\n<p>对应为目标函数中的 $\\lambda$，也用于学习率的计算。</p>\n</li>\n<li><p><code>l1_ratio</code>: L1 正则比例。</p>\n<p>仅当正则项为 ‘elasticnet’ 时有效，用于控制 L1 正则所占比例。</p>\n</li>\n</ul>\n<p>优化相关参数如下：</p>\n<ul>\n<li><p><code>max_iter</code>: 最大迭代次数（访问所有训练数据的次数 / epoches 次数），默认：5。</p>\n<p>SGD 在接近 $10^6$ 的训练样本时收敛，因此可将 <code>max_iter</code> 设置为 <code>np.ceil(10^6 / N)</code>（$\\dfrac {10^6} {N}$），其中 N 为训练集样本数。</p>\n</li>\n<li><p><code>tol</code>: 迭代停止条件。</p>\n<p>若非 <code>None</code>，则当 (loss &gt; previous_loss - tol) 时迭代终止。</p>\n</li>\n<li><p><code>learning_rate</code>: 学习率。</p>\n<p>对应为迭代优化算法中的 $\\alpha$。</p>\n<p>可选：’constant’，’optimal’，’invscaling’。</p>\n<ul>\n<li>‘constant’：eta = eta0</li>\n<li>‘optimal’：eta = 1.0 / (alpha * (t + t0))</li>\n<li>‘invscaling’：eta = eta0 / pow(t, power_t)</li>\n</ul>\n</li>\n<li><p><code>shuffle</code>: 每轮 SGD 之前是否洗牌。</p>\n<p>默认为 <code>True</code>。</p>\n</li>\n<li><p><code>warm_start</code>: 是否热启动。</p>\n<p>随机梯度下降中初始值可以是之前的训练结果，支持在线学习。初始值可在 <code>fit()</code> 函数中作为参数传递。</p>\n</li>\n<li><p><code>average</code>: 是否采用平均随机梯度下降法（随机梯度下降法的改进）ASGD。</p>\n</li>\n<li><p>其他参数与 <code>LogisticRegression</code> 相同。</p>\n</li>\n</ul>\n<p>关于“随机梯度下降实现”的参考文献：</p>\n<blockquote>\n<ul>\n<li>“Stochastic Gradient Descent” L. Bottou - Website, 2010</li>\n<li>“The Tradeoffs of Large Scale Machine Learning” L. Bottou - Website, 2011</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-Logistic优化求解与牛顿法","url":"/post/machinelearning/ml-logistic/ml-logistic-optimization/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-Logistic优化求解与牛顿法\"><a href=\"#ML入门-Logistic优化求解与牛顿法\" class=\"headerlink\" title=\"ML入门-Logistic优化求解与牛顿法\"></a>ML入门-Logistic优化求解与牛顿法</h1><p>前言：在机器学习的优化求解算法中，梯度下降法是无约束优化问题优化求解最常用的方法之一，还有一种求解方法就是牛顿法。相比梯度下降法，牛顿法的收敛速度更快，但同时，每次迭代需要的计算量也更大。</p>\n<p>在牛顿法之前，需要先了解：<a href=\"https://baike.baidu.com/item/泰勒公式/7681487?fr=aladdin\" title=\"@LINK\">泰勒公式</a>。泰勒公式通俗地讲，就是当函数 $f$ 在点 $x$ 处的一阶导数、二阶导数……n 阶导数已知时，即可使用 n 阶泰勒展开来逼近函数 $f$ 在点 $x$ 的 <strong>邻域</strong> 的函数值，因此泰勒公式求的是一个点的邻域的近似函数值。</p>\n<p>对应优化求解中，通常我们习惯于使用迭代法来求解，而迭代法的本质即：每次向正确的方向移动一小段，直到达到给定条件。这就与泰勒公式不谋而合——每次移动一小段之后的函数值可以使用移动前该点的泰勒展开来逼近，因此牛顿法或拟牛顿法都是在泰勒公式的基础上进行的。</p>\n<hr>\n<h2 id=\"1-牛顿法\"><a href=\"#1-牛顿法\" class=\"headerlink\" title=\"1. 牛顿法\"></a>1. 牛顿法</h2><p>牛顿法（Newton - Raphson，牛顿 - 拉夫逊）是牛顿在 17 世纪提出的用于求解方程的根的方法。其求解思想如下：</p>\n<ol>\n<li>假设点 $x^{\\ast}$ 为函数 $f(x)$ 的根，则 $f(x) = 0$。</li>\n<li>将函数 $f(x)$ 在点 $x_0$ 处进行一阶泰勒展开有：$f(x) \\approx f(x_0) + (x - x_0) f’(x_0)$</li>\n<li>假设点 $x$ 为 $x_0$ 邻域内一点，且 $x$ 为函数的根，则有：$f(x) \\approx f(x_0) + (x - x_0) f’(x_0) = 0$</li>\n<li>将上式变换即可得：$x = x_0 - \\dfrac {f(x_0)} {f’(x_0)}$</li>\n</ol>\n<p>上述牛顿法得到的结论，拓展到迭代的过程中，假设当前处在迭代第 t 轮，则可以得到下一轮 (t + 1) 时刻的解的表达式为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {f(x^{(t)})} {f’(x^{(t)})}<br>$</p>\n<p>这就是牛顿法优化求解的基本思想。下图展示了牛顿法求解方程 $f(x) = 0$ 的根的过程（图自 Wiki）：</p>\n<p><img data-src=\"./newton_iteration.png\" alt=\"牛顿法迭代过程\" title=\"@ASSET\"></p>\n<p>回到最优化问题中，通常会将问题转化成求极小值（误差、损失最小等），极小值对应了函数的导数为 0，因此需要适当调整牛顿法的目标，从求 $f(x) = 0$ 变为求 $f’(x) = 0$，因此原问题变为求 $f’(x)$ 的根。</p>\n<p>令 $g(x) = f’(x)$，则关于 $x$ 的迭代条件变为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {g(x^{(t)})} {g’(x^{(t)})} = x^{(t)} - \\dfrac {f’(x^{(t)})} {f’’(x^{(t)})}<br>$</p>\n<p>在实际问题中，通常输入 $X$ 的维度都大于 1，因此将一阶导数替换为梯度（即 $f$ 分别对每个 $x_i$ 求偏导后组成向量）：</p>\n<p>$<br>\\nabla f(x_1, \\cdots, x_D)<br>$</p>\n<p>将二阶导数替换为海森（Hessian）矩阵 H：</p>\n<p>$<br>H(X) = \\left[<br>\\begin{matrix}<br>\\dfrac {\\partial^2 f} {\\partial^2 x^2_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_D}<br>\\\\<br>\\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_D}<br>\\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots<br>\\\\<br>\\dfrac {\\partial^2 f} {\\partial x_D \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_D \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_D}<br>\\end{matrix}<br>\\right]<br>$</p>\n<p>Hessian 矩阵即：第 i 行第 j 列的元素为 $f$ 先对 $x_i$ 求偏导后再对 $x_j$ 求偏导。由于 $f$ 先对 $x_i$ 再对 $x_j$ 求偏导和 $f$ 先对 $x_j$ 再对 $x_i$ 求偏导相等，即 $\\dfrac {\\partial^2 f} {\\partial x_i \\partial x_j} = \\dfrac {\\partial^2 f} {\\partial x_j \\partial x_i}$，因此 Hessian 矩阵是对称的。</p>\n<p>这样，牛顿法的迭代公式就变换为：</p>\n<p>$$<br>x^{(t + 1)} = x^{(t)} - H^{-1} (X^{(t)}) \\ \\nabla f(X^{(t)})<br>$$</p>\n<blockquote>\n<p>二阶导转换为 Hessian 矩阵 $H(X^{(t)})$ 后作为分母，使用逆运算 $H^{-1} (X^{(t)})$ 来表示。</p>\n</blockquote>\n<p>总结牛顿法求解目标函数极值的迭代步骤如下：</p>\n<ol>\n<li>从 $t = 0$ 开始，初始化 $X^{(0)}$ 为随机值</li>\n<li>计算目标函数 $f(X)$ 在点 $X^{(t)}$ 的梯度：$g^{(t)} = \\nabla f(X^{(t)})$，以及 Hessian 矩阵：$H^{(t)} = H(X^{(t)})$</li>\n<li>计算移动方向：$d^{(t)} = (H^{(t)})^{-1} \\ g^{(t)}$</li>\n<li>根据迭代公式更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</li>\n<li>判断是否满足迭代终止条件（是否到达最大迭代次数，或相邻两次迭代的相对变化量或绝对变化量小于预设值，通常使用绝对量：$\\dfrac {f(X^{(t + 1)}) - f(X^{(t)})} {f(X^{(t)})} \\le \\varepsilon$），若满足则循环计数，返回最佳参数 $X^{(t + 1)}$ 和目标函数极小值 $f(X^{(t + 1)})$，否则跳转到第 2 步</li>\n</ol>\n<p>其中，第 3 步计算移动方向 $d^{(t)}$ 时，由于矩阵的逆求解困难，因此常用线性方程组计算：$H^{(t)} d^{(t)} = g^{(t)}$，当 $X$ 维度比较小时，可采用解析法求解 $d^{(t)}$，当 $X$ 维度比较高时，可采用梯度下降法或共而梯度下降法求解，因此对 $d^{(t)}$ 的求解又是一个迭代的计算过程。</p>\n<p>对比梯度下降法中的移动方向：$d^{(t)} = - \\eta g^{(t)}$，牛顿法：$d^{(t)} = - (H^{(t)})^{-1} \\ g^{(t)}$，Hessian 矩阵相比学习率（步长）$\\eta$ 包含的信息更多，因此牛顿法收敛速度更快，但从上述步骤也可明显看出牛顿法每次迭代的计算量都大幅增加。</p>\n<p>由于梯度下降法仅使用了一阶导数，而牛顿法使用了二阶导数矩阵，因此梯度下降法是一阶最优化算法，而牛顿法是二阶最优化算法。</p>\n<hr>\n<h2 id=\"2-拟牛顿法\"><a href=\"#2-拟牛顿法\" class=\"headerlink\" title=\"2. 拟牛顿法\"></a>2. 拟牛顿法</h2><p>牛顿法虽然收敛速度比梯度下降法更快，但在高维的情况下，计算目标函数二阶偏导数的复杂度很大，而且有时候目标函数的 Hessian 矩阵无法保持正定，不存在逆矩阵，此时牛顿法将不再能使用。</p>\n<p>为此提出：拟牛顿法（Quasi-Newton Methods），拟牛顿法旨在：不用二阶偏导数，而构造出可以近似 Hessian 矩阵（或 Hessian 矩阵的逆矩阵）的正定对称矩阵，再逐步优化目标函数。不同的近似 Hessian 矩阵构造方法产生了不同的拟牛顿法：BFGS / L-BFGS。</p>\n<blockquote>\n<p>扩展阅读：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/aws3217150/article/details/50548177\" title=\"@LINK\">谈谈常见的迭代优化方法</a></li>\n<li><a href=\"https://www.scipy-lectures.org/advanced/mathematical_optimization/\" title=\"@LINK\">Mathematical optimization: finding minima of functions</a></li>\n</ol>\n</blockquote>\n<p>重新考虑迭代条件，假设有某点 $x_0$，目标函数 $f(x)$ 在该点（已知点）进行二阶泰勒展开：</p>\n<p>$<br>f(x) \\approx f(x_0) + f’(x_0) (x - x_0) + \\dfrac {1} {2} f’’(x_0) (x - x_0)^2<br>$</p>\n<p>当 $X$ 为 向量 / 矩阵 时，导数即为梯度，上式转换为：</p>\n<p>$<br>f(X) \\approx f(X_0) + \\nabla f(X_0) (X - X_0) + \\dfrac {1} {2} (X - X_0)^T \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>对上式取梯度运算（$X_0$ 为已知点，因此其与其导数均可视为常数项）得：</p>\n<p>$<br>\\nabla f(X) \\approx \\nabla f(X_0) + \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>由于函数在点 $X_0$ 处的泰勒展开可以近似 $X_0$ 邻域内的函数值，假设 $X_0$ 即为迭代 t 次后得到的 $X^{(t + 1)}$，则迭代前一轮的 $X^{(t)}$ 即为邻域内一点，可用二阶泰勒展开逼近，因此可得迭代关系：</p>\n<p>$<br>\\nabla f(X^{(t)}) \\approx \\nabla f(X^{(t + 1)}) + \\nabla^2 f(X^{(t + 1)}) (X^{(t)} - X^{(t + 1)})<br>$</p>\n<p>再使用 gradiant 和 Hessian 分别表示 $X$ 的一阶梯度和二阶梯度矩阵：$g^{(t)} = \\nabla f(X^{(t)})$，$H^{(t)} = \\nabla^2 f(X^{(t)})$，整理可得：</p>\n<p>$<br>g^{(t + 1)} - g^{(t)} \\approx H^{(t + 1)} (X^{(t + 1)} - X^{(t)})<br>$</p>\n<p>进一步，引入记号：$s^{(t)} = X^{(t + 1)} - X^{(t)}$ 表示 $X$ 的变化量，$y^{(t)} = g^{(t + 1)} - g^{(t)}$ 表示梯度变化量，则可得简洁迭代关系：</p>\n<p>$$<br>y^{(t)} \\approx H^{(t + 1)} s^{(t)}<br>$$</p>\n<p>由于牛顿法中 Hessian 矩阵的逆难以计算，因此在拟牛顿法中，令 $B$ 表示 $H$ 的近似，$D$ 表示 $H^{-1}$ 的近似，代入上式即可得到 <strong>拟牛顿法的条件&lt;</strong> 为：</p>\n<p>$$<br>y^{(t)} = B^{(t + 1)} s^{(t)}<br>$$</p>\n<p>或</p>\n<p>$$<br>s^{(t)} = D^{(t + 1)} y^{(t)}<br>$$</p>\n<p><strong>实际上，拟牛顿法的条件给出了 Hessian 矩阵的近似需要满足的条件。</strong></p>\n<h3 id=\"2-1-BFGS\"><a href=\"#2-1-BFGS\" class=\"headerlink\" title=\"2.1 BFGS\"></a>2.1 BFGS</h3><p>BFGS（Broyden, Fletcher, Glodfarb, Shanno）被认为是数值效果最好的拟牛顿法，且具有全局收敛性和超线性收敛速度。</p>\n<p>BFGS 算法采用迭代法逼近 Hessian 矩阵：$B^{(t + 1)} = B^{(t)} + \\Delta B^{(t)}$，初始值 $B^{(0)} = I$ 为单位矩阵，因此关键在于如何构造 $\\Delta B^{(t)}$。</p>\n<p>为保证矩阵 $B$ 的正定性，令 $\\Delta B^{(t)} = \\alpha u u^T + \\beta v v^T$，代入上述拟牛顿法条件可得：</p>\n<p>$<br>\\begin{aligned}<br>y^{(t)} &amp;= B^{(t + 1)} s^{(t)} = (B^{(t)} + \\Delta B^{(t)}) s^{(t)} = B^{(t)} s^{(t)} + \\Delta B^{(t)} s^{(t)}<br>\\\\<br>&amp;= B^{(t)} s^{(t)} + \\alpha u u^T s^{(t)} + \\beta v v^T s^{(t)}<br>\\\\<br>&amp;= B^{(t)} s^{(t)} + u (\\alpha u^T s^{(t)}) + v (\\beta v^T s^{(t)})<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>当 $u^T$ 或 $v^T$ 的维数与 $s^{(t)}$ 的维数一致（由于 $\\Delta B^{(t)}$ 是构造的，因此可以构造为相同维数）时，$u^T s^{(t)}$ 以及 $v^T s^{(t)}$ 均为一个标量数值（向量的转置 x 向量 = 数值）。</p>\n</blockquote>\n<p>令 $\\alpha u^T s^{(t)} = 1$，$\\beta v^T s^{(t)} = -1$，即 $\\alpha = \\dfrac {1} {u^T s^{(t)}}$，$\\beta = - \\dfrac {1} {v^T s^{(t)}}$，得到：</p>\n<p>$<br>u - v = y^{(t)} - B^{(t)} s^{(t)}<br>$</p>\n<p>不妨令 $u = y^{(t)}$，$v = B^{(t)} s^{(t)}$，代入 $\\alpha$ 和 $\\beta$ 的表达式得：</p>\n<p>$<br>\\alpha = \\dfrac {1} {u^T s^{(t)}} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>$<br>\\beta = - \\dfrac {1} {v^T s^{(t)}} = - \\dfrac {1} {(B^{(t)} s^{(t)})^T s^{(t)}} = - \\dfrac {1} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>$</p>\n<p><strong>代入 $\\Delta B^{(t)}$ 的表达式得：</strong></p>\n<p>$$<br>\\begin{aligned}<br>\\Delta B^{(t)} &amp;= \\alpha u u^T + \\beta v v^T<br>\\\\<br>&amp;= \\dfrac {y^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} - \\dfrac {B^{(t)} s^{(t)} (B^{(t)} s^{(t)})^T} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$$</p>\n<blockquote>\n<p>Sherman-Morrison 公式：若 $A$ 为非奇异方阵，$1 + v^T A^{-1} u \\ne 0$，则有：</p>\n</blockquote>\n<p>$<br>(A + uv^T)^{-1} = A^{-1} - \\dfrac {A^{-1} u v^T A^{-1}} {1 + v^T A^{-1}}<br>$</p>\n<p><strong>由于牛顿法迭代过程需要计算 Hessian 矩阵的逆矩阵，因此根据 Sherman-Morrison 公式可得：</strong></p>\n<p>$$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$$</p>\n<p>综上，对于 $\\Delta B^{(t)}$ 和 $D^{(t + 1)}$，均可使用 $s^{(t)}$（$X$ 的变化量）和 $y^{(t)}$（函数梯度的变化量）表示，而初始化 $B^{(0)} = D^{(0)} = I$ 是一指的，$s^{(t)}$ 和 $y^{(t)}$ 在 $X$ 已知（优化求解的目的是寻找最优的 $X$，而 $X$ 本来就是已知的）时均是可计算的。</p>\n<p>整理得 BFGS 更新参数的流程如下：</p>\n<ol>\n<li><p>从 $t = 0$ 开始，初始化 $D^{(0)} = I$</p>\n</li>\n<li><p>计算移动方向：$d^{(t)} = D^{(t)} g^{(t)}$</p>\n<blockquote>\n<p>先用 $B^{(t)} = B^{(t - 1)} + \\Delta B^{(t - 1)}$ 迭代解出 $B^{(t)}$，再用 Sherman-Morrison 公式解出 $D^{(t)}$。</p>\n</blockquote>\n</li>\n<li><p>更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</p>\n</li>\n<li><p>$s^{(t)} = d^{(t)}$</p>\n</li>\n<li><p>若 $||g^{(t + 1)}|| \\le \\varepsilon$，则迭代终止</p>\n</li>\n<li><p>计算：$y^{(t)} = g^{(t + 1)} - g^{(t)}$</p>\n</li>\n<li><p>$t = t + 1$，跳转第 2 步</p>\n</li>\n</ol>\n<h3 id=\"2-2-L-BFGS\"><a href=\"#2-2-L-BFGS\" class=\"headerlink\" title=\"2.2 L-BFGS\"></a>2.2 L-BFGS</h3><p>在 BFGS 中，每一轮迭代需要存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），但当 $X$ 维数很高时，矩阵的维度也会很高，需要耗费大量存储空间。</p>\n<p>L-BFGS（Limited memory BFGS）不直接存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），而是存储迭代计算过程中的 $s^{(t)}$ 和 $y^{(t)}$ 来计算，从而减少参数存储所需空间。</p>\n<p>在 BFGS 中，Hessian 矩阵的更新公式为：</p>\n<p>$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>令 $\\rho^{(t)} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}$，$V^{(t)} = \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) = I - \\rho^{(t)} y^{(t)} (s^{(t)})^T$</p>\n<blockquote>\n<p>由于向量 $s^{(t)}$（X的变化量）和向量 $y^{(t)}$（梯度变化量）的维数相同（都与 $X$ 维度相等），因此 $s^{(t)} (y^{(t)})^T$ 和 $s^{(t)} (s^{(t)})^T$ 是矩阵，而 $(y^{(t)})^T s^{(t)}$ 是一个数值，因此 $\\rho^{(t)}$ 是一个常数。</p>\n</blockquote>\n<p>则有：</p>\n<p>$<br>\\begin{aligned}<br>(V^{(t)})^T &amp;= \\left( I - \\rho^{(t)} y^{(t)} (s^{(t)})^T \\right)^T<br>\\\\<br>&amp;= I - \\rho^{(t)} \\left( y^{(t)} (s^{(t)})^T \\right)^T<br>\\\\<br>&amp;= I - \\rho^{(t)} s^{(t)} (y^{(t)})^T<br>\\\\<br>&amp;= I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$</p>\n<p>因此原 Hessian 更新公式变为：</p>\n<p>$$<br>D^{(t + 1)} = (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>$$</p>\n<p>将上述迭代更新公式展开得：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\\\<br>&amp; \\Downarrow<br>\\\\<br>D^{(1)} &amp;= (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T<br>\\\\ \\\\<br>D^{(2)} &amp;= (V^{(1)})^T D^{(1)} V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp;= (V^{(1)})^T \\left( (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right) V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp;= (V^{(1)})^T (V^{(0)})^T D^{(0)} V^{(0)} V^{(1)} + (V^{(1)})^T \\rho^{(0)} s^{(0)} (s^{(0)})^T V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp; \\ \\ \\vdots<br>\\\\<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(0)})^T \\right] D^{(0)} \\left[ V^{(0)} V^{(1)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(1)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(1)} V^{(2)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(2)})^T \\right] \\left[ \\rho^{(1)} s^{(1)} (s^{(1)})^T \\right] \\left[ V^{(2)} V^{(3)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>从上述迭代过程可知，计算 $D^{(t + 1)}$ 需要用到 $\\left \\{ s^{(k)} y^{(k)} \\right \\}^t_{k = 0}$，若存储空间有限，仅能存储 m 组 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$，当 $t &gt; m$ 时，应当丢弃较早生成的 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$。当然，由于丢弃了部分信息，此时计算的 $D^{(m + 1)}$ 是 $D^{(t + 1)}$ 的近似，也即 Hessian 矩阵的逆矩阵的进一步近似。</p>\n<p>当 $t &gt; m + 1$ 时，构造近似公式：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 1)})^T \\right] D^{(0)} \\left[ V^{(t - m + 1)} V^{(1)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 2)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(t - m + 2)} V^{(2)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>$D^{(t)}$ 的迭代计算很繁琐，但计算 $D^{(t)}$ 的目的是为了得到搜索方向 $d^{(t)} = D^{(t)} g^{(t)}$，因此可以设计快速计算 $D^{(t)} g^{(t)}$ 的方法：</p>\n<p><img data-src=\"./double_circle_direction.png\" alt=\"双向循环快速求解搜索方向\" title=\"@ASSET\"></p>\n<p>算法中还有部分不太明白，暂时只放上图片，待研究透彻后改为 Python 代码形式。另有几篇关于该双向循环快速求解 $D^{(t)} g^{(t)}$ 算法的参考文章如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://blog.csdn.net/red_stone1/article/details/80821760\" title=\"@LINK\">机器学习中牛顿法凸优化的通俗解释（作者：红色石头Will）</a></li>\n<li><a href=\"https://blog.csdn.net/itplus/article/details/21897715\" title=\"@LINK\">牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法（作者：皮果提）</a></li>\n<li><a href=\"https://blog.csdn.net/snaillup/article/details/53524415\" title=\"@LINK\">spark L-BFGS实现（作者：snaillup）</a></li>\n<li><a href=\"https://github.com/scalanlp/breeze/blob/master/math/src/main/scala/breeze/optimize/LBFGS.scala\" title=\"@LINK\">LBFGS.scala（作者：ScalaNLP）</a></li>\n<li><a href=\"https://liuxiaofei.com.cn/blog/lbfgs方法推导/#lbfgs方法推导\" title=\"@LINK\">LBFGS方法推导（作者：慢慢的回味）</a></li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"3-Logistic优化求解算法\"><a href=\"#3-Logistic优化求解算法\" class=\"headerlink\" title=\"3. Logistic优化求解算法\"></a>3. Logistic优化求解算法</h2><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失：</p>\n<p>$<br>L(y, \\mu (X)) = - y \\log (\\mu (X)) - (1 - y) \\log (1 - \\mu (X))<br>$</p>\n<p>其中 $y$ 为真值， $\\mu (X)$ 为预测值为 1 的概率。</p>\n<p>与其他机器学习一样，Logistic 回归的目标函数也包括两项：训练集上的损失和 + 正则项。</p>\n<p>$<br>J(W; \\lambda) = \\sum^N_{i = 1} L(y_i, \\mu (X_i; W)) + \\lambda R(W)<br>$</p>\n<blockquote>\n<p>由于 L1 正则在零点不可导，因此当正则项中含有 L1 正则时，不能直接使用基于梯度、Hessian 矩阵的优化求解算法，而通常使用坐标轴下降法求解，或也可使用次梯度法。</p>\n</blockquote>\n<p>在给定正则参数 $\\lambda$ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W, \\lambda)$，取得最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W, \\lambda)} {\\partial W} = 0$。</p>\n<p>与线性回归模型不同的是，Logistic 回归模型的参数无法用解析法求解，因此可使用迭代法逼近求解。</p>\n<p>其中一阶近似有与梯度相关的几个算法：</p>\n<ul>\n<li>梯度下降（Logistic 使用梯度下降法收敛速度较慢）</li>\n<li>随机梯度下降（SGD）</li>\n<li>随机平均梯度法（SAG）</li>\n<li>随机平均梯度法改进版（SAGA）</li>\n<li>共轭梯度</li>\n<li>坐标轴下降</li>\n</ul>\n<p>二阶近似有：</p>\n<ul>\n<li>牛顿法</li>\n<li>拟牛顿法（BFGS、L-BFGS）</li>\n</ul>\n<p>观察目标函数的损失和部分：</p>\n<p>$<br>J_1 (W) = \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>$</p>\n<h3 id=\"3-1-梯度\"><a href=\"#3-1-梯度\" class=\"headerlink\" title=\"3.1 梯度\"></a>3.1 梯度</h3><p>最优化问题的求解离不开梯度的计算，由于目标函数中包含了 $\\mu$，即 Sigmoid 变换，记 $\\mu_i = \\mu (X_i; W) = \\sigma (W^T X_i)$，令 $z_i = W^T X_i$，根据复合函数的求导，$\\dfrac {\\partial \\mu_i} {\\partial W}$ 的求解如下：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {\\partial \\sigma (W^T X_i)} {\\partial W} = \\dfrac {\\partial \\sigma {z_i}} {\\partial W}<br>\\\\<br>&amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\end{aligned}<br>$</p>\n<p>其中 ① 复合函数外层 $\\sigma (z_i)$ 求导：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {d \\sigma (z_i)} {d z_i} &amp;= \\dfrac {d (\\dfrac {1} {1 + e^{- z_i}})} {d z_i}<br>\\\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times \\dfrac {d (1 + e^{- z_i})} {d z_i}<br>\\\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times (- e^{- z_i})<br>\\\\<br>&amp;= \\dfrac {1} {(1 + e^{- z_i})^2} \\times (e^{- z_i})<br>\\\\<br>&amp;= \\dfrac {1} {1 + e^{- z_i}} \\times \\dfrac {(1 + e^{- z_i}) - 1} {1 + e^{- z_i}}<br>\\\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i))<br>\\end{aligned}<br>$</p>\n<p>② 复合函数内层 $z_i$ 求导：</p>\n<p>$<br>\\dfrac {\\partial z_i} {\\partial W} = \\dfrac {\\partial (W^T X_i)} {\\partial W} = X_i<br>$</p>\n<p>综合上述 2 式得：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i)) \\times X_i<br>\\\\<br>&amp;= \\mu_i \\times (1 - \\mu_i) \\times X_i<br>\\end{aligned}<br>$</p>\n<p>回到目标函数梯度，将上式代入求导得：</p>\n<p>$<br>\\begin{aligned}<br>J_1 (W) &amp;= \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\left( - y_i \\log \\mu_i - (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left(y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\end{aligned}<br>$</p>\n<p>$<br>\\begin{aligned}<br>g_1 (W) &amp;= \\nabla J_1 (W) = \\dfrac {d J_1 (W)} {d W}<br>\\\\<br>&amp;= - d \\left( \\sum^N_{i = 1} \\left( y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right) \\right) / d W<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} \\times \\dfrac {\\partial \\mu_i} {\\partial W} + (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\times - \\dfrac {\\partial \\mu_i} {\\partial W} \\right)<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} - (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\right) \\times \\mu_i (1 - \\mu_i) X_i<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i (1 - \\mu_i) - (1 - y_i) \\mu_i \\right) \\times X_i<br>\\\\<br>&amp;= - \\sum^N_{i = 1} (y_i - \\mu_i) \\times X_i<br>\\\\<br>&amp;= (\\mu - y) X<br>\\end{aligned}<br>$</p>\n<p><strong>整理可得 Logistic 回归损失和部分的梯度表达式：</strong></p>\n<p>$$<br>g_1 (W) = X^T (\\mu - y)<br>$$</p>\n<blockquote>\n<p>这里直接解出来的结果是 $(\\mu - y) X$，但表达式使用的是 $X^T (\\mu - y)$，对此我有些自己的理解方式如下。</p>\n</blockquote>\n<p>首先要提一下矩阵的形式。在机器学习中有一个很重要的工具包 <code>numpy</code>，这个工具包里其中两个很重要的类：<code>numpy.matrix</code> 和 <code>numpy.array</code>也即矩阵和向量，通常手动创建一个矩阵的时候可以用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>A = np.matrix([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">[[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"> [<span class=\"number\">3</span> <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<p>这就可以视为一个 2 x 2 的矩阵：$\\left[ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{matrix} \\right]$，但是当我们如下创建一个向量时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>B = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B.shape)</span><br><span class=\"line\">(<span class=\"number\">2</span>,)</span><br></pre></td></tr></table></figure>\n\n<p><strong>可以看到，尽管输出的 B 的形式还是 <code>[1 2]</code>，但这是一个 2 行（也即 1 列）的向量（之所以没有标出 <code>(2, 1)</code> 是因为向量要么只有 1 行要么只有 1 列，防止与矩阵的 n x m 搞混了）。也就是说，默认情况下的向量是列向量，这也符合机器学习中的直觉，例如标签 y，预测值，或单个特征等都是列向量。</strong></p>\n<p><strong>回到原问题的梯度表达式中，假设训练数据共有 D 维特征 N 个样本，则 X 是 N x D 维的矩阵，$\\mu$ 和 y 均为 N 行的列向量，都知道矩阵的乘法 (A x B) 需要满足 A 的列数 = B 的行数时才有意义，而当作为矩阵运算 $(\\mu - y) X$ 时，$(\\mu - y)$ 列数为 1，此时无论 $X$ 是否转置，$(\\mu - y) X$ 都无意义，不能做乘法运算。因此 $\\sum^N_{i = 1} (\\mu_i - y_i) \\times X_i$ 转换为矩阵表达式时，将 $X$ 提到左乘并转置，不仅 $X^T$ 的列数恰好为 N，与 $\\mu$ 和 $y$ 的行数相等，可以做乘法，而且从矩阵的乘法运算规则上符合直观地计算过程（$X$ 转置后，每一列为一个样本，分别与每个 $(\\mu_i - y_i)$ 相乘）。</strong></p>\n<p><strong>因此，梯度的表达式为：$g_1 (W) = X^T (\\mu - y)$。</strong></p>\n<h3 id=\"3-2-Hessian矩阵\"><a href=\"#3-2-Hessian矩阵\" class=\"headerlink\" title=\"3.2 Hessian矩阵\"></a>3.2 Hessian矩阵</h3><p>Logistic 损失和部分的梯度为 $g_1 (W) = X^T (\\mu - y)$，由此求解 Hessian 矩阵：</p>\n<p>$<br>\\begin{aligned}<br>H_1 (W) &amp;= \\dfrac {\\partial g_1 (W)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} (\\mu_i - y_i) X_i \\right)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} X^T_i (\\mu_i - y_i) \\right)} {\\partial W}<br>\\\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\dfrac {\\partial (\\mu_i)} {\\partial W}<br>\\\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\mu_i (1 - \\mu_i) X_i<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>说明：$\\dfrac {\\partial (a^T y)} {\\partial y} = a^T$</p>\n</blockquote>\n<p><strong>令矩阵 $S \\triangleq \\mu_i (1 - \\mu_i)$，即 $S$ 为对角阵，对角元素为 $\\mu_i (1 - \\mu_i)$。可得 Hessian 矩阵表达式：</strong></p>\n<p>$$<br>H_1 (W) = X^T S X<br>$$</p>\n<h3 id=\"3-3-牛顿法求解Logistic损失函数和极小值：IRLS\"><a href=\"#3-3-牛顿法求解Logistic损失函数和极小值：IRLS\" class=\"headerlink\" title=\"3.3 牛顿法求解Logistic损失函数和极小值：IRLS\"></a>3.3 牛顿法求解Logistic损失函数和极小值：IRLS</h3><p>当解得梯度 $g_1 (W) = X^T (\\mu - y)$ 和 Hessian 矩阵 $H_1 (W) = X^T S X$ 后，即可代入牛顿迭代公式中：</p>\n<p>$<br>\\begin{aligned}<br>W^{(t + 1)} &amp;= W^{(t)} - H(W^{(t)})^{-1} g(W)<br>\\\\<br>&amp;= W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} (X^T S^{(t)} X) \\times W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T (\\mu - y) \\right)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T S^{(t)} {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} X^T S^{(t)} \\times \\left( X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\end{aligned}<br>$</p>\n<p><strong>令 $z^{(t)} \\triangleq X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y)$，则得到牛顿法迭代求 Logistic 损失函数和极小值的解：</strong></p>\n<p>$$<br>W^{(t + 1)} = (X^T S^{(t)} X)^{-1} X^T S^{(t)} z^{(t)}<br>$$</p>\n<p>对比线性回归 $X W = y$ 方程中最小二乘的解：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，给每个样本加权（每个样本的权重为 $S_i$）即可得加权最小二乘的解：</p>\n<p>$<br>\\hat{W}_{OLS_weight} = (X^T S X)^{-1} X^T y<br>$</p>\n<p>牛顿迭代法求得的 Logistic 损失函数和极小值的解 与 加权最小二乘的解形式类似，因此也称为 <strong>迭代加权最小二乘（Iteratively Reweighted Least Squares, IRLS）</strong>，其中每个样本的权重为 $S_i = \\mu_i (1 - \\mu_i)$。而 IRLS 又通过 共轭梯度（Conjugate Gradient）法 求解，因此 Scikit-Learn 中采用牛顿法求解的优化算法为 <code>&#39;newton-cg&#39;</code>。</p>\n<hr>\n<h2 id=\"4-Logistic的优化求解器Solver\"><a href=\"#4-Logistic的优化求解器Solver\" class=\"headerlink\" title=\"4. Logistic的优化求解器Solver\"></a>4. Logistic的优化求解器Solver</h2><p>Logistic 回归有多种优化求解方法。当使用 L2 正则时，可采用所有优化算法，而由于 L1 正则在零点处不可导，因此次不能使用需要计算梯度 / Hessian 矩阵的方法，此时可以类似 Lasso 求解，采用坐标轴下降法。</p>\n<p>Scikit-Learn 中的 Logistic 类已在：<a href=\"/post/machinelearning/ml-logistic/ml-logistic-introduction/ml-logistic-introduction/\" title=\"@LINK\">《ML入门——Logistic回归简介》</a> 文中介绍，此处展开参数 <code>solver</code> 的一些可选项：</p>\n<p>‘liblinear’：<br>线性求解器，适用于小数据集，支持 L1 正则和 L2 正则。<br>内部使用了坐标轴下降法来迭代优化损失函数，如果模型的特征非常多，希望一些不重要的特征系数归零从而让模型系数稀疏的话，可以使用 L1 正则化。在多类 Logistic 回归任务中仅支持 OvR，不支持多项分布损失（MvM），但 MVM 相对精确。</p>\n<p>‘lbfgs’：<br>拟牛顿法，适用于较大数据集，仅支持 L2 正则。<br>支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘newton-cg’：<br>牛顿法，适用于较大数据集，仅支持 L2 正则。<br>每个大迭代中的加权最小二乘回归部分采用共轭梯度算法实现。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘sag’：<br>随机平均梯度下降，适用于很大（如大于 5 万）的数据集，仅支持 L2 正则。<br>梯度下降法的变种，支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘saga’：<br>改进的随机平均梯度下降，适用于非常大的数据集，支持 L1 正则。<br>当数据量很大，且选择 L1 正则时，只能采用 ‘saga’ 优化求解器。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>其中，’sag’ 和 ‘saga’ 只有在特征尺度大致相等时才能保证收敛，因此需要对数据做缩放（<code>class sklearn.preprocessing</code> 可以实现如：标准化、MinMaxScaler、MaxAbsScaler 等）。在实际任务中，大部分情况下数据预处理时都最好做标准化。实际上，加正则项本身也要求对每维特征做缩放。</p>\n<p>另外，对于大数据集的训练任务，可以使用 <code>SGDClassifier</code>，并使用 LogLoss 作为损失函数。</p>\n<blockquote>\n<p>若 <code>SGDClassifier</code> 使用 HingeLoss 作为损失函数，则为实现随机梯度下降的 SVM。在回归任务中还有 <code>SDGRegressor</code>。</p>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"Android子线程到底能否更新UI——可能是最全面的解析","url":"/post/android/android-ui_thread/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android子线程到底能否更新UI——可能是最全面的解析\"><a href=\"#Android子线程到底能否更新UI——可能是最全面的解析\" class=\"headerlink\" title=\"Android子线程到底能否更新UI——可能是最全面的解析\"></a>Android子线程到底能否更新UI——可能是最全面的解析</h1><p>前言：Android 开发中有这么一条“潜规则”：「一个 App 的主线程就是 UI 线程，子线程不能更新 UI」。绝大部分情况下，我们在需要处理 UI 逻辑时，都会自觉地放在主线程操作，但是为什么会有这么一条“铁律”，其原因是什么，以及这条“铁律”就一定正确吗？带着这些疑问我在度娘和 StackOverFlow 上搜了一遍，绝大部分分析都止于「子线程更新 UI 会抛出异常的逻辑在哪」，所以我决定自己探索一遍，并写下这篇截止到目前，【可能】是最全面的一篇分析。</p>\n<p>当然，这篇文章不会深入到屏幕渲染、线程调度等等这样的层面，其重点在于从源码的角度论证：「子线程到底能不能更新 UI」，本文默认读者已有初级 Android 基础。</p>\n<hr>\n<h2 id=\"1-子线程更新UI异常\"><a href=\"#1-子线程更新UI异常\" class=\"headerlink\" title=\"1. 子线程更新UI异常\"></a>1. 子线程更新UI异常</h2><p>下面这段代码，是很典型的子线程更新 UI 的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码运行会抛出异常：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么子线程不能更新 UI 呢？这就需要从 3 个方面解释。</p>\n<h3 id=\"1-1-设计思想\"><a href=\"#1-1-设计思想\" class=\"headerlink\" title=\"1.1 设计思想\"></a>1.1 设计思想</h3><p>首先不得不提到，子线程更新 UI 会抛出异常肯定是 Android 有意为之，但 Android 为什么要这么设计呢？</p>\n<p>这是因为，人眼感到【流畅】需要满足帧率大于等于 60 Fps，对应的也就是约等于 16 毫秒一帧，Android 为了让交互和显示足够流畅，就需要尽可能保证这个帧率，尤其在现在高刷屏普及的时代，就需要尽可能缩短每一帧的渲染时间。因为频繁的加锁和锁释放会带来很大的内存开销，很可能会延长每一帧的渲染时间，因此对于 UI 更新的操作，是没有加锁的。但如果不加锁，在出现并发问题时，系统如何确保下一帧画面到底应该渲染成什么样呢？</p>\n<p>所以，Android 系统为了避免这个问题，就从源码层限制了其他线程更新 UI，以兼顾 UI 更新的效率和并发安全性。</p>\n<h3 id=\"1-2-异常原因\"><a href=\"#1-2-异常原因\" class=\"headerlink\" title=\"1.2 异常原因\"></a>1.2 异常原因</h3><p>解释完设计思想，就要老生常谈分析一下抛出异常的直接原因了。</p>\n<p>首先有一个基础：View 在更新时，是将自己测量并绘制，但这个绘制并不是一旦 View 完成初始化、或者调用更新时就马上绘制，而是发起一个屏幕同步 Sync 请求，等待下一次屏幕刷新时，再绘制到屏幕上。</p>\n<p>而这个 View 发起绘制请求的命令，就是 UI 更新都离不开的：<code>requestLayout()</code>。</p>\n<p>就以 <code>TextView.setText(...)</code> 为例，顺着 <code>setText(...)</code> 的源码一路点进去，直到下面这个方法（省略其他代码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这个 requestLayout()：</span></span><br><span class=\"line\">        requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再点进 requestLayout() 源码：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 每个 View 都逐级调用上层父 View 的 requestLayout，最上层的父 View 就是 ViewRootImpl</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">            mParent.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，每个 View 都会一层层请求自己的父布局调用 <code>requestLayout()</code>，而最最上层的父布局，就是一个 ViewRootImpl，它也实现了 <code>ViewParent</code> 接口。而在 ViewRootImpl 内，<code>requestLayout()</code> 的实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// 注意这个方法是关键</span></span><br><span class=\"line\">            checkThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 看看源码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 就是在这里判断了线程</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这一步就清晰明了了，因为 <code>Thread.currentThread()</code> 是子线程，而 <code>mThread</code> 是主线程，所以在这里抛出了异常。</p>\n<p>【但是！】这个判断有个很大的问题，因为它的判断是 <code>mThread != Thread.currentThread()</code>，而 <code>mThread</code> 是在这个 ViewRootImpl 的构造方法里面存入的，因此这个判断本质上比较的是：当前线程与「ViewRootImpl 初始化时的线程」是否相同，而不是当前线程与「主线程」是否相同，并且这里抛出的异常说明也是「the original thread」而不是「the main thread」，所以我们常说的「子线程不能更新 UI」，实际上是：</p>\n<p>一个线程初始化了 ViewRootImpl 后，其 UI 不能被其他线程更新！而这两个线程，和是不是主线程并没有关系！</p>\n<hr>\n<h2 id=\"2-Activity视图加载流程\"><a href=\"#2-Activity视图加载流程\" class=\"headerlink\" title=\"2. Activity视图加载流程\"></a>2. Activity视图加载流程</h2><p>现在知道了线程能否更新 UI 主要看这个 UI 所处的最上层 ViewRootImpl 是否由同一个线程初始化，那么 ViewRootImpl 是怎么初始化的呢？又是在什么时候初始化的呢？</p>\n<p>既然 ViewRootImpl 是最上层布局，那不妨从 Activity 启动加载开始：<a href=\"/post/android/android-activity\" title=\"@LINK\">Android-Activity深入理解</a>。</p>\n<hr>\n<h2 id=\"3-ViewRootImpl线程的定义\"><a href=\"#3-ViewRootImpl线程的定义\" class=\"headerlink\" title=\"3. ViewRootImpl线程的定义\"></a>3. ViewRootImpl线程的定义</h2><p>通过 <a href=\"/post/android/android-activity\" title=\"@LINK\">Android-Activity深入理解</a>，可以知道：</p>\n<ul>\n<li>ViewRootImpl 判断线程时依据的 <code>mThread</code> 就是创建并初始化 ViewRootImpl 时的所在线程。</li>\n<li><code>setContentView(...)</code> 之后 Activity 视图的加载流程，主要包括对 DecorView、subDecor、以及 mContentParent 的加载和持有逻辑。</li>\n</ul>\n<p>但是！结合上面这两条来看，就会发现两个结论：</p>\n<ul>\n<li>在 <code>setContentView(...)</code> 中，虽然也有判断 Window、DecorView、subDecor 等是否创建以及立即创建的逻辑，但并没有对 ViewRootImpl 的操作逻辑！！！也就是说，调用 <code>setContentView(...)</code> 时所处的线程并不能决定 ViewRootImpl 的初始线程，也就无法决定哪个线程可以更新 UI！</li>\n<li>从 Activity 的加载流程 2.2.1 部分来看，决定 ViewRootImpl 初始线程的，似乎只有 <code>handleResumeActivity(...)</code>，而不论 startActivity 是否在子线程中调用，一个 Activity 都是通过 AMS 管理的，<code>handleResumeActivity(...)</code> 的调用都会发生在 ActivityThread 中，ActivityThread 又处在主线程中。</li>\n</ul>\n<p><strong>这两个结论说明：不论 startActivity 是否在子线程中调用，也不论一个 Activity 的 <code>setContentView(...)</code> 是否在子线程中调用，都无法影响到 Activity 是在 ActivityThread 这个主线程中加载的，所以尽管 ViewRootImpl 比较的线程是【初始线程】与当前线程，但在 Activity 常规加载流程中，ViewRootImpl 总是在主线程初始化的，所以在大部分情况下，子线程的确无法更新 UI。</strong></p>\n<hr>\n<h2 id=\"4-子线程绝对不能更新UI吗？\"><a href=\"#4-子线程绝对不能更新UI吗？\" class=\"headerlink\" title=\"4. 子线程绝对不能更新UI吗？\"></a>4. 子线程绝对不能更新UI吗？</h2><p>在上面第 3 部分，我做了一个结论，表明「大部分情况下，子线程的确无法更新 UI」，但请注意原画中的「常规加载流程」，以及「大部分情况下」这两个关键词。</p>\n<p>先写结论：<strong>实际上，子线程可以更新 UI。</strong></p>\n<p>在这里我又再一次推倒了前面的结论，因为我们已经知道，只要能让 ViewRootImpl 在子线程中初始化，就能在该子线程中更新 UI。虽然通常初始化 ViewRootImpl 的动作会被 ActivityThread 自动完成，但实际上仍有方法手动创建。</p>\n<h3 id=\"4-1-手动触发ViewRootImpl的初始化\"><a href=\"#4-1-手动触发ViewRootImpl的初始化\" class=\"headerlink\" title=\"4.1 手动触发ViewRootImpl的初始化\"></a>4.1 手动触发ViewRootImpl的初始化</h3><p>从前文可以知道，ViewRootImpl 的初始化发生在 <code>ActivityThread.handleResumeActivity(...)</code> 中，并且发生在初始化 Window 和 DecorView 之后调用 <code>mWindow.addView(DecorView, LayoutParams)</code> 时。那就可以想个办法，在 onCreate 阶段就手动初始化 PhoneWindow，手动触发 <code>mWindow.addView(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">    HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">    newThread.start();</span><br><span class=\"line\">    Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadText = <span class=\"keyword\">new</span> TextView(DemoActivity.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            WindowManager.LayoutParams windowLP = <span class=\"keyword\">new</span> WindowManager.LayoutParams(</span><br><span class=\"line\">                    <span class=\"number\">200</span>,  <span class=\"comment\">// width</span></span><br><span class=\"line\">                    <span class=\"number\">50</span>,   <span class=\"comment\">// height</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// x position</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// y position</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.FIRST_SUB_WINDOW,  <span class=\"comment\">// type</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.TYPE_TOAST,        <span class=\"comment\">// flag</span></span><br><span class=\"line\">                    PixelFormat.OPAQUE                            <span class=\"comment\">// format</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            WindowManager windowManager = MainActivity.<span class=\"keyword\">this</span>.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 实际上就是把这个 TextView 作为 DecorView 传递给 WindowManager 加载</span></span><br><span class=\"line\">            windowManager.addView(tvNewThreadText, windowLP);</span><br><span class=\"line\">            tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过手动初始化 Window 并添加 View，的确可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h3 id=\"4-2-避开ViewRootImpl的检查\"><a href=\"#4-2-避开ViewRootImpl的检查\" class=\"headerlink\" title=\"4.2 避开ViewRootImpl的检查\"></a>4.2 避开ViewRootImpl的检查</h3><p>从文章最开始对 <code>TextView#setText(...)</code> 的源码分析可知，子线程中更新 UI 会抛出异常在于更新 UI 时，View 会逐级向上层父 View 调用 <code>requestLayout()</code>，直到最上层的 <code>ViewRootImpl#requestLayout()</code> 判断了线程。但在后面 Activity 加载流程的分析中又发现，ViewRootImpl 是在 <code>handleResumeActivity()</code> 时初始化的，也就是说，在 Activity 处于 onCreate 生命周期时，ViewRootImpl 根本都还没有初始化，此时如果 TextView 更新 UI，则在逐级向上层调用父 View 的 <code>requestLayout()</code> 时，到了 ViewRootImpl 就会因为 <code>mParent == null</code> 而跳过了。</p>\n<p>Show me the code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_demo);</span><br><span class=\"line\"></span><br><span class=\"line\">    tvNewThreadTitle = findViewById(R.id.tvNewThreadTitle);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程修改后的 Text&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过避开 ViewRootImpl 的检查，的确也可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h3 id=\"4-3-针对TextView避开重绘\"><a href=\"#4-3-针对TextView避开重绘\" class=\"headerlink\" title=\"4.3 针对TextView避开重绘\"></a>4.3 针对TextView避开重绘</h3><p>4.1 和 4.2 中的两个方法，是对所有 View 更新 UI 都适用的，但对于 TextView，还有一种方式，就是避开重绘。</p>\n<p>首先看下这样一个布局（省略部分）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/btUpdate&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;100dp&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;在子线程更新 UI&quot;</span></span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过 Activity 加载（省略部分）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击 Button 时，会开启一个子线程并在子线程中更新 TextView。</p>\n<p>毫无疑问这段代码 Crash 了，原因和文首说明的一样，因为 ViewRootImpl 在主线程中初始化，因此子线程无法更新 UI。</p>\n<p>但！如果把布局中 TextView 的宽度改为精确值或 <code>match_parent</code>，Activity 中的代码不变：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度改为精确值或 match_parent--&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;200dp&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Activity 中的代码逻辑不变，仍然是在点击时开启子线程并在子线程中更新 TextView</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次运行发现居然没有 Crash，子线程成功更新了 UI！这难道又要再次推翻之前的结论吗？</p>\n<p>再重新翻一下 <code>TextView#setText(...)</code> 的源码，这一次仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we have a fixed width, we can just swap in a new text layout</span></span><br><span class=\"line\">        <span class=\"comment\">// if the text height stays the same or if the view height is fixed.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))</span><br><span class=\"line\">                &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Static width, so try making a new text layout.</span></span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// In a fixed-height view, so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                        &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Dynamic height, but height has stayed the same,</span></span><br><span class=\"line\">                <span class=\"comment\">// so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayout.getHeight() == oldht</span><br><span class=\"line\">                        &amp;&amp; (mHintLayout == <span class=\"keyword\">null</span> || mHintLayout.getHeight() == oldht)) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We lose: the height has changed and we have a dynamic height.</span></span><br><span class=\"line\">            <span class=\"comment\">// Request a new view layout using our new text layout.</span></span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Dynamic width, so we have no choice but to request a new</span></span><br><span class=\"line\">            <span class=\"comment\">// view layout with a new text layout.</span></span><br><span class=\"line\">            nullLayouts();</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码可以发现，在 <code>checkForRelayout()</code> 之前，先通过 <code>setTextInternal(text);</code> 把 text 存入了成员变量，然后才会调用 <code>checkForRelayout()</code> 检查线程。</p>\n<p>通过上文已经知道，如果调用了 <code>requestLayout()</code>，就会导致 ViewRootImpl 判断线程。而 <code>TextView#checkForRelayout()</code> 中，<code>requestLayout()</code> 之前有两个 <code>return</code> 的机会（已在代码注释中标出），接下来就是看看如何才能触发这两个 <code>return</code>！</p>\n<p>（1）首先是最外层的 <code>if</code> 判断必须要满足的条件，否则 <code>else</code> 中一定会走到 <code>requestLayout</code>。这个最外层的 <code>if</code> 条件是（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (</span><br><span class=\"line\">        mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">        || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，这三个条件均满足就表示 TextView 的宽度是固定值且大于 0，也就是宽度是不需要重新测绘的。这也是为什么当 TextView 的宽度设置为 <code>wrap_content</code> 时，子线程更新 TextView 会抛出异常的原因，因为这个最外层的 <code>if</code> 不满足而走到了 <code>else</code> 中。</p>\n<p>（2）接着是第二层的 <code>if</code> 判断也必须要满足条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE)</span><br></pre></td></tr></table></figure>\n\n<p>这个判断满足时表示 TextView 不是跑马灯效果的状态。这个很好理解，因为跑马灯效果是需要一直刷新 UI 的。</p>\n<p>（3）然后是第一个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">    &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n\n<p>代码很好懂，如果高度既不是 <code>wrap_content</code> 又不是 <code>match_parent</code>，那就只能是精确高度了，这也就表示高度也不需要重新测绘。</p>\n<p>（4）最后是第二个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayout.getHeight() == oldht</span><br><span class=\"line\">    &amp;&amp; (</span><br><span class=\"line\">        mHintLayout == <span class=\"keyword\">null</span></span><br><span class=\"line\">        || mHintLayout.getHeight() == oldht</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>代码依然很好懂，如果新的高度和久的高度一致，也表示高度不需要重新测绘。</p>\n<p>综合上述的（1）、（2）、（3）、（4）可以得出结论：如果一个 TextView 的内容被改变了，但是新 TextView 的高度和宽度都不会发生变化，并且也不是跑马灯效果模式，也即 TextView 不需要重新测绘，则不需要调用 requestLayout，也就不会走到 ViewRootImpl 判断线程的地方！</p>\n<p>这里需要注意的是：宽度和高度必须同时都是固定值（精确值或 <code>match_parent</code>）才不会发生重绘。上面测试代码中，TextView 的高度为 <code>wrap_content</code> 却没问题的原因，是更新内容时能在一行内显示完全，因此高度没有发生变化，走进了条件（4）中的 <code>return</code>。如果把 TextView 改成宽度为很小的值、高度为自适应，然后子线程中 set 一个很长的文本，使得 TextView 会因为换行导致高度发生变化，则也是会抛出异常的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度设为很小的值，高度为自适应，然后子线程中 set 一个很长的文本使其换行导致高度变化，会抛出异常--&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;10dp&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>因此 TextView 的 UI 更新方式可以总结为两种：</p>\n<ul>\n<li>如果更新后宽度或高度会发生变化，或者是跑马灯效果模式，则立即逐级向父 View 请求重绘一次，并在绘制时绘制出新的文本。</li>\n<li>否则就把把需要更新的文本存在 TextView 内，等下一次屏幕刷新的时候顺便就绘制成新的文本。</li>\n</ul>\n<p>实践证明：针对 TextView，通过避免重绘，的确可以实现子线程更新 UI，但仅针对 TextView 或类似有跳过重绘逻辑的 View。</p>\n<h3 id=\"4-4-使用SurfaceView-TextureView\"><a href=\"#4-4-使用SurfaceView-TextureView\" class=\"headerlink\" title=\"4.4 使用SurfaceView/TextureView\"></a>4.4 使用SurfaceView/TextureView</h3><p>SurfaceView 算是正儿八经使用子线程更新 UI 的例子了，也是其最大的优点。SurfaceView 的画面渲染主要是通过其持有的一个 <code>Surface</code> 类型的 <code>mSurface</code> 对象实现的，这个 <code>Surface</code> 并不是一个 View 的子类，因此其更新并不收到 View 更新中 <code>checkThread()</code> 的限制。简单来说，SurfaceView 可以在子线程中更新 UI 的原理是因为其渲染的目标并不是一个 View。</p>\n<p>当然，实际上 SurfaceView / TextureView 的原理远不止这么简单，本文主要聚焦于子线程更新 UI 的可行性，所以不对 SurfaceView / TextureView 的原理深入解析，相关解析也在计划中，感兴趣的读者可以关注后续更新。</p>\n<h3 id=\"4-5-特例Toast\"><a href=\"#4-5-特例Toast\" class=\"headerlink\" title=\"4.5 特例Toast\"></a>4.5 特例Toast</h3><p>Toast 作为 Android 系统级别的 UI 组件，甚至与 Activity 生命周期都无关，常见的例子就是如果一个 App 正在弹 Toast 的时候出现 Crash 或者手动杀掉了，Toast 还是能正常显示的。</p>\n<h4 id=\"4-5-1-Toast可以跨线程显示\"><a href=\"#4-5-1-Toast可以跨线程显示\" class=\"headerlink\" title=\"4.5.1 Toast可以跨线程显示\"></a>4.5.1 Toast可以跨线程显示</h4><p>实际上 Toast 的显示除了和 Activity 无关之外，也和线程无关，下面这段代码执行不会抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中的Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同时抛出一个注意事项：如果需要在子线程中 Toast，则该子线程必须初始化 Looper，因此需要使用 HandlerThread 或者在子线程中手动调用 Looper 的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在未初始化 Looper 的子线程中 Toast 会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">// RuntimeException: Can&#x27;t toast on a thread that has not called Looper.prepare()</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;未初始化Looper的子线程Toast会报错&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以使用 HandlerThread，或者手动初始化 Looper</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;已初始化Looper的子线程可以正确Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>Toast 本质上也是一种 View，因此是可以通过 <code>toast.setView(View)</code> 来自定义 Toast 样式的，那既然 Toast 是 View，为什么可以在子线程显示呢？老办法，看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(Context context, CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> makeText(context, <span class=\"keyword\">null</span>, text, duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Make a standard toast to display using the specified looper.</span></span><br><span class=\"line\"><span class=\"comment\">     * If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty Toast object.  If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Toast</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mTN = <span class=\"keyword\">new</span> TN(context.getPackageName(), looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TN</span> <span class=\"keyword\">extends</span> <span class=\"title\">ITransientNotification</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        TN(String packageName, <span class=\"meta\">@Nullable</span> Looper looper) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Use Looper.myLooper() if looper is not specified.</span></span><br><span class=\"line\">                looper = Looper.myLooper();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                            <span class=\"string\">&quot;Can&#x27;t toast on a thread that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：</p>\n<ul>\n<li>默认情况下三参数的 <code>Toast.makeText(...)</code> 会调用四参数的重载方法，并且传入的 looper 参数是 <code>null</code></li>\n<li>四参数的方法中，<code>new</code> 了一个 Toast 实例</li>\n<li>查看对应的 Toast 构造方法发现，又用传入的 looper 作为构造函数参数 <code>new</code> 了一个 <code>TN</code> 类的实例</li>\n<li>再查看 TN 的构造方法发现，如果传入的 looper 为 <code>null</code>，就直接用当前调用线程的 Looper</li>\n</ul>\n<p>简言之，<code>Toast.makeText(...)</code> 是直接使用调用的线程作为显示线程的，这就可以直接验证上文说的 Toast 的两个特性：</p>\n<ul>\n<li>Toast 可以在子线程显示，因为 <code>Toast.makeText(...)</code> 内部在调用时每次都使用当前线程作为显示线程，因此实际上不存在跨线程的问题。</li>\n<li>Toast 要求线程初始化 Looper 否则在 <code>new TN(...)</code> 的时候就会因为拿不到 looper 抛出异常。</li>\n</ul>\n<h4 id=\"4-5-2-Toast不能跨线程更新\"><a href=\"#4-5-2-Toast不能跨线程更新\" class=\"headerlink\" title=\"4.5.2 Toast不能跨线程更新\"></a>4.5.2 Toast不能跨线程更新</h4><p>看到这个小标题别慌，Toast 可以在子线程中显示是毫无疑问的，但是有一种情况下，Toast 也会抛出 <code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code> 异常，就是更新内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Toast generalToast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在子线程中弹一个 Toast，并把这个 Toast 持久化到成员变量</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        generalToast = Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中创建并显示的Toast&quot;</span>, Toast.LENGTH_LONG);</span><br><span class=\"line\">        generalToast.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确保子线程已经弹了 Toast 之后，也就是 generalToast 已经初始化，再在主线程更新 generalToast 的内容</span></span><br><span class=\"line\">btUpdateInMainThread.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generalToast != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            generalToast.setText(<span class=\"string\">&quot;在主线程更新子线程创建的Toast的内容&quot;</span>);</span><br><span class=\"line\">            generalToast.show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>运行发现报错了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么 <code>Toast.makeText(...)</code> 不限制线程，但 <code>toast.setText(...)</code> 又限制线程呢？再仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\"></span><br><span class=\"line\">        LayoutInflater inflate = (LayoutInflater)</span><br><span class=\"line\">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">        View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        tv.setText(text);</span><br><span class=\"line\"></span><br><span class=\"line\">        result.mNextView = v;</span><br><span class=\"line\">        result.mDuration = duration;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mNextView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TextView tv = mNextView.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tv == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tv.setText(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来在 <code>Toast.makeText(...)</code> 时，Toast 会使用当前线程作为该 Toast 的消息处理 Looper，然后使用系统的 Inflater 服务去加载一个 <code>com.android.internal.R.layout.transient_notification</code> 的布局作为 Toast 的根布局，其中具有一个 TextView 元素，使用该 TextView 元素承载需要显示的文字。</p>\n<p>当调用 <code>toast.setText(...)</code>  时，TextView 就会像文首提到的方式，一层层向上通知更新，因此如果线程与 toast 在初始化时的线程不一致，自然会抛出异常。</p>\n<h3 id=\"4-6-捕获异常\"><a href=\"#4-6-捕获异常\" class=\"headerlink\" title=\"4.6 捕获异常\"></a>4.6 捕获异常</h3><p>上述的在子线程更新 UI 的方式，都是通过避开已知会抛出异常的情况（SurfaceView 相当于直接不检查）实现的。还有一种更新 UI 的方式最为简单粗暴，就是捕获异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程中更新UI并捕获异常&quot;</span>);</span><br><span class=\"line\">            ivImage.setImageResource(R.drawable.ic_launcher_foreground);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ignore)&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码当然不会抛出异常，并且 TextView 也确实能更新文本内容，但是 ImageView 却没有任何反应。对比一下 <code>TextView#setText(...)</code> 和 <code>ImageView#setImageResource(...)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"meta\">@DrawableRes</span> <span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过看源码发现：</p>\n<ul>\n<li><code>TextView#setText(...)</code> 是先通过 <code>setTextInternal(...)</code> 把 text 存入到成员变量，然后再调用 <code>checkForRelayout()</code> 检查是否需要重绘，如果需要的话才调用 <code>requestLayout()</code>，检查线程也就发生在 <code>ViewRootImpl#requestLayout()</code> 中。所以即使 <code>ViewRootImpl#requestLayout()</code> 抛出了异常，也不会影响到 <code>setTextInternal(...)</code> 已经把 text 存下来了，那只需要等待下一次屏幕刷新即可把文本刷新上去。</li>\n<li><code>ImageView#setImageResource(...)</code> 是先通过 <code>requestLayout()</code> 请求更新，并在 <code>ViewRootImpl#requestLayout()</code> 中检查了线程，只有未抛出异常时，才会走到 <code>invalidate()</code> 并重绘，否则抛出异常则会中断跳出方法。</li>\n</ul>\n<p>所以，通过捕获异常的方式，只能针对类似于 TextView 这种，可以在检查线程前先做更新 / 缓存的 View，其他 View 则尽管不会抛出异常，也无法更新 UI，所以捕获异常属于一种“骚操作”，是极为不建议使用的。</p>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><p>概括一下本文内容：</p>\n<ul>\n<li>Android 中视图的顶点都是 Window，显示视图的根基就是需要有一个可用的 Window</li>\n<li>Window 持有 DecorView</li>\n<li>Window 在创建并持有 DecorView 时会初始化 ViewRootImpl 时的当前线程会作为 ViewRootImpl 持有的初始化线程</li>\n<li>DecorView 加载 subDecor</li>\n<li>用 subDecor 承载 Activity 的 layout</li>\n<li>更新 View 时，如果需要重绘，会逐级调用父 View 的 <code>requestLayout()</code>，最上层的父 View 就是 ViewRootImpl，在 <code>ViewRootImpl#requestLayout()</code> 中判断了当前线程与初始化线程是否相同，如果不相同则抛出异常</li>\n<li>有几种方式是可以在子线程更新 UI 的：</li>\n<li>手动触发 ViewRootImpl 初始化：也就是手动创建 Window 并添加 DecorView。</li>\n<li>避开 ViewRootImpl 的检查：针对 TextView 这类先缓存再判断的 View 可以通过避开重绘等待下一次屏幕刷新时显示已缓存的内容来刷新 UI。</li>\n<li>使用 SurfaceView / TextureView。</li>\n<li>显示 Toast：Toast 的创建每次都会使用当前线程初始化，因此显示 Toast 不受跨线程的影响。但不能对其他线程的 Toast 实例对象调用 <code>Toast#setText(...)</code>，否则就相当于子线程更新 UI。</li>\n<li>捕获异常：针对 TextView 这类先缓存再判断的 View，可以更新 UI。但其他 View 通常会先检查线程再重绘，就会导致检查的那一步抛出异常，虽然捕获了不会 Crash，但也会中断重绘逻辑导致无法刷新。</li>\n</ul>\n<hr>\n<p>以上就是本篇关于「子线程到底能不能更新 UI」的全部内容了，相信看完后应当可以对 Android 到底能不能在子线程中更新 UI 有了全面了解。如果觉得写得不错的，欢迎留个言鼓励一下～</p>\n","categories":["Android"],"tags":["Android","子线程","UI线程"]},{"title":"Android-Activity深入理解","url":"/post/android/android-activity/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Activity深入理解\"><a href=\"#Android-Activity深入理解\" class=\"headerlink\" title=\"Android-Activity深入理解\"></a>Android-Activity深入理解</h1><h2 id=\"1-Activity简介\"><a href=\"#1-Activity简介\" class=\"headerlink\" title=\"1. Activity简介\"></a>1. Activity简介</h2><p>Activity 即一个用户界面，可以理解成一个视图容器，容器内可以包裹和展示各类控件。全部 Activity 都需要在 Manifest 内声明。Activity 的生命周期为：</p>\n<p><img data-src=\"./activity_lifecycle.svg\" alt=\"Activity 生命周期\" title=\"@ASSET\"></p>\n<p>需要注意的是：</p>\n<ul>\n<li><code>onStop()</code> 在 Activity 不可见时才调用，例如 AActivity 启动 BActivity，若 BActivity 是透明或弹窗形式（<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>），则 AActiivty 不会调用 <code>onStop()</code>。</li>\n<li>Activity 的 <code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code> 并不是生命周期方法，当 Activity 处于 <code>isFinishing()</code> 状态时，<code>onSaveInstanceState()</code> 就不会被调用，因此只适合用于保存一些临时性的状态。</li>\n</ul>\n<h3 id=\"1-1-启动Activity\"><a href=\"#1-1-启动Activity\" class=\"headerlink\" title=\"1.1 启动Activity\"></a>1.1 启动Activity</h3><p>假设有一个 DemoActivity 注册信息如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=&quot;demo.DemoActivity&quot;</span><br><span class=\"line\">    android:exported=&quot;false&quot;</span><br><span class=\"line\">    android:excludeFromRecents=&quot;false&quot;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;demo.customActionName&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>exported</code>: 是否对外部 App 可见，默认为 <code>false</code>。隐式启动 Activity 时搜索 ActionName 的范围是当前 App 内，如果允许被其他 App 启动，则需要设置为 <code>true</code>。</li>\n<li><code>excludeFromRecents</code>: 是否在 Activity 进入后台时立即从「最近任务」中移除记录，默认为 <code>false</code>。如果设置为 `true，则该 Activity 一旦进入后台，就会从「最近任务」中删除其记录，不论该 Activity 是否是最后一个或唯一一个活跃的 Activity。</li>\n</ul>\n<p>（1）显式启动 Actiivty：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoActivity.class);</span><br><span class=\"line\"><span class=\"comment\">// 直接插入数据</span></span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;key&quot;</span>, value)</span><br><span class=\"line\"><span class=\"comment\">// 通过 Bundle</span></span><br><span class=\"line\">Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">bundle.putXXX(String key, XXX value);</span><br><span class=\"line\">intent.putExtra(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">context.startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p>（2）隐式启动 Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;demo.customActionName&quot;</span>);</span><br><span class=\"line\">context.startActivity(intent)</span><br></pre></td></tr></table></figure>\n\n<p>（3）<code>startActivity()</code> 是 Context 中的方法，因此 Activity 或 Application 都可以调用。但如果使用 <code>Application.startActivity()</code> 则需要给 Intent 添加一个 Flag <code>FLAG_ACTIVITY_NEW_TASK</code>，否则会报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Activity、Application 都是 Context 抽象类的子类，而 ContextImpl 是 Context 的实现。ActivityThread 在 <code>main()</code> 方法中实例化一个 ComtextImpl 并与 Activity 绑定。</p>\n</blockquote>\n<h3 id=\"1-2-退出Activity\"><a href=\"#1-2-退出Activity\" class=\"headerlink\" title=\"1.2 退出Activity\"></a>1.2 退出Activity</h3><p>Activity 可以通过调用 <code>finish()</code> 退出。当 App 正在退出时，<code>isFinishing() == true</code>，可用于在 <code>onPause()</code> 或 <code>onStop()</code> 中判断该 Activity 是正在退出或只是进入后台。</p>\n<p>同时退出多个 Activity 的方法：</p>\n<ul>\n<li>在所有被开启的 Activity 中注册特定的广播监听，收到该广播时退出自己，并在需要统一退出时发送广播。</li>\n<li>启动新的 Activity 时，使用 <code>startActivityForResult()</code> 替代 <code>startActivity()</code>，并在 <code>onActivityResult()</code> 中将自己 <code>finish()</code>。</li>\n<li>用 List 等记录每个启动的 Activity，并在需要时分别关闭。需要注意的是，使用 List 存放 Activity 有内存泄露的风险，当 Activity 关闭后，要及时清掉对应 List 中的引用。</li>\n<li>启动一个 <code>singleTask</code> 模式的 Activity，或是给 Intent 添加 Flag：<code>FLAG_ACTIVITY_CLEAR_TOP</code>，则系统会在新 Activity 启动后将其上的所有 Activity 销毁。</li>\n</ul>\n<hr>\n<h2 id=\"2-Activity启动模式\"><a href=\"#2-Activity启动模式\" class=\"headerlink\" title=\"2. Activity启动模式\"></a>2. Activity启动模式</h2><p>Activity 有 4 种启动模式：</p>\n<ul>\n<li><code>standard</code></li>\n<li><code>singleTop</code></li>\n<li><code>singleTask</code></li>\n<li><code>singleInstance</code></li>\n</ul>\n<p>需要先了解到，Android 中 Activity 是存在任务栈 Task 中的，启动一个 Activity 时会将其压栈，销毁时弹出，不同启动模式会导致 Activity 任务栈产生不同的行为，且一个 App 进程可以拥有多个 Activity 任务栈。</p>\n<p>Activity 可以通过在 Manifest 中指定 <code>taskAffinity</code> 来指定其 <strong>倾向于</strong> 加入的任务栈，但只有在满足条件时才会添加到该指定任务栈中。Activity 在启动时会先查找是否存在指定的栈，假如存在则会 <strong>「优先尝试」</strong> 压入对应栈，否则才会新建一个栈并启动。如果 Activity 没有指定，则默认等同于 Application 的 taskAffinity，如果 Application 也没有指定，则默认等同于包名。</p>\n<blockquote>\n<p><code>taskAffinity</code> 并非 100% 生效。例如 singleInstance 模式启动 Activity 时，其栈内仅允许存在该 Activity；即使其他 Activity 指定同一个 taskAffinity，依然会启动到新的栈中，但这两个栈的 taskAffinity 名称相同；所以判断栈是否相同仍然只能通过 TaskID，而不是 taskAffinity。</p>\n</blockquote>\n<h3 id=\"2-1-Standard\"><a href=\"#2-1-Standard\" class=\"headerlink\" title=\"2.1 Standard\"></a>2.1 Standard</h3><p>（1）Standard 即标准默认模式。启动一个 Activity 时，不论 Activity 在任务栈中是否已经有实例，都新建一个实例并压入任务栈。当前 Activity 在当前任务栈可以有多个实例，每个实例也可以在不同任务栈。</p>\n<p>Standard 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">Start Standard A</td>\n</tr>\n<tr>\n<td align=\"left\">/ABBA&gt;</td>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）Standard 模式通常用于允许一个页面同时创建多个，或者从逻辑上可以保证不会触发多个的情况下。</p>\n<h3 id=\"2-2-SingleTop\"><a href=\"#2-2-SingleTop\" class=\"headerlink\" title=\"2.2 SingleTop\"></a>2.2 SingleTop</h3><p>（1）SingleTop 即栈顶唯一模式，启动一个 Activity 时，如果该 Activity 已在栈顶则不会新建一个 Activity 实例而是复用它，否则其行为和 Standard 模式一致。</p>\n<p>SingleTop 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTop A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/ABAB&gt;</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）SingleTop 模式通常用于可能多次弹出的页面。实际上，我认为除非某个 Activity 有明确的需求要打开多个实例，否则都应该使用 SingleTop。因为大多数页面跳转都有可能被误触发多次，但绝大多数情况下都是不希望同时存在多个实例的。</p>\n<h3 id=\"2-3-SingleTask\"><a href=\"#2-3-SingleTask\" class=\"headerlink\" title=\"2.3 SingleTask\"></a>2.3 SingleTask</h3><p>（1）SingleTask 即任务栈唯一模式，启动一个 Activity 时，如果任务栈中存在该 Activity 实例，则复用它，否则才创建一个新的 Activity 实例。SingleTask 和 SingleTop 的区别在于，SingleTop 只在栈顶 Activity 和要启动的 Activity 相同时才复用，而 SingleTask 是每个 Activity 在当前整个任务栈中都只有一个实例。</p>\n<p>此外 SingleTask 还有一个重要特性：当一个 SingleTask 模式 Activity 被从任务栈中间移到栈顶时，会将原本任务栈中位于该 SingleTask Activity 之上的其他 Activity 销毁。需要注意的是，如果新启动一个 SingleTask Activity 并压入任务栈，由于其原本并不在栈中而是直接压入栈顶，因此不会导致栈内其他 Activity 被销毁。</p>\n<p>SingleTask 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleTask B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTask B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTask A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）SingleTask 模式常用在 App 的 MainActivity 中，因为大多数情况下 App 在主页面上返回时都应该返回到桌面或退出，而不是返回到其他页面中，因此可以在将 MainActivity 移入栈顶时，直接销毁其他 Activity。</p>\n<h3 id=\"2-4-SingleInstance\"><a href=\"#2-4-SingleInstance\" class=\"headerlink\" title=\"2.4 SingleInstance\"></a>2.4 SingleInstance</h3><p>（1）SingleInstance 即唯一实例模式，启动一个 Activity 时，寻找所有的任务栈，如果某个任务栈中存在该 Activity 实例，则切换到该任务栈，否则新建一个任务栈并创建该 Activity 实例。</p>\n<p>假如有三个 Activity 按照以下关系启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">A(Standard) -&gt; B(SingleInstance) -&gt; C(Standard)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>因为 B 是 SingleInstance，所以会创建一个新的栈，并在新的栈中启动 B。</li>\n<li>而 B 启动 C 时，同样由于 B 设置了 SingleInstance 属性，因此会先判断 C 的启动模式，以及 Manifest 中 C 对应的 <code>taskAffinity</code>，如果没有指定，则会把 C 启动在默认栈中，也就是和 A 同一个栈。</li>\n<li>因此如果在 C 中按下返回键，由于 A 和 C 在同一个栈，所以会回到 A，而不是 B。</li>\n</ul>\n<p>重点在于：任务栈不是唯一的，一个 App 可以有多个任务栈，就像 Android 系统的后台应用列表一样，里面包括了多个应用，而每个应用又管理自己的多个任务栈（可以理解为 <strong>任务栈的总栈</strong>），每个任务栈又分别管理包含的 Activity。</p>\n<p>SingleInstance 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>，任务栈之间用 <code>-</code> 连接，右侧的任务栈为最新任务栈，M 为最开始以 Standard 启动的 Activity）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleInstance A</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"center\">Start SingleInstance B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/M&gt; - /A&gt; - /B&gt;</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"center\">Start SingleInstance A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/M&gt; - /B&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt; - /B&gt;</td>\n<td align=\"center\">Start Standard C</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/B&gt; - /A&gt; - /MC&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>前 3 步都比较好理解，反正就是整个 App 所有任务栈都只允许有一个实例。重点在从第 4 步开始，由于最开始的 M 是 Standard 模式启动的，而第 4 步中 C 也是 Standard 模式，也就导致本来在最底下的任务栈 <code>/M&gt;</code> 处于最上层任务栈，并将 C 压入了 <code>/M&gt;</code> 所在的这个栈顶，因此从 C 返回的时候会先返回到 M。</p>\n<p>（2）SingleInstance 通常用于某些可被共享唤起的 App，但这些 App 仅有部分页面需要被共享唤起。</p>\n<p>例如：</p>\n<ul>\n<li>电话：其包括了拨号页和来电提醒页，而来电提醒页（通话页）则需要设置为 SingleInstance。</li>\n<li>闹铃：其包括了设置闹钟的页面和响铃提醒的页面，而响铃提醒页面则需要设置为 SingleInstance。</li>\n</ul>\n<p>以电话的来电提醒页为例：</p>\n<ul>\n<li>首先 standard 和 singleTop 是一定不能满足的，否则如果通话期间切到其他 App 后再切回来，就会再次创建一个新的「通话页」。</li>\n<li>而 singleTask 同样存在问题：假如用户通过「拨号页」拨打电话，进入「通话页」后，由于设置了 singleTask，「拨号页」就会被销毁，通话结束后用户就无法再次返回到「拨号页」了。收到来电提醒也是类似的场景。</li>\n<li>如果电话 App 的「拨号页」是启动的但被置到后台，假如用户正在某个 App「Demo」中，此时收到来电进入「通话页」，电话结束后用户当然是期望能返回到原先的「Demo」页面，因此「通话页」必须处于独立的栈中，否则「通话页」结束后返回时，就会回到「拨号页」了。</li>\n</ul>\n<hr>\n<h2 id=\"3-Activity启动流程\"><a href=\"#3-Activity启动流程\" class=\"headerlink\" title=\"3. Activity启动流程\"></a>3. Activity启动流程</h2><p>操作系统启动后，第一个启动的就是 <code>init</code> 进程，<code>init</code> 进程会启动 <code>Zygote</code>、<code>ServiceManager</code> 等基本进程。随后 Zygot 创建并初始化 system_service，system_service 会分裂出 AMS 等各项系统服务。当启动一个 App 时，实际流程是：</p>\n<ul>\n<li>Launcher 通过 IPC 通知 AMS。</li>\n<li>AMS 通知 system_service。</li>\n<li>system_service 通知 Zygote。</li>\n<li>Zygote 收到通知后 Fork 出子进程。</li>\n<li>子进程在 <code>Process#start()</code> 中通过反射调用 <code>ActivityThread.main()</code>。</li>\n</ul>\n<p>App 进程的入口在 <code>ActivityThread#main()</code>，包括初始化操作系统、用户环境、启动主线程 Looper 等。<code>ActivityThread$ActivityClientRecord</code> 以容器的形式持有了一个 Activity，以及管理这个 Activity 相关的其他资源，并且与持有的 Activity 是一一对应的，系统大多都是通过 ActivityClientRecord 操作 Activity 来管理和调度 Activity。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Activity client record, used for bookkeeping for the real &#123;<span class=\"doctag\">@link</span> Activity&#125; instance. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityClientRecord</span> </span>&#123;</span><br><span class=\"line\">        Activity activity;</span><br><span class=\"line\">        Window window;</span><br><span class=\"line\">        Activity parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">        thread.attach(<span class=\"keyword\">false</span>, startSeq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动一个 Activity 的入口，在 API 29 开始与之前版本有不同。在 API 29 之前的版本，ActivityThread 内部持有的一个 Handler 对象 <code>H</code> 监听了 <code>LAUNCH_ACTIVITY</code> 事件，并在收到 <code>LAUNCH_ACTIVITY</code> 请求后会调用 <code>handleLaunchActivity(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// API 29 移除了 LAUNCH_ACTIVITY 这个条件分支，</span></span><br><span class=\"line\">            <span class=\"comment\">// 而是放在 BIND_APPLICATION 中处理。</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\"></span><br><span class=\"line\">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">                handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但在 API 29 以上版本已经移除了这个分支，下文基于 API 29 分析。</p>\n<h3 id=\"3-1-ActivityThread初始化\"><a href=\"#3-1-ActivityThread初始化\" class=\"headerlink\" title=\"3.1 ActivityThread初始化\"></a>3.1 ActivityThread初始化</h3><p>首先在入口方法 <code>ActivityThread#main()</code> 中，有一个关键步骤 <code>thread.attach(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类 ApplicationThread 继承自 AIDL 类 IApplicationThread#Stub</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ApplicationThread mAppThread = <span class=\"keyword\">new</span> ApplicationThread();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mgr 就是 AMS 的远程 AIDL 接口</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityManagerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IActivityManager</span>.<span class=\"title\">Stub</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Watchdog</span>.<span class=\"title\">Monitor</span>, <span class=\"title\">BatteryStatsImpl</span>.<span class=\"title\">BatteryCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ActivityTaskManagerInternal 抽象类只有一个实现类：ActivityTaskManagerService$LocalService</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ActivityTaskManagerInternal mAtmInternal;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread thread, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// AMS 通过 ApplicationThread 这个 AIDL Proxy 和 App 进程的 ActivityThread 通信</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app.isolatedEntryPoint != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// This is an isolated process which should just call an entry point instead of being bound to an application.</span></span><br><span class=\"line\">                thread.runIsolatedEntryPoint(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (instr2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                thread.bindApplication(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                thread.bindApplication(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试启动 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// See if the top visible activity is waiting to run in this process...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (normalMode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                Slog.wtf(TAG, <span class=\"string\">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class=\"line\">                badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 AMS 调用 <code>attachApplication(...)</code> 后主要分为两个步骤：</p>\n<ul>\n<li>调用 <code>ActivityThread$ApplicationThread#bindApplication(...)</code></li>\n<li>调用 <code>ActivityTaskManagerService$LocalService#attachApplication(...)</code></li>\n</ul>\n<h3 id=\"3-2-创建和绑定Application\"><a href=\"#3-2-创建和绑定Application\" class=\"headerlink\" title=\"3.2 创建和绑定Application\"></a>3.2 创建和绑定Application</h3><p><code>AMS#attachApplication(...)</code> 内第 1 步执行 <code>ApplicationThread.bindApplication(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">IApplicationThread</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// AppBindData 提供绑定 Application 对象的信息，例如 Process, Instrumentation, AppInfo 等。</span></span><br><span class=\"line\">            AppBindData data = <span class=\"keyword\">new</span> AppBindData();</span><br><span class=\"line\">            <span class=\"comment\">// 向 ActivityThread 的 Handler 发送了一条 BIND_APPLICATION 请求，回到 App 进程</span></span><br><span class=\"line\">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BIND_APPLICATION: &#123;</span><br><span class=\"line\">                AppBindData data = (AppBindData)msg.obj;</span><br><span class=\"line\">                handleBindApplication(data);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回调 Application#onCreate()</span></span><br><span class=\"line\">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-进入Activity启动事务\"><a href=\"#3-3-进入Activity启动事务\" class=\"headerlink\" title=\"3.3 进入Activity启动事务\"></a>3.3 进入Activity启动事务</h3><p><code>AMS#attachApplication(...)</code> 内第 2 步执行 <code>mAtmInternal.attachApplication(...)</code>，是启动 Activity 的起点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityTaskManagerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IActivityTaskManager</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActivityTaskManagerInternal</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplication</span><span class=\"params\">(WindowProcessController wpc)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mRootActivityContainer.attachApplication(wpc);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootActivityContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ConfigurationContainer</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">DisplayManager</span>.<span class=\"title\">DisplayListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityStackSupervisor mStackSupervisor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">attachApplication</span><span class=\"params\">(WindowProcessController app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束 Application 启动流程，正式进入 Activity 启动流程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mStackSupervisor.realStartActivityLocked(activity, app,</span><br><span class=\"line\">                top == activity <span class=\"comment\">/* andResume */</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* checkConfig */</span>)) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-1-初始化Activity启动事务\"><a href=\"#3-3-1-初始化Activity启动事务\" class=\"headerlink\" title=\"3.3.1 初始化Activity启动事务\"></a>3.3.1 初始化Activity启动事务</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityStackSupervisor</span> <span class=\"keyword\">implements</span> <span class=\"title\">RecentTasks</span>.<span class=\"title\">Callbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 proc.getThread 就是 IApplicationThread</span></span><br><span class=\"line\">        <span class=\"comment\">// Create activity launch transaction.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class=\"line\">                proc.getThread(), r.appToken);</span><br><span class=\"line\">        <span class=\"comment\">// 注意入参是 LaunchActivityItem 对象</span></span><br><span class=\"line\">        clientTransaction.addCallback(LaunchActivityItem.obtain(...));</span><br><span class=\"line\">        <span class=\"comment\">// Set desired final state.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是 App 启动则 andResume == true，表示需要让首个 Activity 进入 Resume 状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (andResume) &#123;</span><br><span class=\"line\">            lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lifecycleItem = PauseActivityItem.obtain();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// mService 是 ClientLifecycleManager 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// Schedule transaction.</span></span><br><span class=\"line\">        mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ActivityStackSupervisor 生成了一个 ClientTransaction 对象，用于记录客户端要处理的事务（也就是 Activity 启动）：</p>\n<ul>\n<li>给 ClientTransaction 添加 Callback，传入 LaunchActivityItem 类型的对象。</li>\n<li>给 ClientTransaction 设置生命周期状态流转请求，传入 ResumeActivityItem 类型的对象，表示目标是流转到 onResume 状态。</li>\n<li>调用 <code>ClientLifecycleManager#scheduleTransaction</code> 提交 ClientTransaction 启动事务。</li>\n</ul>\n<h4 id=\"3-3-2-提交Activity启动事务\"><a href=\"#3-3-2-提交Activity启动事务\" class=\"headerlink\" title=\"3.3.2 提交Activity启动事务\"></a>3.3.2 提交Activity启动事务</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientLifecycleManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IApplicationThread client = transaction.getClient();</span><br><span class=\"line\">        transaction.schedule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientTransaction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span>, <span class=\"title\">ObjectPoolItem</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IApplicationThread mClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Obtain an instance initialized with provided params. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClientTransaction <span class=\"title\">obtain</span><span class=\"params\">(IApplicationThread client, IBinder activityToken)</span> </span>&#123;</span><br><span class=\"line\">        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> ClientTransaction();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入参的 client 就是 ApplicationThread，存到成员变量 mClient 中</span></span><br><span class=\"line\">        instance.mClient = client;</span><br><span class=\"line\">        instance.mActivityToken = activityToken;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回到 ActivityThread#ApplicationThread 中</span></span><br><span class=\"line\">        mClient.scheduleTransaction(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">IApplicationThread</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实际是调用父类 ClientTransactionHandler 中的方法</span></span><br><span class=\"line\">            ActivityThread.<span class=\"keyword\">this</span>.scheduleTransaction(transaction);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        transaction.preExecute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送 Message 到 ActivityThread，回到 App 进程</span></span><br><span class=\"line\">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，ClientTransaction, ClientLifecycleManager, ActivityThread 都并不直接执行事务：</p>\n<ul>\n<li>ClientTransaction 只用于记录事务。</li>\n<li>ClientLifecycleManager 调用 <code>scheduleTransaction(...)</code> 只是提交事务。</li>\n<li>ActivityThread 调用父类方法 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 也只是提交事务。</li>\n</ul>\n<p>真正用于执行事务的是 ActivityThread 的成员变量：<code>TransactionExecutor mTransactionExecutor</code>。</p>\n<h4 id=\"3-3-3-执行Actviity启动事务\"><a href=\"#3-3-3-执行Actviity启动事务\" class=\"headerlink\" title=\"3.3.3 执行Actviity启动事务\"></a>3.3.3 执行Actviity启动事务</h4><p>上文中 ClientTransactionHandler 发送了 <code>EXECUTE_TRANSACTION</code> 消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入参传入了自己，TransactionExecutor 才是真正的事务「执行器」。</span></span><br><span class=\"line\">    <span class=\"comment\">// An executor that performs multi-step transactions.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TransactionExecutor mTransactionExecutor = <span class=\"keyword\">new</span> TransactionExecutor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> EXECUTE_TRANSACTION: &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class=\"line\">                mTransactionExecutor.execute(transaction);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ActivityThread 在成员变量初始化时把自己传进来，所以 mTransactionHandler 就是 ActivityThread 本身。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClientTransactionHandler mTransactionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Initialize an instance with transaction handler, that will execute all requested actions. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransactionExecutor</span><span class=\"params\">(ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class=\"line\">        mTransactionHandler = clientTransactionHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Cycle through all states requested by callbacks and execute them at proper times. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeCallbacks</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// transaction.getCallbacks() 获取的 Callback 实际是之前 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// ClientTransaction.addCallback(LaunchActivityItem) 传入的 LaunchActivityItem。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class=\"line\">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>TransactionExecutor#execute(ClientTransaction)</code> 分为两个步骤：</p>\n<ul>\n<li><code>executedCallbacks(ClientTransaction)</code> 用于使 Activity 进入 onCreate 状态。</li>\n<li><code>executeLifecycleState(ClientTransaction)</code> 用于使 Activity 生命周期流转到 onResume 状态。</li>\n</ul>\n<h3 id=\"3-4-Activity启动事务总结\"><a href=\"#3-4-Activity启动事务总结\" class=\"headerlink\" title=\"3.4 Activity启动事务总结\"></a>3.4 Activity启动事务总结</h3><p>Activity 的启动事务可以分成两大块：Application 的初始化、Activity 启动事务的初始化。</p>\n<p>（1）Application 初始化：</p>\n<ul>\n<li>AMS 调用 ActivityThread 的 <code>main()</code> 方法启动。</li>\n<li><code>main()</code> 方法中创建一个 ActivityThread 对象，并调用 <code>ActivityThread#attach(...)</code>，内部获取 AMS 并与自己的内部类对象 ApplicationThread 绑定。</li>\n<li>绑定成功后，AMS 向 ActivityThread 发送 <code>BIND_APPLICATION</code> 消息，ActivityThread 回调 Application 的 onCreate 生命周期。</li>\n<li>ActivityThread 调用 <code>ActivityTaskManagerService#attachApplication(...)</code>，尝试启动 Activity。</li>\n<li>ActivityTaskManagerService 调用 <code>RootActivityContainer#attachApplication(...)</code>。</li>\n</ul>\n<p>（2）Activity 启动事务初始化：</p>\n<ul>\n<li>RootActivityContainer 调用 <code>ActivityStackSupervisor#realStartActivityLocked(...)</code>。</li>\n<li>ActivityStackSupervisor 创建 ClientTransaction 实例，传入 ApplicationThread，并调用 <code>ClientTransaction#addCallback(LaunchActivityItem)</code> 和 <code>ClientTransaction#setLifecycleStateRequest(ResumeActivityItem)</code></li>\n<li>ActivityStackSupervisor 调用 <code>ClientLifecycleManager#scheduleTransaction(...)</code>，并传入之前创建的 ClientTransaction 对象。</li>\n<li>ClientLifecycleManager 调用 <code>ClientTransaction#schedule()</code>。</li>\n<li>ClientTransaction 调用 <code>ApplicationThread#scheduleTransaction(...)</code>。</li>\n<li>ActivityThread 调用父类的 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 发送一条 <code>EXECUTE_TRANSACTION</code> 消息。</li>\n<li>ActivityThread 收到消息后调用 <code>TransactionExecutor#execute(ClientTransaction)</code>。</li>\n<li>TransactionExecutor 分别调用 <code>executeCallbacks(ClientTransaction)</code>（对应 onCreate）和 <code>executeLifecycleState(ClientTransaction)</code>（对应 onStart 和 onResume）。</li>\n</ul>\n<p>从 TransactionExecuotr 正式调用 <code>execute(...)</code> 执行事务开始，Activity 才正式进入生命周期流转阶段。</p>\n<hr>\n<h2 id=\"4-Activity生命周期流转\"><a href=\"#4-Activity生命周期流转\" class=\"headerlink\" title=\"4. Activity生命周期流转\"></a>4. Activity生命周期流转</h2><h3 id=\"4-1-onCreate\"><a href=\"#4-1-onCreate\" class=\"headerlink\" title=\"4.1 onCreate\"></a>4.1 onCreate</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，先执行 <code>executedCallbacks(ClientTransaction)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeCallbacks</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过上文可以知道，callback 就是 LaunchActivityItem</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class=\"line\">            <span class=\"comment\">// 所以实际上调用的是 LaunchActivityItem#execute</span></span><br><span class=\"line\">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LaunchActivityItem</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 client 就是 ActivityThread</span></span><br><span class=\"line\">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">        ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord(...);</span><br><span class=\"line\">        <span class=\"comment\">// 重点就是这一步调用的 ActivityThread#handleLaunchActivity</span></span><br><span class=\"line\">        client.handleLaunchActivity(r, pendingActions, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此后才与 API 29 以下版本的逻辑重合。</p>\n<h4 id=\"4-1-1-handleLaunchActivity\"><a href=\"#4-1-1-handleLaunchActivity\" class=\"headerlink\" title=\"4.1.1 handleLaunchActivity()\"></a>4.1.1 handleLaunchActivity()</h4><p><code>LaunchActivityItem#execute(...)</code> 创建了一个 ActivityClientRecord 对象用于持有目标 Activity 以及一些相关资源，再通过 <code>ActivityThread.handleLaunchActivity(...)</code> 创建并启动目标 Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Extended implementation of activity launch. Used when server requests a launch or relaunch.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 关键步骤 performLaunchActivity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ActivityTaskManager.getService().finishActivity(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>handleLaunchActivity(...)</code> 主要是调用 <code>performLaunchActivity(...)</code> 生成一个 Activity 实例对象，并在生成失败时直接通知 ActivityTaskManagerService 结束该 Activity，或是抛出一个异常，中断后续流程。</p>\n<h4 id=\"4-1-2-performLaunchActivity\"><a href=\"#4-1-2-performLaunchActivity\" class=\"headerlink\" title=\"4.1.2 performLaunchActivity()\"></a>4.1.2 performLaunchActivity()</h4><p><code>performLaunchActivity(...)</code> 是实际创建 Activity 的方法，过程中调用了一个重要方法 <code>Activity#attach</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 ActivityClientRecord 中取出了一个 Window</span></span><br><span class=\"line\">            window = r.mPendingRemoveWindow;</span><br><span class=\"line\">            r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这个方法是重点，并且注意参数中传入了上面从 ActivityClientRecord 中取出的 Window</span></span><br><span class=\"line\">        activity.attach(...);</span><br><span class=\"line\">        <span class=\"comment\">// 通知 Instrumentation 回调 Activity 的 onCreate()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在冷启 Activity 时，ActivityClientRecord 是在 <code>LaunchActivityItem#execute(...)</code> 中被 <code>new</code> 出来的，所以 <code>r.mPendingRemoveWindow</code> 肯定是 <code>null</code>，那什么时候才能进入 <code>if</code> 的条件呢？换句话说，什么时候 <code>ActivityThread#performLaunchActivity(...)</code> 传入的 ActivityClientRecord 中 <code>mPendingRemoveWindow != null</code> 呢？查找一下 ActivityClientRecord 中 <code>mPendingRemoveWindow</code> 写入的地方，发现在 <code>handleDestroyActivity(...)</code> 中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = performDestroyActivity(...);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            View v = r.activity.mDecor;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 核心逻辑：</span></span><br><span class=\"line\">                        <span class=\"comment\">// Hold off on removing this until the new activity&#x27;s</span></span><br><span class=\"line\">                        <span class=\"comment\">// window is being added.</span></span><br><span class=\"line\">                        r.mPendingRemoveWindow = r.window;</span><br><span class=\"line\">                        r.mPendingRemoveWindowManager = wm;</span><br><span class=\"line\">                        <span class=\"comment\">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class=\"line\">                        <span class=\"comment\">// everything else must be removed, because it might not be able to</span></span><br><span class=\"line\">                        <span class=\"comment\">// behave properly when activity is relaunching.</span></span><br><span class=\"line\">                        r.window.clearContentView();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        wm.removeViewImmediate(v);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码注释就能明白，当一个 Activity 销毁时，会在其 ActivityVlientRecord 中把自己的 Window 保存到 mPendingRemoveWindow 中，然后移除 Window 中所有 View，直到新的 Activity 的 Window 被添加为止：</p>\n<ul>\n<li>在 <code>handleRelaunchActivityInner(...)</code> 中，先调用了 <code>handleDestroyActivity(...)</code>，这一步就把当前 Activity 的 Window 存进了 <code>mPendingRemoveWindow</code></li>\n<li>接下来调用了 <code>handleLaunchActivity(...)</code></li>\n<li>然后在其内部调用了 <code>performLaunchActivity(...)</code></li>\n</ul>\n<p>这下明白了，当一个 Activity 被系统回收等等场景销毁时，有可能接下来又会回到这个 Activity，这种情况下就可以先把 Window 缓存下来，当自己这个 Activity 再次被激活时，就可以直接复用 Activity 上一次的 Window 而不需要从新分配。当然，由于 <code>r.window.clearContentView();</code>，Window 中的 View 被清空了，所以还是需要重新走一遍视图加载。这样做的好处也许是在效率和内存消耗中的一种折中，或许是因为 View 会占用很大内存，所以需要回收 View，但 Window 本身占用较少，每次都回收再让系统重新分配可能比缓存占用的内存更多、或者可能带来更大的内存抖动风险，所以选择临时缓存。继续查看 <code>Activity.attach(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过上文可知，冷启 Activity 时传入的 window 是 null，如果是 performRelaunchActivity 则会传入 Activity 上一次销毁前缓存下来的 window。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            CharSequence title, Activity parent, String id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个 Window 实例，这里 mWindow 是 Window 类型的接口对象，该接口只有 PhoneWindow 唯一一个实例对象，</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且当新启动一个 Activity 时，这里传入的 window 也是 null。</span></span><br><span class=\"line\">        mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>, window, activityConfigCallback);</span><br><span class=\"line\">        mUiThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统服务创建一个 WindowManager 的实例 WindowManagerImpl，并存进 mWindow (PhoneWindow) 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// 此外还存入了 IBinder 类型的 token，可以理解为用于在后续 App 创建 Window 时的授权。</span></span><br><span class=\"line\">        mWindow.setWindowManager(</span><br><span class=\"line\">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class=\"line\">                mToken, mComponent.flattenToString(),</span><br><span class=\"line\">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mWindow.setContainer(mParent.getWindow());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 同时也把上面创建的 WindowManager 存入 Activity 内。</span></span><br><span class=\"line\">        mWindowManager = mWindow.getWindowManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> <span class=\"keyword\">implements</span> <span class=\"title\">MenuBuilder</span>.<span class=\"title\">Callback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructor for main window of an activity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneWindow</span><span class=\"params\">(Context context, Window preservedWindow,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里的判断条件，是需要 preservedWindow != null 才去初始化 DecorView。</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动一个 Activity，传进来的 preservedWindow == null，是不会走这个逻辑的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preservedWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class=\"line\">            mElevation = preservedWindow.getElevation();</span><br><span class=\"line\">            mLoadElevation = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mForceDecorInstall = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// If we&#x27;re preserving window, carry over the app token from the preserved</span></span><br><span class=\"line\">            <span class=\"comment\">// window, as we&#x27;ll be skipping the addView in handleResumeActivity(), and</span></span><br><span class=\"line\">            <span class=\"comment\">// the token will not be updated as for a new window.</span></span><br><span class=\"line\">            getAttributes().token = preservedWindow.getAttributes().token;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此 <code>Activity.attach()</code> 执行完毕，接下来会由 Instrumentation 回调 <code>Activity.onCreate()</code>，表示 Activity 走到了 <code>onCreate()</code> 的生命周期。</p>\n<h4 id=\"4-1-3-onCreate总结\"><a href=\"#4-1-3-onCreate总结\" class=\"headerlink\" title=\"4.1.3 onCreate总结\"></a>4.1.3 onCreate总结</h4><p>Activity 在 onCreate 时的流程可以这么总结：</p>\n<ul>\n<li>Application 成功启动、初始化、并绑定 AMS 后，调用 <code>TransactionExecutor#execute()</code>，内部先执行 <code>executeCallbacks(ClientTransaction)</code>，调用 <code>LaunchActivityItem#execute(...)</code>，进而调用 <code>handleLaunchActivity(...)</code>，进入启动 Activity 的流程。</li>\n<li><code>handleLaunchActivity(...)</code> 内部调用 <code>performLaunchActivity(...)</code>。</li>\n<li><code>performLaunchActivity(...)</code> 判断传入的 ActivityClientRecord.mPendingRemoveWindow 是否为空。<ul>\n<li>如果是通过 <code>LaunchActivityItem#execute(...)</code> 触发的 <code>performLaunchActivity(...)</code>，则 <code>ActivityClientRecord.mPendingRemoveWindow == null</code>；</li>\n<li>否则如果一个 Activity 是已经启动后被 <code>handleRelaunchActivityInner(...)</code> 唤醒的，就会先调用 <code>handleDestroyActivity(...)</code>，这一步将当前 Activity 的 Window 缓存在 mPendingRemoveWindow 后再销毁，然后调用 <code>performLaunchActivity(...)</code>，这样重新启动的同一个 Activity 就能拿到上一次销毁时保存的 Window 了。</li>\n</ul>\n</li>\n<li><code>performLaunchActivity(...)</code> 中从 ActivityClientRecord 取出对应的 Activity，并调用 <code>Activity.attach(...)</code>，传入了从 ActivityClientRecord 中取出的 mPendingRemoveWindow（可能为空）。</li>\n<li><code>Activity.attach(...)</code> 中直接 <code>new</code> 了一个新的 PhoneWindow，构造方法中传入了 ActivityClientRecord.mPendingRemoveWindow，PhoneWindow 判断 mPendingRemoveWindow 是否为空，为空说明是新启动的 Activity，否则说明是 relaunch 的 Activity。</li>\n<li>如果传入的 mPendingRemoveWindow 不为空，则从 mPendingRemoveWindow 中取出 DecorView，并作为当前 Activity 自己的 DecorView，否则不处理。</li>\n<li>创建完新的 PhoneWindow 后，再通过系统服务创建一个 WindowManager。</li>\n<li>将这个新建的 WindowManager 绑定到 Activity 新建的 PhoneWindow 中，以及在 Activity 本身中保存。</li>\n<li>此时 Activity 和对应的 ActivityClientRecord 共用同一个 WindowManager，但注意，Activity 在 <code>attach(...)</code> 中 <code>new</code> 出来的 Window，暂时还没有存入到对应的 ActivityClientRecord 中。</li>\n<li>如果 </li>\n</ul>\n<p>也就是说，走完 <code>onCreate()</code> 的流程后，一个 Activity 就创建好了自己的 Window 并绑定了 WindowManager。并且如果这个 Activity 是 relaunch 的，还会直接复用上一次销毁时缓存的 Window 和 DecorView；但如果是新启动的 Activity，则到当前为止，Activity 已经创建好了 Window，但还不具有 DecorView。</p>\n<h3 id=\"4-2-onStart\"><a href=\"#4-2-onStart\" class=\"headerlink\" title=\"4.2 onStart\"></a>4.2 onStart</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，第二步调用 <code>executeLifecycleState(ClientTransaction)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransactionExecutorHelper mHelper = <span class=\"keyword\">new</span> TransactionExecutorHelper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"comment\">// 在生成 ClientTransaction 的方法 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// andResume == true 时 lifecycleItem 时 ResumeActivityItem 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际上 transaction 持有的 lifecycleItem 是 `ResumeActivityItem` 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此 lifecycleItem.getTargetState() 返回的就是 ON_RESUME。</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>, transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Transition the client between states with an option not to perform the last hop in the</span></span><br><span class=\"line\"><span class=\"comment\">     * sequence. This is used when resolving lifecycle state request, when the last transition must</span></span><br><span class=\"line\"><span class=\"comment\">     * be performed with some specific parameters.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cycleToPath</span><span class=\"params\">(ActivityClientRecord r, <span class=\"keyword\">int</span> finish, <span class=\"keyword\">boolean</span> excludeLastState,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于此前 Activity 刚完成 onCreate，所以 start == ON_CREATE，</span></span><br><span class=\"line\">        <span class=\"comment\">// executeLifecycleState(...) 方法中传入的 finish == ON_RESUME，</span></span><br><span class=\"line\">        <span class=\"comment\">// executeLifecycleState(...) 方法中传入的 excludeLastState == true。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start = r.getLifecycleState();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class=\"line\">        performLifecycleSequence(r, path, transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition the client through previously initialized state sequence. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLifecycleSequence</span><span class=\"params\">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, state; i &lt; size; i++) &#123;</span><br><span class=\"line\">            state = path.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ON_START: &#123;</span><br><span class=\"line\">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutorHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Calculate the path through main lifecycle states for an activity and fill</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@link</span> #mLifecycleSequence&#125; with values starting with the state that follows the initial</span></span><br><span class=\"line\"><span class=\"comment\">     * state.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;<span class=\"doctag\">NOTE:</span> The returned value is used internally in this class and is not a copy. It&#x27;s contents</span></span><br><span class=\"line\"><span class=\"comment\">     * may change after calling other methods of this class.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntArray <span class=\"title\">getLifecyclePath</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> finish, <span class=\"keyword\">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finish &gt;= start) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start + <span class=\"number\">1</span>; i &lt;= finish; i++) &#123;</span><br><span class=\"line\">                mLifecycleSequence.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLifecycleSequence.remove(mLifecycleSequence.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mLifecycleSequence;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 <code>for(...)</code> 循环中的起始序号是从 <code>start + 1</code> 开始，实际上就是先把 <code>ON_CREATE</code>（不包括）到 <code>ON_RESUME</code>（包括）之间的生命周期都添加到了 <code>mLifecycleSequence</code>，但由于 <code>excludeLastState == true</code>，因此 mLifecycleSequence 又移除了最后一项（也即 <code>ON_RESUME</code>），因此最终 <code>path = mHelper.getLifecyclePath(start, finish, excludeLastState)</code> 返回的 mLifecycleSequence 只包含 <code>ON_START</code>。</p>\n<p>由于 mTransactionHandler 就是 ActivityThread，所以 <code>TransactionExecutor#performLifecycleSequence(...)</code> 最终会调用 <code>ActivityThread#handleStartActivity(...)</code>。</p>\n<h4 id=\"4-2-1-handleStartActivity\"><a href=\"#4-2-1-handleStartActivity\" class=\"headerlink\" title=\"4.2.1 handleStartActivity()\"></a>4.2.1 handleStartActivity()</h4><p><code>ActivityThread#handleStartActivity(...)</code> 主要是调用 <code>performStart(String)</code>，并判断是否需要回调 <code>onRestoreInstanceState()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleStartActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity activity = r.activity;</span><br><span class=\"line\">        <span class=\"comment\">// Start</span></span><br><span class=\"line\">        activity.performStart(<span class=\"string\">&quot;handleStartActivity&quot;</span>);</span><br><span class=\"line\">        r.setState(ON_START);</span><br><span class=\"line\">        <span class=\"comment\">// Restore instance state</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                            r.persistentState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-2-performStart\"><a href=\"#4-2-2-performStart\" class=\"headerlink\" title=\"4.2.2 performStart()\"></a>4.2.2 performStart()</h4><p>需要注意的是，<code>performStart(...)</code> 是 Activity 内的方法，而不是 ActivityThread 的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">(String reason)</span> </span>&#123;</span><br><span class=\"line\">        mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instrumentation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Perform calling of an activity&#x27;s &#123;<span class=\"doctag\">@link</span> Activity#onStart&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * method.  The default implementation simply calls through to that method.</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity The activity being started.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.onStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>performStart()</code> 主要就是通知 Instrumentation 来回调 Activity 的 onStart 生命周期。</p>\n<h4 id=\"4-2-3-onStart总结\"><a href=\"#4-2-3-onStart总结\" class=\"headerlink\" title=\"4.2.3 onStart总结\"></a>4.2.3 onStart总结</h4><p>Activity 在 onStart 的流程可以这么总结：</p>\n<ul>\n<li>如果 ActivityThreade 在 <code>handleLauncherActivity</code> 期间，通过 <code>performLauncherActivity()</code> 未能成功创建一个 Activity 实例对象，则会请求 AMS 直接中断后续流程。</li>\n<li>否则 <code>executeCallbacks(ClientTransaction)</code> 执行完 handleLaunchActivity 后，再执行 <code>executeLifecycleState(ClientTransaction)</code>。</li>\n<li>executeLifecycleState 内先执行 <code>cycleToPath(...)</code>，回调 Activity 需要经过的生命周期。</li>\n<li>cycleToPath 传入 <code>ON_CREATE</code>, <code>ON_START</code>, <code>ONRESUME</code>，但从第二个开始选择，并排除最后一个，因此最终只有 <code>ON_START</code> 被送入 <code>TransactionExecutor#performLifecycleSequence(...)</code>，并由此回调 <code>ActivityThread#handleActivityStart(...)</code>。</li>\n<li>ActivityThread 调用 <code>Activity#performStart(...)</code>，Activity 调用 <code>Instrumentation#callActivityOnStart(this);</code>，并由 Instrumentation 回调 Activity 的 onStart 生命周期。</li>\n<li>ActivityThread 判断是否需要回调 onRestoreInstanceState 以及 onPostCreate。</li>\n</ul>\n<h3 id=\"4-3-onResume\"><a href=\"#4-3-onResume\" class=\"headerlink\" title=\"4.3 onResume\"></a>4.3 onResume</h3><p>回顾 <code>TransactionExecutor#executeLifecycleState</code>，当 <code>cycleToPath(...)</code> 执行完毕后，Activity 需要先经过的生命周期均已回调：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"comment\">// 在生成 ClientTransaction 的方法 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// andResume == true 时 lifecycleItem 时 ResumeActivityItem 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际上 transaction 持有的 lifecycleItem 是 `ResumeActivityItem` 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此 lifecycleItem.getTargetState() 返回的就是 ON_RESUME。</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>, transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上文也提到此处的 lifecycleItem 实际就是 <code>ResumeActivityItem</code>，因此查看 <code>ResumeActivityItem#execute(...)</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request to move an activity to resumed state.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResumeActivityItem</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActivityLifecycleItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// client 就是 ActivityThread，从 AMS 回到 ActivityThread#handleResumeActivity 中。</span></span><br><span class=\"line\">        client.handleResumeActivity(token, <span class=\"keyword\">true</span> <span class=\"comment\">/* finalStateRequest */</span>, mIsForward,</span><br><span class=\"line\">                <span class=\"string\">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-1-handleResumeActivity\"><a href=\"#4-3-1-handleResumeActivity\" class=\"headerlink\" title=\"4.3.1 handleResumeActivity()\"></a>4.3.1 handleResumeActivity()</h4><p><code>ActivityThread#handleResumeActivity</code> 内部通过调用 <code>performResumeActivity(...)</code> 获取包装了各类资源的 ActivityClientRecord，并用该 ActivityClientRecord 为 Activity 初始化与视图相关的资源，例如绑定 Window，初始化 DecorView 等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 token 从所有 ActivityClientRecord 中取出目标</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动的 Activity，可以理解为这里取出来的 ActivityClientRecord 就是上面 startActivityNow(...) 中 new 出来的 ActivityClientRecord</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActivityThread#performLaunchActivity 阶段在 Activity#attach 中 new 了一个 PhoneWindow，但 ActivityClientRecord 并没有持有 PhoneWindow，</span></span><br><span class=\"line\">            <span class=\"comment\">// 这一步就将 PhoneWindow 存入了 ActivityClientRecord，此时 Activity 和对应的 ActivityClientRecord 都持有了同一个 Window 和 WindowManager 对象</span></span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            <span class=\"comment\">// 获取目标 Activity 的 Window 的 DecorView</span></span><br><span class=\"line\">            <span class=\"comment\">// Window#getDecorView() 内部包含两个逻辑，如果持有的 DecorView 已存在（例如 relaunch 的场景）则直接返回，否则（例如 startActivityNow 的场景）就 new 一个再返回</span></span><br><span class=\"line\">            <span class=\"comment\">// 详见下面的源码</span></span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            <span class=\"comment\">// 取出之前 Activity.attach() 中存入 PhoneWindow 的 WindowManager 接口实例 WindowManagerImpl 对象。</span></span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 创建的 DecorView 的窗口属性</span></span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            <span class=\"comment\">// 将创建的的 DecorView 作为目标 Activity 的 DecorView，此时还未创建 ViewRootImpl</span></span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            <span class=\"comment\">// 判断 Activity 的 Window 是不是从上一次销毁时缓存下来的，如果是则通知 DecorView 的所有子 View 即将重建</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取 DecorView 的 ViewRootImpl，如果没有则返回 null</span></span><br><span class=\"line\">                <span class=\"comment\">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class=\"line\">                <span class=\"comment\">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class=\"line\">                <span class=\"comment\">// the decor view we have to notify the view root that the</span></span><br><span class=\"line\">                <span class=\"comment\">// callbacks may have changed.</span></span><br><span class=\"line\">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">                <span class=\"comment\">// 当 Activity 是 relaunch 的时候，Window 和其持有的 DecorView 是从上一次缓存下来的，则 DecorView#getViewRootImpl 才不为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通知所有的子 View：「准备重新创建视图」</span></span><br><span class=\"line\">                    impl.notifyChildRebuilt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用 WindowManagerImpl#addView</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 清除掉 Activity 缓存的 Window 等，并重置了 r.mPreserveWindow 标志位</span></span><br><span class=\"line\">        <span class=\"comment\">// Get rid of anything left hanging around.</span></span><br><span class=\"line\">        cleanUpPendingRemoveWindows(r, <span class=\"keyword\">false</span> <span class=\"comment\">/* force */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段逻辑可以分为两个关键点：</p>\n<ul>\n<li><code>r.window.getDecorView();</code>: 如果 Activity 不是 ReLaunch 的，也没有调用过 <code>setContentView(...)</code>，则需要先初始化 DecorView。</li>\n<li><code>wm.addView(decor, l);</code>: 通过 <code>WindowManagerImpl#addView</code> 传入 DecorView，然后创建 ViewRootImpl，并使得 ViewRootImpl 持有 DecorView。</li>\n</ul>\n<p>（1）初始化 DecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对应上面 View decor = r.window.getDecorView(); 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ViewGroup mContentParent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Retrieve the top-level window decor view (containing the standard</span></span><br><span class=\"line\"><span class=\"comment\">     * window frame/decorations and the client&#x27;s content inside of that), which</span></span><br><span class=\"line\"><span class=\"comment\">     * can be added as a window to the window manager.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;&lt;em&gt;Note that calling this function for the first time &quot;locks in&quot;</span></span><br><span class=\"line\"><span class=\"comment\">     * various window characteristics as described in</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> #setContentView(View, android.view.ViewGroup.LayoutParams)&#125;.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Returns the top-level window decor view.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">View <span class=\"title\">getDecorView</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span> || mForceDecorInstall) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 内部逻辑其实就是 new 出来一个 DecorView，并与当前 Window 绑定</span></span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）通过 <code>WindowManagerImpl#addView</code> 创建 ViewRootImpl 并持有 DecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handleResumeActivity(...) 中，调用该方法传入的 View 实际上就是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        <span class=\"comment\">// 这个 mGlobal 是 WindowManagerGlobal 实例对象</span></span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应 mGlobal.addView(...) 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  这里传入的 View 实际上是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 ViewRootImpl。</span></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            <span class=\"comment\">// mRoots 是一个 ArrayList&lt;ViewRootImpl&gt; 类型的集合。</span></span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\">            <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ViewRootImpl 持有 DecorView。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终于找到了 ViewRootImpl 初始化的地方，其构造方法内绑定了初始化时的线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> IWindowSession mWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个 WindowSession，App 创建 Window 时，实际上都是通过 ViewRootImpl 拿到 WindowSession，</span></span><br><span class=\"line\">        <span class=\"comment\">// 再通过 WindowSession 与 WindowManagerService 交互完成的，</span></span><br><span class=\"line\">        <span class=\"comment\">// 其中用到了 Activity#attach 传入 PhoneWindow 的 IBinder token。</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以实际上 PhoneWindow 持有了和 Window 相关的信息，但真正和 WMS 通信的是 ViewRootImpl。</span></span><br><span class=\"line\">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定了初始化时的线程</span></span><br><span class=\"line\">        mThread = Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 view 就是 DecorView。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mView = view;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 调用 WindowSession#addToDisplay(...)，才是真正创建了一个 Window。</span></span><br><span class=\"line\">                res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 Instrumentation 会回调 <code>Activity.onResume()</code>，表示 Activity 进入到了 <code>onResume()</code> 的生命周期。到了这一步，Activity 初始化了 PhoneWindow 以及 DecorView，并且在 ViewRootImpl 中加载了 DecorView，这也表示 Activity 已经从视觉上可见。</p>\n<h4 id=\"4-3-2-performResumeActivity\"><a href=\"#4-3-2-performResumeActivity\" class=\"headerlink\" title=\"4.3.2 performResumeActivity()\"></a>4.3.2 performResumeActivity()</h4><p>ActivityThread 在 Activity 的 onResume 阶段大部分逻辑都在 <code>handlerResumeActivity(...)</code> 内，和视图资源相关。<code>performResumeActivity(...)</code> 则主要是为 <code>handlerResumeActivity(...)</code> 提供了依赖的 ActivityClientRecord 资源，以及通知 Instrumentation 回调 <code>onResume()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = <span class=\"keyword\">new</span> ArrayMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\">            r.state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.persistentState = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.setState(ON_RESUME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">(<span class=\"keyword\">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class=\"line\">        dispatchActivityPreResumed();</span><br><span class=\"line\">        performRestart(<span class=\"keyword\">true</span> <span class=\"comment\">/* start */</span>, reason);</span><br><span class=\"line\">        <span class=\"comment\">// mResumed is set by the instrumentation</span></span><br><span class=\"line\">        mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instrumentation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        activity.onResume();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-3-onResume总结\"><a href=\"#4-3-3-onResume总结\" class=\"headerlink\" title=\"4.3.3 onResume总结\"></a>4.3.3 onResume总结</h4><p>Activity 在 onResume 时的流程可以这么总结：</p>\n<ul>\n<li>ActivityThread 已经通过 <code>handleLaunchActivity(...)</code> 成功创建 Activity 实例，并且通过 <code>TransactionExecutor#cycleToPath(...)</code> 回调了 Activity 需要经历的生命周期。</li>\n<li>TransactionExecutor 调用 <code>ResumeActivityItem#execute(...)</code>，从而调用了 <code>ActivityThread#handleResumeActivity(...)</code>。</li>\n<li>ActivityThread 在 handleResumeActivity 中通过 <code>performResumeActivity(...)</code> 获取对应的 ActivityClientRecord。</li>\n<li>获取 DecorView，分为两种逻辑：由于 startActivityNow 触发的 handleResumeActivity、以及由于 relaunch 触发的 handleResumeActivity。<ul>\n<li>如果是由于 startActivityNow 触发的，则 DecorView 尚未创建，立即创建一个 DecorView，此时 DecorView 或者说 Activity 尚未初始化 ViewRootImpl。</li>\n<li>如果是由于 relaunch 触发的，则 Window、DecorView 均是从上一次销毁时缓存中复用的，此时 DecorView 已经初始化过了 ViewRootImpl，也即 Activity 已经拥有 ViewRootImpl 了，只需要通知所有子 View 即将重建。</li>\n</ul>\n</li>\n<li>如果 Activity 还未初始化 ViewRootImpl（对应 startActivityNow 的场景），则调用 <code>WindowManager#addView(...)</code>，其内部初始化了 ViewRootImpl，将初始化 ViewRootImpl 时的所在线程，作为 ViewRootImpl 的初始线程。</li>\n<li>ViewRootImpl 持有 DecorView。</li>\n</ul>\n<p>也就是说，到了 onResume 这一步，Activity 已经创建了 DecorView 和 ViewRootImpl，并且对 ViewRootImpl 的原始线程做了初始化。此时 Activity 已经完整具有了 Window、DecorView、ViewRootImpl。</p>\n<hr>\n<h2 id=\"5-Activity布局加载流程\"><a href=\"#5-Activity布局加载流程\" class=\"headerlink\" title=\"5. Activity布局加载流程\"></a>5. Activity布局加载流程</h2><h3 id=\"5-1-setContentView\"><a href=\"#5-1-setContentView\" class=\"headerlink\" title=\"5.1 setContentView()\"></a>5.1 setContentView()</h3><p>接下来就是 Activity 的另一项重要功能，加载布局文件。通常加载布局文件都是通过 <code>setContentView(...)</code> 实现的，这里其实分为两个版本：</p>\n<p>（1）早期的 Activity 直接继承自 Activity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        getWindow().setContentView(layoutResID);</span><br><span class=\"line\">        initWindowDecorActionBar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是通过之前 <code>Activity.attach(...)</code> 时创建的 PhoneWindow 去直接加载布局。</p>\n<p>（2）新版本的 Activity 继承自 AppCompatActivity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// getDelegate() 返回一个 AppCompatDelegate 接口类型的实例对象</span></span><br><span class=\"line\">        getDelegate().setContentView(layoutResID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AppCompatDelegate <span class=\"title\">getDelegate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDelegate == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实际上内部就是 new 了一个 AppCompatDelegateImpl</span></span><br><span class=\"line\">            mDelegate = AppCompatDelegate.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDelegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看 <code>AppCompatDelegateImpl.setContentView()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class=\"line\">        ensureSubDecor();</span><br><span class=\"line\">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class=\"line\">        contentParent.removeAllViews();</span><br><span class=\"line\">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class=\"line\">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要分为两个部分：</p>\n<ul>\n<li><code>ensureSubDecor();</code>: 创建一个 SubDecorView。</li>\n<li>从 SubDecorView 中找到 ID 为 <code>android.R.id.content</code> 的 <code>ViewGroup contentParent</code>，清除其中所有 View，并把传入的布局 ID <code>resId</code> 解析并加载进 contentParent 内。</li>\n</ul>\n<p>（1）创建 SubDecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mSubDecorInstalled) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 真正的创建是这个方法</span></span><br><span class=\"line\">            mSubDecor = createSubDecor();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 可以看到在 setContentView(...) 内部加载了标题和 ActionBar</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么在 Activity 中，对 ActionBar 或 Title 的修改必须放在 setContentView(...) 调用之前</span></span><br><span class=\"line\">            <span class=\"comment\">// If a title was set before we installed the decor, propagate it now</span></span><br><span class=\"line\">            CharSequence title = getTitle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(title)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDecorContentParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mDecorContentParent.setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (peekSupportActionBar() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    peekSupportActionBar().setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mTitleView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mTitleView.setText(title);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSubDecorInstalled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ViewGroup <span class=\"title\">createSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class=\"line\">        <span class=\"comment\">// 这下面有一堆 if - else 都只是为了确定这个 Activity 对应 Window 的样式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (...) &#123;......&#125;</span><br><span class=\"line\">        a.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先确保了 Window 已经初始化</span></span><br><span class=\"line\">        <span class=\"comment\">// Now let&#x27;s make sure that the Window has installed its decor by retrieving it</span></span><br><span class=\"line\">        ensureWindow();</span><br><span class=\"line\">        <span class=\"comment\">// 从 Activity 存储的 PhoneWindow 中获取 DecorView，但并不是需要拿到 DecorView 实例，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而是为了像上面 handleResumeActivity(...) 中的 r.activity.getWindow() 一样，确保 DecorView 已被创建</span></span><br><span class=\"line\">        mWindow.getDecorView();</span><br><span class=\"line\">        <span class=\"comment\">// 这个就是目标 subDecor</span></span><br><span class=\"line\">        ViewGroup subDecor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mWindowNoTitle) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 Activity 含有 WindowTitle：</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mIsFloating) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加载悬浮窗样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) inflater.inflate(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mHasActionBar) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 加载有 ActionBar 样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) LayoutInflater.from(themedContext).inflate(...);</span><br><span class=\"line\">                <span class=\"comment\">// 这个 mDecorContentParent 是 ActionBarOverlayLayout 类型的，用于管理 ActionBar</span></span><br><span class=\"line\">                mDecorContentParent = (DecorContentParent) subDecor.findViewById(R.id.decor_content_parent);</span><br><span class=\"line\">                mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Propagate features to DecorContentParent</span></span><br><span class=\"line\"><span class=\"comment\">                 * 给 DecorContentParent 应用特性</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                ......</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然无法加载出 subDecor，就抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;AppCompat does not support the current theme features: &#123; &quot;</span> + ...... + <span class=\"string\">&quot; &#125;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将 subDecor 加载到 PhoneWindow 中</span></span><br><span class=\"line\">        mWindow.setContentView(subDecor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）将传入的布局 ID 解析成 View 并加载进 SubDecor 的一个 ViewGroup 子元素 <code>contentParent</code> 中：</p>\n<p>在 <code>createSubDecor()</code> 中，先确保 Window 和 DecorView 已创建，然后根据 Title 和 ActionBar 的样式不同，通过 <code>inflate</code> 的方式加载对应的模板 subDecor。然后再从加载好的 SubDecor 中通过 <code>findViewById(...)</code> 的方式获取到一个 ViewGroup 子元素 <code>contentParent</code> 并把布局加载进其中，也就是说，实际上在 Activity 中调用的 <code>setContentView(int resId)</code> 传入的布局文件，是加载在 subDecor 的一个子 View 中，而 DecorView 又持有了 SubDecor。</p>\n<blockquote>\n<p>如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，从类名也能看出这个 View 就是专门负责 ActionBar 的。</p>\n</blockquote>\n<p>当 subDecor 被成功创建后，通过 <code>mWindow.setContentView(subDecor);</code> 把 subDecor 添加到 PhoneWindow 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里也可以看出，默认情况下是全屏的</span></span><br><span class=\"line\">        setContentView(view, <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContentParent 是 DecorView 中的一个 ViewGroup 子元素。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            mContentParent.removeAllViews();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 传入的参数 View 就是 subDecor，所以实际是将 SubDecor 添加到 DecorView 的 ViewGroup 子元素 mContentParent 内。</span></span><br><span class=\"line\">            mContentParent.addView(view, params);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParent.requestApplyInsets();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">            cb.onContentChanged();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 PhoneWindow 中有一个成员变量 <code>mContentParent</code> 是 DecorView 的一个 ViewGroup 子元素，而 <code>AppCompatDelegateImpl#setContentView</code> 中从 SubDecor 中 <code>findViewById(android.R.id.content)</code> 获取了一个局部变量 <code>contentParent</code> 是 SubDecor 的一个 ViewGroup 子元素，二者是不同的。总的来说，<code>AppCompatActivity#setContentView</code> 加载的布局，实际上是加载到了 SubDecor 的 <code>(ViewGroup) contentParent</code> 中，然后 SubDecor 又被加载到了 DecorView 的 <code>(ViewGroup) mContentParent</code> 中。</p>\n<p>并且，当调用了 <code>setContentView(...)</code> 后，就已经创建好了 DecorView 和 SubDecor、加载好了布局、将 DecorView 传入了 PhoneWindow，因此：</p>\n<ul>\n<li>如果在 onCreate 阶段调用 <code>setContentView(...)</code>，则 <code>ActivityThread#handleResumeActivity</code> 阶段 <code>r.window.getDecorView()</code> 获取的 DecorView 就不为 <code>null</code>，并且 DecorView 已经加载了对应布局。</li>\n<li>否则 DecorView 和 SubDecor 都会在 <code>ActivityThread#handleResumeActivity</code> 阶段用默认模板加载出来。</li>\n<li>不论是否调了 <code>setContentView(...)</code>，ViewRootImpl 都是在 <code>ActivityThread#handleResumeActivity</code> 阶段通过 <code>WindowManagerImpl#addView</code> 才加载的，并且持有了 DecorView。</li>\n<li>如果 ViewRootImpl 已经初始化并持有了默认模板的 DecorView 之后才调用 <code>setContentView(...)</code>，由于布局最终只是加载进了 SubDecor 的一个子 ViewGroup，所以并不会重新初始化 SubDecor、DecorView、PhoneWindow、ViewRootImpl。</li>\n</ul>\n<h3 id=\"5-2-setContentView-总结\"><a href=\"#5-2-setContentView-总结\" class=\"headerlink\" title=\"5.2 setContentView()总结\"></a>5.2 setContentView()总结</h3><p>至此，可以对 Activty 中调用 <code>setContentView(int resId)</code> 后的流程做一个总结：</p>\n<ul>\n<li>如果是老版本直接继承自 Activity，则调用 <code>setContentView(int resId)</code> 后会直接把布局 <code>inflate</code> 到 Activity 对应的 Window 中。</li>\n<li>如果是新版本继承自 AppCompatActivity，则先确保 subDecor 已创建。</li>\n<li>在创建 subDecor 前，先确保 Window 和 DecorView 已创建。</li>\n<li>首先判断 PhoneWindow 是否创建，如果未创建则先创建 Window。</li>\n<li>然后通过 <code>PhoneWindow#getDecorView() - installDecor()</code> 确保了 DecorView 已被创建、以及根据 DecorView 生成了 <code>PhoneWindow#mContentParent</code> 这个实例 ViewGroup，也即：PhoneWindow 加载了 DecorView 并持有了 DecorView 加载后的 ViewGroup。</li>\n<li>创建 subDecor 时，根据 Activity 及其 Window 的属性加载预置的 subDecor 模板，如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，专门用于管理 ActionBar 相关的视图。</li>\n<li>根据模板创建了 subDecor 后，通过 <code>Window#setContentView(View)</code> 将 subDecor 传入，并把传入的 subDecor 作为子 View 添加到 <code>PhoneWindow#mContentParent</code> 中，本质上就是把 subDecor 添加到 DecorView 中。</li>\n<li>subDecor 创建好后，从 subDecor 中通过 <code>findViewById(int)</code> 获取一个 ID 为 <code>android.R.id.content</code> 的布局 <code>contentParent</code>，接着 <code>contentParent</code> 先 remove 掉所有子 View，再 <code>inflate</code> 传入的布局文件。这一步才真正加载 Activity 布局。</li>\n</ul>\n<p>也就是说，在 setContentView 的时候，Activity 实际上是在确保 Window 和 DecorView 均已创建的基础上，把 subDecor 根据模板创建出来并 add 进 <code>mContentParent</code> 这个 ViewGroup 中（<code>mContentParent</code> 是从 DecorView 加载出来的），然后从 subDecor 的模板布局中获取一个子元素 <code>contentParent</code>，最后把实际的 Activity 布局 <code>inflate</code> 进 <code>contentParent</code>。</p>\n<p>虽然顺序上是先把 subDecor 添加到 DecorView 中，再将 Activity 布局 <code>inflate</code> 进 subDecor 的子元素 <code>contentParent</code> 中，但因为 JVM 对象引用的缘故，所以实际上的关系链依然是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ViewRootImpl 持有 IWindowSession, WindowManager, DecorView</span><br><span class=\"line\">    -&gt; WindowManager 可以获取 PhoneWindow</span><br><span class=\"line\"></span><br><span class=\"line\">Window 持有 DecorView</span><br><span class=\"line\">    -&gt; DecorView 持有 subDecor</span><br><span class=\"line\">        -&gt; subDecor 加载 Activity 的布局。</span><br></pre></td></tr></table></figure>\n\n<p>此外，Window 有「子 Window」的概念，例如当 Activity 创建一个 Dialog 的 Window 时，会传入把 Activity 的 PhoneWindow 作为 WindowParant，当判断 <code>parent != null</code> 时，就会用 <code>parent</code> 的 Token 创建 Window。</p>\n","categories":["Android"],"tags":["Android","四大组件","Activty","taskAffinity","启动模式","生命周期","启动流程"]}]