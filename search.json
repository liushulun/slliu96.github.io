[{"title":"Billboard","url":"/post/billboard/","content":"<center>\n\n<p><a href=\"/categories/BlogDIY/\" title=\"@LINK\"><font color=EB6D39 size=5>欢迎点此参考超详细的博客 DIY 系列</font></a></p>\n</center>"},{"title":"Hexo博客DIY（10）一键转到页首、页尾、主页","url":"/post/blogdiy/blogdiy-10-jumplinks/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-增加跳转链接\"><a href=\"#1-增加跳转链接\" class=\"headerlink\" title=\"1. 增加跳转链接\"></a>1. 增加跳转链接</h1><p>默认情况下，想象一下这几个场景：</p>\n<ol>\n<li>看一篇比较长的文章，前半部分看完之后有个疑问，想评论一下，结果发现评论在最底下</li>\n<li>看一篇比较长的文章，看到一半了，发现后面是看过的或者打算再返回主页看看别的，结果发现主侧栏上的“首页”按钮在最顶上</li>\n<li>看一篇比较长的文章，想看看最新的评论都有哪些，结果发现评论在最底下，看完评论想返回首页，结果首页又在最顶上</li>\n</ol>\n<p>  ……</p>\n<p>虽说滚几下滚轮，点一下滚动栏也没什么大不了的，但毕竟还是影响到了阅读体验，总觉得有种跳出当前专注的事情一样。Next 主题为此提供了一键返回顶部的功能，还能显示阅读进度，这都是不错的，不过毕竟只能一键返回顶部，一键下滑到底部和一键返回主页还是要自己加上去。</p>\n<p>我考虑了一下，如果把这三个都单独做成一个控件，似乎有点繁杂，最后感觉集成到悬浮侧栏是最好的，理由有四：</p>\n<ol>\n<li>不突兀，没有多余的控件</li>\n<li>阅读文章时大概率会浏览目录，不需要专门引导读者就能知道有这个功能，使用起来比较沉浸</li>\n<li>浮动侧栏不论文章怎么滑动、滑动到哪，位置都相对固定，不会因为文章的不同导致这三个功能的位置发生变化而使得读者找不到在哪</li>\n<li>不论文章是否有目录，浮动侧栏都显示这些功能，避免了某些情况下，文章没有任何目录标题（全部文字都是正文格式的长文），导致目录栏不显示，进而导致这三个功能不显示。</li>\n</ol>\n<p>具体的功能效果大家可以在阅读本文时先试试我的博客浮动侧栏最上面的“页首 | 主页 | 评论”这三个功能（动图加载较慢）：</p>\n<center>\n\n<p><img data-src=\"./custom_jump_links.gif\" alt=\"自定义链接功能\" title=\"@ASSET\"></p>\n</center>\n\n<p>既然是加到浮动侧栏上，那就从浮动侧栏的样式文件入手，修改 <code>next/layout/_macro/sidebar.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;aside id=<span class=\"string\">&quot;sidebar&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;sidebar&quot;</span>&gt;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;sidebar-inner&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% set display_toc = is_post and theme.toc.enable or is_page and theme.toc.enable %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;############## ↓↓↓在这里插入以下代码↓↓↓ ##############&#125;</span><br><span class=\"line\">    &#123;## 所有文章都显示快捷栏，其他界面如果目录不为空也显示 ##&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> is_post || toc(page.content).length &gt; <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">      &#123;## 用&lt;p&gt;&lt;/p&gt;标签包裹的控件会在下方空出一行而不只是换行 ##&#125;</span><br><span class=\"line\">      &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;underline&quot;</span> style=<span class=\"string\">&quot;width: 100%; display: inline-block&quot;</span>&gt;</span><br><span class=\"line\">        &lt;style&gt;</span><br><span class=\"line\">        .underline&#123; padding-bottom:1px; border-bottom:1px solid #EB6D39&#125;</span><br><span class=\"line\">        &lt;/style&gt;</span><br><span class=\"line\">        &lt;span style=<span class=\"string\">&quot;width: 100%; font-size: 13px; color: #EB6D39;&quot;</span>&gt;</span><br><span class=\"line\">          &#123;### Top Link ###&#125;</span><br><span class=\"line\">          &lt;div style=<span class=\"string\">&quot;cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block&quot;</span> onclick=<span class=\"string\">&quot;window.location=&#x27;#&#x27;;&quot;</span>&gt;</span><br><span class=\"line\">          页首</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &amp;ensp;|&amp;ensp;</span><br><span class=\"line\">          &#123;### Home Link ###&#125;</span><br><span class=\"line\">          &lt;div style=<span class=\"string\">&quot;cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block&quot;</span> onclick=<span class=\"string\">&quot;window.location=&#x27;/&#x27;;&quot;</span>&gt;</span><br><span class=\"line\">          主页</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &amp;ensp;|&amp;ensp;</span><br><span class=\"line\">          &#123;### Bottom Link ###&#125;</span><br><span class=\"line\">          &lt;div style=<span class=\"string\">&quot;cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block&quot;</span> onclick=<span class=\"string\">&quot;window.scrollBy(0, document.getElementsByTagName(&#x27;BODY&#x27;)[0].scrollHeight);&quot;</span>&gt;</span><br><span class=\"line\">          评论</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/span&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;############## ↑↑↑在这里插入以上代码↑↑↑ ##############&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> display_toc and toc(page.content).length &gt; <span class=\"number\">1</span> %&#125;</span><br><span class=\"line\">      &lt;ul <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;sidebar-nav motion-element&quot;</span>&gt;</span><br><span class=\"line\">        &lt;li <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;sidebar-nav-toc sidebar-nav-active&quot;</span> target=<span class=\"string\">&quot;post-toc-wrap&quot;</span>&gt;</span><br><span class=\"line\">          &#123;&#123; __(<span class=\"string\">&#x27;sidebar.toc&#x27;</span>) &#125;&#125;</span><br><span class=\"line\">        &lt;/li&gt;</span><br><span class=\"line\">        &lt;li <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;sidebar-nav-overview&quot;</span> target=<span class=\"string\">&quot;site-overview-wrap&quot;</span>&gt;</span><br><span class=\"line\">          &#123;&#123; __(<span class=\"string\">&#x27;sidebar.overview&#x27;</span>) &#125;&#125;</span><br><span class=\"line\">        &lt;/li&gt;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/aside&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就能随时随地跳转到页首、页尾和首页了。当然，也可以把这段代码按照自己的喜好进一步修改、或放到自己想要的位置。</p>\n<hr>\n<h1 id=\"2-调整页码导航栏\"><a href=\"#2-调整页码导航栏\" class=\"headerlink\" title=\"2. 调整页码导航栏\"></a>2. 调整页码导航栏</h1><p>首页的文章列表以及分类中的文章列表底部都有一个页码导航栏：</p>\n<center>\n\n<p><img data-src=\"./page_nav_default.png\" alt=\"默认页码导航栏\" title=\"@ASSET\"></p>\n</center>\n\n<p>如上图所示，这个页码导航栏通常会将中间的页码省略，但如果页码比较多，默认情况下就会导致前后的页码要点很多下才能切换过去，因此可以适当减少省略的数量。修改：<code>next/layout/_partials/pagination.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> page.prev or page.next %&#125;</span><br><span class=\"line\">  &lt;nav <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;pagination&quot;</span>&gt;</span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: <span class=\"string\">&#x27;&lt;i class=&quot;fa fa-angle-left&quot; aria-label=&quot;&#x27;</span>+__(<span class=\"string\">&#x27;accessibility.prev_page&#x27;</span>)+<span class=\"string\">&#x27;&quot;&gt;&lt;/i&gt;&#x27;</span>,</span><br><span class=\"line\">        next_text: <span class=\"string\">&#x27;&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;&#x27;</span>+__(<span class=\"string\">&#x27;accessibility.next_page&#x27;</span>)+<span class=\"string\">&#x27;&quot;&gt;&lt;/i&gt;&#x27;</span>,</span><br><span class=\"line\">        mid_size: <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>mid_size</code> 代表当前页码到省略号之间有多少页，默认为 <code>mid_size: 1</code>，加入设置为 <code>mid_size: 3</code>，则效果如下：</p>\n<center>\n\n<p><img data-src=\"./page_nav_custom.png\" alt=\"调整页码导航栏\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n<hr>\n<h1 id=\"3-附录-参考指导\"><a href=\"#3-附录-参考指导\" class=\"headerlink\" title=\"3. 附录[参考指导]\"></a>3. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/baitaibai/article/details/54561918\" title=\"@LINK\">【1】css样式中的class，style与id的优先级问题（作者：白太白QAQ）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/kuoAT/p/6706327.html?utm_source=itdadao&utm_medium=referral\" title=\"@LINK\">【2】div和span显示在同一行（作者：适AT）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（11）修改文章类别位置、文章顶部显示标签","url":"/post/blogdiy/blogdiy-11-post-meta/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-首页文章列表分类位置调整\"><a href=\"#1-首页文章列表分类位置调整\" class=\"headerlink\" title=\"1. 首页文章列表分类位置调整\"></a>1. 首页文章列表分类位置调整</h1><p>让文章的分类在首页与其他信息显示在同一行，而在进入具体某篇文章后，分类则与标签单独显示在下一行内。首先解决分类的部分，修改 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;### 调整文章列表分类的位置 ###&#125;</span><br><span class=\"line\">&#123;### 个人喜欢把分类放在最后 ###&#125;</span><br><span class=\"line\">&#123;### 在分类上面添加以下内容 ###&#125;</span><br><span class=\"line\">&#123;### 文章列表分类前加分隔符 ###&#125;</span><br><span class=\"line\">&#123;### 正文显示分类前加换行符 ###&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> is_index %&#125;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class=\"line\">    &lt;div&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span>&lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;### 以下是分类的部分 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;## Categories ###&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回首页可以看到文章列表的文章信息末尾已经有分类了，点进去某篇文章，分类和标签则是另起一行显示：</p>\n<center>\n\n<p><img data-src=\"./post_list_show_categories.png\" alt=\"自定义链接功能\" title=\"@ASSET\"></p>\n</center>\n\n<p>不过，如果文章的分类多于两个，在中文模式下，Next 主题会使用中文逗号“，”来分隔，个人觉得并不是那么好看，或许可以也改一改，在分类的代码里面找到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">for</span> cat <span class=\"keyword\">in</span> post.categories %&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> cat_length &gt; <span class=\"number\">1</span> and loop.index !== cat_length %&#125;</span><br><span class=\"line\">    &#123;&#123; __(<span class=\"string\">&#x27;symbol.comma&#x27;</span>) &#125;&#125;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123; __(<span class=\"string\">&#x27;symbol.comma&#x27;</span>) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应了语言配置文件中的 <code>comma</code>，在中文模式中，<code>comma</code> 对应的就是中文逗号，由于只想改掉这一个地方，所以直接把这行替换一下就好了，我用的就是一个半角空格 <code>&amp;ensp;</code>，和标签的分隔保持统一风格。效果如下：</p>\n<center>\n\n<p><img data-src=\"./multiple_categories_split.png\" alt=\"多分类自定义分隔\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-文首显示标签并与分类对齐\"><a href=\"#2-文首显示标签并与分类对齐\" class=\"headerlink\" title=\"2. 文首显示标签并与分类对齐\"></a>2. 文首显示标签并与分类对齐</h1><p>在 Next 主题中所有的文章称为 __Post__，默认情况下 Post 的标签是在文章底部的，不够我个人觉得这样并不适合读者在阅读文章前了解文章的大致方向，或许应该像论文一样，把标签放在文首更好。关于文章内的各个控件、内容的布局都在：<code>next/layout/_macro/post.swig</code> 文件中。先找到文章标签对应的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;footer <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-footer&quot;</span>&gt;</span><br><span class=\"line\">  &#123;### ↓↓↓以下就是标签代码↓↓↓ ###&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> theme.tag_icon %&#125;</span><br><span class=\"line\">      &#123;% set tag_indicate = <span class=\"string\">&#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27;</span> %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">      &#123;% set tag_indicate = <span class=\"string\">&#x27;#&#x27;</span> %&#125;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-tags&quot;</span>&gt;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> post.tags %&#125;</span><br><span class=\"line\">        &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;tag&quot;</span>&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\">      &#123;% endfor %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  &#123;### ↑↑↑以上就是标签代码↑↑↑ ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这段就是标签的代码了。直接把这段剪切到上面和分类代码同级的地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;### 分类代码 ###&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;### 标签代码 ###&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过这样移完会发现分类和标签的大小、高度都不一致，有点参差不齐的感觉，甚是不爽。修改细节就不详细介绍了，直接给出我目前在用的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;## Categories ###&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class=\"line\">  &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-category&quot;</span>&gt;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-item-icon&quot;</span> style=<span class=\"string\">&quot;text-align:center;font-size:12px;vertical-align:middle;display:inline-block;&quot;</span>&gt;</span><br><span class=\"line\">        &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-th&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> theme.post_meta.item_text %&#125;</span><br><span class=\"line\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-item-text&quot;</span> style=<span class=\"string\">&quot;text-align:center;font-size:12px;vertical-align:middle;display:inline-block;&quot;</span>&gt;</span><br><span class=\"line\">        &#123;&#123; __(<span class=\"string\">&#x27;post.in&#x27;</span>) &#125;&#125;:&amp;ensp;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">for</span> cat <span class=\"keyword\">in</span> post.categories %&#125;</span><br><span class=\"line\">      &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;&#123;#</span><br><span class=\"line\">      #&#125;&lt;a style=&quot;vertical-align:middle;display:inline-block;&quot; href=&quot;&#123;&#123; url_for(cat.path) &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&lt;span itemprop=&quot;name&quot; style=&quot;text-decoration: none; font-size:12px&quot;&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt;&#123;#</span><br><span class=\"line\">      #&#125;&lt;/a&gt;&#123;#</span><br><span class=\"line\">    #&#125;&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#123;% set cat_length = post.categories.length %&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> cat_length &gt; <span class=\"number\">1</span> and loop.index !== cat_length %&#125;</span><br><span class=\"line\">        &#123;&#123; __(<span class=\"string\">&#x27;symbol.comma&#x27;</span>) &#125;&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">  &lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;##### Tags ######&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-divider&quot;</span> style=<span class=\"string\">&quot;vertical-align: middle;display:inline-block;&quot;</span>&gt;|&lt;/span&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-tags&quot;</span> style=<span class=\"string\">&quot;display: inline&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div style=<span class=\"string\">&quot;text-align:center;vertical-align: middle;display:inline-block;font-size:12px;&quot;</span>&gt;</span><br><span class=\"line\">      &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-tags&quot;</span>&gt;&lt;/i&gt;&amp;ensp;Tags:&amp;ensp;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> post.tags %&#125;</span><br><span class=\"line\">      &lt;span style=&quot;display:inline-block;vertical-align: middle;&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;&#123;#</span><br><span class=\"line\">      #&#125;&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&amp;ensp;&lt;/a&gt;&#123;#</span><br><span class=\"line\">      #&#125;&lt;/span&gt;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还需要对 <strong>Tags</strong> 的显示样式文件 <code>next/source/css/_common/components/post/post-tags.styl</code> 做一些修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.posts-expand .post-tags &#123;</span><br><span class=\"line\">  margin-top: 20px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  text-decoration: none;</span><br><span class=\"line\"></span><br><span class=\"line\">  a &#123;</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    margin-right: 10px;</span><br><span class=\"line\">    font-size: 12px;</span><br><span class=\"line\">    text-decoration: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<center>\n\n<p><img data-src=\"./categories_tags_same_line.png\" alt=\"自定义链接功能\" title=\"@ASSET\"></p>\n</center>\n\n<p>大致来说我做的修改就是：调整了文字、连接的大小，使分类和标签一致，调整了链接和文字的位置为垂直居中，使得链接看起来不会下面拖了一个很不美观的下划线。</p>\n<hr>\n<h1 id=\"3-文首增加原创声明\"><a href=\"#3-文首增加原创声明\" class=\"headerlink\" title=\"3. 文首增加原创声明\"></a>3. 文首增加原创声明</h1><p>首先可以看到，我的文章顶部属性以及分类和标签的中间有这么一行小字：</p>\n<center>\n\n<p><img data-src=\"./originalStatement.png\" alt=\"文首的原创声明\" title=\"@ASSET\"></p>\n</center>\n\n<p>声明一个原创标识还是有必要的，但是这么多文章，如果每个都手动写在正文内太麻烦，虽然可以通过 <code>blog/scaffolds/post.md</code> 文件定义好声明语句，在新文章生成时自动添加，但是这种方式只能添加到正文中，而这种声明感觉更偏向于文章属性，所以还是添加到文首比较好。</p>\n<p>首先在 <code>next/languages/</code> 目录下找到需要动态修改语言的对应语言文件，在 <code>post</code> 字段下添加如下属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 英文对应 en.yml</span></span><br><span class=\"line\"><span class=\"attr\">post:</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br><span class=\"line\">  <span class=\"attr\">originalStatement:</span> <span class=\"string\">【Note】This</span> <span class=\"string\">is</span> <span class=\"string\">an</span> <span class=\"string\">original</span> <span class=\"string\">post</span> <span class=\"string\">by</span> <span class=\"string\">SLLiu</span> <span class=\"string\">on</span> <span class=\"string\">liushulun.cn,</span> <span class=\"string\">requiring</span> <span class=\"string\">authorization</span> <span class=\"string\">before</span> <span class=\"string\">any</span> <span class=\"string\">quote</span> <span class=\"string\">or</span> <span class=\"string\">repost.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 简体中文对应 zh-CN.yml</span></span><br><span class=\"line\"><span class=\"attr\">post:</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br><span class=\"line\">  <span class=\"attr\">originalStatement:</span> <span class=\"string\">【注】本文由</span> <span class=\"string\">SLLiu</span> <span class=\"string\">原创于</span> <span class=\"string\">liushulun.cn，参考链接仅做学习指导，引用前请务必联系授权。</span></span><br></pre></td></tr></table></figure>\n\n<p>具体的声明内容就看自己喜好了。然后在文章内的头部属性栏添加一个自定义布尔类型属性 <code>hideOriginalStatement</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo博客DIY（11）修改文章类别位置、文章顶部显示标签</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">SLLiu</span></span><br><span class=\"line\"><span class=\"attr\">hideOriginalStatement:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>再修改 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;####################&#125;</span><br><span class=\"line\">&#123;##### 原创声明 ######&#125;</span><br><span class=\"line\">&#123;####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not post.hideOriginalStatement and not is_index %&#125;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;font color=#999999 size=1&gt;&#123;&#123; __(&#x27;post.originalStatement&#x27;) &#125;&#125;&lt;/font&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码可以添加到自己想放的位置，我自己放在了正文上面。文字显示的样式也可以随意调整。由于我的博客基本全部都是原创文章，为了方便，在模板文件 <code>blog/scaffolds/post.md</code> 内设置每篇文章自动增加原创声明的属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> &#123;&#123; <span class=\"string\">title</span> &#125;&#125;</span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">SLLiu</span></span><br><span class=\"line\"><span class=\"attr\">hideOriginalStatement:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">......</span></span><br></pre></td></tr></table></figure>\n\n<p>因为我绝大部分文章都是原创，所以用 <code>hideOriginalStatement: false</code>，这样当某篇文章忘记加这个字段时，<code>(not post.hideOriginalStatement) == true</code>，默认就会增加原创声明。</p>\n<p>用相同的思路，还可以添加例如“转载声明”，“引用声明”等等。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（12）文章顶部显示上一篇/下一篇","url":"/post/blogdiy/blogdiy-12-prev-next/","content":"<span id=\"more\"></span>\n\n<p>一般在阅读文章的时候，如果恰好在阅读一个系列，或者想要找到某一部分内容却又记不清到底在哪篇文章的时候，通常会使用“上一篇/下一篇”来切换阅读，但默认情况下这个导航在文章的最底下，如果仅仅只是为了快速切换，每次都拉到最底下就太麻烦了，为此可以在文章顶部也增加一个导航栏，首先在 <code>next/layout/_macro/post.swig</code> 中找到底部导航栏的代码部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;### Prev and Last ###&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not is_index and (post.prev or post.next) %&#125;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav&quot;</span>&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-next post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">    &#123;### 在系列第（7）篇中记录的，防止进入公告栏的优化 ###&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> post.next and not post.next.billboard %&#125;</span><br><span class=\"line\">        &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;next&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.next.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">          &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-left&quot;</span>&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-divider&quot;</span>&gt;&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-prev post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">      &#123;### 在系列第（7）篇中记录的，防止进入公告栏的优化 ###&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> post.prev and not post.prev.billboard %&#125;</span><br><span class=\"line\">        &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;prev&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">          &#123;&#123; post.prev.title &#125;&#125; &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-right&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% set isLast = loop.index % page.per_page === <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> is_index and not isLast %&#125;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-eof&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这一段复制一份到上面文章块 <code>POST BLOCK</code> 内的最顶上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;article <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;&#123;&#123; post_class &#125;&#125;&quot;</span> itemscope itemtype=<span class=\"string\">&quot;http://schema.org/Article&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&#123;### POST BLOCK ###&#125;</span><br><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-block&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;### 复制插入到这里 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/article&gt;</span><br></pre></td></tr></table></figure>\n\n<p>不过单单这么添加完，显示的效果比较一般：</p>\n<center>\n\n<p><img data-src=\"./post_header_prev_next_default.png\" alt=\"文章页首导航栏默认样式\" title=\"@ASSET\"></p>\n</center>\n\n<p>对比一下原来底部的导航栏：</p>\n<center>\n\n<p><img data-src=\"./post_footer_prev_next_default.png\" alt=\"文章页尾导航栏默认样式\" title=\"@ASSET\"></p>\n</center>\n\n<p>发现原来把样式也复制过来了，底部的导航栏分割线在上面，顶部的导航栏应该让分割线在下面才好，那么就自己写一个吧！把顶部的导航栏代码稍作更改，里面添加进自定义的样式——底下分割线，并且和文章标题间隔一段距离：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;article <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;&#123;&#123; post_class &#125;&#125;&quot;</span> itemscope itemtype=<span class=\"string\">&quot;http://schema.org/Article&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&#123;### POST BLOCK ###&#125;</span><br><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-block&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;#####################&#125;</span><br><span class=\"line\">  &#123;### Prev and Last ###&#125;</span><br><span class=\"line\">  &#123;#####################&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> not is_index and (post.prev or post.next) %&#125;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;bottom-divider&quot;</span>&gt;</span><br><span class=\"line\">      &lt;style&gt;</span><br><span class=\"line\">        .bottom-divider &#123;</span><br><span class=\"line\">          display: table;</span><br><span class=\"line\">          padding-bottom: 10px;</span><br><span class=\"line\">          margin-bottom: 50px;</span><br><span class=\"line\">          width: <span class=\"number\">100</span>%;</span><br><span class=\"line\">          border-bottom: 1px solid #eee;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &lt;/style&gt;</span><br><span class=\"line\">      &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-next post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">        &#123;### 在系列第（7）篇中记录的，防止进入公告栏的优化 ###&#125;</span><br><span class=\"line\">        &#123;% <span class=\"keyword\">if</span> post.next and not post.next.billboard %&#125;</span><br><span class=\"line\">          &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;next&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.next.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">            &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-left&quot;</span>&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;</span><br><span class=\"line\">          &lt;/a&gt;</span><br><span class=\"line\">        &#123;% endif %&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-divider&quot;</span>&gt;&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-prev post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">        &#123;### 在系列第（7）篇中记录的，防止进入公告栏的优化 ###&#125;</span><br><span class=\"line\">        &#123;% <span class=\"keyword\">if</span> post.prev and not post.prev.billboard %&#125;</span><br><span class=\"line\">          &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;prev&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">            &#123;&#123; post.prev.title &#125;&#125; &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-right&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">          &lt;/a&gt;</span><br><span class=\"line\">        &#123;% endif %&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% set isLast = loop.index % page.per_page === <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> is_index and not isLast %&#125;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-eof&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  &#123;#####################&#125;</span><br><span class=\"line\">  &#123;# END Prev and Last #&#125;</span><br><span class=\"line\">  &#123;#####################&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/article&gt;</span><br></pre></td></tr></table></figure>\n\n<p>把分割线的颜色也修改为和底部导航栏分割线的颜色一致，同时分割线和导航栏文字内距大约是 <code>10px</code>，分割线和标题外距大约 <code>50px</code>，看起来好多了！</p>\n<center>\n\n<p><img data-src=\"./post_header_prev_next_custom.png\" alt=\"文章页首导航栏自定义样式\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（13）隐藏修改时间信息和时间下滑虚线","url":"/post/blogdiy/blogdiy-13-hidetime/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-隐藏修改时间信息\"><a href=\"#1-隐藏修改时间信息\" class=\"headerlink\" title=\"1. 隐藏修改时间信息\"></a>1. 隐藏修改时间信息</h1><p>默认情况下，一篇文章会具有“创建时间”和“更新时间”两个信息：</p>\n<center>\n\n<p><img data-src=\"./update_time_show.png\" alt=\"文章列表显示更新时间\" title=\"@ASSET\"></p>\n</center>\n\n<p>不过两个时间标签放在一起，如果是正文内显示，会觉得特别繁杂，很多信息都挤在一块：</p>\n<center>\n\n<p><img data-src=\"./update_time_show_in_post.png\" alt=\"文章正文显示更新时间\" title=\"@ASSET\"></p>\n</center>\n\n<p>不论是出于简约美观、还是出于隐私性，可能有时会不希望显示这个信息，比如我只希望在明确会更新的文章或者经过讨论后认为有改进部分的文章内显示，从而给合作者、读者一个更明确地更新信号，在 Next 主题的主题配置文件中倒是有一个“更新时间”的开关：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post meta display settings</span></span><br><span class=\"line\"><span class=\"attr\">post_meta:</span></span><br><span class=\"line\">  <span class=\"attr\">item_text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">created_at:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">updated_at:</span>  <span class=\"comment\"># 这里可以开关“更新时间”</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">another_day:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>但这个开关是全局性的，要么所有文章都显示，要么所有文章都隐藏，而我只需要某些文章显示其他的隐藏，还是一样从代码入手。修改 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.post_meta.updated_at.enable %&#125;</span><br><span class=\"line\">  &#123;% set display_updated = !theme.post_meta.updated_at.another_day || theme.post_meta.updated_at.another_day &amp;&amp; date_diff %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> display_updated or !theme.post_meta.created_at %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> theme.post_meta.created_at and theme.post_meta.updated_at.enable %&#125;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-item-icon&quot;</span>&gt;</span><br><span class=\"line\">      &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-calendar-check-o&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> theme.post_meta.item_text %&#125;</span><br><span class=\"line\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-item-text&quot;</span>&gt;&#123;&#123; __(<span class=\"string\">&#x27;post.edited&#x27;</span>) &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;time title=&quot;&#123;&#123; __(&#x27;post.modified&#x27;) + __(&#x27;symbol.colon&#x27;) + full_date(post.updated) &#125;&#125;&quot; itemprop=&quot;dateModified&quot; datetime=&quot;&#123;&#123; moment(post.updated).format() &#125;&#125;&quot;&gt;&#123;#</span><br><span class=\"line\">    #&#125;&#123;&#123; date(post.updated) -&#125;&#125;</span><br><span class=\"line\">    &lt;/time&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这段代码的第一行改一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;### 根据文章是否有 modify 字段判断是否显示修改时间 ###&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.post_meta.updated_at.enable &amp;&amp; post.modify %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后默认情况下，所有文章都不会显示“更新时间”了，如果某些文章需要显示，只需要在文章的头部信息栏增加一个属性 <code>modify: true</code> 即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo博客DIY（13）隐藏修改时间信息和时间下滑虚线</span></span><br><span class=\"line\"><span class=\"attr\">modify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019-01-11 09:12:49</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>隐藏“修改时间”后看起来清爽的多：</p>\n<center>\n\n<p><img data-src=\"./update_time_hide.png\" alt=\"文章列表隐藏更新时间\" title=\"@ASSET\"></p>\n</center>\n\n<p>文章正文内显示效果：</p>\n<center>\n\n<p><img data-src=\"./update_time_hide_in_post.png\" alt=\"文章列表隐藏更新时间\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-隐藏时间信息下滑虚线\"><a href=\"#2-隐藏时间信息下滑虚线\" class=\"headerlink\" title=\"2. 隐藏时间信息下滑虚线\"></a>2. 隐藏时间信息下滑虚线</h1><p>默认情况下，时间信息（包括创建时间和修改时间）的底部还有一个下滑虚线：</p>\n<center>\n\n<p><img data-src=\"./time_underline_show.png\" alt=\"显示时间信息下滑虚线\" title=\"@ASSET\"></p>\n</center>\n\n<p>不过后面的各个信息都没有下划线，看起来总觉得不太统一。去掉这个下滑虚线修改 <code>next/source/css/_common/components/post/post-meta.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.posts-expand .post-meta</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  time &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 删除下面一行</span></span><br><span class=\"line\">    <span class=\"comment\">// border-bottom: 1px dashed $grey-dark;</span></span><br><span class=\"line\">    cursor: help;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照注释，删掉 <code>border-bottom</code> 一行即可。修改完效果：</p>\n<center>\n\n<p><img data-src=\"./time_underline_hide.png\" alt=\"隐藏时间信息下滑虚线\" title=\"@ASSET\"></p>\n</center>\n\n<p>当然，如果想保留，也可以按照自己的需求 DIY，这个文件内还有各个其他信息的样式，都可以自定义。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（14）自动为每篇文章增加结束语","url":"/post/blogdiy/blogdiy-14-autoend/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-增加结束词\"><a href=\"#1-增加结束词\" class=\"headerlink\" title=\"1. 增加结束词\"></a>1. 增加结束词</h1><p>作为一名码畜，“体验感”是一个很重要的东西，如果能让读者在看完每篇文章的时候都显示一个感谢词，也是作为技术人非常看重的一点：鼓励宣传。当然，我们可以自己手动在每篇文章末端内添加一段话，也可以在模板文件 <code>blog/scaffolds/post.md</code> 增加结束词，这样每次通过 <code>hexo new &quot;[title]&quot;</code> 创建文章时都会自动添加，但是说到底这个方式说白了还是有点费心思。</p>\n<p>话不多说，来看看如何实现！这个功能的实现逻辑主要是先创建一个样式文件，在里面定义好结束词的样式，然后再在文章内的结尾加载这个文件。首先是创建样式文件，在 <code>next/layout/_macro/</code> 下创建一个 <strong>swig</strong> 文件 <code>post-end.swig</code>，可以自定义命名，里面按照自己的喜好输入想要的结束语样式，我自己的结束语样式是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">\t&lt;br /&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span></span><br><span class=\"line\">\t&lt;div style=<span class=\"string\">&quot;text-align:center;color: #678;font-size:18px;&quot;</span>&gt;======================&lt;/div&gt;</span><br><span class=\"line\">        &lt;div style=<span class=\"string\">&quot;text-align:center;color: #678;font-size:18px;&quot;</span>&gt;全 文 结 束&amp;ensp;&amp;ensp;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;fa fa-leanpub&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span>&amp;ensp;&amp;ensp;感 谢 阅 读&lt;/div&gt;</span><br><span class=\"line\">\t&lt;div style=<span class=\"string\">&quot;text-align:center;color: #678;font-size:18px;&quot;</span>&gt;======================&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>next/layout/_macro/post.swig</code> 中，在 <code>POST BODY</code> 的下面有很多文章底部内容模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;##### License #######&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.creative_commons.license and theme.creative_commons.post and not is_index %&#125;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;% include <span class=\"string\">&#x27;../_partials/post/post-copyright.swig&#x27;</span> <span class=\"keyword\">with</span> &#123; <span class=\"attr\">post</span>: post &#125; %&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;# Wechat Subscriber #&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.wechat_subscriber.enable and not is_index %&#125;</span><br><span class=\"line\">  &#123;% include <span class=\"string\">&#x27;../_partials/post/wechat-subscriber.swig&#x27;</span> %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;##### Donation ######&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> page.reward === <span class=\"literal\">undefined</span> and theme.reward_settings.enable %&#125;</span><br><span class=\"line\">  &#123;% set reward_able = <span class=\"literal\">true</span> %&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">  &#123;% set reward_able = page.reward %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> reward_able and not is_index %&#125;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;% include <span class=\"string\">&#x27;../_partials/post/reward.swig&#x27;</span> %&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;#### POST FOOTER ####&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&lt;footer <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-footer&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>按照个人喜好在对应位置插入以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&#123;## 文章末尾结束语 ##&#125;</span><br><span class=\"line\">&#123;##################&#125;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> not is_index %&#125;</span><br><span class=\"line\">    &#123;% include <span class=\"string\">&#x27;post-end.swig&#x27;</span> %&#125;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我是放在 <code>License</code> 的上面了，参考我博客的显示效果：</p>\n<center>\n\n<p><img data-src=\"./auto_end_tag.png\" alt=\"自动增加结束语\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n<hr>\n<h1 id=\"2-附录-参考指导\"><a href=\"#2-附录-参考指导\" class=\"headerlink\" title=\"2. 附录[参考指导]\"></a>2. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://asdfv1929.github.io/2018/01/28/add-the-end/\" title=\"@LINK\">【1】Hexo NexT主题内给每篇文章后添加结束标语（作者：asdfv1929）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（15）首页及正文的标题高亮、加粗","url":"/post/blogdiy/blogdiy-15-titlestyle/","content":"<span id=\"more\"></span>\n\n<p>前言：可能是我自己的喜好问题，我总觉得 Next 默认的标题不够突出，要么颜色可以更突出一些，要么文字可以再加粗一些，总之感觉上没有高亮感。为此我想修改一下标题的样式，换个更具有视觉冲击的颜色！</p>\n<hr>\n<h1 id=\"1-首页文章列表标题高亮\"><a href=\"#1-首页文章列表标题高亮\" class=\"headerlink\" title=\"1. 首页文章列表标题高亮\"></a>1. 首页文章列表标题高亮</h1><p>首先是首页文章列表显示的文章标题，修改 <code>next/source/css/_common/components/post/post-title.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.posts-expand .post-title-link &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  color: #EB6D39;  <span class=\"comment\">// 这里修改颜色，按照个人喜好自定义</span></span><br><span class=\"line\">  border-bottom: none;</span><br><span class=\"line\">  line-height: <span class=\"number\">1.2</span>;</span><br><span class=\"line\">  vertical-align: top;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置完之后的效果如下：</p>\n<center>\n\n<p><img data-src=\"./title_highlight_in_home.png\" alt=\"首页标题高亮\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-正文标题高亮\"><a href=\"#2-正文标题高亮\" class=\"headerlink\" title=\"2. 正文标题高亮\"></a>2. 正文标题高亮</h1><p>为了风格统一，再把正文内的标题颜色也改为相同的高亮色，因为和下面的很多信息放在一块，顺便再加个粗凸显一下，修改 <code>next/source/css/_schemes/Gemini/index.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.posts-expand .post-title &#123;</span><br><span class=\"line\">  font-size: <span class=\"number\">1.</span>7em;</span><br><span class=\"line\">  color: #EB6D39;  <span class=\"comment\">// 这里修改颜色，按照个人喜好自定义</span></span><br><span class=\"line\">  font-weight: bold;  <span class=\"comment\">// 这里选择加粗，可选：100~900，整 100 取值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改完之后的效果如下：</p>\n<center>\n\n<p><img data-src=\"./title_highlight_in_post.png\" alt=\"正文标题高亮加粗\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（16）SEO描述作为简介并添加LaTeX提示","url":"/post/blogdiy/blogdiy-16-description/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-文首显示文章描述\"><a href=\"#1-文首显示文章描述\" class=\"headerlink\" title=\"1. 文首显示文章描述\"></a>1. 文首显示文章描述</h1><p>在给博客做 SEO 优化时，通常会给每一篇文章都加一个描述 description 属性，这样能更方便地使得文章被搜索引擎检索到。不过 description 会和正文的 <code>ReadMore</code> 冲突，也就是不论正文在哪里划分 <code>&lt;!-- more --&gt;</code> 标签，只要设置了 description 就会导致首页显示的文章缩略内容是 description，并且点击阅读全文后，这个 description 会作为一个文章信息的形式展示而非正文：</p>\n<center>\n\n<p><img data-src=\"./description_in_post_meta.png\" alt=\"文章信息中的描述\" title=\"@ASSET\"></p>\n</center>\n\n<p>这就使得本就信息栏更加复杂，而且如果文章确实需要一个简介，在正文处又要再写一次，不仅重复而且不美观。所以可以想办法把 description 从信息栏移到正文开头，恰好作为简介使用，而且还能优化 SEO，一举两得。调整 description 的位置需要修改 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;## POST HEADER ##&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not headlessPost %&#125;</span><br><span class=\"line\">  &lt;header <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-header&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;### 中间隔了很长一大段 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;### 一直到 Post Header 的最下面 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;#################&#125;</span><br><span class=\"line\">  &#123;## Description ##&#125;</span><br><span class=\"line\">  &#123;#################&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.description and (not theme.excerpt_description or not is_index) %&#125;</span><br><span class=\"line\">    &lt;div class=&quot;post-description&quot;&gt;&#123;#</span><br><span class=\"line\">      #&#125;&#123;&#123; post.description &#125;&#125;&#123;#</span><br><span class=\"line\">    #&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/header&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;### POST BODY ###&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>把这段 Description 的代码复制下来，然后把这里删掉，找到下面 <strong>Post Body</strong> 部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;### POST BODY ###&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-body&#123;% if theme.han %&#125; han-init-context&#123;% endif %&#125;&#123;% if post.direction &amp;&amp; post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot;</span> itemprop=<span class=\"string\">&quot;articleBody&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> is_index %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> post.description and theme.excerpt_description %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#123;### 这里是首页文章列表的描述 ###&#125;</span><br><span class=\"line\">      &#123;### 在描述前面加一个高亮的“简介：”开头 ###&#125;</span><br><span class=\"line\">      &lt;span style=<span class=\"string\">&quot;color: #EB6D39&quot;</span>&gt;简介：&lt;/span&gt;&#123;&#123; post.description &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      ......</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;### 这里是正文内的描述 ###&#125;</span><br><span class=\"line\">    &#123;### 在描述前面加一个高亮的“简介：”开头 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;#################&#125;</span><br><span class=\"line\">    &#123;## Description ##&#125;</span><br><span class=\"line\">    &#123;#################&#125;</span><br><span class=\"line\">    &#123;### 把 Description 显示在正文内 ###&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> post.description and (not theme.excerpt_description or not is_index) %&#125;</span><br><span class=\"line\">      &lt;div class=&quot;post-description&quot;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&lt;span style=&quot;color: #EB6D39&quot;&gt;简介：&lt;/span&gt;&#123;&#123; post.description &#125;&#125;&#123;#</span><br><span class=\"line\">      #&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;### 下面就是正文内容 ###&#125;</span><br><span class=\"line\">    &#123;&#123; post.content &#125;&#125;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，首页的描述前就会自动加上高亮的“简介：”开头了：</p>\n<center>\n\n<p><img data-src=\"./description_in_home_with_title.png\" alt=\"首页文章列表的描述\" title=\"@ASSET\"></p>\n</center>\n\n<p>正文内的描述也会有同样效果：</p>\n<center>\n\n<p><img data-src=\"./description_in_post_with_title.png\" alt=\"正文内的描述\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-自动切换“简介”和“未完待续”\"><a href=\"#2-自动切换“简介”和“未完待续”\" class=\"headerlink\" title=\"2. 自动切换“简介”和“未完待续”\"></a>2. 自动切换“简介”和“未完待续”</h1><p>如果一篇文章尚未完成，想要在文首提示一些信息，可能会这么做：</p>\n<center>\n\n<p><img data-src=\"./description_and_unfinished.png\" alt=\"简介后加入“未完待续”\" title=\"@ASSET\"></p>\n</center>\n\n<p>但是显得不够简洁，简介就应该是针对一篇已完成的文章。因此，可以利用自定义文章头部属性的方式进行适配。首先在未完成的文章头部属性中增加一个自定义属性 <code>unfinished: true</code>，当然也可以按自己的喜好来：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">例文</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">SLLiu</span></span><br><span class=\"line\"><span class=\"attr\">unfinished:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">简介</span> <span class=\"string\">/</span> <span class=\"string\">未完待续</span></span><br></pre></td></tr></table></figure>\n\n<p>然后修改 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> is_index %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;####################################&#125;</span><br><span class=\"line\">  &#123;### 首页文章列表中显示的简介/未完待续 ###&#125;</span><br><span class=\"line\">  &#123;####################################&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.description and theme.excerpt_description %&#125;</span><br><span class=\"line\">    &lt;span style=&quot;color: #EB6D39&quot;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&#123;% if post.unfinished %&#125;</span><br><span class=\"line\">            未完待续：</span><br><span class=\"line\">          &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">            简介：</span><br><span class=\"line\">          &#123;% endif %&#125;&#123;#</span><br><span class=\"line\">      #&#125;&lt;/span&gt;&#123;&#123; post.description &#125;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;#################################&#125;</span><br><span class=\"line\">  &#123;### 正文文首中显示的简介/未完待续 ###&#125;</span><br><span class=\"line\">  &#123;#################################&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.description and (not theme.excerpt_description or not is_index) %&#125;</span><br><span class=\"line\">    &lt;div class=&quot;post-description&quot;&gt;&#123;#</span><br><span class=\"line\">      #&#125;&lt;span style=&quot;color: #EB6D39&quot;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&#123;% if post.unfinished %&#125;</span><br><span class=\"line\">            未完待续：</span><br><span class=\"line\">          &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">            简介：</span><br><span class=\"line\">          &#123;% endif %&#125;&#123;#</span><br><span class=\"line\">      #&#125;&lt;/span&gt;&#123;&#123; post.description &#125;&#125;&#123;#</span><br><span class=\"line\">    #&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，如果文章具有 <code>unfinished: true</code> 属性，则会显示“未完待续”，完成文章后删掉这个属性，即可正常显示“简介”了。</p>\n<p>未完成文章显示：</p>\n<center>\n\n<p><img data-src=\"./post_unfinished.png\" alt=\"未完成的文章\" title=\"@ASSET\"></p>\n</center>\n\n<p>已完成文章显示：</p>\n<center>\n\n<p><img data-src=\"./post_finished.png\" alt=\"已完成的文章\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"3-增加LaTeX公式提示\"><a href=\"#3-增加LaTeX公式提示\" class=\"headerlink\" title=\"3. 增加LaTeX公式提示\"></a>3. 增加LaTeX公式提示</h1><p>由于 Safari 浏览器对 LaTeX 的支持不是特别好，会导致某些情况下 LaTeX 的公式显示错位或异常，例如：</p>\n<center>\n\n<p><img data-src=\"./latex_error_in_safari.png\" alt=\"Safari 显示 LaTeX 异常\" title=\"@ASSET\"></p>\n</center>\n\n<p>可以看到这个向量图标错了，正常情况下（基于 Chrome 和 FireFox 的浏览器）显示效果应该是这样的：</p>\n<center>\n\n<p><img data-src=\"./latex_right_in_chrome.png\" alt=\"LaTeX 正常显示效果\" title=\"@ASSET\"></p>\n</center>\n\n<p>为此，可以在文首增加一条提示，用于提醒读者切换浏览器。如果每一篇添加了的文章都手动增加提示，效率太低，不符合程序猿的习惯，况且如果是后面增加公式的文章，还容易忘记添加提示，因此把这个提示也添加到自动生成中去！</p>\n<p>显示效果可以查看文章：<a href=\"/post/machinelearning/ml-introduction/ml-introduction/\" title=\"@LINK\">机器学习简介</a>，图片效果如下：</p>\n<center>\n\n<p><img data-src=\"./latex_tips_in_post.png\" alt=\"文首自动添加 LaTeX 提示\" title=\"@ASSET\"></p>\n</center>\n\n<p>为了能在比较显眼的地方提示，就把它放在描述的上方好了！增加的方法是一样一样的，因为 Hexo 如果要使用 LaTeX 渲染，除了在配置文件中开启 MathJax 之外，还需要在每篇文章的头部属性中增加</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>那么就判断每篇文章是否使用了这个属性即可！还是修改刚才添加正文描述的地方 <code>next/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;### 这里是正文内LaTeX提示 ###&#125;</span><br><span class=\"line\">&#123;### 在正文描述的上方添加提示，并居中显示 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;## LaTeX Tips ###&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> post.mathjax %&#125;</span><br><span class=\"line\">&lt;div style=<span class=\"string\">&quot;color: #EB6D39; text-align: center&quot;</span>&gt;Tips : Safari 浏览器对 LaTeX 的支持不太好。&amp;emsp;LaTeX not supported well <span class=\"keyword\">in</span> Safari.&lt;/div&gt;&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;### 这里是正文内的描述 ###&#125;</span><br><span class=\"line\">&#123;### 在描述前面加一个高亮的“简介：”开头 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;## Description ##&#125;</span><br><span class=\"line\">&#123;#################&#125;</span><br><span class=\"line\">&#123;### 把 Description 显示在正文内 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里我只是在正文的描述上方添加提示语，在首页文章列表是不会显示的，以保持首页的简洁性。当然如果想要在首页也显示，复制下来粘贴到对应位置即可。并且没有开启 LaTeX 功能的文章是不会显示的，比如本文：</p>\n<center>\n\n<p><img data-src=\"./latex_no_tips_in_post.png\" alt=\"无 LaTeX 功能文章不显示提示\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（17）分离数据文件及DIY","url":"/post/blogdiy/blogdiy-17-datafile/","content":"<span id=\"more\"></span>\n\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（3）字数、访客、阅读统计","url":"/post/blogdiy/blogdiy-3-counter/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-字数与阅读时间统计\"><a href=\"#1-字数与阅读时间统计\" class=\"headerlink\" title=\"1. 字数与阅读时间统计\"></a>1. 字数与阅读时间统计</h1><p>字数统计的效果可以参见我的文章标题下方的本文统计以及整个博客最底部的全站统计。</p>\n<p>安装插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>\n\n<p>在主题配置文件中找到并修改以下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post wordcount display settings</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class=\"line\"><span class=\"comment\"># AWL — Average Word Length (chars count in word). Default: 4, CN≈2, EN≈5, RU≈6</span></span><br><span class=\"line\"><span class=\"comment\"># WPM — Words Per Minute. Default: 275, Slow≈200, Normal≈275, Fast≈350</span></span><br><span class=\"line\"><span class=\"attr\">symbols_count_time:</span></span><br><span class=\"line\">  <span class=\"attr\">separated_meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_post:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_total:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">awl:</span> <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"attr\">wpm:</span> <span class=\"number\">275</span></span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>separated_meta</code> 表示在“总字数”和“阅读时间”中间加一条分割线</li>\n<li><code>item_text_post</code> 为每篇文章内是否显示当前文章的字数和阅读时间统计</li>\n<li><code>item_text_total</code> 为是否在博客最底下显示整个站点所有文章的字数总和及阅读时间总和</li>\n<li><code>awl</code> 为每个单词的平均长度，根据提示，中文为 2，英文为 5，默认是 4，同样的文章，这个值设置的越大，估计的阅读时间越短。</li>\n<li><code>wpm</code> 为每分钟阅读的单词数，默认为275，更慢则设置为200，更快则设置为350，由于我的文章多与代码有关，因此阅读时间应当属于偏慢的，所以我的设置是 225</li>\n</ul>\n<hr>\n<h1 id=\"2-访客与阅读量统计\"><a href=\"#2-访客与阅读量统计\" class=\"headerlink\" title=\"2. 访客与阅读量统计\"></a>2. 访客与阅读量统计</h1><p>阅读量有两种统计方案，一个是<a href=\"http://busuanzi.ibruce.info/\" title=\"@LINK\">不蒜子</a>，一个是 <a href=\"https://leancloud.cn/\" title=\"@LINK\">LeanCloud</a>，不蒜子可以同时提供每篇文章的访客计数以及整个站点的访客计数，而 LeanCloud 仅支持单个文章的访客计数，因此如果需要全站统计的话，则至少需要使用一个不蒜子。不过，不蒜子目前还没有开放后台，有时不太方便更复杂的数据统计等功能，因此我的选择是每篇文章使用 LeanCloud 统计，全站使用不蒜子统计。</p>\n<p>不蒜子的引入非常简单，直接在主题配置文件内搜索 <code>busuanzi</code>，并修改以下部分即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class=\"line\"><span class=\"comment\"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class=\"line\"><span class=\"attr\">busuanzi_count:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># 开启访客总量统计</span></span><br><span class=\"line\">  <span class=\"attr\">total_visitors:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">total_visitors_icon:</span> <span class=\"string\">user</span></span><br><span class=\"line\">  <span class=\"comment\"># 开启查看文章总数统计</span></span><br><span class=\"line\">  <span class=\"attr\">total_views:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">total_views_icon:</span> <span class=\"string\">eye</span></span><br><span class=\"line\">  <span class=\"comment\"># 文章阅读量单独使用 LeanCloud</span></span><br><span class=\"line\">  <span class=\"attr\">post_views:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">post_views_icon:</span> <span class=\"string\">eye</span></span><br></pre></td></tr></table></figure>\n\n<p>设置 <code>enable: true</code> 打开功能，icon 指的是计数左边的图标，使用 FontAwesome 图标代码。<code>visitors</code> 和 <code>views</code> 分别代表了访客数和阅读数，比如一个人一次查看了三篇文章，则访客数 +1，而阅读数 +3.</p>\n<p>引入 LeanCloud 则需要先注册，然后在控制台点击创建一个新应用，名字可以随便输入，对于单日流量并不太高的个人博客页而言，不需要使用商用版，开发版的每日 30,000 次请求已经足足够够了。</p>\n<p>新建完应用后点击进入，然后在左侧选择 __存储__，然后点击“创建 Class”，新建一个新的表 <code>Counter</code>，注意，由于 Next 主题的规定，表名必须是这个，下方的权限选择 __无限制__，安全性可以在成功建立后台后再修改。</p>\n<p>创建完毕后，再点击左侧栏最下方的 __设置__，然后在子目录中选择 __安全中心__，由于只用到了计数功能，因此只需要打开“存储”开关即可，并在下方“Web 安全域名”处输入自己的博客地址，如果博客有绑定自定义域名，则应该同时输入自定义域名，如图：</p>\n<center>\n\n<p><img data-src=\"./leancloud_security_setting.png\" alt=\"LeanCloud 安全设置\" title=\"@ASSET\"></p>\n</center>\n\n<p>设置完毕后，再在左侧子栏找到 __应用 Key__，复制其中的 App ID 和 APP Key，并分别粘贴到主题配置文件中以下部分即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Show number of visitors to each article.</span></span><br><span class=\"line\"><span class=\"comment\"># You can visit https://leancloud.cn to get AppID and AppKey.</span></span><br><span class=\"line\"><span class=\"attr\">leancloud_visitors:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">app_id:</span></span><br><span class=\"line\">  <span class=\"attr\">app_key:</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要更高的安全性，需要安装组件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure>\n\n<p>安全组件的详情请查阅 LeanCloud 官方文档。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（2）内置的小功能扩展","url":"/post/blogdiy/blogdiy-2-extension/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-文章版权\"><a href=\"#1-文章版权\" class=\"headerlink\" title=\"1. 文章版权\"></a>1. 文章版权</h1><p>作为一个码畜，版权意识还是要有的（虽然没什么用），文章的版权该加还是加上，在主题配置文件中找到：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Creative Commons 4.0 International License.</span></span><br><span class=\"line\"><span class=\"comment\"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class=\"line\"><span class=\"comment\"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class=\"line\"><span class=\"comment\"># You can set a language value if you prefer a translated version of CC license.</span></span><br><span class=\"line\"><span class=\"comment\"># CC licenses are available in 39 languages, where you can find the specific and correct abbreviation you need.</span></span><br><span class=\"line\"><span class=\"comment\"># Valid values of language: deed.zh, deed.fr, deed.de, etc.</span></span><br><span class=\"line\"><span class=\"attr\">creative_commons:</span></span><br><span class=\"line\">  <span class=\"attr\">license:</span> <span class=\"string\">by-nc-sa</span></span><br><span class=\"line\">  <span class=\"attr\">sidebar:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">post:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span> <span class=\"string\">deed.zh</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，如果开启 <code>sidebar</code>，则文章的侧栏目录处会显示版权信息，如果开启 <code>post</code>，则文章底部会显示版权信息。</p>\n<hr>\n<h1 id=\"2-标签词云\"><a href=\"#2-标签词云\" class=\"headerlink\" title=\"2. 标签词云\"></a>2. 标签词云</h1><p>具体标签词云的效果可以参考：<a href=\"/tags/\" title=\"@LINK\">我的标签页面</a>，简单来说就是：所有文章中，出现次数不同的标签会具有不同大小、颜色，这样就能更好地区分哪些内容会是博客的主要部分。自定义效果在主题配置文件内：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TagCloud settings for tags page.</span></span><br><span class=\"line\"><span class=\"attr\">tagcloud:</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, font size, font color and amount of tags can be customized</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># All values below are same as default, change them by yourself</span></span><br><span class=\"line\">  <span class=\"attr\">min:</span> <span class=\"number\">13</span> <span class=\"comment\"># min font size in px</span></span><br><span class=\"line\">  <span class=\"attr\">max:</span> <span class=\"number\">30</span> <span class=\"comment\"># max font size in px</span></span><br><span class=\"line\">  <span class=\"attr\">start:</span> <span class=\"string\">&quot;#008577&quot;</span> <span class=\"comment\"># start color (hex, rgba, hsla or color keywords)</span></span><br><span class=\"line\">  <span class=\"attr\">end:</span> <span class=\"string\">&quot;#EB6D39&quot;</span> <span class=\"comment\"># end color (hex, rgba, hsla or color keywords)</span></span><br><span class=\"line\">  <span class=\"attr\">amount:</span> <span class=\"number\">200</span> <span class=\"comment\"># amount of tags, change it if you have more than 200 tags</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>min</code> 和 <code>max</code> 分别代表最冷门和最热门标签的大小，<code>start</code> 和 <code>end</code> 分别代表最冷门和最热门标签的颜色，出现次数位于中间的标签会根据这个大小、颜色范围自动生成不同的大小和颜色。</p>\n<hr>\n<h1 id=\"3-文件下载\"><a href=\"#3-文件下载\" class=\"headerlink\" title=\"3. 文件下载\"></a>3. 文件下载</h1><p>很多时候我们想要给读者提供一个小的例程或者说明文档时，会把文件传到网盘上然后分享出来，不过这么做不仅麻烦，而且随时面临文件失效、被移动、修改后要重新上传等问题，所以如果能直接在博客内提供下载会更好。实际上这种静态博客的所有文件都是能下载的，因为其都对应了一个具体的地址，只不过一般我们在文章内放入的，点击链接会跳转到浏览器打开后的界面，我们希望这个链接可以是下载链接的形式，就能用以下方法实现：</p>\n<ol>\n<li>在站点配置文件内找到：</li>\n</ol>\n  <figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>将其改为 <code>true</code> 即可，然后在 <code>blog/source/</code> 下建立一个文件夹（也可以放在已有文件夹内），比如我新建一个 <strong>post_files</strong> 文件夹存放，然后文件放在：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">blog&#x2F;source&#x2F;TestWord.docx</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在文章内需要提供下载的地方这么写即可：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[测试下载 Word](.&#x2F;TestWord.docx)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>测试一下：<a href=\"./TestWord.docx\" title=\"@LINK\">点击下载 Word</a>、<a href=\"./TestExcel.xlsx\" title=\"@LINK\">点击下载 Excel</a></li>\n</ol>\n<p>不过，目前已知 TXT 文本、图片、RTF 富文本、MarkDown 文本等无法提供下载，点击后会直接跳转到浏览器打开文件的界面，建议多个小文件做成压缩包的形式再提供下载，大文件去掉扩展名或先改变扩展名，下载后再改回来。不过，如果去掉文件扩展名，下载下来之后会自动增加一个“dms”扩展名，需要手动改为正确扩展名才可用。</p>\n<hr>\n<h1 id=\"4-更改文章URL路径\"><a href=\"#4-更改文章URL路径\" class=\"headerlink\" title=\"4. 更改文章URL路径\"></a>4. 更改文章URL路径</h1><p>默认情况下，当我们发布了一篇文章后，会发现文章的 URL 路径通常都是类似于：</p>\n<center>\n\n<p><img data-src=\"./url_format_default.png\" alt=\"默认 URL 格式\" title=\"@ASSET\"></p>\n</center>\n\n<p>这种路径格式其实非常不适合作为长期维护的博客页使用，第一，有时分享的时候能记得住标题，但记不住时间，为了分享还要专门再看一次文章地址。第二，如果接入后台、接入分析统计接口等等，一堆文章前面都是日期打头的链接，不仅不方便分类管理，自己也看的头疼。为此，Hexo 其实提供了可以修改默认格式的设置，在站点配置文件里面：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">slliu96.github.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink_defaults:</span></span><br></pre></td></tr></table></figure>\n\n<p>把 <code>permalink</code> 修改为：<code>permalink: :postfrom/:title/</code>，然后在文章内顶部的信息区添加一个 <code>postfrom</code> 属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">基于Hexo的博客DIY（2）——</span> <span class=\"string\">附加功能扩展</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">SLLiu</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019-01-09 11:26:17</span></span><br><span class=\"line\"><span class=\"attr\">postfrom:</span> <span class=\"string\">aaa</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p><code>postfrom</code> 和上面写的取值 <code>aaa</code> 只是示例，都可以自定义，只要站点配置文件内写的属性名和文章内写的属性名一致即可，这样就可以在写每篇文章的时候自定义一个 URL 格式了：</p>\n<center>\n\n<p><img data-src=\"./url_format_custom.png\" alt=\"自定义 URL 格式\" title=\"@ASSET\"></p>\n</center>\n\n<p>当然，也可以直接把格式用固定字符串代替，这样就不用每篇文章都手动加格式了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: postfrom&#x2F;:title&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>这样，每篇文章的 URL 都会是这种格式：<code>xxx.github.io/postfrom/XXXXXXXX</code>。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（5）博客站内本地搜索及相关问题","url":"/post/blogdiy/blogdiy-5-search/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-启用博客搜索\"><a href=\"#1-启用博客搜索\" class=\"headerlink\" title=\"1. 启用博客搜索\"></a>1. 启用博客搜索</h1><p>搜索功能基本在 Next 主题内就有介绍，一个是在线搜索，一个是本地搜索。我个人选择了本地搜索功能，引入也很简单，执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>\n\n<p>并在主题配置文件内找到：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Local search</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class=\"line\"><span class=\"attr\">local_search:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># If auto, trigger search by changing input.</span></span><br><span class=\"line\">  <span class=\"comment\"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class=\"line\">  <span class=\"attr\">trigger:</span> <span class=\"string\">auto</span></span><br><span class=\"line\">  <span class=\"comment\"># Show top n results per article, show all results by setting to -1</span></span><br><span class=\"line\">  <span class=\"attr\">top_n_per_article:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\"># Unescape html strings to the readable one.</span></span><br><span class=\"line\">  <span class=\"attr\">unescape:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>将 <code>enable</code> 设置为 true 即可。</p>\n<hr>\n<h1 id=\"2-搜索无法使用\"><a href=\"#2-搜索无法使用\" class=\"headerlink\" title=\"2. 搜索无法使用\"></a>2. 搜索无法使用</h1><p>在使用搜索功能时，有时可能会遇到：点击搜索后，一直处于加载中的状态，无法正确显示搜索框。其原因可能是以下几点之一导致的：</p>\n<ol>\n<li>如果你是最近才开始建立的这个博客，但在网上查看别人介绍的关于如何开启搜索的文章时间又比较久远，那么可能你照着创建好了以后是搜不到结果的。如果按照之前版本的做法，即使完全照做，建立好本地搜索后，直接从网址进入博客搜索内容载体：<code>xxx.github.io/search.xml</code> 还是会出现 404 页面不存在的情况。</li>\n</ol>\n<p>  按照当时的版本，网上的文章可能会告诉你这代表你的搜索模块没有装成功，让你完全去掉搜索后重新安装再试，不过这个现象很可能是因为以前版本的本地搜索，搜索内容存放载体是 <code>search.xml</code>，而现在的存放载体已经变成了 <code>search.json</code>，可以在站点配置文件内查看到：</p>\n  <figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The following content is not recommended to modify</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索数据文件路径设置，不建议改动：</span></span><br><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.json</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br></pre></td></tr></table></figure>\n\n<p>  同样，你也可以在 Hexo 命令三连之后，在博客根目录下的 public 文件夹内找到这个文件：search.json<br>  3. 如果上面的没有做错，还是出现了无法搜索的情况，那就有可能是因为特殊字符的原因了，对于这个特殊字符：<code>\\u8</code>，会导致本地搜索无法正确读取并编码，如何确定这种问题？就是直接在你的博客首页网址后面接上 <code>/search.json</code> 跳转到搜索载体，如果页面上显示的是很多文字，那就说明你的文章内没有特殊字符：</p>\n  <center>\n\n<p>  <img data-src=\"./search_json_normal.png\" alt=\"正常的 search.json 样式\" title=\"@ASSET\"></p>\n  </center>\n\n<p>  否则会出现报错，由于我无法重现，因此从 <a href=\"https://www.sqlsec.com/2017/12/hexosearch.html\" title=\"@LINK\">这篇文章（作者：国光）</a>内找了一个图片：</p>\n  <center>\n\n<p>  <img data-src=\"./search_json_error.png\" alt=\"有特殊字符的 search.json 样式\" title=\"@ASSET\"></p>\n  </center>\n\n<p>  Sublime Text3 和 VS Code 都可以看到这个字符，因此可以使用这两个编辑器查看并删除字符。</p>\n<hr>\n<h1 id=\"3-搜索没有结果\"><a href=\"#3-搜索没有结果\" class=\"headerlink\" title=\"3. 搜索没有结果\"></a>3. 搜索没有结果</h1><p>还有一种情况，就是已经开启搜索功能，直接进入搜索内容文件 <code>xxx.github.io/search.json</code> 也能打开并且没有异常，搜索框可以正确弹出，但是无论你搜索什么内容，下面的搜索结果栏都是空白的：</p>\n<center>\n\n<p><img data-src=\"./search_error_no_result.png\" alt=\"搜索没有结果\" title=\"@ASSET\"></p>\n</center>\n\n<p>这种情况很可能是因为你有某一篇文章没有标题，比如我的博客置顶的公告栏，我设置的文章类型是“quote”，这就使得这篇文章不会显示标题，但在这篇文章的文件内，title 属性还是必须要写的，因为不会显示所以随便写即可，否则就会导致无法搜索。</p>\n<hr>\n<h1 id=\"4-搜索框无法显示\"><a href=\"#4-搜索框无法显示\" class=\"headerlink\" title=\"4. 搜索框无法显示\"></a>4. 搜索框无法显示</h1><p>有些个性化比较多的博客，应用了大量视觉效果，结果突然发现点击搜索后，博客页面有变暗的效果，但搜索框根本显示不出来（Safari 浏览器），也没有加载中的图标，即使能显示出来（Chrome 浏览器），也无法获取焦点、无法输入文字，就像这样：</p>\n<center>\n\n<p><img data-src=\"./search_error_not_show.png\" alt=\"无法显示搜索框\" title=\"@ASSET\"></p>\n</center>\n\n<p>出现这个情况的，很可能博客个性化比较丰富，如果目前还没遇到可以跳过，在系列后面一篇关于背景 DIY 的文章会再讲到这个问题。</p>\n<p>先说原因：很大可能是因为自己调整了博客整体的透明度，也就是修改了这个文件：<code>next/source/css/_custom/custom.styl</code> 添加这一段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改主体透明度</span></span><br><span class=\"line\">.main-inner &#123;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改侧栏透明度</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网上有不少 DIY 的文章里面都有提到，给博客加了一个自定义的背景图片以后，为了让博客具有一定的半透明效果给整体设置一个透明度，这么设置其实没有什么错，但是！由于 Next 主题中，搜索是基于固定侧栏（也就是 header-inner）的一个弹窗 Popup，而 <code>opacity</code> 这个属性设置的是整个界面控件的不透明度，所以会导致弹窗的绘制在后，使得弹窗被覆盖在了博客显示界面的底下。要解决这个问题，无非就是去掉 <code>opacity</code> 属性（或者把值设为1）或者禁用搜索，但如果既想保留搜索功能还想要带点不透明度（比如我目前这个博客）怎么办？其实也很简单，曲线救国：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意修改的是 header-inner 部分</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  background: #ddddddcc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把设置改成这样即可！单独调整博客界面控件的填充背景，其中这个 RGB 颜色值的前六位 <code>#dddddd</code> 表示的是背景颜色（也就是整个博客主体背景包括文章的底色），这个可以随便自定义，后面的两位 <code>cc</code> 代表的是不透明度，也可以随便定义。由于这个 RGB 色是 16 进制色，所以颜色和不透明度都要用 16 进制来表示，完全不透明是 <code>ff</code>，完全透明是 <code>00</code>，不透明度 0.8 也就是 16 进制里面的 <code>cc</code>。这么设置以后，就能同时保留搜索和背景半透明了。如果想调整透明度又不太熟悉 16 进制的，可以这么计算：<code>ff</code> 对应的 10 进制数值为 255，想要多少透明度（比如 0.8），就用 <code>255 x 0.8 = 204</code>，再从 10 进制转换为 16 进制（网上很多工具）即可得到：<code>204(x10) = cc(x16)</code>。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（6）动态头像与动态浏览器标题","url":"/post/blogdiy/blogdiy-6-avatar-title/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-侧栏头像动画\"><a href=\"#1-侧栏头像动画\" class=\"headerlink\" title=\"1. 侧栏头像动画\"></a>1. 侧栏头像动画</h1><p>先从简单的开始吧！修改头像其实很简单，直接把头像放进 <code>next/source/images/</code> 下，然后再主题配置文件中，找到以下部分：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar Avatar</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span></span><br><span class=\"line\">  <span class=\"comment\"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class=\"line\">  <span class=\"comment\"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class=\"line\">  <span class=\"comment\"># You can also use other linking images.</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"string\">/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar would be dispalyed in circle.</span></span><br><span class=\"line\">  <span class=\"attr\">rounded:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class=\"line\">  <span class=\"attr\">opacity:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar would be rotated with the cursor.</span></span><br><span class=\"line\">  <span class=\"attr\">rotated:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>url</code> 处指定头像文件即可，头像可以是网络图片，只需要把本地路径替换为网络图片的网址即可。另外，当打开了 <code>rotated</code> 后，鼠标移到头像处会逆时针旋转半圈，鼠标移开又转回来，不过这个效果看起来好像也比较普通，如果你想让鼠标一过去头像就控记不住记几鬼畜疯狂旋转，就像这样：</p>\n<center>\n\n<p><img data-src=\"./avatar_rotate_hover.gif\" alt=\"鼠标覆盖头像鬼畜式旋转\" title=\"@ASSET\"></p>\n</center>\n\n<p>请找到这个文件并愤怒地打开它：<code>/next/source/css/_common/components/sidebar/sidebar-author.styl</code>，然后找到如下部分修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    transition: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">    <span class=\"comment\">/*animation: rotate 5s linear infinite;*/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*@keyframes rotate&#123;from&#123;transform: rotate(0deg)&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  to&#123;transform: rotate(360deg)&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 原本只是简单地逆时针旋转 180°</span></span><br><span class=\"line\"><span class=\"comment\">  .site-author-image:hover &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    transform: rotateZ(-180deg);</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    animation: rotate <span class=\"number\">0.</span>15s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @keyframes rotate&#123;<span class=\"keyword\">from</span>&#123;<span class=\"attr\">transform</span>: rotate(0deg)&#125;</span><br><span class=\"line\">  to&#123;<span class=\"attr\">transform</span>: rotate(360deg)&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.site-author-image:hover</code> 就是鼠标覆盖上去时的代码，代码的意思就是：动画是 rotate，时间是 0.15 秒（也即 0.15 秒转一圈），动画速度是线性，动画重复无限次，在下方定义了旋转的角度是从 0 ~ 360°，其中正数是顺时针旋转，负数是逆时针旋转。设置完了以后别忘了 Hexo 三连一下试试效果。如果你不想这么鬼畜，想走文艺路线，就换一下注释并且让它转的缓慢一点唱片式旋转，变成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    transition: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">    animation: rotate 5s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @keyframes rotate&#123;<span class=\"keyword\">from</span>&#123;<span class=\"attr\">transform</span>: rotate(0deg)&#125;</span><br><span class=\"line\">  to&#123;<span class=\"attr\">transform</span>: rotate(360deg)&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*animation: rotate 0.15s linear infinite;*/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*@keyframes rotate&#123;from&#123;transform: rotate(0deg)&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  to&#123;transform: rotate(360deg)&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<center>\n\n<p><img data-src=\"./avatar_rotate_normal.gif\" alt=\"文艺风头像唱片式旋转\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-浏览器标签页动态标题\"><a href=\"#2-浏览器标签页动态标题\" class=\"headerlink\" title=\"2. 浏览器标签页动态标题\"></a>2. 浏览器标签页动态标题</h1><p>先看看效果：</p>\n<center>\n\n<p><img data-src=\"./animate_browser_title.gif\" alt=\"浏览器标签页动态标题\" title=\"@ASSET\"></p>\n</center>\n\n<p>首先在 <code>next/source/custom/</code> 下找一个地方新建一个 animator_title.js 文件（路径和文件名均可自定义），输入以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--动态浏览器标签--&gt;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> OriginTitle = <span class=\"built_in\">document</span>.title;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> titleTime;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> titleTime2;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> titleTime3;</span><br><span class=\"line\"> <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;visibilitychange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.hidden) &#123;</span><br><span class=\"line\">         $(<span class=\"string\">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).attr(<span class=\"string\">&#x27;href&#x27;</span>, <span class=\"string\">&quot;/images/favicon-32x32-next.png&quot;</span>);</span><br><span class=\"line\">         <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Waiting...&quot;</span>;</span><br><span class=\"line\">         <span class=\"built_in\">clearTimeout</span>(titleTime);</span><br><span class=\"line\">         <span class=\"built_in\">clearTimeout</span>(titleTime2);</span><br><span class=\"line\">         <span class=\"built_in\">clearTimeout</span>(titleTime3);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome&quot;</span>;</span><br><span class=\"line\">         titleTime = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Back&quot;</span>;</span><br><span class=\"line\">             titleTime2 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                 <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome Back !&quot;</span>;</span><br><span class=\"line\">                 titleTime3 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                     <span class=\"built_in\">document</span>.title = OriginTitle;</span><br><span class=\"line\">                 &#125;, <span class=\"number\">800</span>);</span><br><span class=\"line\">             &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">         &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后打开 <code>next/layout/_layout.swig</code> ，在最底下定格加入如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span> src=<span class=\"string\">&quot;/custom/animator_title.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体的文件名和路径请按照自己的实际情况修改。其实我这个效果做的太 Low 了，从别的网页切回来就是三个定时器的嵌套，不知道有没有办法可以重用定时器，还望大佬指明。</p>\n<p>另外，<code>icon</code> 处可以自定义一个小图像，可以是本地图像也可以是网络图片。不过需要注意的是，这里如果选择本地图片，“/”表示的就不是博客根目录了，而是主题根目录，所以“/images/”其实和“blog/themes/next/images/”是等价的。同理，在主题配置文件中的 <code>favicon</code> 选项设置的也是浏览器标签页小图标，指定的路径也是以主题根目录为起始路径的。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n<hr>\n<h1 id=\"3-附录-参考指导\"><a href=\"#3-附录-参考指导\" class=\"headerlink\" title=\"3. 附录[参考指导]\"></a>3. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://asdfv1929.github.io/2018/01/25/crash-cheat/\" title=\"@LINK\">【1】Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效（作者：asdfv1929）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（8）博客各部分背景设置","url":"/post/blogdiy/blogdiy-8-background/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-站点背景图\"><a href=\"#1-站点背景图\" class=\"headerlink\" title=\"1. 站点背景图\"></a>1. 站点背景图</h1><p>先从最容易看到的开始，站点背景是内置支持的一个功能，只需要修改：<code>/next/source/css/_custom/custom.styl</code> 并增加代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom styles.</span></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  background: url(<span class=\"regexp\">/images/</span>site-back.jpg);</span><br><span class=\"line\">  background-repeat: no-repeat;</span><br><span class=\"line\">  background-attachment: fixed;</span><br><span class=\"line\">  background-position: <span class=\"number\">100</span>% <span class=\"number\">25</span>%;</span><br><span class=\"line\">  background-size: cover;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>next/source/images/</code> 下放入自己的图片（具体路径和图片名称可以自定义，但这里的路径是从主体根目录开始的）即可。</p>\n<ol>\n<li><code>no-repeat</code> 是当你的图片小于显示大小时，是否通过重复图片铺满</li>\n<li><code>position</code> 可以自行指定背景图片的左右、上下位移距离</li>\n<li><code>size</code> 选择 <code>cover</code> 也即按比例拉伸铺满背景</li>\n</ol>\n<p>效果参考我的博客背景，更多详细设置可以参考 Next 的文档。</p>\n<hr>\n<h1 id=\"2-修改博客内容背景色\"><a href=\"#2-修改博客内容背景色\" class=\"headerlink\" title=\"2. 修改博客内容背景色\"></a>2. 修改博客内容背景色</h1><p>默认情况下，博客显示文章、文章列表、分类、标签、归档等等页面时，文字的底色就是白色，这其实不仅不美观，看久了还觉得累眼睛：</p>\n<center>\n\n<p><img data-src=\"./background_default.png\" alt=\"默认背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>为了避免这种白底黑字的视觉效果，可以在 <code>/next/source/css/_schemes/Gemini/index.styl</code> 内找到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Post &amp; Comments blocks.</span></span><br><span class=\"line\">.post-block &#123;</span><br><span class=\"line\">  padding: $content-desktop-padding;</span><br><span class=\"line\">  background: #ddd;  <span class=\"comment\">// 修改这里的颜色</span></span><br><span class=\"line\">  box-shadow: $box-shadow-inner;</span><br><span class=\"line\">  border-radius: $border-radius-inner;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>background</code> 默认的白色 white 修改为自定义颜色即可，我自己用的是 <code>#ddd</code>。此外，通常还会选择加一点透明度，网上比较大众的做法就是在 <code>/next/source/css/_custom/custom.styl</code> 内增加一段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.main-inner &#123;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样加上了透明效果，看起来好多了！不会再像白底黑字一样过于刺眼，效果如下：</p>\n<center>\n\n<p><img data-src=\"./main_background_custom.png\" alt=\"优化主体背景\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"3-修改侧栏背景\"><a href=\"#3-修改侧栏背景\" class=\"headerlink\" title=\"3. 修改侧栏背景\"></a>3. 修改侧栏背景</h1><h2 id=\"3-1-修改主侧栏背景\"><a href=\"#3-1-修改主侧栏背景\" class=\"headerlink\" title=\"3.1 修改主侧栏背景\"></a>3.1 修改主侧栏背景</h2><p>前两部分别自定义了背景和主体背景/透明度之后，会发现对显示“首页、分类、标签…”的这个侧栏并不生效，原因是这个侧栏属于单独的控件 <code>header-inner</code>，所以只需要在 <code>/next/source/css/_custom/custom.styl</code> 内加上这么一段即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 也可以同时定义背景色</span></span><br><span class=\"line\">  <span class=\"comment\">// background: #ddd</span></span><br><span class=\"line\"></span><br><span class=\"line\">  opacity: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>确实，可以改变主侧栏的显示透明度，不过这也会带来一个问题：搜索框不显示，或者只能透出一点点但无法输入也无法获取焦点，这个问题以及解决方案在：<a href=\"/post/BlogDIY/blogdiy-5-search/blogdiy-5-search/\" title=\"@LINK\">Hexo博客DIY（5）博客站内本地搜索及相关问题</a>中的第 4 点有详细介绍，可以参考一下。简单来说就是把这个透明度改为单独的带有透明效果的 RGB 主体底色：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 颜色可自定义</span></span><br><span class=\"line\">  background: #ddddddcc</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 直接设置透明度会导致搜索窗弹不出来</span></span><br><span class=\"line\">  <span class=\"comment\">// opacity: 0.8;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<center>\n\n<p><img data-src=\"./activate_menu_default.png\" alt=\"默认高亮菜单背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>颜色的选择可以和主体底色一致，看起来比较和谐。不过还有一个地方就是主侧栏上的不同菜单，已被选定的、鼠标悬停的高亮菜单颜色还是白底，修改的文件在 <code>themes/next/source/css/_schemes/Pisces/_menu.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.menu-item-active a &#123;</span><br><span class=\"line\">  background: #ddddddcc;  <span class=\"comment\">// 修改这里</span></span><br><span class=\"line\">  border-bottom-color: white;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改完的效果：</p>\n<center>\n\n<p><img data-src=\"./activate_menu_custom.png\" alt=\"自定义高亮菜单背景\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"3-2-修改浮动侧栏背景\"><a href=\"#3-2-修改浮动侧栏背景\" class=\"headerlink\" title=\"3.2 修改浮动侧栏背景\"></a>3.2 修改浮动侧栏背景</h2><p>同样，浮动侧栏（阅读文章时显示目录的侧栏）的背景色默认也是白色：</p>\n<center>\n\n<p><img data-src=\"./sidebar_background_default.png\" alt=\"浮动侧栏默认背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>可在 <code>/next/source/css/_schemes/Pisces/_sidebar.styl</code> 中修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.sidebar-inner &#123;</span><br><span class=\"line\">  <span class=\"comment\">//padding: 20px 10px 0;</span></span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">  width: $sidebar-desktop;</span><br><span class=\"line\">  color: $text-color;</span><br><span class=\"line\">  background: #ddd;  <span class=\"comment\">// 修改这里</span></span><br><span class=\"line\">  box-shadow: $box-shadow;</span><br><span class=\"line\">  border-radius: $border-radius;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我把 <code>background</code> 默认的 white 同样改为了 <code>#ddd</code>，理论上也可以直接在 custom.styl 内修改，不过还没尝试过，效果如下：</p>\n<center>\n\n<p><img data-src=\"./sidebar_background_custom.png\" alt=\"浮动侧栏自定义背景\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"4-修改“阅读全文”按钮背景\"><a href=\"#4-修改“阅读全文”按钮背景\" class=\"headerlink\" title=\"4. 修改“阅读全文”按钮背景\"></a>4. 修改“阅读全文”按钮背景</h1><p>在修改完前面几个背景之后，还有一个问题，就是“阅读全文”这个按钮的颜色还是原来的白底黑字，和文章底色相比显得有些突兀：</p>\n<center>\n\n<p><img data-src=\"./button_background_default.png\" alt=\"“阅读全文”按钮默认背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>修改这个按钮在 <code>/next/source/css/_common/components/buttons.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.btn &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  padding: <span class=\"number\">0</span> 20px;</span><br><span class=\"line\">  font-size: $btn-<span class=\"keyword\">default</span>-font-size;</span><br><span class=\"line\">  color: $btn-<span class=\"keyword\">default</span>-color;</span><br><span class=\"line\">  background: #ddd;  <span class=\"comment\">// 修改这里</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样改为了 <code>#ddd</code>，同理下面的代码还可以修改鼠标覆盖时的效果、大小、表框、内距外距等，修改效果如下：</p>\n<center>\n\n<p><img data-src=\"./button_background_custom.png\" alt=\"阅读全文按钮自定义背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>。如果想要修改全局颜色，可以在 <code>/next/source/css/_variables/base.styl</code> 中查找到对应全局颜色并修改。当然这个文件里面除了颜色外，还有一些角度、尺寸等等都是全局性的。</p>\n<hr>\n<h1 id=\"5-修改评论区背景\"><a href=\"#5-修改评论区背景\" class=\"headerlink\" title=\"5. 修改评论区背景\"></a>5. 修改评论区背景</h1><p>评论区和博客文章、主体区是两个部分，评论区的背景需要单独设置，在 <code>/next/source/css/_schemes/Gemini/index.styl</code> 中修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Comments blocks.</span></span><br><span class=\"line\">.comments &#123;</span><br><span class=\"line\">  padding: $content-desktop-padding;</span><br><span class=\"line\">  margin: auto;</span><br><span class=\"line\">  margin-top: $sidebar-offset;</span><br><span class=\"line\">  background: #ddd;  <span class=\"comment\">// 修改这里</span></span><br><span class=\"line\">  box-shadow: $box-shadow;</span><br><span class=\"line\">  border-radius: $border-radius;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改成和文章主体同样的 <code>#ddd</code>，效果如下：</p>\n<center>\n\n<p><img data-src=\"./comment_background_custom.png\" alt=\"评论区自定义背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>看起来舒服多了！</p>\n<hr>\n<h1 id=\"6-修改博客顶部横条背景\"><a href=\"#6-修改博客顶部横条背景\" class=\"headerlink\" title=\"6. 修改博客顶部横条背景\"></a>6. 修改博客顶部横条背景</h1><p>在默认情况下，站点的顶端其实有一个横条，横条默认是和菜单颜色一致的，平时可能看不出来，但是如果把页面拉到顶端再往上拉一点（可能用鼠标滚轮无法显示，用笔记本的触控板可以）就会看到有这么一个条：</p>\n<center>\n\n<p><img data-src=\"./header_ban_default.png\" alt=\"顶部横条\" title=\"@ASSET\"></p>\n</center>\n\n<p>在普通情况下，当页面拉到顶端时，这个条使得主侧栏和主体部分和页面顶端有一个连接的感觉，会导致感觉上顶部的圆角有点违和：</p>\n<center>\n\n<p><img data-src=\"./header_band_not_fit.png\" alt=\"顶部横条默认样式\" title=\"@ASSET\"></p>\n</center>\n\n<p>为了去掉这个条，但又使得顶部能空出一小段距离，可以在 <code>next/source/css/_common/components/header/headerband.styl</code> 中修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.headband &#123;</span><br><span class=\"line\">  height: 10px;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">  background: transparent;  <span class=\"comment\">// 颜色</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，主页文章之间的间隔大概在 10 ~ 15 左右，因此我把宽度设置为 10，并且把颜色设置为透明，效果如下：</p>\n<center>\n\n<p><img data-src=\"./header_band_fit.png\" alt=\"顶部横条自定义样式\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"7-修改过渡动画速度\"><a href=\"#7-修改过渡动画速度\" class=\"headerlink\" title=\"7. 修改过渡动画速度\"></a>7. 修改过渡动画速度</h1><p>默认的过渡动画其实挺慢的，每次载入的时候都觉得等了很久，尤其是有时候找文章或者需要来回切换页面的时候，每次都要等一会儿页面才加载进来的感觉特别不爽，于是找了一下源码，发现动画速度是由这个文件控制的：<code>next/source/js/motion.js</code>，打开并修改其中 <code>duration</code> 字段的值，根据自己的喜好修改即可，我自己用的方案如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">showSidebar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.sidebarEl.velocity(<span class=\"string\">&#x27;stop&#x27;</span>).velocity(&#123;</span><br><span class=\"line\">        width: SIDEBAR_WIDTH</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里维持原状</span></span><br><span class=\"line\">        duration: SIDEBAR_DISPLAY_DURATION,</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMistLineSettings</span>(<span class=\"params\">element, translateX</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          e: $(element),</span><br><span class=\"line\">          p: &#123;<span class=\"attr\">translateX</span>: translateX&#125;,</span><br><span class=\"line\">          o: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里修改为 200</span></span><br><span class=\"line\">            duration     : <span class=\"number\">200</span>,</span><br><span class=\"line\">            sequenceQueue: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">menu: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">integrator</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      ......</span><br><span class=\"line\"></span><br><span class=\"line\">      $(<span class=\"string\">&#x27;.menu-item&#x27;</span>).velocity(<span class=\"string\">&#x27;transition.slideDownIn&#x27;</span>, &#123;</span><br><span class=\"line\">        display : <span class=\"literal\">null</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 这里也维持原状</span></span><br><span class=\"line\">        duration: <span class=\"number\">200</span>,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>除了以上标明的三处之外，其他的 <code>duration</code> 字段都设置成 80。</p>\n<hr>\n<h1 id=\"8-菜单栏小标背景\"><a href=\"#8-菜单栏小标背景\" class=\"headerlink\" title=\"8. 菜单栏小标背景\"></a>8. 菜单栏小标背景</h1><p>菜单栏的分类、标签、归档等有一个小标记：</p>\n<center>\n\n<p><img data-src=\"./menu_badges.png\" alt=\"菜单栏小标记\" title=\"@ASSET\"></p>\n</center>\n\n<p>这个效果是在站点配置文件中开启 <code>badges</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Enable / Disable menu icons / item badges.</span></span><br><span class=\"line\"><span class=\"attr\">menu_settings:</span></span><br><span class=\"line\">  <span class=\"attr\">icons:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">badges:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>相关背景设置修改 <code>next/source/css/_schemes/Pisces/_menu.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.badge &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  padding: 2px 6px;</span><br><span class=\"line\">  font-weight: <span class=\"number\">500</span>;</span><br><span class=\"line\">  line-height: <span class=\"number\">1</span>;</span><br><span class=\"line\">  color: #777;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">  background-color: $grey-light;</span><br><span class=\"line\">  border-radius: 10px;</span><br><span class=\"line\">  float: right;</span><br><span class=\"line\">  margin: <span class=\"number\">0.</span>35em <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  text-shadow: 1px 1px 0px rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（9）侧栏个人链接居中","url":"/post/blogdiy/blogdiy-9-sidebar/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-浮动侧栏个人链接居中\"><a href=\"#1-浮动侧栏个人链接居中\" class=\"headerlink\" title=\"1. 浮动侧栏个人链接居中\"></a>1. 浮动侧栏个人链接居中</h1><p>默认情况下，侧栏中个人信息的链接是这样的：</p>\n<center>\n\n<p><img data-src=\"./sidebar_author_links_default.png\" alt=\"默认背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>上下都是中心对称，偏偏只有个人链接这块是左对齐的，强迫症简直不能忍啊！这里的链接其实是每行两个，倒是可以直接设置为居中显示，不过因为每个链接的长度都不一样，如果直接设置居中会导致每行的图标的位置很可能是错开的。所以其实我想要的 <strong>居中</strong> 只是把现在这样整体往右移一点，这块对应的样式文件在：<code>next/source/css/_common/components/sidebar/sidebar-author-links.styl</code>，可以这么修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.links-<span class=\"keyword\">of</span>-author &#123;</span><br><span class=\"line\">  margin-top: 20px;</span><br><span class=\"line\"></span><br><span class=\"line\">  a, span.exturl &#123;</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: middle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除下面的两行：</span></span><br><span class=\"line\">    <span class=\"comment\">// margin-right: 10px;</span></span><br><span class=\"line\">    <span class=\"comment\">// margin-bottom: 10px;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入下面两行：</span></span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    left: <span class=\"number\">18</span>%</span><br><span class=\"line\"></span><br><span class=\"line\">    border-bottom-color: $black-light;</span><br><span class=\"line\">    font-size: 13px;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;social_icons.transition&#x27;</span></span>)</span> &#123; the-transition(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>left: 18%</code> 表示左侧位移 18%，这个值只是我自己肉眼看出来的大致值，应当根据自己的链接的长度手动调整。修改后的效果如下：</p>\n<center>\n\n<p><img data-src=\"./sidebar_author_links_custom.png\" alt=\"默认背景\" title=\"@ASSET\"></p>\n</center>\n\n<p>确实是笨方法，不过目前还没找到用什么更好的办法去实现，留着以后有更好的办法时再更新。</p>\n<hr>\n<h1 id=\"2-修改标签页词云样式\"><a href=\"#2-修改标签页词云样式\" class=\"headerlink\" title=\"2. 修改标签页词云样式\"></a>2. 修改标签页词云样式</h1><p>标签词云样式在之前的文章：<a href=\"/post/BlogDIY/blogdiy-2-extension/blogdiy-2-extension/\" title=\"@LINK\">Hexo博客DIY（2）内置的小功能扩展</a>中的第 2 条有介绍，不过那篇主要是介绍如何给词云显示出更丰富的效果。这里小小的记录一下，标签页词云的布局修改，比如不同标签之间的间隔之类的，样式文件在 <code>next/source/css/_common/components/pages/tag-cloud.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.tag-cloud &#123;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\"></span><br><span class=\"line\">  a &#123;</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    margin: 10px <span class=\"number\">0</span> 20px 20px;  <span class=\"comment\">// 修改间距</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  a:hover &#123;</span><br><span class=\"line\">    color: $link-hover-color !important;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的边距顺序是：上、右、下、左，除了边距外，其他样式也可以按照需要自行修改。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（X）其他DIY收录","url":"/post/blogdiy/blogdiy-x-others/","content":"<span id=\"more\"></span>\n\n<p>前言：收录了一些有趣、实用的 DIY。这些收录大部分是我的博客没有用上的，所以不太好给出明确的展示效果。引文原文大多数都有配图、或已部署到他们的博客上了，因此引出原文链接给各位读者查看，为保护版权就不作转载了，建议放到系列文章的最后再研究。</p>\n<hr>\n<p>大部分我的博客用到过、或曾用到过的 DIY 都已记录在了 <a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a> 中，还有一些虽然我的博客没有用上，但看起来还是比较实用的功能、文章，都记录在这里供可能需要的读者查阅。</p>\n<h1 id=\"MarkDown格式\"><a href=\"#MarkDown格式\" class=\"headerlink\" title=\"MarkDown格式\"></a>MarkDown格式</h1><p>详情参考：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/e989689a331d\" title=\"@LINK\">Markdown通用的常用语法说明（作者：seay）</a></li>\n<li><a href=\"https://www.jianshu.com/p/d60b844d3ba5\" title=\"@LINK\">简书 Markdown 常用数学符号汇总（作者：拓季）</a></li>\n<li><a href=\"https://blog.csdn.net/xingxinmanong/article/details/78528791\" title=\"@LINK\">【Markdown】markdown 输入数学符号（作者：xingxinmanong）</a></li>\n</ul>\n<p>包括基本 MarkDown 语法，和数学公式的语法。经常需要写数学公式的话，还是需要多看看多背背。</p>\n<hr>\n<h1 id=\"文章加密\"><a href=\"#文章加密\" class=\"headerlink\" title=\"文章加密\"></a>文章加密</h1><p>详情参考：<a href=\"https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md\" title=\"@LINK\">hexo-blog-encrypt（作者：MikeCoder）</a></p>\n<hr>\n<h1 id=\"点击爱心特效\"><a href=\"#点击爱心特效\" class=\"headerlink\" title=\"点击爱心特效\"></a>点击爱心特效</h1><p>详情参考：<a href=\"https://asdfv1929.github.io/2018/01/26/click-love/\" title=\"@LINK\">Hexo NexT主题添加点击爱心效果（作者：asdfv1929）</a></p>\n<p>不过这个特效会导致双击选中、三击选中整行失效，所以没有引入。</p>\n<hr>\n<h1 id=\"博客加载进度条\"><a href=\"#博客加载进度条\" class=\"headerlink\" title=\"博客加载进度条\"></a>博客加载进度条</h1><p>详情参考：<a href=\"https://blog.csdn.net/u011236348/article/details/88146947\" title=\"@LINK\">Hexo博客NexT主题美化之顶部加载进度条（作者：潘高）</a></p>\n<p>效果有很多种，而且作者很有心为每种效果都配了动图，我的博客为了协调性把进度条去掉了所以没有使用。</p>\n<hr>\n<h1 id=\"自定义右上角GitHub标志\"><a href=\"#自定义右上角GitHub标志\" class=\"headerlink\" title=\"自定义右上角GitHub标志\"></a>自定义右上角GitHub标志</h1><p>详情参考：<a href=\"http://tholman.com/github-corners/\" title=\"@LINK\">GitHub Corners</a></p>\n<p>这个随便找一个下载下来，都可以通过里面的颜色配置实现更高的自定义效果，Anyway，默认的黑白配就挺适合我这个码畜哈哈。</p>\n<hr>\n<h1 id=\"侧栏添加“系列”标签\"><a href=\"#侧栏添加“系列”标签\" class=\"headerlink\" title=\"侧栏添加“系列”标签\"></a>侧栏添加“系列”标签</h1><p>详情参考：<a href=\"http://baijiahao.baidu.com/s?id=1604123889806467436&wfr=spider&for=pc\" title=\"@LINK\">给hexo博客添加系列文章功能（作者：hojun）</a></p>\n<p>或者比较简单的做法：<a href=\"https://www.zhihu.com/question/33324071/answer/58775540\" title=\"@LINK\">hexo下新建页面下如何放多个文章？（答主：匿名用户）</a></p>\n<p>前者是通过增加一个自定义文章头部标签，然后在生成的时候添加一个遍历所有文章识别来实现的，需要对 JS 做修改，后者是直接通过“分类”功能实现的，更简单一些。前者稍微更符合要求一点，不过显示效果都没有太大差别，可以自由选择。</p>\n<hr>\n<h1 id=\"HexoEditor\"><a href=\"#HexoEditor\" class=\"headerlink\" title=\"HexoEditor\"></a>HexoEditor</h1><p>详情参考：<a href=\"https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md\" title=\"@LINK\">HexoEditor</a></p>\n<p>HexoEditor 是 GitHub 上一款专门为 Hexo 优化的开源 MarkDown 编辑器，基本上可以实现“所看即所得”，编写时的预览效果和最终博客上的展示效果几乎一致</p>\n<hr>\n<h1 id=\"MathJax公式支持\"><a href=\"#MathJax公式支持\" class=\"headerlink\" title=\"MathJax公式支持\"></a>MathJax公式支持</h1><p>详情参考：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/d95a4795f3a8\" title=\"@LINK\">Hexo 安装 LaTeX</a></li>\n<li><a href=\"https://ihaoming.top/archives/171023e7.html#more\" title=\"@LINK\">MathJax语法</a></li>\n<li><a href=\"https://qianwenma.cn/2018/05/17/mathjax-yu-fa-can-kao/\" title=\"@LINK\">MathJax 语法参考</a></li>\n<li><a href=\"https://blog.csdn.net/ethmery/article/details/50670297\" title=\"@LINK\">基本数学公式语法(of MathJax)</a></li>\n</ul>\n<p>包括安装部署 MathJax，以及 LaTeX 公式的语法合集。</p>\n<p>还有一篇专门针对 Hexo 和 MathJax 不兼容问题的文章写得非常详细：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000007261752\" title=\"@LINK\">Hexo下mathjax的转义问题</a></li>\n</ul>\n<p>另外补充一点，目前网上普遍的做法是更换渲染引擎，老版本的 Hexo 尚不清楚，不过目前我使用的 <code>hexo: 3.9.0</code> <code>hexo-cli: 2.0.0</code> 原生渲染引擎 <code>hexo-renderer-marked</code> 已经支持 LaTeX 了，如果更换为 <code>hexo-renderer-kramed</code>，会遇到的一个很 X 蛋的事是和各种 Html 标签冲突，比如 <code>&lt;center&gt;</code> 之类的，甚至 MarkDown 的原生图片语法 <code>![]()</code> 都会被转义，通常还会建议修改渲染的语法，跳过指定的符号，但总体就我个人的体验下来，似乎现在的 <code>kramed</code> 并没有原生 <code>marked</code> 好用，也可能我没有把 <code>kramed</code> 的语法改正确，不过为此找到了一个折中的方式：直接使用默认的 <code>marked</code> 引擎，但同样修改 marked 的语法文件，默认在：<code>Blog/node_modules/marked/lib/marked.js</code>，如果有手动另外安装过 marked，则修改：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked/lib/marked.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inline = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//escape: /^\\\\([!&quot;#$%&amp;&#x27;()*+,\\-./:;&lt;=&gt;?@\\[\\]\\\\^_`&#123;|&#125;~])/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  <span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//em: /^_([^\\s_])_(?!_)|^\\*([^\\s*&lt;\\[])\\*(?!\\*)|^_([^\\s&lt;][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_&lt;][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s&lt;&quot;][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*&quot;&lt;\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>即可达到同样的效果，同时也不会导致标签冲突。详细的准备再另写一文。</p>\n<hr>\n<h1 id=\"自定义域名\"><a href=\"#自定义域名\" class=\"headerlink\" title=\"自定义域名\"></a>自定义域名</h1><p>详情参考：<a href=\"https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider\" title=\"@LINK\">Setting up an apex domain</a></p>\n<p>自定义域名也是蛮有意思的，也考虑专门拿一篇来写。</p>\n<hr>\n<h1 id=\"自定义文字块\"><a href=\"#自定义文字块\" class=\"headerlink\" title=\"自定义文字块\"></a>自定义文字块</h1><p>详情参考：<a href=\"https://bestzuo.cn/posts/3147047336.html\" title=\"@LINK\">Note 标签</a></p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Android面试题汇总","url":"/post/interview/interview-android/","content":"<span id=\"more\"></span>\n\n<p>前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。</p>\n<hr>\n<h1 id=\"四大组件\"><a href=\"#四大组件\" class=\"headerlink\" title=\"四大组件\"></a>四大组件</h1><ul>\n<li><a href=\"/post/android/android-activity/android-activity/\" title=\"@LINK\">Activity</a></li>\n<li><a href=\"/post/android/android-service/android-service/\" title=\"@LINK\">Service</a></li>\n<li><a href=\"/post/android/android-broadcastreceiver/android-broadcastreceiver/\" title=\"@LINK\">BroadcastReceiver</a></li>\n<li><a href=\"/post/android/android-contentprovider/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n</ul>\n<h2 id=\"Service保活\"><a href=\"#Service保活\" class=\"headerlink\" title=\"- Service保活\"></a>- Service保活</h2><p>从 Android 8 开始，Google 针对资源控制限制了后台服务，不允许后台应用启动后台服务（<code>startService</code>），只能通过 <code>startForgroundService</code> 启动前台服务。启动 Service 后，会在内部调用 <code>ActivityServices.setServiceForegroundInnerLocked()</code> 创建一个 5s 的定时任务，必须在 5s 内调用 <code>startForeground()</code>，其内部设置了 <code>fgRequired = false;</code>，<code>setServiceForegroundInnerLocked()</code> 内部判断 <code>fgRequired == false</code> 说明已经安全处理，否则会抛出 ANR。通常在 <code>onStartCommand()</code> 中调用 <code>startForeground()</code>。并且，如果 <code>foreground</code> 的 <code>notification == null</code> 或 <code>id == 0</code> 都会抛出 <code>null notification</code> 异常，因此启动前台服务一定会创建一个通知提醒用户。</p>\n<p>而想要Service保活，可以由某个前台 Activity 启动 Service，且 <code>onStartCommand()</code> 返回值为 <code>return START_STICKY;</code>，当 Activity 转至后台，则 Service 在 1 分钟左右就会被系统杀死，并回调 <code>onDestroy()</code> 方法，可以在该方法中，启动一个新的 Activity，并在新的 <code>Activity.onCreate()</code> 中将当前 Activity 设置为只有一个像素大小的透明的背景（<code>getWindow</code>，<code>window.setGravity</code>，<code>params = window.getAttributes</code>，<code>params.x</code>，<code>params.y</code>，p<code>arams.width</code>，<code>params.height</code>，<code>window.setAttributes(params)</code>），并且设置（<code>getwindow().addFlags()</code>）不可点击（<code>WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE</code>）以及不关心外部触摸事件（<code>WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH</code>），然后再在该 Activity 中启动 Service 并 finish 掉自己。</p>\n<p>另外还有一种常见的做法，是同族、同系列的应用，可以相互唤醒。</p>\n<hr>\n<h1 id=\"五大存储\"><a href=\"#五大存储\" class=\"headerlink\" title=\"五大存储\"></a>五大存储</h1><ul>\n<li><a href=\"/post/android/android-sharedpreference/android-sharedpreference/\" title=\"@LINK\">SharedPreferences</a></li>\n<li><a href=\"/post/android/android-sqlite/android-sqlite/\" title=\"@LINK\">SQLite</a></li>\n<li>文件存储</li>\n<li>网络存储</li>\n<li><a href=\"/post/android/android-contentprovider/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n</ul>\n<hr>\n<h1 id=\"六大布局\"><a href=\"#六大布局\" class=\"headerlink\" title=\"六大布局\"></a>六大布局</h1><ul>\n<li>LinearLayout</li>\n<li>RelativeLayout</li>\n<li>FrameLayout</li>\n<li>GridLayout</li>\n<li>TableLayout</li>\n<li>AbsoluteLayout</li>\n</ul>\n<hr>\n<h1 id=\"其他组件\"><a href=\"#其他组件\" class=\"headerlink\" title=\"其他组件\"></a>其他组件</h1><h2 id=\"Fragment生命周期及回调\"><a href=\"#Fragment生命周期及回调\" class=\"headerlink\" title=\"- Fragment生命周期及回调\"></a>- Fragment生命周期及回调</h2><hr>\n<h1 id=\"Android消息处理机制\"><a href=\"#Android消息处理机制\" class=\"headerlink\" title=\"Android消息处理机制\"></a>Android消息处理机制</h1><p><a href=\"/post/android/android-message-handling/android-message-handling/\" title=\"TOOINKS\">Android-消息处理机制</a></p>\n<hr>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><ul>\n<li>AIDL</li>\n<li>Socket</li>\n<li><a href=\"/post/android/android-contentprovider/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n<li><a href=\"/post/android/android-broadcastreceiver/android-broadcastreceiver/\" title=\"@LINK\">BroadcastReceiver</a></li>\n<li>Messenger</li>\n<li>文件共享：多进程读写同一文件是难以控制、不安全的。</li>\n<li><del>SharedPrefernces：公共读（<code>MODE_WORLD_READABLE</code>）模式、公共写（<code>MODE_WORLD_WRITEABLE</code>）模式、跨进程（<code>MODE_MULTI_PROCESS</code>）模式均已弃用，多进程读写同一文件是难以控制、不安全的，Google 推荐使用基于 ContentProvider 的 FileProvider 来实现。</del></li>\n</ul>\n<hr>\n<h1 id=\"Android中的缓存\"><a href=\"#Android中的缓存\" class=\"headerlink\" title=\"Android中的缓存\"></a>Android中的缓存</h1><h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"- 内存缓存\"></a>- 内存缓存</h2><h2 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"- 本地缓存\"></a>- 本地缓存</h2><hr>\n<h1 id=\"图片加载框架\"><a href=\"#图片加载框架\" class=\"headerlink\" title=\"图片加载框架\"></a>图片加载框架</h1><ul>\n<li>Glide</li>\n</ul>\n<hr>\n<h1 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h1><ul>\n<li>OKHttp</li>\n<li>基于OKHttp二次封装</li>\n</ul>\n<hr>\n<h1 id=\"断点下载\"><a href=\"#断点下载\" class=\"headerlink\" title=\"断点下载\"></a>断点下载</h1><hr>\n<h1 id=\"性能和优化\"><a href=\"#性能和优化\" class=\"headerlink\" title=\"性能和优化\"></a>性能和优化</h1><h2 id=\"如何检测性能以及如何优化\"><a href=\"#如何检测性能以及如何优化\" class=\"headerlink\" title=\"- 如何检测性能以及如何优化\"></a>- 如何检测性能以及如何优化</h2><h2 id=\"内存抖动的检测和优化\"><a href=\"#内存抖动的检测和优化\" class=\"headerlink\" title=\"- 内存抖动的检测和优化\"></a>- 内存抖动的检测和优化</h2><h2 id=\"ANR和OOM的定位和优化\"><a href=\"#ANR和OOM的定位和优化\" class=\"headerlink\" title=\"- ANR和OOM的定位和优化\"></a>- ANR和OOM的定位和优化</h2><h2 id=\"分析堆栈输出\"><a href=\"#分析堆栈输出\" class=\"headerlink\" title=\"- 分析堆栈输出\"></a>- 分析堆栈输出</h2><hr>\n<h1 id=\"打包和发布\"><a href=\"#打包和发布\" class=\"headerlink\" title=\"打包和发布\"></a>打包和发布</h1><h2 id=\"代码混淆\"><a href=\"#代码混淆\" class=\"headerlink\" title=\"- 代码混淆\"></a>- 代码混淆</h2><h2 id=\"App加固\"><a href=\"#App加固\" class=\"headerlink\" title=\"- App加固\"></a>- App加固</h2><h2 id=\"热更新和热修复\"><a href=\"#热更新和热修复\" class=\"headerlink\" title=\"- 热更新和热修复\"></a>- 热更新和热修复</h2><h2 id=\"VersionCode和VersionName的区别\"><a href=\"#VersionCode和VersionName的区别\" class=\"headerlink\" title=\"- VersionCode和VersionName的区别\"></a>- VersionCode和VersionName的区别</h2><hr>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><ul>\n<li><a href=\"/post/java/java-hashmap/java-hashmap/\" title=\"@LINK\">HashMap</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Handler</a></li>\n<li>Glide</li>\n</ul>\n<hr>\n<h2 id=\"SparseArray的改进\"><a href=\"#SparseArray的改进\" class=\"headerlink\" title=\"- SparseArray的改进\"></a>- SparseArray的改进</h2><hr>\n<h1 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h1><hr>\n<h1 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h1><hr>\n<h1 id=\"其他细节\"><a href=\"#其他细节\" class=\"headerlink\" title=\"其他细节\"></a>其他细节</h1><h2 id=\"getWidth和getMeasureWidth的区别\"><a href=\"#getWidth和getMeasureWidth的区别\" class=\"headerlink\" title=\"- getWidth和getMeasureWidth的区别\"></a>- getWidth和getMeasureWidth的区别</h2><p><code>getMeasureWidth</code> 是 View 自己测量自己的宽度，<code>getWidth</code> 是 View 的父布局测量的高度，当屏幕可显示范围小于 View 本身的宽高时，<code>getMeasureWidth</code> 得到的仍然是 View 本身的宽高，而 <code>getWidth</code> 得到的是屏幕实际显示的宽高</p>\n<h2 id=\"为什么方法参数要加final才能在子线程内使用\"><a href=\"#为什么方法参数要加final才能在子线程内使用\" class=\"headerlink\" title=\"- 为什么方法参数要加final才能在子线程内使用\"></a>- 为什么方法参数要加final才能在子线程内使用</h2><hr>\n<h1 id=\"App架构\"><a href=\"#App架构\" class=\"headerlink\" title=\"App架构\"></a>App架构</h1><p>App 架构的核心思想，主要就是为了降低 UI 逻辑和数据业务逻辑之间的耦合度。</p>\n<h2 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"- MVC模式\"></a>- MVC模式</h2><p>MVC 即：Model - View - Controller 模式，Model 与 View、View 与 Controller、Controller 与 Model，都是单向直接通信，View 层负责 UI 逻辑，Model 层负责数据，Controller 负责替 View 层操作 Model 层，但由于 Android 中，Activity 通常会同时担任 View 层和 Controller 层，随着业务变得复杂，Activity 也会越来越臃肿，而且 Activity 与 Model 层交互时，相当于 View 层可以与 Model 层直接交互，没有完全解耦。</p>\n<h2 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"- MVP模式\"></a>- MVP模式</h2><p>MVP 即：Model - View - Presenter 模式，Presenter 与 View、Presenter 与 Model 之间都是双向通信，而 Model 与 View 之间完全没有直接通信，从而彻底解耦。并且由于将 MVC 模式中的 Controller 完全解放成独立的 Presenter，也避免了 Activity 中逻辑代码过多的情况。</p>\n<ul>\n<li>MVP 模式的变种：Passive View</li>\n</ul>\n<p>  Passive View 即：被动 View 层，是 MVP 模式最广泛的一个变种，其核心思想就是：View 层所需的数据，不是由其主动拉取 Presenter 获得的，而是被动地由 Presenter 推送的，在 Android 中，也就是 View 层开放自己被动接受数据的接口，Presenter 在转发 View 层请求数据的逻辑给 Model 后，由 Model 通过 Presenter 来主动调用 View 的接口来回传数据。</p>\n<h2 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"- MVVM模式\"></a>- MVVM模式</h2><p>MVVM 即：Model - View - ViewModel 模式，View 仍然对应了 UI 层，Model 仍然是负责主要的数据处理，但一些和 View 层有关的属性及操作则放入了 ViewModel 中实现，其关键在于 DataBinding 技术，View 的变化和 ViewModel 的操作会双向同步，实际上是 Jetpack 框架替开发人员做了一些工作。</p>\n<ul>\n<li>DataBinding 原理</li>\n</ul>\n<p>  DataBinding 会对布局文件中使用 <code>&lt;layout&gt;</code> 标签包裹的元素预处理，会为每个元素增加一个 <code>tag</code> 属性，然后将各个元素抽取出来生成一个名为 <code>xxxxx-layout.xml</code> 的文件（<code>xxxxx</code> 是原本 xml 布局文件的命名），文件中将原本的所有 View 标签，都转换成了 <code>&lt;Target id=&quot;xxx&quot; tag=&quot;yyy&quot; view=&quot;ZzzView&quot;&gt;</code> 的形式，其中根布局对应的 tag 是 <code>layout</code>，然后根据原布局文件和新生成的文件，生成一个继承自 <code>ViewDataBinding</code> 的类，并将布局文件中的元素，都根据类型和 id 创建成员变量。</p>\n<h2 id=\"路由框架\"><a href=\"#路由框架\" class=\"headerlink\" title=\"- 路由框架\"></a>- 路由框架</h2><p><a href=\"/post/android/android-router/android-router\" title=\"@LINKS\">Android-浅析ARouter路由框架</a></p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"- 单例模式\"></a>- 单例模式</h2><h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"- 工厂模式\"></a>- 工厂模式</h2><h2 id=\"DCL双锁检测\"><a href=\"#DCL双锁检测\" class=\"headerlink\" title=\"- DCL双锁检测\"></a>- DCL双锁检测</h2><h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"- 观察者模式\"></a>- 观察者模式</h2><h2 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"- 中介者模式\"></a>- 中介者模式</h2><h2 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"- EventBus\"></a>- EventBus</h2><hr>\n","categories":["Interview"],"tags":["Interview","Android","面试题"]},{"title":"Java面试题汇总","url":"/post/interview/interview-java/","content":"<span id=\"more\"></span>\n\n<p>前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。</p>\n<hr>\n<h1 id=\"Java中的引用\"><a href=\"#Java中的引用\" class=\"headerlink\" title=\"Java中的引用\"></a>Java中的引用</h1><h2 id=\"Java引用的实现\"><a href=\"#Java引用的实现\" class=\"headerlink\" title=\"- Java引用的实现\"></a>- Java引用的实现</h2><p>Java 中的引用，是指除了基本数据类型以外的所有类型，这些类型在内存中，会在堆区存储实际的数据，在栈区存储一个别名（Alias），应用通过栈区的别名指向堆区的实际存储空间，来操作实际的数据，详细参考 JVM 内存分区：<a href=\"/post/java/java-jvm/java-jvm/\" title=\"@LINK\">JVM内存模型</a>。</p>\n<hr>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"ThreadPool线程池\"><a href=\"#ThreadPool线程池\" class=\"headerlink\" title=\"- ThreadPool线程池\"></a>- ThreadPool线程池</h2><hr>\n<h1 id=\"Java集合框架\"><a href=\"#Java集合框架\" class=\"headerlink\" title=\"Java集合框架\"></a>Java集合框架</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"- HashMap\"></a>- HashMap</h2><p>答：<a href=\"/post/java/java-hashmap/java-hashmap/\" title=\"@LINK\">HashMap</a></p>\n<hr>\n<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h1><h2 id=\"JVM的五个区\"><a href=\"#JVM的五个区\" class=\"headerlink\" title=\"- JVM的五个区\"></a>- JVM的五个区</h2><p>答：<a href=\"/post/java/java-jvm/java-jvm/\" title=\"@LINK\">JVM内存模型和内存分区</a></p>\n<h2 id=\"方法区是否会OOM\"><a href=\"#方法区是否会OOM\" class=\"headerlink\" title=\"- 方法区是否会OOM\"></a>- 方法区是否会OOM</h2><p>答：会。在 JDK 1.8 以前，HotSpot 虚拟机的方法区是用永久代实现的，方法区的内存固定，因此如果频繁调用 <code>String.intern()</code> 方法，或者一次性加载太多类，会导致OOM。JDK 1.8 之后，虽然用元数据取代了方法区，直接使用本地内存，支持扩容，也取消了永久代，但并不是无限扩容的，所以仍然会，只是几率会小一些。</p>\n<h2 id=\"GC垃圾回收机制\"><a href=\"#GC垃圾回收机制\" class=\"headerlink\" title=\"- GC垃圾回收机制\"></a>- GC垃圾回收机制</h2><p>答：<a href=\"/post/java/java-gc/java-gc/\" title=\"@LINK\">JVM的GC策略</a></p>\n<hr>\n<h1 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h1><hr>\n<h1 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h1><hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"finally什么时候执行\"><a href=\"#finally什么时候执行\" class=\"headerlink\" title=\"- finally什么时候执行\"></a>- finally什么时候执行</h2><p><a href=\"/post/java/java-finally/java-finally\" title=\"@LINKS\">Java-finally关键字</a></p>\n<h2 id=\"为什么方法参数要加final才能在子线程内使用\"><a href=\"#为什么方法参数要加final才能在子线程内使用\" class=\"headerlink\" title=\"- 为什么方法参数要加final才能在子线程内使用\"></a>- 为什么方法参数要加final才能在子线程内使用</h2>","categories":["Interview"],"tags":["Interview","面试题","Java"]},{"title":"面试题-数据库中查找图片","url":"/post/interview/interview-find_pictures/","content":"<span id=\"more\"></span>\n","categories":["Interview"],"tags":["Interview","面试题"]},{"title":"Network面试题汇总","url":"/post/interview/interview-network/","content":"<span id=\"more\"></span>\n\n<p>前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。</p>\n<hr>\n<h1 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h1><h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"- TCP\"></a>- TCP</h2><h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"- UDP\"></a>- UDP</h2><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"- HTTP\"></a>- HTTP</h2><h2 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"- SSL\"></a>- SSL</h2><h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"- HTTPS\"></a>- HTTPS</h2>","categories":["Interview"],"tags":["Interview","面试题","Network"]},{"title":"面试题-运输和消耗最优解问题","url":"/post/interview/interview-transport_and_consume/","content":"<span id=\"more\"></span>\n","categories":["Interview"],"tags":["Interview","面试题"]},{"title":"Android——Activity","url":"/post/android/android-activity/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-Activity\"><a href=\"#1-Activity\" class=\"headerlink\" title=\"1. Activity\"></a>1. Activity</h1><h2 id=\"1-1-Activity生命周期\"><a href=\"#1-1-Activity生命周期\" class=\"headerlink\" title=\"1.1 Activity生命周期\"></a>1.1 Activity生命周期</h2><p>Activity 即一个用户界面，可以理解成一个视图容器，容器内可以包裹和展示各类控件。全部 Activity 都需要在 Manifest 内声明。</p>\n<p>Activity 的生命周期为：<code>onCreate()</code> - <code>onStart()</code> - <code>onResume()</code> - <code>onPause()</code> - <code>onStop()</code> - <code>onDestroy()</code>【或 <code>onRestart()</code> - <code>onStart()</code>…】。</p>\n<p>需要注意的是：<code>onStop()</code> 在 Activity 不可见时才调用，例如 AActivity 启动 BActivity，若 BActivity 是透明或弹窗形式（<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>），则 AActiivty 不会调用 <code>onStop()</code>。</p>\n<p>Activity 的 <code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code> 并不是生命周期方法，不同于生命周期方法，它们并不一定会被触发。当用户按 Home 键返回桌面、\b从多任务切换应用、锁屏、屏幕方向变化、启动新的 Activity时，或者当应用遇到意外情况（如内存不足）且 Activity 由系统销毁时，则 <code>onSaveInstanceState()</code> 会被调用。但是当用户主动销毁一个 Activity（例如在应用中按返回键）时，<code>onSaveInstanceState()</code> 就不会被调用。通常 <code>onSaveInstanceState()</code> 只适合用于保存一些临时性的状态，而 <code>onPause()</code> 适合用于数据的持久化保存。</p>\n<p>如果一个 Activity 被打开过，然后被置入任务栈顶端（例如切换到另一个 Activity 且没有再次切换新 Activity），且此时处于 <code>onPause()</code>、<code>onStop</code> 状态，则当有一个 Intent 启动该 Activity，会先调用 <code>onNewIntent()</code>，然后才调用 <code>onRestart()</code> - <code>onStart()</code> - <code>onResume()</code>。</p>\n<p>Activity 必须在 Manifest 中注册：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Manifest 中声明</span></span><br><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;lsl.demo.OtherModuleActivity&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;module.demo.OtherModuleActivity&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-Context\"><a href=\"#1-2-Context\" class=\"headerlink\" title=\"1.2 Context\"></a>1.2 Context</h2><p>Activity、Application 都是 Context 的子类，而 Context 是抽象类 ContextImpl 的实现。context 维护当前 Activity 的生命周期，而 Application 维护整个应用的生命周期，因此一些全局变量可以放在 Application 中。</p>\n<hr>\n<h1 id=\"2-Activity的启动和退出\"><a href=\"#2-Activity的启动和退出\" class=\"headerlink\" title=\"2. Activity的启动和退出\"></a>2. Activity的启动和退出</h1><h2 id=\"2-1-启动Activity\"><a href=\"#2-1-启动Activity\" class=\"headerlink\" title=\"2.1 启动Activity\"></a>2.1 启动Activity</h2><p>直接启动 Actiivty：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoActivity.class);</span><br><span class=\"line\"><span class=\"comment\">// 直接插入数据</span></span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;key1&quot;</span>, value)</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;key2&quot;</span>, value)</span><br><span class=\"line\"><span class=\"comment\">// 通过 Bundle</span></span><br><span class=\"line\">Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">bundle.putXXX(String key1, XXX value);</span><br><span class=\"line\">bundle.putXXX(String key2, XXX value);</span><br><span class=\"line\">intent.putExtra(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p>启动跨 Module 的 Activity，需要先在目标 Activity 注册的 Manifest 文件中设置一个 Action：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=<span class=\"string\">&quot;demo.DemoActivity&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;demo.customActionName&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后利用 Manifest 中设置的 <code>demo.customActionName</code> 来启动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;demo.customActionName&quot;</span>);</span><br><span class=\"line\">startActivity(intent)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：默认情况下，假如这里设置的 <code>demo.customActionName</code> 和别的 App 某个 Activity 设置的一样，则通过 <code>setAction</code> 启动时只会启动本 App 中的 Activity。如果想要让 Activity 可以被别的 App 唤起，则需要添加一个 <code>export</code> 属性（不显式设置该属性时默认为 false）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;demo.DemoActivity&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-2-退出Activity\"><a href=\"#2-2-退出Activity\" class=\"headerlink\" title=\"2.2 退出Activity\"></a>2.2 退出Activity</h1><ul>\n<li><p>当一个 Application 已开启了多个 Activity，则在安全退出时，可以发送预定义的广播，在所有被开启的 Activity 中注册广播监听，监听到广播后各自调用 <code>finish()</code> 即可。</p>\n</li>\n<li><p>当一个应用有层叠 Activity（即 AActivity 启动 BActivity，BActivity 启动 CActivity…）时，可在每个 Activity 启动新 Activity 时，使用 <code>startActivityForResult()</code> 替代 <code>startActivity()</code>，并在 <code>onActivityResult()</code> 中将自己 <code>finish()</code>。</p>\n</li>\n<li><p>用 List 等记录每个启动的 Activity，并在需要时分别关闭。需要注意的是，使用 List 存放 Activity 有内存泄露的风险，当 Activity 关闭后，要及时清掉对应 List 中的引用。</p>\n</li>\n<li><p>在启动 Activity 时，给 Intent 设置 Flag：<code>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)</code>，则系统会在新 Activity 启动后将其上的所有 Activity 销毁，效果等效于给新 Activity 配置 SingleTop 启动模式。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"3-Activity启动模式\"><a href=\"#3-Activity启动模式\" class=\"headerlink\" title=\"3. Activity启动模式\"></a>3. Activity启动模式</h1><p>Activity 有 4 种启动模式：</p>\n<ul>\n<li><ol>\n<li><code>standard</code></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><code>singleTop</code></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><code>singleTask</code></li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li><code>singleInstance</code></li>\n</ol>\n</li>\n</ul>\n<p>需要先了解到，Android 中 Activity 是存在堆栈（任务栈）中的，启动一个 Activity 时会将其压栈，销毁时弹出，当然不同启动模式会导致 Activity 任务栈产生不同的行为。同时一个 App 进程也可以拥有多个 Activity 任务栈，例如 <code>singleInstance</code> 模式。</p>\n<h2 id=\"3-1-Standard模式\"><a href=\"#3-1-Standard模式\" class=\"headerlink\" title=\"3.1 Standard模式\"></a>3.1 Standard模式</h2><p>Standard 就是标准默认模式，启动一个 Activity 时，不论 Activity 在任务栈中是否已经有实例，都新建一个实例并压入往当前任务栈。当前 Activity 在当前任务栈可以有多个实例，每个实例也可以在不同任务栈。</p>\n<p>简单来说，也就是每次启动一个 Activity 都当做一个新的 Actviity 创建实例并压进对应的任务栈。需要注意的是，Standard 模式并不会创建任务栈，这也是为什么使用 ApplicationContext 启动，或在 Service 中以 Standard 方式启动 Activity 时会报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context <span class=\"keyword\">requires</span> the FLAG_ACTIVITY_NEW_TASK flag. Is <span class=\"keyword\">this</span> really what you want?</span><br></pre></td></tr></table></figure>\n\n<p>因为 ApplicationContext 和 Service 并没有任务栈。</p>\n<p>Standard 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“&gt;” 表示 <font color=red>栈顶</font>）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Standard Start B</td>\n</tr>\n<tr>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Standard Start B</td>\n</tr>\n<tr>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">Standard Start A</td>\n</tr>\n<tr>\n<td align=\"left\">/ABBA&gt;</td>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-2-SingleTop模式\"><a href=\"#3-2-SingleTop模式\" class=\"headerlink\" title=\"3.2 SingleTop模式\"></a>3.2 SingleTop模式</h2><p>SingleTop 即栈顶唯一模式，启动一个 Activity 时，如果该 Activity 已在栈顶则不会新建一个 Activity 实例而是复用它，否则其行为和 Standard 模式一致。</p>\n<p>SingleTop 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“&gt;” 表示 <font color=red>栈顶</font>）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">SingleTop Start B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">SingleTop Start B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">SingleTop Start A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">SingleTop Start B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/ABAB&gt;</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-3-SingleTask模式\"><a href=\"#3-3-SingleTask模式\" class=\"headerlink\" title=\"3.3 SingleTask模式\"></a>3.3 SingleTask模式</h2><p>SingleTask 即任务栈唯一模式，启动一个 Activity 时，如果任务栈中存在该 Activity 实例，则复用它，否则才创建一个新的 Activity 实例。SingleTask 和 SingleTop 的区别在于，SingleTop 只在栈顶 Activity 和要启动的 Activity 相同时才复用，而 SingleTask 是每个 Activity 在当前整个任务栈中都只有一个实例。</p>\n<p>SingleTask 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“&gt;” 表示 <font color=red>栈顶</font>）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">SingleTask Start B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">SingleTask Start B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">SingleTask Start A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/BA&gt;</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"center\">Standard Start B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/BAB&gt;</td>\n<td align=\"left\">/BA&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-4-SingleInstance模式\"><a href=\"#3-4-SingleInstance模式\" class=\"headerlink\" title=\"3.4 SingleInstance模式\"></a>3.4 SingleInstance模式</h2><p>SingleInstance 即唯一实例模式），启动一个 Activity 时，寻找所有的任务栈，如果某个任务栈中存在该 Activity 实例，则切换到该任务栈，否则新建一个任务栈并创建该 Activity 实例。</p>\n<p>重点在于：任务栈不是唯一的，一个 App 可以有多个任务栈，就像 Android 系统的后台应用列表一样，里面包括了多个应用，而每个应用又管理自己的多个任务栈（可以理解为<font color=#EB6D39>任务栈的总栈</font>），每个任务栈又分别管理包含的 Activity。</p>\n<p>SingleInstance 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“&gt;” 表示 <font color=red>栈顶</font>，任务栈之间用 “-” 连接，右侧的任务栈为最新任务栈，M 为最开始以 Standard 启动的 Activity）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">SingleInstance Start A</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"center\">SingleInstance Start B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/M&gt; - /A&gt; - /B&gt;</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"center\">SingleInstance Start A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/M&gt; - /B&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt; - /B&gt;</td>\n<td align=\"center\">Standard Start C</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/B&gt; - /A&gt; - /MC&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>前 3 步都比较好理解，反正就是整个 App 所有任务栈都只允许有一个实例。重点在从第 4 步开始，由于最开始的 M 是 Standard 模式启动的，而第 4 步中 C 也是 Standard 模式，也就导致本来在最底下的任务栈 <code>/M&gt;</code> 被移到了 “任务栈的总栈” 的栈顶，并将 C 压入了 <code>/M&gt;</code> 所在的这个栈顶，因此从 C 返回的时候会先返回到 M，然后才是按顺序下来的 A → B。</p>\n","categories":["Android"],"tags":["Android","四大组件","Activty","启动模式","生命周期"]},{"title":"Android——BroadcastReceiver","url":"/post/android/android-broadcastreceiver/","content":"<span id=\"more\"></span>\n\n<p>BroadcastReceiver 本质上通过设置过滤来有选择地响应某些事件，例如网络状态的变化、锁屏的变化等等，其本身没有用户界面，但可以启动 Activity 或 Service，或使用 NotificationManager 通知用户。</p>\n<p>BroadcastReceiver 有两种注册方式：在 Manifest 中静态注册、在代码中通过 <code>registerReceiver()</code> 动态注册。在 Manifest 中静态注册的广播接收会随系统的启动而保持活跃，即便 App 未运行，只要接收到指定广播均会触发响应。</p>\n<p>广播按照类型分为两种：全局广播和本地广播</p>\n<ul>\n<li>全局广播：发出的广播可以被其他任意的应用程序接收，或者可以接收来自其他任意应用程序的广播。</li>\n<li>本地广播：只能在应用程序的内部进行传递的广播，广播接收器也只能接收内部的广播，不能接受其他应用程序的广播。</li>\n</ul>\n<p>按照广播机制也可以分为两种：标准广播和有序广播</p>\n<ul>\n<li>标准广播：所有的接收者都会接收事件，不可以被拦截，不可以被修改。</li>\n<li>有序广播：按照优先级，逐级向下传递，接收者可以修改广播数据，也可以终止广播事件。</li>\n</ul>\n<p>自定义广播接收需要重写 <code>onReceive()</code> 方法以在接收到广播后响应。由于广播接收不允许开启多线程，因此不应在此处做耗时操作，耗时较长会导致 Crash。广播接收通常作为一个通知者，在接收到特定的消息后通知 Activity 或 Service 进行处理，或是显示地直接通知用户。</p>\n<p>创建一个自定义的广播接收器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收广播后的响应</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-1-全局广播和全局广播接收器\"><a href=\"#4-1-全局广播和全局广播接收器\" class=\"headerlink\" title=\"4.1 全局广播和全局广播接收器\"></a>4.1 全局广播和全局广播接收器</h2><p>全局广播发送的广播可以被所有全局广播接收器接收，即使注册接收器的 App 并未启动。同样，全局广播接收器能接收到所有全局广播，即使这些广播接收器的 App 并未启动。</p>\n<p>若使用动态注册，则需要监听广播的地方设置过滤，且广播接收器跟随组件的生命周期，在组件结束前必须手动销毁广播接收器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DemoBroadcastReceiver demoBroadcaseReceiver = <span class=\"keyword\">new</span> DemoBroadcaseReceiver();</span><br><span class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\"><span class=\"comment\">// 监听网络变化</span></span><br><span class=\"line\">intentFilter.addAction(<span class=\"string\">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态注册</span></span><br><span class=\"line\">registerReceiver(demoBroadcaseReceiver, intentFilter);</span><br><span class=\"line\"><span class=\"comment\">// 销毁广播接收器，通常可以放进 onDestroy() 中处理</span></span><br><span class=\"line\">unregisterReceiver(demoBroadcaseReceiver);</span><br></pre></td></tr></table></figure>\n\n<p>若使用 Manifest 静态注册则如下声明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoBroadcastReceiver&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;broadcast.action.DEMO_NOTIFY&quot;</span>&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以监听自定义的广播，只需要将广播过滤内容存进 Intent 内并发送即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接构造</span></span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;broadcast.action.DEMO_NOTIFY&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 action</span></span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;broadcast.action.DEMO_NOTIFY&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送标准广播</span></span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>当需要发送有序广播时，则需要设置广播的优先级。广播会优先发送给优先级更高的接收器，然后逐级发送给更低优先级的接收器，优先级的范围为：-1000 ~ 1000。</p>\n<ul>\n<li>静态注册全局广播的优先级只需给全局接收器的 intent-filter 添加优先级属性：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter android:priority=<span class=\"string\">&quot;100&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或使用动态注册设置全局接收器优先级：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">intentFilter.setPriority(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态注册</span></span><br><span class=\"line\">registerReceiver(demoBroadcaseReceiver, intentFilter);</span><br><span class=\"line\"><span class=\"comment\">// 销毁广播接收器</span></span><br><span class=\"line\">unregisterReceiver(demoBroadcaseReceiver);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在发送有序全局广播的地方：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要发送的广播只被特定的接收器接收，可以设置权限，则只有具有对应权限的接收器才能接收到广播。</p>\n<ul>\n<li>静态注册全局广播设置权限：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义权限需要先在 Manifest 顶层声明</span></span><br><span class=\"line\">&lt;permission android:name = <span class=\"string\">&quot;broadcast.permission.DEMO_PERMISSION&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoBroadcastReceiver&quot;</span></span><br><span class=\"line\">    android:permission=<span class=\"string\">&quot;broadcast.permission.DEMO_PERMISSION&quot;</span>&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>动态注册全局接收器设置权限：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">registerReceiver(demoBroadcaseReceiver, intentFilter, <span class=\"string\">&quot;broadcast.permission.DEMO_PERMISSION&quot;</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>发送全局广播时加上权限即可：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送带权限的标准广播</span></span><br><span class=\"line\">sendBroadcast(intent, <span class=\"string\">&quot;broadcast.permission.DEMO_PERMISSION&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 发送带权限的有序广播</span></span><br><span class=\"line\">sendOrderedBroadcast(intent, <span class=\"string\">&quot;broadcast.permission.DEMO_PERMISSION&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-本地广播和本地广播接收器\"><a href=\"#4-2-本地广播和本地广播接收器\" class=\"headerlink\" title=\"4.2 本地广播和本地广播接收器\"></a>4.2 本地广播和本地广播接收器</h2><p>本地广播发送的广播只能被当前 App 中注册的本地广播接收器接收，同样，本地广播接收器也只能接收当前 App<br> 发送的本地广播。</p>\n<p>发送本地广播和接收本地广播与全局的非常类似，只有使用的类和方法有些许区别。需要注意的是，由于静态注册主要是为了能在 App 不启动时也能响应广播，而本地广播接收器仅能接收本地广播，因此只能通过动态注册。</p>\n<ul>\n<li>动态注册本地广播接收器：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DemoBroadcastReceiver demoBroadcaseReceiver = <span class=\"keyword\">new</span> DemoBroadcaseReceiver();</span><br><span class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\"><span class=\"comment\">// 监听网络变化</span></span><br><span class=\"line\">intentFilter.addAction(<span class=\"string\">&quot;broadcast.action.DEMO_NOTIFY&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">LocalBroadcastManager localBroadcastManager = <span class=\"keyword\">new</span> LocalBroadcastManager.getInstance(context);</span><br><span class=\"line\"></span><br><span class=\"line\">localBroadcastManager.registerReceiver(demoBroadcaseReceiver, intentFilter);</span><br><span class=\"line\"><span class=\"comment\">// 销毁广播接收器，通常可以放进 onDestroy() 中处理</span></span><br><span class=\"line\">localBroadcastManager.unregisterReceiver(demoBroadcaseReceiver);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>发送本地广播：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;broadcast.action.DEMO_NOTIFY&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 发送本地标准广播</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcast(intent);</span><br><span class=\"line\"><span class=\"comment\">// 发送本地有序广播</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcastSync(intent);</span><br></pre></td></tr></table></figure>\n\n<p>本地广播不支持权限过滤，因此无法设置 Permission。</p>\n","categories":["Android"],"tags":["Android","四大组件","BroadcastReceiver"]},{"title":"AndroidStudio中使用CMake进行NDK开发","url":"/post/android/android-cmake/","content":"<span id=\"more\"></span>\n\n<p>前言：目前着手的一个项目需要使用JNI方法从USB读取数据，项目在建立之初并没有考虑添加原生的NDK支持，最初想用比较简便原始的方式：NDK-Build来完成，但Android Studio在3.2版本之后弃用了NDK-Build方式（其实还可以用，但是谷歌官方不推荐），因此改用 CMake 建立并记录于本文。</p>\n<hr>\n<h1 id=\"1-官方Demo\"><a href=\"#1-官方Demo\" class=\"headerlink\" title=\"1. 官方Demo\"></a>1. 官方Demo</h1><p>先解释一下 <a href=\"https://developer.android.google.cn/ndk/guides\" title=\"@LINK\">什么是NDK</a> 以及 <a href=\"https://baike.baidu.com/item/JNI/9412164?fr=aladdin\" title=\"@LINK\">什么是JNI</a> 。<br>两者结合起来，用最粗略的话来讲，就是：在 Android 开发中调用 C/C++ 代码。早期 Android 版本通常使用 NDK-Build 方式构建，但由于不便于管理等原因在新版中被弃用。</p>\n<blockquote>\n<p>对JNI的详细介绍和进阶知识可以参考官方文档或附录</p>\n</blockquote>\n<p>先新建一个原生支持NDK的Android项目，即在新建项目的时候勾选 <code>Include C++ support</code> ，观察一下谷歌建议我们使用的CMake方式的样子。在官方的Demo中，调用和以前的方式并无区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Used to load the &#x27;native-lib&#x27; library on application startup.</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;native-lib&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Example of a call to a native method</span></span><br><span class=\"line\">        TextView tv = (TextView) findViewById(R.id.sample_text);</span><br><span class=\"line\">        tv.setText(stringFromJNI());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A native method that is implemented by the &#x27;native-lib&#x27; native library,</span></span><br><span class=\"line\"><span class=\"comment\">     * which is packaged with this application.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>都是先用静态代码块 <code>static&#123;&#125;</code> 加载JNI模块，然后声明一个native方法并调用。当然，JNI方法的加载和调用不推荐在Activity中实现，应该放在数据处理类或工具类中按需调用，这里涉及到一些性能和安全性的问题，暂时不做多的展开。具体的JNI方法也很简单，只是返回了一个String字符串。重要的是Gradle和CMakeLists.txt文件里的代码，尤其是官方注释，需要注意的地方分别是：①C/C++文件的JNI方法；②项目Gradle；③CMakeLists.txt里的内容。先不急着对官方Demo解释，为了实现手动增加NDK支持，再创建一个不支持原生NDK的空项目，一边改一边对各个模块解释说明。</p>\n<p>在C++文件的函数头中，有这么一句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br></pre></td></tr></table></figure>\n\n<p>这一行代码其实可以分成两个部分：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一部分</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 第二部分</span></span><br><span class=\"line\">JNIEXPORT jstring JNICALL</span><br></pre></td></tr></table></figure>\n\n<p>第一部分 <code>extern &quot;C&quot;</code>表示对编译C的支持，第二部分 <code>JNIEXPORT jstring JNICALL</code> 可以看成定义了函数的返回值， <code>jstring</code> 可以理解为Java中的String。如果在JNI文件中有多个函数，可以用一个大的 <code>extern &quot;C&quot;</code> 将多个函数一次性括起来，但是C函数和C++函数不能混用，还是要分两个文件（好像是废话= =）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromCpp1</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++1&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromCpp2</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++2&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"2-为已有项目增加NDK支持\"><a href=\"#2-为已有项目增加NDK支持\" class=\"headerlink\" title=\"2. 为已有项目增加NDK支持\"></a>2. 为已有项目增加NDK支持</h1><p>既然是要给已有项目增加NDK支持，那就首先创建一个新的空项目模拟一个已存在的项目，然后再通过手动配置添加NDK。<br>切换到 <code>Project</code> 视图，并在如下图所示的目录层级下创建一个文件夹用来存放C/C++代码：</p>\n<center>\n\n<p><img data-src=\"./create_jni_folder.png\" alt=\"创建JNI文件夹\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"2-1-创建JNI文件\"><a href=\"#2-1-创建JNI文件\" class=\"headerlink\" title=\"2.1 创建JNI文件\"></a>2.1 创建JNI文件</h2><p>接着在这个 <strong>JNI</strong> 文件夹里新建 <strong>C/C++ Source File</strong> ，先创建一个C文件，假设起名为 <code>HelloC</code> ，在下方的 <strong>Type:</strong> 下拉框中选择 <strong>.c</strong> ，同时勾选 <strong>Create an associated header</strong> 自动创建对应的头文件。</p>\n<center>\n\n<p><img data-src=\"./create_c_file.png\" alt=\"创建C文件\" title=\"@ASSET\"></p>\n</center>\n\n<p>点击OK，就会创建 <code>HelloC.c</code> 和 <code>HelloC.h</code> 并自动将头文件导入到C文件中。函数很简单，直接返回一个String： <code>&quot;Hello from C&quot;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;HelloC.h&quot;</span><br><span class=\"line\">#include &lt;jni.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_demo_ndktest_MainActivity_helloFromC</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        JNIEnv *env,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jobject obj <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">&quot;Hello from C&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里要说明一点，代码中 <code>Java_com_demo_ndktest_MainActivity_helloFromC</code> 可以看成是一个方法名，但是这个方法名有严格的命名限制，先进行分解：首先命名必须以 <code>Java_</code> 开头，后面紧跟着的 <code>com_demo</code> 是项目的包名， <code>ndktest</code> 是项目名， <code>MainActivity</code> 是调用这个JNI方法的类名，最后 <code>helloFromC</code> 才是这个JNI方法的方法名。如果把 <code>com_demo_ndktest_MainActivity</code> 连在一起看，其实就是调用这个JNI方法的类的绝对路径，在本例中也即 <code>MainActivity</code> 的绝对路径，只不过把包的层级表示从点“**.<strong>”换成了下划线“</strong>_**”。<br>另外， <code>extern &quot;C&quot; </code> 关键字通常在C/C++混合编程中用于 <strong>指定使用C编译方式编译的代码块</strong> ，但是这里本来就是在C文件中写C语言代码，所以没有必要也不允许使用这个关键字了。<br>如果怕出错，可以在我们想要调用这个JNI方法的类的最上方找到绝对路径，再把点都替换成下划线即可：</p>\n<center>\n\n<p><img data-src=\"./set_package_name.png\" alt=\"设置包名\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"2-2-创建CMakeLists-txt\"><a href=\"#2-2-创建CMakeLists-txt\" class=\"headerlink\" title=\"2.2 创建CMakeLists.txt\"></a>2.2 创建CMakeLists.txt</h2><p>确定好JNI文件后，开始写 <strong>CMakeLists.txt</strong> ！在创建CMake文件时，理论上可以在任意位置创建，但是一方面为了便于项目管理，另一方面为了防止混淆，还是创建在当前Module根目录下比较好，对于只有一个Module的项目，也就是创建在 <strong>app</strong> 的根目录下。右键 <strong>app</strong> 目录，选择 <strong>New File</strong> ，输入文件名 <code>CMakeLists.txt</code> 。<br><strong>对于这个文件，文件名必须是“CMakeLists.txt”而不能自定义</strong>。</p>\n<center>\n\n<p><img data-src=\"./cmake_file_path.png\" alt=\"创建CMakeLists.txt的位置\" title=\"@ASSET\"></p>\n</center>\n\n<p>创建完成后向里面写构件库的内容。</p>\n<p><strong>（1）指定CMake的最低版本</strong> 。这是第一条也是必要的一条：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）为项目增加一个lib库</strong> 。也就是指定刚才写的 <code>HelloC.c</code> 文件，这里我们要指定出C文件的绝对路径： <code>src/main/jni/HelloC.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_library( # Sets the name of the library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Sets the library as a shared library.</span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        # Provides a relative path to your source file(s).</span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>HelloC</code> 是创建这个库的命名，可以任意指定，这个名称将在Java中 <strong>加载JNI</strong> 时用到。</li>\n<li><code>SHARED</code> 代表这是个动态库，除了这个选项外还有 <code>STATIC</code> 可选</li>\n</ul>\n<p><strong>（3）使用原生log模块</strong> 。因为要给项目添加NDK支持，所以需要用到NDK库，采用 <code>find_library</code> 使用原生的库和API：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find_library( # Sets the name of the path variable.</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        # Specifies the name of the NDK library that</span><br><span class=\"line\">        <span class=\"meta\"># you want CMake to locate.</span></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>log-lib</code> 是给要使用的NDK库命名，可以自定义，在 <strong>CMake关联指定库</strong> 时会用到</li>\n<li><code>log</code> 是我们要使用的库： <strong>log模块</strong></li>\n</ul>\n<p><strong>（4）CMake关联指定库</strong> 。这一步将第（2）步中添加的库关联给CMake：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">target_link_libraries( # Specifies the target library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Links the target library to the <span class=\"built_in\">log</span> library</span><br><span class=\"line\">        <span class=\"meta\"># included in the NDK.</span></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<ul>\n<li><code>HelloC</code> 就是第（2）步新增库时给库的命名</li>\n<li><code>$&#123;log-lib&#125;)</code> 是引用第（3）步中定义的log模块</li>\n</ul>\n<p>完成之后整体的代码（从注释也基本可以看出每一行的用途）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add_library( # Sets the name of the library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Sets the library as a shared library.</span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        # Provides a relative path to your source file(s).</span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br><span class=\"line\"></span><br><span class=\"line\">find_library( # Sets the name of the path variable.</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        # Specifies the name of the NDK library that</span><br><span class=\"line\">        <span class=\"meta\"># you want CMake to locate.</span></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">target_link_libraries( # Specifies the target library.</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        # Links the target library to the <span class=\"built_in\">log</span> library</span><br><span class=\"line\">        <span class=\"meta\"># included in the NDK.</span></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时CMakeLists.txt部分就已经完成！</p>\n<h2 id=\"2-3-多JNI方法支持\"><a href=\"#2-3-多JNI方法支持\" class=\"headerlink\" title=\"2.3 多JNI方法支持\"></a>2.3 多JNI方法支持</h2><p>对于大部分时候，JNI和CMakeLIsts的配置就大概如此了，但是有时候可能会遇到需要多个JNI接口的时候，此时就需要在CMakeLists中添加多个库了。在本例中，再新增一个C++的JNI方法，并通过CMake增加到库中。</p>\n<h3 id=\"2-3-1-创建第二个JNI方法（C-）\"><a href=\"#2-3-1-创建第二个JNI方法（C-）\" class=\"headerlink\" title=\"2.3.1 创建第二个JNI方法（C++）\"></a>2.3.1 创建第二个JNI方法（C++）</h3><p>同样在 <strong>jni</strong> 目录下新建一个C++文件 <strong>HelloCPP.cpp</strong> ，与之前创建 <strong>HelloC.c</strong> 时一样，勾选自动关联头文件，代码和官方Demo如出一辙，只不过把函数名改为 <code>helloFromCPP</code> ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_com_demo_ndkdemo_MainActivity_stringFromJNI(</span><br><span class=\"line\">        JNIEnv *env,</span><br><span class=\"line\">        jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> hello = <span class=\"string\">&quot;Hello from C++&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，既然要让这个JNI方法被编译，就需要在CMakeLists中进行添加和关联。</p>\n<h3 id=\"2-3-2在CMake中添加和关联两个JNI接口\"><a href=\"#2-3-2在CMake中添加和关联两个JNI接口\" class=\"headerlink\" title=\"2.3.2在CMake中添加和关联两个JNI接口\"></a>2.3.2在CMake中添加和关联两个JNI接口</h3><p>步骤与C文件的步骤一模一样，只需要注意库命名和绝对路径正确即可，直接贴代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.4</span><span class=\"number\">.1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第一个JNI（HelloC）</span><br><span class=\"line\">add_library(</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        src/main/jni/HelloC.c)</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第二个JNI（HelloCPP）</span><br><span class=\"line\">add_library(</span><br><span class=\"line\">        HelloCPP</span><br><span class=\"line\"></span><br><span class=\"line\">        SHARED</span><br><span class=\"line\"></span><br><span class=\"line\">        src/main/jni/HelloCPP.cpp</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">find_library(</span><br><span class=\"line\">        <span class=\"built_in\">log</span>-lib</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">log</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 连接到第一个库</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">        HelloC</span><br><span class=\"line\"></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 连接到第二个库</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">        HelloCPP</span><br><span class=\"line\"></span><br><span class=\"line\">        $&#123;<span class=\"built_in\">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样就把两个JNI方法都连接到CMake了，接下来就是Gradle的配置，使得系统可以调用JNI方法。</p>\n<h2 id=\"2-4-修改Gradle配置\"><a href=\"#2-4-修改Gradle配置\" class=\"headerlink\" title=\"2.4 修改Gradle配置\"></a>2.4 修改Gradle配置</h2><p>修改模块的Gradle： <strong>build.gradle (Module: app)</strong> 。先在 <code>defaultConfig</code> 内部增加CMake的一些参数：预处理选项 <code>cppFlags</code> 和架构选择 <code>abiFilters</code>，对于默认情况， <code>cppFlags</code> 为空即可， <code>abiFilters</code> 可以控制生成指定的abi，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">externalNativeBuild &#123;</span><br><span class=\"line\">\tcmake &#123;</span><br><span class=\"line\">\t\tcppFlags <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t\tabiFilters &#x27;armeabi&#x27;,&#x27;armeabi-v7a&#x27;,&#x27;x86&#x27;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者删除 <code>abiFilters</code> 语句表示生成支持所有架构的so库。<br>接着在与 <code>buildTypes</code> 同级的地方增加一个CMakeLists文件的连接：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">externalNativeBuild &#123;</span><br><span class=\"line\">\tcmake &#123;</span><br><span class=\"line\">\t\tpath <span class=\"string\">&quot;CMakeLists.txt&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成后整个Gradle的配置大致如下（省略非必要部分的内容，但保留了层级关系便于比对）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 此处添加CMake参数</span></span><br><span class=\"line\">        externalNativeBuild &#123;</span><br><span class=\"line\">            cmake &#123;</span><br><span class=\"line\">                cppFlags <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处指定CMake文件</span></span><br><span class=\"line\">    externalNativeBuild &#123;</span><br><span class=\"line\">        cmake &#123;</span><br><span class=\"line\">            path <span class=\"string\">&quot;CMakeLists.txt&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Sync同步一下，再Rebuild一下项目确保没有问题后，就可以运行测试啦！</p>\n<hr>\n<h1 id=\"3-完成效果\"><a href=\"#3-完成效果\" class=\"headerlink\" title=\"3. 完成效果\"></a>3. 完成效果</h1><p>布局很简单就不放代码了，一个 <code>TextView</code> 用来显示String返回值，和两个 <code>Button</code> 分别用来获取C和C++文件JNI方法的字符串并设置到TextView上。代码调用和JNI加载伪代码如下（省略点击监听和控件初始化等）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.lsl.demo.ndktest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnClickListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 通过静态初始化块加载两个编译库</span></span><br><span class=\"line\">\t<span class=\"comment\">// 库名分别是在CMakeLists.txt文件中定义的两个库名</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloC&quot;</span>);</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloCPP&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// btC：从C文件获取字符串并显示</span></span><br><span class=\"line\">\t<span class=\"comment\">// btCpp：从C++文件获取字符串并显示</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView tvText;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Button btC, btCpp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        initView(); <span class=\"comment\">// 初始化控件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 定义JNI方法，方法名和对应的C/C++文件内的函数名相对应</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">helloFromC</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">helloFromCPP</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在需要使用的地方调用上方两个方法即可</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (v.getId()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> R.id.btC: &#123;</span><br><span class=\"line\">                tvText.setText(helloFromC());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> R.id.btCpp: &#123;</span><br><span class=\"line\">                tvText.setText(helloFromCPP());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行，分别点击两个按钮，可以看到确实成功运行了两个JNI方法并获取到了字符串返回值：</p>\n<center>\n\n<p><img data-src=\"./run.gif\" alt=\"运行效果\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"4-总结备注\"><a href=\"#4-总结备注\" class=\"headerlink\" title=\"4. 总结备注\"></a>4. 总结备注</h1><p>对于Android项目的NDK支持基本上就是如此了，不难，但是容易出错，复杂的点通常在具体的函数实现上。最后再总结和强调一些注意事项。</p>\n<ol>\n<li>尽量不要在Activity中执行JNI的静态加载和调用</li>\n<li>CMakeLists.txt文件中 <code>add_library</code> 设置的名称与下方 <code>target_link_libraries</code> 以及静态加载JNI的地方 <code>static&#123;System.loadLibrary(&quot;LibraryName&quot;)&#125;</code> 中的 <code>&quot;LibraryName&quot;</code> 三者名称要一致</li>\n<li>C/C++函数的函数名与声明该JNI方法处的方法名要一致</li>\n<li>具体的C/C++函数定义的名称前面的包名和调用函数的类名必须与实际包名和类名一致，并且用下划线 <strong>“_”</strong> 代替点 <strong>“.”</strong> 表示层级关系</li>\n</ol>\n<p>以上。</p>\n<hr>\n<h1 id=\"5-附录-参考指导\"><a href=\"#5-附录-参考指导\" class=\"headerlink\" title=\"5. 附录[参考指导]\"></a>5. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/aidesudi/article/details/68946918\" title=\"@LINK\">【1】Android Studio 2.3使用CMake方式NDK入门（作者：狮村小孩）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/lei_notes/article/details/78548433\" title=\"@LINK\">【2】小白初用Android studio的cMake编译生成.so库并调用（作者：lei_notes）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/xufei5789651/article/details/73694634\" title=\"@LINK\">【3】NDK开发笔记—CMake构建JNI（作者：xufei5789651）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/pkandroid/article/details/67074346\" title=\"@LINK\">【4】AndroidStudio2.3 NDk Cmake配置（作者：Android小屋）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.jianshu.com/p/cb3064450688\" title=\"@LINK\">【5】AS2.2使用CMake方式进行JNI/NDK开发（作者：于连林520wcf）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/qq_34329508/article/details/52330437\" title=\"@LINK\">【6】android ndk 调用C/C++函数（作者：至信）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/shenhuxi_yu/article/details/79788760\" title=\"@LINK\">【7】makefile中的CPPFLAGS LDFLAGS CFLAGS选项详解（作者：shenhuxi_yu）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","CMake","NDK","JNI","CMakeList"]},{"title":"Android——ContentProvider","url":"/post/android/android-contentprovider/","content":"<span id=\"more\"></span>\n\n<p>ContentProvider 使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过 ContentResolver 类从该内容提供者中获取或存入数据。</p>\n<p>只有需要在多个应用程序间共享数据是才需要内容提供者，且必须存储在一个内容提供者中。好处是可以统一数据访问方式。例如通讯录数据被多个应用程序使用。</p>\n<p>ContentProvider 使用 URI（Universal Resource Identifier，统一资源定位符）来唯一标识其数据集，URI 以 <code>content://</code> 作为前缀。通常不会直接使用 ContentProvider 类的对象，大多数是通过 ContentResolver 对象实现对 ContentProvider 的操作。</p>\n<p>一个 ContentProvider 应该包括或重写如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;lsl.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 匹配成功后返回的匹配码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MATCH_CODE = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于判断数据请求的 URI 是否匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UriMatcher uriMatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该 APP 用于共享的数据集</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoData demoData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据改变后通知该 URI</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri NOTIFY_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若匹配不成功则返回 NO_MATCH == -1</span></span><br><span class=\"line\">        uriMatcher = <span class=\"keyword\">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//添加预留需要匹配的 URI</span></span><br><span class=\"line\">        uriMatcher.addURI(AUTHORITY, <span class=\"string\">&quot;data&quot;</span>, MATCH_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        demoData = DemoData.getInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cursor <span class=\"title\">query</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String[] projection,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"meta\">@Nullable</span> String sortOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行数据的增删改查前先验证请求的 URI 和预留的 URI 是否匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            Cursor cursor = demoData.queryData();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getType</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">insert</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            demoData.insertData(values);</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> deleteCount = demoData.deleteData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> deleteCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> updateCount = demoData.updateData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> updateCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyChange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        getContext().getContentResolver().notifyChange(NOTIFY_URI, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他应用中使用 ContentResolver 获取数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ContentResolver contentResolver = getContentObserver();</span><br></pre></td></tr></table></figure>\n\n<p>非必须的可选功能：如果需要对 URI 指向的数据监听变化，则需要重写并注册 ContentObserver，并传入一个 Handler 以在数据发生变化时通过 Handler 通知主线程更新 UI：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler Handler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyContentObserver</span><span class=\"params\">(Handler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(handler);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange, uri);</span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.obj = uri;</span><br><span class=\"line\">        Handler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在需要接收数据的 ContentResolver 中注册该 ContentObserver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;lsl.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri DATA_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\">contentResolver.registerContentObserver(DATA_URI, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DemoContentObserver(handler));</span><br></pre></td></tr></table></figure>\n\n<p>当需要对某个 ContentProvider 提供的数据增删改查时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">Cursor cursor = contentResolver.query(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; cursor.getCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cursor.moveToNext()) &#123;</span><br><span class=\"line\">        dataValue1 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column1&quot;</span>));</span><br><span class=\"line\">        dataValue2 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column2&quot;</span>));</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\">ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn1&quot;</span>, dataValue1);</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn2&quot;</span>, dataValue2);</span><br><span class=\"line\">......</span><br><span class=\"line\">contentResolver.insert(DATA_URI, contentValues);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\">contentResolver.delete(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，对一个 App 共享的数据集，通常是通过 ContentResolver 处理的，而 ContentProvider 更像是提供了一个可以处理数据的接口，其定义了入口 URI，调用增删改查时的具体逻辑，并返回数据处理的结果。</p>\n","categories":["Android"],"tags":["Android","四大组件","ContentProvider"]},{"title":"AndroidStudio打包JAR","url":"/post/android/android-jar/","content":"<span id=\"more\"></span>\n\n<p>前言：做 Android 项目应该经常会用到一些符合自己习惯的工具类，但如果每次都重新写一遍或者复制粘贴既麻烦也不便于保存，所以通常会把一些特别常用的工具类（Log，自定义 View、自定义框架等）打包成 jar 或 aar（aar 除了必须的 class 代码，还会包含所有 res 下的资源文件，jar 仅包含 class 和 Manifests），打包成 aar 比较简单，所以本文仅记载如何打包成 jar 文件。</p>\n<hr>\n<h1 id=\"1-新建需要打包的项目\"><a href=\"#1-新建需要打包的项目\" class=\"headerlink\" title=\"1. 新建需要打包的项目\"></a>1. 新建需要打包的项目</h1><p>为了避免奇奇怪怪的因素影响正式项目，把需要打包的东西新建一个项目。我的工具类以 AndroidLogger 为例：</p>\n<center>\n\n<p><img data-src=\"./new_project.png\" alt=\"新建项目\" title=\"@ASSET\"></p>\n</center>\n\n<p>下一步，选择哪个平台都无所谓，但是在选择最低SDK版本这里，作为工具类，除非是高版本才有的特性（比如 ConstraintLayout），一般在应该设置的低一点以提高平时开发的通用性。本来我设置的是 <code>minimumSDK = 8</code> 结果出来个提示，大致意思是选择的版本太低了，然后一点点调高到 14 的时候消失，Api 14 对应的是 Android 4.0，对于市面上几乎全部的安卓手机而言应该都不止 4.0 了，索性就用 14 作为最低版本吧！</p>\n<p>再下一步，因为本例中所做的工具类是单纯的辅助 Debug，完全没有用到视图功能，所以我选择了 No Activity ，如果有用到的话还是按需要勾选对应的模板即可。</p>\n<center>\n\n<p><img data-src=\"./select_template.png\" alt=\"选择模板\" title=\"@ASSET\"></p>\n</center>\n\n<p>直接 Finish，创建了一个什么都没有的项目。然后在常规的项目目录下新建一个类写工具类的代码，这里以 <code>Logger</code> 为例：</p>\n<center>\n\n<p><img data-src=\"./project_structure.png\" alt=\"项目结构\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-构建Library\"><a href=\"#2-构建Library\" class=\"headerlink\" title=\"2. 构建Library\"></a>2. 构建Library</h1><p>此时这个项目虽然除了这个类以外什么都没有，但是其本质还是一个 Android 项目，打包成 jar 之前需要先把项目改成 Library，然后再进行打包。这里需要改动 <code>build.gradle (Module: app)</code> 的两个地方：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首行把application改为library</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注释或删除defaultConfig中的applicationId字段</span></span><br><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">    <span class=\"comment\">// applicationId &quot;XXXXX&quot;</span></span><br><span class=\"line\">    minSdkVersion <span class=\"number\">14</span></span><br><span class=\"line\">    targetSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    versionCode <span class=\"number\">1</span></span><br><span class=\"line\">    versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\">    testInstrumentationRunner <span class=\"string\">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改完之后如下：</p>\n<center>\n\n<p><img data-src=\"./edit_gradle.png\" alt=\"修改 Gradle\" title=\"@ASSET\"></p>\n</center>\n\n<p>点击 <code>Sync Now</code> 同步 Gradle。完成之后再看一下项目文件夹的图标，已经变成了 Library！</p>\n<center>\n\n<p><img data-src=\"./library_icon.png\" alt=\"Library 项目图标\" title=\"@ASSET\"></p>\n</center>\n\n<p>然后把项目切换成 <code>Project</code> 视图模式：</p>\n<center>\n\n<p><img data-src=\"./switch_view.png\" alt=\"切换项目视图\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"3-创建执行任务\"><a href=\"#3-创建执行任务\" class=\"headerlink\" title=\"3. 创建执行任务\"></a>3. 创建执行任务</h1><p>接下来需要再在 <code>build.gradle (Module: app)</code> 里面加上一段代码，加的位置在 <code>android&#123;&#125;</code> 里面，与 <code>defaultConfig&#123;&#125;</code> 和 <code>buildTypes&#123;&#125;</code> 同级的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">task <span class=\"title\">makeJar</span><span class=\"params\">(type: Copy)</span> </span>&#123;</span><br><span class=\"line\">    delete <span class=\"string\">&#x27;build/libs/logger.jar&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要打包的class文件的目录</span></span><br><span class=\"line\">    from(<span class=\"string\">&#x27;build/intermediates/intermediate-jars/debug/&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 打包完后输出jar文件的目录</span></span><br><span class=\"line\">    into(<span class=\"string\">&#x27;build/&#x27;</span>)</span><br><span class=\"line\">    include(<span class=\"string\">&#x27;classes.jar&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 后面的logger.jar自行命名</span></span><br><span class=\"line\">    rename (<span class=\"string\">&#x27;classes.jar&#x27;</span>, <span class=\"string\">&#x27;logger.jar&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<center>\n\n<p><img data-src=\"./gradle_add_script.png\" alt=\"Gradle 增加打包脚本\" title=\"@ASSET\"></p>\n</center>\n\n<p>解释一下，基本上英文单词都已经表示了啥意思了，主要是说一下 <code>from</code> 里面的东西，老版本的打包脚本这个目录应该是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是老版本的目录</span></span><br><span class=\"line\">from(<span class=\"string\">&#x27;build/intermediates/bundle/debug/&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但是升级了之后 <code>intermediates</code> 文件夹下没有 <code>Bundle</code> 文件夹了，但是意外的发现执行完后会有 <code>intermediate-jars</code> 文件夹，一看名字就知道里面放的是 jar 包，点进去后发现确实如此，所以就改成了这个文件夹。这时大家可能会发现连 <code>intermediate-jars</code> 文件夹也没有啊！放心不是我在耍你们，到这一步为止还没有这个目录，需要等我们执行完Task之后才有。</p>\n<p>另外，<code>into</code> 目录也是可以自定的，你想输出到哪就写哪，但是最好选择一个已存在的目录，印象中以前在 <code>app\\build\\</code> 下有一个 <code>libs</code> 文件夹，现在发现没了不知道是不是自己记错了，所以干脆输出到 <code>build</code> 文件夹的根目录下了。<code>into</code> 这一步的路径和第一步 <code>delete</code> 的路径配合使用，只是为了防止目标文件夹里已经有了 jar 包导致写入失败而已。<code>rename</code> 就更简单了，只是需要注意 <code>`classes.jar`</code>这个不要改动。</p>\n<p>再点击 <code>Sync Now</code> 同步一下，等待同步完后 <code>Rebuild Project</code> 一下，然后打开 AndroidStudio 下面的一排工具栏处找到 <code>Terminal</code> 工具：</p>\n<center>\n\n<p><img data-src=\"./open_inner_terminal.png\" alt=\"打开 AS 自带 Terminal\" title=\"@ASSET\"></p>\n</center>\n\n<p>执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第 1 个命令</span></span><br><span class=\"line\">gradlew makeJar</span><br></pre></td></tr></table></figure>\n\n<p>注意这里是 <code>gradlew</code> 不是 <code>gradle</code> ，后面的 <code>makeJar</code> 与 <code>build.gradle (Module: app)</code> 中加的那段代码的。</p>\n<p>等待执行完后，再执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第 2 个命令</span></span><br><span class=\"line\">task makeJar</span><br></pre></td></tr></table></figure>\n\n<p>名称相同（可以自定义），然后回车运行，等他读条执行完毕，如果显示绿色的 <font color=#00ff00>BUILD SUCCESSFUL</font> 就说明成功了。</p>\n<center>\n\n<p><img data-src=\"./terminal_successful.png\" alt=\"命令执行成功\" title=\"@ASSET\"></p>\n</center>\n\n<p>再看一下 <code>build</code> 目录下，出现了 <code>Logger.jar</code>（没有的先折叠 <code>build</code> 目录再重新展开看看），成功打包！</p>\n<center>\n\n<p><img data-src=\"./create_jar_successful.png\" alt=\"成功打包 jar\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"4-打包成功\"><a href=\"#4-打包成功\" class=\"headerlink\" title=\"4. 打包成功\"></a>4. 打包成功</h1><p>复制到硬盘上就能拿来用了，实测可以导入到其他工程中使用。说个题外话，如果好奇心比较重去看了一眼现在的 <code>intermediates</code> 目录下的文件，会发现依然没有 <code>intermediate-jars</code> 文件夹，也没有 <code>bundle</code> 文件夹，但是没所谓啦！反正已经获取到 jar 包了，如果强迫症非要看一眼 <code>intermediate-jars</code> 文件夹的话也不是没有办法，只需要在 <code>Terminal</code> 命令行中重新执行一次 <code>gradlew makeJar</code> 并成功构建后即可！完成以后再看 <code>build\\intermediates\\</code> 目录下就有啦！</p>\n<center>\n\n<p><img data-src=\"./intermediate_jars_folder.png\" alt=\"intermediate-jars 目录\" title=\"@ASSET\"></p>\n</center>\n\n<p>有这个强迫症的 <del>（比如我）</del>，得改！如果在第一次执行完之后没有输出 jar 的，也可以尝试再次执行。</p>\n","categories":["Android"],"tags":["Android","Jar","打包"]},{"title":"Android-Looper","url":"/post/android/android-looper/","content":"<span id=\"more\"></span>\n\n<p>前言：本文是针对 Looper 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h1 id=\"1-Looper简介\"><a href=\"#1-Looper简介\" class=\"headerlink\" title=\"1. Looper简介\"></a>1. Looper简介</h1><p>首先看一下源码中对 Looper 的注释说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Class used to run a message loop for a thread.  Threads by default do</span></span><br><span class=\"line\"><span class=\"comment\">  * not have a message loop associated with them; to create one, call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #prepare&#125; in the thread that is to run the loop, and then</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop&#125; to have it process messages until the loop is stopped.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;Most interaction with a message loop is through the</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Handler&#125; class.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,</span></span><br><span class=\"line\"><span class=\"comment\">  * using the separation of &#123;<span class=\"doctag\">@link</span> #prepare&#125; and &#123;<span class=\"doctag\">@link</span> #loop&#125; to create an</span></span><br><span class=\"line\"><span class=\"comment\">  * initial Handler to communicate with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  *  class LooperThread extends Thread &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *      public Handler mHandler;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *      public void run() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.prepare();</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          mHandler = new Handler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *              public void handleMessage(Message msg) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *                  // process incoming messages here</span></span><br><span class=\"line\"><span class=\"comment\">  *              &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *          &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.loop();</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *  &#125;&lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Looper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * API Implementation Note:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * This class contains the code required to set up and manage an event loop</span></span><br><span class=\"line\"><span class=\"comment\">     * based on MessageQueue.  APIs that affect the state of the queue should be</span></span><br><span class=\"line\"><span class=\"comment\">     * defined on MessageQueue or Handler rather than on Looper itself.  For example,</span></span><br><span class=\"line\"><span class=\"comment\">     * idle handlers and sync barriers are defined on the queue whereas preparing the</span></span><br><span class=\"line\"><span class=\"comment\">     * thread, looping, and quitting are defined on the looper.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致翻译：</p>\n<p>（1）Looper 被 Thread 用于运行一个消息循环。一个线程默认不具有与之关联的消息循环（消息队列），如果想要为线程创建一个消息队列，在该线程中调用 <code>Looper.prepare()</code>，然后再调用 <code>Looper.loop()</code> 来启动消息处理循环，该循环将一直运行直到被终止。</p>\n<p>（2）大多数情况下，和消息循环的交互是通过 <code>Handler</code> 完成的。</p>\n<p>（3）以下代码是实现一个具有消息循环的线程的典型方式，通过分别调用 <code>prepare()</code> 和 <code>loop()</code> 来创建一个初始化的 <code>Handler</code> 并用于和 <code>Looper</code> 交互：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）Looper 类中包含某些代码，是需要通过 MessageQueue 来设置和管理事件循环的。影响消息队列的状态的 API 应该在 MessageQueue 或 Handler 中而不是在 Looper 本身定义，例如 <code>Idle Handler</code> 和同步障栅是在消息队列中定义的，而 Thread 的前期准备、消息循环、退出则是在 Looper 中完成的。</p>\n<p>以上内容可能涉及到 Handler 或 Message 的内容，可以通过系列对应的文章查阅。</p>\n<hr>\n<h1 id=\"2-Looper初始化和实例化\"><a href=\"#2-Looper初始化和实例化\" class=\"headerlink\" title=\"2. Looper初始化和实例化\"></a>2. Looper初始化和实例化</h1><p>Looper 类光是从名字就能看出来作用，通过之前对 Handler 的源码分析可以知道，Handler 构造时，可以手动传入一个 Looper 对象和处理消息的回调 Callback，用来与 Handler 绑定，此时这个 Handler 则会用来处理该 Looper 的消息队列中的消息，并且与该 Looper 处在同一线程，而默认构造方法则最终都调用了以下构造方法，并且内部给 Looper 传入了一个 <code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到默认情况下会调用 <code>Looper.myLooper()</code>，再查看一下这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Return the Looper object associated with the current thread.  Returns</span></span><br><span class=\"line\"><span class=\"comment\">  * null if the calling thread is not associated with a Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Looper <span class=\"title\">myLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadLocal.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法也就是从 <code>ThreadLocal</code> 中获取一个对象，ThreadLocal 的相关内容在系列文章中已有介绍，简单来说，首先需要向当前线程中 <code>set()</code> 一个对象，才能 <code>get()</code> 出来，并且 ThreadLocal 中存放的对象是和线程绑定的，不同线程只能 <code>get()</code> 到该线程自己 <code>set()</code> 进去的对象，再看一下这个 <code>sThreadLocal</code> 在一开始的声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>说明存取的都是 Looper 对象。Looper 其实有两个 <code>prepare()</code> 方法，一个无参，另一个就是以下这个有一个布尔类型参数的，但无参的 <code>prepare()</code> 最终也是调用的有参这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Initialize the current thread as a looper.</span></span><br><span class=\"line\"><span class=\"comment\">  * This gives you a chance to create handlers that then reference</span></span><br><span class=\"line\"><span class=\"comment\">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #quit()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Looper.prepare(boolean)</code> 方法中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里就清楚了，Looper 在调用 <code>prepare()</code> 方法后，会往对应的 ThreadLocal 中存放一个实例化的 Looper 对象，而 <code>Looper.myLooper()</code> 则是从 ThreadLocal 中取出这个对象，因此如果一个 Looper 没有先调用 <code>prepare()</code> 就直接使用会报错。但是为什么不直接通过 <code>new</code> 来生成实例对象呢？因为 Looper 的构造方法是私有的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这么设计的好处我个人理解为：① Looper、Handler、Thread 这些类都是由系统进行资源管理的，用户不应具有太大的修改权限，并且 Looper 类是 <code>final</code> 修饰的，也不允许用户继承重写。② Looper 必须和指定的线程绑定，指定调用 <code>prepare()</code> 方法可以强调这一特性。③ Looper 只能和一个线程绑定，使用 ThreadLocal 管理，采用 <code>new</code> 的方式可能会有多线程的问题。</p>\n<hr>\n<h1 id=\"3-Looper总结\"><a href=\"#3-Looper总结\" class=\"headerlink\" title=\"3. Looper总结\"></a>3. Looper总结</h1><p>其实到这里 Looper 的工作原理和流程就已经可以总结了：</p>\n<ul>\n<li>① Looper 是一个消息循环。</li>\n<li>② Looper 内有成员变量 MessageQueue，并通过它循环取出、派发消息进行事件处理。</li>\n<li>③ Looper 无法通过构造方法实例化，而是通过 <code>prepare()</code> 方法，并在内部调用了 <code>myLooper()</code> 方法来实例化一个 Looper 对象，且会和线程绑定，通过对应线程的 ThreadLocal 来存取。</li>\n<li>④ Looper 所在的线程决定了 Handler 处理消息时所在的线程。实例化 Handler 时，可以自行创建某线程的 Looper 实例化对象，并将其与 Handler 绑定，则 Handler 处理的消息即来自于 Looper 所在的线程。</li>\n<li>⑤ 线程默认是不具有消息循环的，也即默认情况下一个 Thread 是不会维护 Looper 的，通过继承重写 Thread，并在其中调用 <code>Looper.prepare()</code> 来创建消息循环，再通过 <code>Looper.loop()</code> 来开启循环。</li>\n</ul>\n<p>但在实际开发中其实有些比较常见的问题：</p>\n<p>（1）平时用 Handler 处理消息时，并没有调用 <code>Looper.prepare()</code> 或通过其手动创建一个 Looper 对象，但依然可以正常处理消息。这是因为，Android 的主线程即 UI 线程，有一定的特殊性，整个 App 过程中仅允许存在一个 UI 线程，而 App 的主线程对应在 <code>ActivityThread.main()</code> 方法，其也是整个 App 的入口方法，在这个方法里面就生成了 Looper 的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure>\n\n<p>对应 Looper 中的源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Initialize the current thread as a looper, marking it as an</span></span><br><span class=\"line\"><span class=\"comment\">  * application&#x27;s main looper. The main looper for your application</span></span><br><span class=\"line\"><span class=\"comment\">  * is created by the Android environment, so you should never need</span></span><br><span class=\"line\"><span class=\"comment\">  * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然本质上仍然是通过 <code>prepare(boolean)</code> 方法生成了一个成员变量 <code>sMainLooper</code>，但是加了类锁，并且只允许创建一次，由于 App 运行期间，主线程一直存在，因此主线程的对应的 Looper 实例对象 <code>sMainLooper</code> 在 App 运行期间有且仅有一个，所以在主线程中使用 Handler 无需手动创建 Looper 实例对象以及显式调用 <code>prepare()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程中实例化 Handler</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(<span class=\"keyword\">new</span> Handler.Callback() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（2）即使在子线程中，也可以不显式调用 <code>prepare()</code> 方法，这时 Handler 的初始化方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@注：这里是 <code>void handleMessage(Message)</code>和（1）中使用匿名 Callback 的 <code>boolean handleMessage(Message)</code> 不同。</p>\n</blockquote>\n<p>这里不需要显式调用 <code>prepare()</code> 的原因是给 Handler 传了一个 <code>Looper.getMainLooper()</code> 的参数，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Returns the application&#x27;s main looper, which lives in the main thread of the application.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Looper <span class=\"title\">getMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sMainLooper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到实际上就是返回了主线程的 <code>sMainLooper</code>，所以也不需要手动创建 Looper 实例对象。</p>\n<p>（3）利用 <font color=#EB6D39>“Handler 处理消息所在线程由其实例化时传入的 Looper 对象决定”</font> 这一特性，可以衍生出主线程和子线程之间交互的方式：</p>\n<ul>\n<li>① 子线程向主线程发送消息：在子线程实例化 Handler 时传入 <code>Looper.getMainLooper()</code> 参数。</li>\n<li>② 主线程向子线程发送消息：在主线程实例化 Handler 时传入一个在子线程中调用过 <code>prepare()</code> 方法已初始化的 Looper 对象。</li>\n</ul>\n<p>针对以上情形 ②，主线程开启子线程后向下执行，如果主线程发送消息的时间较早，可能子线程还没有完成对 Looper 的实例化，则会导致空指针异常，此时可以将子线程用 <code>HandlerThread</code> 类代替，实例化时传入一个 <code>String</code> 类型的线程标记名，HandlerThread 不能重写 <code>run()</code> 方法，当然也不需要显式调用 <code>prepare()</code> 和 <code>loop()</code>，通过 <code>HandlerThread.getLooper()</code> 即可获取 Looper 实例对象。</p>\n","categories":["Android"],"tags":["Android","Looper","源码"]},{"title":"Android-Matrix入门","url":"/post/android/android-matrix/","content":"<span id=\"more\"></span>\n\n<p>前言：最近项目中遇到了一个动画展示的需求——在不改变View的基础上，对“画布”进行动画变换，包括缩放、位移等，传统的 Animation 和 Animator 已经不能满足，于是开始着手接触 Matrix，将 Matrix 的入门知识与基础用法记录于本文。</p>\n<hr>\n<h1 id=\"1-Matrix初步认识\"><a href=\"#1-Matrix初步认识\" class=\"headerlink\" title=\"1. Matrix初步认识\"></a>1. Matrix初步认识</h1><p>Matrix：在英语里就是矩阵的意思，在Android中可以用来对控件在屏幕上的空间位置进行设置，Matrix在Android中是一个3×3的矩阵，但是是由长度为9的一维数组表示的，可以通过getMatrix().getValues();获取一个控件的矩阵，返回值是一个float[]数组，长度为9位：\n　　</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> matrixValues = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[<span class=\"number\">9</span>];</span><br><span class=\"line\">matrixValues = view.getMatrix().getValues();</span><br></pre></td></tr></table></figure>\n\n<p>但是具体Matrix矩阵这个东西有什么用呢？先来看一下这个3×3矩阵在逻辑上的结构如何：</p>\n<center>\n\n<p><img data-src=\"./matrix_structure.png\" alt=\"Matrix结构\" title=\"@ASSET\"></p>\n</center>\n\n<p>解释一下：</p>\n<ul>\n<li><strong>MSCALE</strong> 就是缩放Scale，也就是控件的放大和缩小。</li>\n<li><strong>MSKEW</strong>  就是Skew错切，是控件X（或Y）轴不变，Y（或X）轴根据比例平移形成的变化。</li>\n<li><strong>MTRANS</strong> 就是Translate平移，是控件平移指定距离后的图像</li>\n<li><strong>MPERSP</strong> 的原文为Perspective透视，但是没有用过，也没有找到相关资料，以后再补全。</li>\n</ul>\n<hr>\n<h1 id=\"2-Matrix的基本简介\"><a href=\"#2-Matrix的基本简介\" class=\"headerlink\" title=\"2. Matrix的基本简介\"></a>2. Matrix的基本简介</h1><p>去掉不熟悉的Perspective透视，从其他三个基本参数来看，不难看出Matrix的基本功能如下：</p>\n<ol>\n<li><strong>Translate平移</strong></li>\n<li><strong>Scale缩放</strong></li>\n<li><strong>Skew错切</strong></li>\n<li><strong>Rotate旋转</strong></li>\n</ol>\n<p>这四种变换都分别有三种实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前乘</span></span><br><span class=\"line\">preTranslate();</span><br><span class=\"line\">preScale();</span><br><span class=\"line\">preSkew();</span><br><span class=\"line\">preRotate();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置</span></span><br><span class=\"line\">setTranslate();</span><br><span class=\"line\">setScale();</span><br><span class=\"line\">setSkew();</span><br><span class=\"line\">setRotate();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后乘</span></span><br><span class=\"line\">postTranslate();</span><br><span class=\"line\">postScale();</span><br><span class=\"line\">postSkew();</span><br><span class=\"line\">postRotate();</span><br></pre></td></tr></table></figure>\n\n<p>对于这三种实现方式，很多地方的解释都是从数学矩阵的角度来解释：前乘、后乘，但是对于我这种一看数学就头大的人来说，看完了也没明白是咋回事，其实非常简单，前乘就是“先做”，后乘就是“后做”，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先平移，再缩放</span></span><br><span class=\"line\">preTranslate(x, y);</span><br><span class=\"line\">postScale(<span class=\"number\">2f</span>, <span class=\"number\">2f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先缩放，再平移</span></span><br><span class=\"line\">preScale(<span class=\"number\">2f</span>, <span class=\"number\">2f</span>);</span><br><span class=\"line\">postTranslate(x, y);</span><br></pre></td></tr></table></figure>\n<p>这样实现的效果就是先放大再平移了，这两种方式是有区别的，在前面引用的博客中有相应的详细介绍。而设置<code>setXXX()</code>方式，则是先清除并重置Matrix矩阵，再进行指定变换。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">preTranslate(x, y);</span><br><span class=\"line\">setRotate(<span class=\"number\">50f</span>);</span><br><span class=\"line\">postScale(<span class=\"number\">2f</span>, <span class=\"number\">2f</span>);</span><br></pre></td></tr></table></figure>\n<p>这个变换最后实现的效果就只有：先旋转50度，再放大2倍了，因为<code>setRotate()</code>执行后，会先将matrix对象重置为初始的单位矩阵，然后再执行旋转50度，也即<code>preTranslate()</code>方法没起作用。：</p>\n<center>\n\n<p><img data-src=\"./matrix_identity.png\" alt=\"Matrix单位矩阵\" title=\"@ASSET\"></p>\n</center>\n\n<p>前面三个都好解释，就是分别对应了三个矩阵内的元素，但是旋转怎么说？旋转的具体实现其实是直接调用Matrix的<code>setRotate(angle)</code>方法，其中angle代表需要旋转的角度，需要注意的是，默认的<code>setRotate(angle)</code>方法是顺时针转动。</p>\n<hr>\n<h1 id=\"3-Android动画变换与图像变换\"><a href=\"#3-Android动画变换与图像变换\" class=\"headerlink\" title=\"3. Android动画变换与图像变换\"></a>3. Android动画变换与图像变换</h1><p>在Android开发中，Matrix经常用来做图像的变换操作，这里要提一下所谓的图像变换。</p>\n<p>举个例子，我们都知道当想要将一个视图旋转时，可以给这个View设置一个Animation，然后实现旋转的效果，并且能实现动态效果，能控制动画的时间、方式、多重动画或者更高级的视觉效果等，但是有时我们并不想将这个View整个一起做变换，而只是想要变化View里面包含的图像时，就可以利用这个View的Matrix来实现，举个栗子！</p>\n<p>Demo布局很简单，就是一个ImageView以及右边一个Button，通过Button来控制动画。设置ImageView的宽高均为200dp，为了更直观的展现动画变换与图像变换的区别，给这个ImageView设置一个背景色。\n　　</p>\n<center>\n\n<p><img data-src=\"./image_initial.png\" alt=\"初始状态\" title=\"@ASSET\"></p>\n</center>\n\n<p>如果我们用动画实现放大一倍，很简单</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化控件</span></span><br><span class=\"line\">ImageView ivImage = (ImageView) findViewById(R.id.ivImage);</span><br><span class=\"line\"><span class=\"comment\">//设置一个缩放动画</span></span><br><span class=\"line\">ScaleAnimation scaleAnimation = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1f</span>, <span class=\"number\">2f</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>,</span><br><span class=\"line\">\t\t\t\t\t\tAnimation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">\t\t\t\t\t\tAnimation.RELATIVE_TO_SELF, <span class=\"number\">0.5f</span>);</span><br><span class=\"line\">scaleAnimation.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">//开始缩放动画</span></span><br><span class=\"line\">ivImage.startAnimation(scaleAnimation);</span><br></pre></td></tr></table></figure>\n<p>这样就完成了一个ImageView放大一倍的动画效果。小小地解释一下ScaleAnimation的参数：<br><code>ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)</code></p>\n<p>参数有一点多，慢慢分析：</p>\n<ol>\n<li><strong>fromX（Y）</strong>：动画开始前X（Y）的缩放值，取1表示从当前大小开始。</li>\n<li><strong>toX（Y）</strong>：动画要将控件的X（Y）缩放的值，取2表示放大到现在的两倍。</li>\n<li><strong>pivotXType（pivotYType）</strong>：动画在X（Y）轴上相对控件的位置类型。说白了就是这个动画是基于哪个坐标轴进行缩放，例如上面代码用的RELATIVE_TO_SELF，代表这个缩放是基于自身的坐标轴进行的。</li>\n<li><strong>pivotXValue（pivotYValue）</strong>：动画在所选坐标轴的X（Y）轴的哪个位置作为缩放原点。</li>\n</ol>\n<p>看完参数，<code>fromX（Y）</code>和<code>toX（Y）</code>就很简单了，主要是解释一下后面四个，还是用例子说话。代码中，<code>pivotXValue</code>和<code>pivotYValue</code>都是0.5f，则说明是在中间位置，上面<code>pivotType</code>设定的是<em>RELATIVE_TO_SELF</em>，那么这个中间位置就是ImageView自己的中间位置了，如果上面<code>pivotType</code>设定的是<em>RELATIVE_TO_PARENT</em>，那么就是以父布局的中点作为缩放中心，在本例中父布局就是根布局，那么这个效果就是以屏幕中心作为缩放中心了，这么解释或许会比较直观。</p>\n<p>需要说明一点的是，在Android中，默认情况下坐标原点位于控件左上角，这个位置是(0,0)，也就是说原点相对于整个控件的长度比例为0，控件的最右端为该控件在X轴上的末端，所有处在最右端的点相对于控件的长度比例是1，控件的最下端为该控件在Y轴上的末端，所有处在最下端的点相对于控件的长度比例也是1，这就解释了为什么<code>pivotXValue</code>和<code>pivotYValue</code>均设为0.5f时是以该控件中心点作为缩放中心，如果是两个0.0f，则是以左上角作为缩放中心，两个1f，则是以右下角作为缩放中心。特别强调一点，对于矩形这样的规则图形，右边一条线上的所有点X轴上长度比例都为1，但对于一个不规则图形（例如自定义View等），长度比例为1的点是位于最末端的点。</p>\n<p>回到Demo中，做完这个动画后，我们可以看到界面的变化：</p>\n<center>\n\n<p><img data-src=\"./animate_by_animation.gif\" alt=\"通过Animation变换\" title=\"@ASSET\"></p>\n</center>\n\n<p>但是我们也发现，放大后的ImageView与Button已经有一部分重合了，如果是以原点为缩放中心放大的话，覆盖的范围会更大，这对于某些时候是不合我们需求的。从动画的效果上来看，我们可以把动画变换——Animation类型的变换归类为：控件视图级别的变换，也就是说ImageView设定的src资源画面的变换是基于ImageView本身的变换，再通俗一点，我们的电脑在显示一个图片，我们想要旋转这个图片，如果采用Animation的方式，旋转的实际效果是：扛着显示器旋转，而图片相对显示器是不变的。而在很多时候，我们只是想要图片本身变换，而显示器不动，这时我们就要利用控件的变换矩阵Matrix了！（终于切回正题了？）<br>下面是Matrix变换的代码，短短几行，先看一遍代码再来看效果如何：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ImageView的缩放类型ScaleType为Matrix时才能进行Matrix缩放</span></span><br><span class=\"line\"><span class=\"comment\">//也可以在xml中设置scale_type属性，不设置时默认是fill_center</span></span><br><span class=\"line\">ivImage.setScaleType(ImageView.ScaleType.MATRIX);</span><br><span class=\"line\">Matrix matrix = <span class=\"keyword\">new</span> Matrix();</span><br><span class=\"line\">matrix.setScale(<span class=\"number\">2f</span>, <span class=\"number\">2f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ivImage.setImageMatrix(matrix);</span><br></pre></td></tr></table></figure>\n\n<p>代码非常简单，就是创建一个Matrix对象（新的Matrix对象默认为一个单位矩阵），再设置这个matrix的参数为放大两倍，最后把matrix的效果应用到ImageView中，逻辑非常清楚。效果如何请看动图：</p>\n<center>\n\n<p><img data-src=\"./animate_by_matrix.gif\" alt=\"通过Matrix变换\" title=\"@ASSET\"></p>\n</center>\n\n<p>可以看到Android小人确实放大了两倍，但是黄色背景区域的ImageView还是原本的大小，对其他控件的控件布局没有任何影响，也完美的符合了一些情况下的需求，当然并不是说Matrix比Animation更好，只是这两者各有所长，对于一些复杂的变换、多边形等，对于Matrix来说，尽管可以通过分解的方式实现，但是工作量也会增加很多，这时就不如选择Animation来完成，还能避免一些UI线程上的错误。</p>\n<p>同时上面的两个动图也很直观的表示了，Animation是具有动画效果的，而Matrix是一个点到点、状态到状态的变化，当我们需要一些友好的视觉效果时，单用Matrix就不能满足需求了，但是我们就毫无办法了吗？并不是的，对Android有一点了解的人应该都知道，Android实现动画的方式就是“帧播放”，也就是多个不同状态下的单个帧快速播放形成的连续画面，知道了这个原理想要实现Matrix的动画就很简单了。首先最直观的思路就是利用循环，还是以放大图片作为例子，可以先用一个<code>while</code>或者<code>for</code>包裹Matrix，然后在循环中每次放大一点点，然后<code>sleep()</code>一小段时间，来达到一个视觉上的模拟动画效果。但是这样的做法非常低级也很不友好，容易造成主线程阻塞，或者在循环内出现异常导致<strong>ANR（Application Not Responding程序无响应崩溃）</strong>，改善这个问题的一个简单思路是利用Handler和Thread在子线程中进行处理，同时回调UI线程进行界面更新，但是这样做不仅效率低，对于应用而言也不具有美观性，因此，想要用Matrix达到Animation的效果，可以配合Android自带的一个属性动画工具：<font color=#EB6D39>ObjectAnimator</font>！ObjectAnimator的原理就是由你自己定义多个状态的变化趋势，然后由Android系统自动替你完成状态与状态间变化的过程，来实现动画的效果。</p>\n<hr>\n<h1 id=\"4-Matrix总结\"><a href=\"#4-Matrix总结\" class=\"headerlink\" title=\"4. Matrix总结\"></a>4. Matrix总结</h1><p>上文对Matrix进行了一些基本介绍和简单的用法实例，总结一下：Matrix用来定义控件内包含画面的变换状态，相比Animation的持续动画效果来说，Matrix更加偏向于一个确定的状态，在需要连续展示一个变化过程的时候，Animation是更好的选择，而当我们只需要显示一个特定的画面状态并且不希望在改变画面时影响控件本身，就应该选择Matrix啦！同时Matrix也并不是不能实现动画效果，在我们对控件和控件内某个单独的属性需要控制时，Matrix都是非常好的选择，利用Matrix + ObjectAnimator再配合上自定义View，一样能达到非常好的动画效果！</p>\n<hr>\n<h1 id=\"5-ObjectAnimator——属性动画\"><a href=\"#5-ObjectAnimator——属性动画\" class=\"headerlink\" title=\"5. ObjectAnimator——属性动画\"></a>5. ObjectAnimator——属性动画</h1><p>最后，在下一篇博客中将会对ObjectAnimator做一个比较简单的介绍，详情点击：<a href=\"/post/Android/android-objectanimator-basic/android-objectanimator-basic/\" title=\"@LINK\">Android动画——属性动画：ObjectAnimator</a></p>\n<hr>\n<h1 id=\"6-附录-参考指导\"><a href=\"#6-附录-参考指导\" class=\"headerlink\" title=\"6. 附录[参考指导]\"></a>6. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/a62321780/article/details/51278505\" title=\"@LINK\">【1】Android Matrix的使用与自定义动画（作者：西电吴同学）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/u010838555/article/details/44307615\" title=\"@LINK\">【2】setScale,preScale和postScale的区别（作者：Groople）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/flowingflying/article/details/38304057\" title=\"@LINK\">【3】Pro Android学习笔记（一零九）：2D动画（4）：view的Matrix（作者：恺风）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/legend12300/article/details/51868071\" title=\"@LINK\">【4】Android 图形处理特效 Matrix 的set 、 pre、post方法的区别和使用（作者：Richard_tan0113）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/flash129/article/details/8234599\" title=\"@LINK\">【5】Android Matrix详解（作者：flash129）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","Matrix","ImageView","动画"]},{"title":"Android-消息处理机制","url":"/post/android/android-message-handling/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-消息处理机制基本原理\"><a href=\"#1-消息处理机制基本原理\" class=\"headerlink\" title=\"1. 消息处理机制基本原理\"></a>1. 消息处理机制基本原理</h1><p>消息处理机制中涉及到的关键细化内容在以下系列文章中：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<p>Android 消息处理机制总结：</p>\n<p>Handler 处理消息所在的线程，和初始化该 Handler 时使用的 Looper 有关，Handler 的构造方法中调用了 <code>mLooper = Looper.myLooper();</code>，并在 <code>Looper.myLooper()</code> 内部通过 ThreadLocal 获取了与当前线程绑定的 Looper 实例对象。一个线程默认不具有处理消息的能力，需要通过调用 <code>Looper.prepare()</code> 来初始化线程的消息处理功能，并调用 <code>Looper.loop()</code> 开启消息循环。如果当前线程没有调用 <code>Looper.prepare()</code>，则发送消息会报错 RuntimeException。</p>\n<p>MessageQueue 是 Looper 的一个成员变量，消息队列的本质不是队列而是单链表，Handler 所有发送消息的方法最终都是调用的 <code>sendMessageAtTime</code>，并在内部调用了 <code>enqueueMessage()</code>，每个消息根据发送时设置的时间顺序添加到 MessageQueue 的单链表中。</p>\n<p>Handler 发送消息时，会赋值 <code>Message.targer = this;</code> 将自己与 Message 绑定，因此 Looper 在循环取出消息时，根据 <code>Message.target</code> 取出并发送给该 Handler 实例对象处理。</p>\n<p>Android 的主线程即 UI 线程在一个 App 进程中唯一，在 <code>ActivityThread.main()</code> 方法中调用了 <code>Looper.prepareMainLooper()</code>，因此在主线程在运行时已经开启了消息循环，因此在主线程中使用 Handler 不需要显示调用 <code>Looper.prepare()</code> 和 <code>Looper.loop()</code>，并且在子线程中更新 UI 时，如果使用 <code>Looper.getMainLooper()</code> 来实例化 Handler，则消息都会被发送到主线程。</p>\n<p>因此可以利用消息处理机制的特性，把接收线程的 Looper 传给发送线程并用来初始化 Handler，即可实现进程间通信。但使用该方法实现主线程向子线程通信时可能发生异常，这是因为主线程开启子线程后就向下执行，主线程的发送 Handler 初始化时，子线程的接收 Looper 可能还没有完成实例化或 <code>prepare()</code> 或 <code>loop()</code> 等初始化操作，导致空指针或 RuntimeException。为此可以使用 HandlerThread 类替代普通的子线程，实例化时只需传入一个 String 作为线程名即可。但 HandlerThread 不能重写 <code>run()</code> 方法，当然也无需手动调用 <code>prepare()</code> 和 <code>loop()</code> 初始化。</p>\n<hr>\n<h1 id=\"2-主线程中的消息处理机制\"><a href=\"#2-主线程中的消息处理机制\" class=\"headerlink\" title=\"2. 主线程中的消息处理机制\"></a>2. 主线程中的消息处理机制</h1><p>思考一个问题：根据上面的分析可知，一个线程在处理消息时，是通过 <code>for</code> 循环来不断轮询 MessageQueue 的，但是在主线程中，如果消息耗时或出现异常，就会导致 UI 更新延迟甚至 <code>main()</code> 方法异常退出，那主线程的消息处理机制是如何避免这些情况的呢？</p>\n<p>未完待续</p>\n","categories":["Android"],"tags":["Android","消息处理机制"]},{"title":"Android-Message","url":"/post/android/android-message/","content":"<span id=\"more\"></span>\n\n<p>前言：本文是针对 Message 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h1 id=\"1-Message的种类\"><a href=\"#1-Message的种类\" class=\"headerlink\" title=\"1. Message的种类\"></a>1. Message的种类</h1><p>在 Android 中，Message 是使用 Handler 时不可避免的一个类，通常都会使用 Message 来发送一些“消息”，这个“消息”有自己的标识 <code>what</code>，有自己的两个通用参数 <code>arg1</code> 和 <code>arg2</code>，有自己的具体消息内容 <code>obj</code>，似乎消息就是一个通过标识传递数据的功能，但其实里面大有门道。</p>\n<p>在使用 Message 时，默认情况下越早发送的消息越早被处理，这是因为默认的消息即为同步消息，而实际上消息有三种：同步消息、异步消息、障栅消息：</p>\n<ul>\n<li><ol>\n<li>在默认情况下均为 <strong>同步消息</strong>，同步消息的意义即：除非指定 Message 的执行时间，否咋 Message 会以队列（FIFO，先进先出）的机制顺序处理消息。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>异步消息则不受顺序的限制，即使在同步消息阻塞的情况下，依然可以处理异步消息。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>障栅消息本身并不携带额外的数据，可以看成是一个阻塞器，它用于阻塞同步消息而对异步消息没有影响，可以看成是让异步消息优先执行的一个调节器。</li>\n</ol>\n</li>\n</ul>\n<p>而消息是否同步，并不是由 Message 本身决定的，而是由处理消息的 Handler 决定的（详细可参考：<a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a>），下文将详细介绍这 3 种消息。</p>\n<hr>\n<h1 id=\"2-同步消息\"><a href=\"#2-同步消息\" class=\"headerlink\" title=\"2. 同步消息\"></a>2. 同步消息</h1><p>在默认初始化 Handler 时，不论是调用无参构造方法，还是传递 Looper 的构造方法，或者重写回调的构造方法，其实源码里都有这么一个内部调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内部调用了有布尔值的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略了其他几个带布尔值的构造方法，详细可查源码</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>这些带布尔值的内部构造方法，其布尔值含义都是一样的：<code>async</code>，是否异步。可以看到，当我们实例化 Handler 没有显式传入一个 <code>true</code> 作为参数时，默认调用的内部构造方法均使用了 <code>false</code> 作为参数，也即：<strong>默认情况下不使用异步</strong>。</p>\n<hr>\n<h1 id=\"3-异步消息\"><a href=\"#3-异步消息\" class=\"headerlink\" title=\"3. 异步消息\"></a>3. 异步消息</h1><p>如果需要使用异步消息，则需要实例化 Handler 时手动指定 <code>async</code> 参数。从源码可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码处，这 3 个可以指定 <code>async</code> 的构造方法，均添加了 <code>@hide</code> 注解，也即虽然其定义为 <code>public</code> 方法，但在外部无法直接调用，需要使用反射的方式，而除了两个参数的构造方法外，另外两个还有 <code>@UnsupportedAppUsage</code> 注解，该注解的含义是限制了最大可以调用该方法的 API 等级，不过我本人还没有试过其限制的最大 API 到底是多少。</p>\n<p>查看第二个方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释里面很清楚地写到，该方法使用当前线程的 Looper 来实例化 Handler。手动指定该方法的参数 <code>async = true</code>，即可使得该 Handler 所发送的消息均为 <strong>异步消息</strong>。</p>\n<hr>\n<h1 id=\"4-障栅消息\"><a href=\"#4-障栅消息\" class=\"headerlink\" title=\"4. 障栅消息\"></a>4. 障栅消息</h1><p>障栅消息的本质也只是一个 Message，但是其 <code>target</code> 为 <code>null</code>（其他消息不能设置为 <code>null</code>，否则会报异常），且 <code>arg1</code> 设置为一个从 0 开始每次自增 1 的 token，用于标识不同的障栅消息。前面已经介绍到，障栅消息的作用是阻塞添加到消息队列的时间比它晚的同步消息，因此障栅消息添加到队列时，会根据添加的时间 <code>when</code> 来插入到对应的消息位置。为了便于理解，这里把 <code>when</code> 比障栅消息小的最后一个消息（即障栅消息前一个）称为 LAST，把这个消息的下一个（即障栅消息后一个）称为 ONEMORE。</p>\n<p>（1）在 MessageQueue 中发送障栅消息的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其调用了另一个私有同名方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enqueue a new sync barrier token.</span></span><br><span class=\"line\">    <span class=\"comment\">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mNextBarrierToken 从 0 开始</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"comment\">// 障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 中间变量，用于记录比障栅消息早的最后一个消息（障栅消息的前一个）</span></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 当前第一条消息</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息比障栅消息更早，则不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 用 prev 记录当前消息 p</span></span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                <span class=\"comment\">// p 指向下一条消息</span></span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 循环完成后，会找出所有 when 比障栅消息更小的 Message</span></span><br><span class=\"line\">            <span class=\"comment\">// 且按照原顺序连接在单链表中，这些消息不会阻塞。</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时 LAST 即是 prev，而 p 则指向了 ONEMORE。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            <span class=\"comment\">// 说明循环进到了内部，也即障栅消息将位于 LAST 和 ONEMORE 的中间</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为 ONEMORE，即 p</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// LAST 的下一条为障栅消息</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明循环没有进入，也即障栅消息将位于消息队列的首位</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为原先消息队列的第一条消息</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// 消息队列的第一条消息变为障栅消息</span></span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并返回了一个 token，当一个障栅消息被加入到 MessageQueue 后，比障栅消息被添加的时间 <code>when</code> 更晚的同步消息将被阻塞，而异步消息不受影响，直到使用和返回值相同的 token 作为参数调用 <code>removeSyncBarrier(int token)</code> 将该障栅消息移除后，同步消息才恢复处理。</p>\n<p>从源码中可以得知，这一步其实只是把一个障栅消息插入到 MessageQueue 中，插入的位置是由障栅消息的 <code>when</code> 决定的，而障栅消息的 <code>when</code> 则是在公有无参 <code>postSyncBarrier()</code> 中，传入了一个 <code>SystemClock.uptimeMillis()</code>，因此障栅消息的添加无法自定义插入点，只能在代码中手动在想要阻塞的同步消息的前面执行 <code>postSyncBarrier()</code>。</p>\n<p>（2）接下来是移除障栅消息 <code>removeSyncBarrier(int token)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从消息队列的第一个元素开始</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"comment\">//遍历消息队列的所有元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有 p.targe == null 且 p.arg1 == token 的才是对应的障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是否需要唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明目标障栅消息不是第一个消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则将障栅消息的前一条消息的 next 指向障栅消息的下一条</span></span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 因为障栅消息之前有消息，还没有阻塞，所以不需要唤醒</span></span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果障栅消息是第一条消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则消息队列的第一条消息直接设置为障栅消息的下一条</span></span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息（原先障栅消息的下一条）为 null，说明消息队列中没有消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息的 target != null，说明</span></span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除障栅消息就比较简单了，就是遍历消息队列找到 <code>target == null</code> 且 token 对应的消息并移除即可，满足某些条件时还需要唤醒 native 层的消息队列。</p>\n","categories":["Android"],"tags":["Android","源码","Message","消息"]},{"title":"Android反编译和混淆加固","url":"/post/android/android-proguard/","content":"<span id=\"more\"></span>\n\n","categories":["Android"],"tags":["Android","反编译","混淆","加固"]},{"title":"Android-浅析ARouter路由框架的原理和局限性","url":"/post/android/android-router/","content":"<span id=\"more\"></span>\n\n<p>前言：最近在思考项目 Module 解耦问题的时候，粗略了解了一下路由框架，其中最著名的又属阿里开源的 ARouter 了。但在实操的时候发现路由框架并没有我一开始想象的「能完全实现 Module 间解耦」那么美好，有着其本身的局限性，所以在本文对 ARouter 的基本原理和局限性做一个很浅显的个人总结。</p>\n<hr>\n<h1 id=\"1-什么是ARouter\"><a href=\"#1-什么是ARouter\" class=\"headerlink\" title=\"1. 什么是ARouter\"></a>1. 什么是ARouter</h1><p>ARouter 主要用于针对 Activity 跳转之间的解耦，本质上它提供了一种通过 String 类型的「路径 Path」对应到 Activity 的路由表。其核心是通过 APT 在编译时自动检索添加了 <code>@Route(path=&quot;/XXX/XXX&quot;)</code> 注解的 Activity，并以对应的 Path 为 Key 自动生成了一个 Map，然后在运行时根据 Map 存储的路由信息跳转。</p>\n<hr>\n<h1 id=\"2-ARouter的基本原理\"><a href=\"#2-ARouter的基本原理\" class=\"headerlink\" title=\"2. ARouter的基本原理\"></a>2. ARouter的基本原理</h1><p>ARouter 要求一个 Activity 的路径 Path 必须包括至少两级，例如：<code>/main/sub</code>，将 <code>main</code> 称为主路径，表示某一组 Activity 路由信息统一的主路径，<code>sub</code> 称为子路径，表示具体到某一个 Activity 的精确路由。一个主路径可以包括多个子路径，例如：<code>/main/sub</code>, <code>/main/sub2</code>…</p>\n<p>当项目很庞大或 Activity 的数量很多时，各个需要路由的 Module 下就会产生很大的 Map，因此 ARouter 做了一个优化：分段懒加载，也即运行时不会立即将所有路由信息都加载进内存，而是在发起一个路由请求时，先读取缓存，如果缓存没有，再对目标的主路径下的路由信息做懒加载。</p>\n<h2 id=\"2-1-编译时处理\"><a href=\"#2-1-编译时处理\" class=\"headerlink\" title=\"2.1 编译时处理\"></a>2.1 编译时处理</h2><p>ARouter 在编译时会通过 APT 生成两个表：</p>\n<p>（1）对每个添加了 ARouter 依赖的 Module，检索 Module 内所有添加了 <code>@Route</code> 注解的 Activity，并生成每个具体的 Path 对应 Activity 的表 <code>atlas</code>。</p>\n<ul>\n<li>假设 module_splash 下有一个 ADSActivity 添加了路由，则编译时会生成一个类似以下结构的表：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_splash</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/splash/ads&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, ADSActivity.class, <span class=\"string\">&quot;/splash/ads&quot;</span>, <span class=\"string\">&quot;splash&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>假设 module_user 下 LoginActivity 和 RegisterActivity 都添加了路由，则编译时同样会生成一个类似以下结构的表：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_user</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/login&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, LoginActivity.class, <span class=\"string\">&quot;/user/login&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/register&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, RegisterActivity.class, <span class=\"string\">&quot;/user/register&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）对所有 Router，生成一个主路径对应每个实际路由表 <code>atlas</code> 的表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Root_app</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;slpash&quot;</span>, EaseRouter_Group_splash.class);</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;user&quot;</span>, EaseRouter_Group_user.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，所有和路由相关的表都，都是通过一个实现了 <code>IRouteRoot</code> 接口的类存储的。</p>\n<h2 id=\"2-2-运行时加载\"><a href=\"#2-2-运行时加载\" class=\"headerlink\" title=\"2.2 运行时加载\"></a>2.2 运行时加载</h2><p>ARouter 会在运行时收到路由请求后再做懒加载：</p>\n<p>（1）初始化 <code>ARouter.init();</code> 时，ARouter 会开启一个子线程扫描 apk 中的所有 dex 文件，遍历当前包名下所有实现了 <code>IRouteRoot</code> 接口的类，并存进一个 className 集合中。</p>\n<p>（2）通过 <code>ARouter.getInstance().build(&quot;/XXX/XXX&quot;).navigation();</code> 请求路由到指定 Path 对应的 Activity。</p>\n<p>（3）尝试从缓存中读取对应的 Activity，如果命中缓存的路由信息，则直接定位并启动目标 Activity。</p>\n<p>（4）如果未命中缓存，说明该路由对应所在的整个路由表都没有加载。假设目标路由为：<code>/user/register</code>，则 <code>EaseRouter_Group_user</code> 加载 <code>atlas</code> 时，会同时把当前主路径，也即 <code>user</code> 下的所有路由信息都加载，所以如果找不到 <code>/user/register</code>，就说明整个 <code>user</code> 都没有加载，则根据目标路由的主路径 <code>user</code> 加载所有 <code>user</code> 下的路由信息。</p>\n<p>（5）将所有主路径为 <code>user</code> 的路由信息加载后，就能通过 <code>routes.get(&quot;user&quot;);</code> 获取到 <code>EaseRouter_Group_user</code>，然后再通过 <code>atlas.get(&quot;/user/register&quot;)</code> 获取到 <code>RegisterActivity</code>。</p>\n<hr>\n<h1 id=\"3-ARouter的局限性\"><a href=\"#3-ARouter的局限性\" class=\"headerlink\" title=\"3. ARouter的局限性\"></a>3. ARouter的局限性</h1><p>上文很简单的解释了一下 ARouter 的原理，作为一个路由框架，ARouter 最大的用途就是把多个 Module 间的 Activity 跳转解耦，发起跳转时不再需要关注实际的 Activity，只需要一个 String 类型的路由即可，从代码编写上确实看起来是解耦了，但实际上 ARouter 并没有解决依赖的问题。</p>\n<p>对于 Android 来说，Gradle 在构建 app 时是有优化的，假如一个 AModule 没有被别的 Module 依赖，或者虽然 AModule 被 BModule 依赖了，但 BMdoule 又没有被依赖，类似于 JVM 中的「引用链是断开的」，那 Gradle 在编译时就会忽略掉这些 Module，以减小最后生成的 APK 包大小以及简化资源。</p>\n<p>Gradle 这个优化本是出于减小包大小考虑的，本质上是好的，但对于想要实现 Module 间解耦来说就是一个阻碍了，因为那些我们希望解耦而去掉依赖的 Module，根本没有被打包进最后的 APK 中，那无论是采用路由、还是别的方式都无法访问。例如：</p>\n<ul>\n<li><p>app 主 Module 下有个 <code>MainActivity</code></p>\n</li>\n<li><p>module_user 下有 <code>LoginActivity</code> 和 <code>RegisterActivity</code></p>\n</li>\n<li><p>app 主 Module 和 module_user 都添加了 ARouter 依赖，并且 Activity 都添加了 <code>@Route</code> 路由信息</p>\n</li>\n<li><p>app 主 Module 并不依赖 module_user，两个 Module 都是独立的</p>\n</li>\n<li><p>编译打包，Build 日志中，ARouter 输出确实找到了 LoginActivity 和 RegisterActivity 的路由：</p>\n</li>\n</ul>\n  <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Note: ARouter::Compiler &gt;&gt;&gt; Found activity route: priv.luis.user.LoginActivity &lt;&lt;&lt;</span><br><span class=\"line\">Note: ARouter::Compiler &gt;&gt;&gt; Found activity route: priv.luis.user.RegisterActivity &lt;&lt;&lt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>但是打包完再反解后发现，module_user 没有被打进 APK 内，MainActivity 请求路由到 LoginActivity 时 ARouter 也报错：</li>\n</ul>\n  <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ARouter::There is no route match the path [/user/login]</span><br><span class=\"line\">ARouter::There is no route match the path [/user/register]</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，想要使用路由框架，首先也要确保 Module 能正确被打包进去，那方案只有两种：</p>\n<ul>\n<li><p>（1）app 主 Module 添加所有业务子 Module 的依赖。</p>\n</li>\n<li><p>（2）新建一个中介 Module，中介 Module 添加所有业务子 Module 的依赖，然后 app 主 Module 再添加这个中介 Module 的依赖，除了中介 Module 外，其他 Module 都互不依赖。这样 app 主 Module 并没有显式依赖各个业务子 Module，在开发时可以避免逻辑耦合的情况，而且实际上所有业务子 Module 是间接被 app 主 Module 依赖了，所以也能确保被打包进 APK 中，这也是常用的做法。</p>\n</li>\n</ul>\n<p>所以实际上路由框架并没有从根源上解决依赖的问题，从这个角度来看，ARouter 最大的好处或许其实在于其使用 APT 自动生成了路由信息的录入和查找相关代码，并且对查找路由做了分段懒加载等内存优化，在业务开发上可以节省一些编码时间，但 ARouter 最基本的使用也需要开发人员对相关 Gradle 配置、路由配置等稍有熟悉后才可上手（当然这个过程其实已经有傻瓜式文档了，使用门槛很低），对于整个 App 的路由信息，也需要专门管理，以避免路由信息混乱、重复、不规范等问题，当然这些确实都能通过良好的管理方式优化。但实际上我个人对使用 String 来管理路由的做法反倒是略有排斥的，至于是否真的使得代码变得更「内聚」、「解耦」、以及「高级」，和每个人的开发习惯有关，就见仁见智了。</p>\n<h1 id=\"附录-参考指导\"><a href=\"#附录-参考指导\" class=\"headerlink\" title=\"附录[参考指导]\"></a>附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/857aea5b54a8\" title=\"@LINK\">【1】ARouter原理剖析及手动实现（作者：xiasem）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","Router","ARouter","路由"]},{"title":"Android-Service","url":"/post/android/android-service/","content":"<span id=\"more\"></span>\n\n<p>Service 可以在后台执行长时间而无界面的操作，且存在于主线程中。可以通过 startService() 和 bindService() 两种方法启动。全部 Service 都要在 Manifest 内声明。</p>\n<p>startService() 后该 Service 即变为 stared 状态，处于后台运行中，与启动它的 Activity 生命周期无关，除非手动 <code>stopService()</code> 终止或被 Android 系统回收。bindService() 后该 Service 为 bound 状态，生命周期与 Activity 绑定，Activity 销毁则 Service 也被销毁。</p>\n<p>Service 有 3 类：</p>\n<ul>\n<li>Foreground Service：执行一些用户可感知的操作，使用 <code>startService()</code> 启动。如 Audio播放。</li>\n<li>BackGround Service：用户不可感知的后台操作，使用 <code>startForegroundService()</code> 启动。如监控、轮询拉取等。</li>\n<li>Bound Service：主要提供 C / S 接口，允许组件与 Service 通信或跨进程通信，使用 <code>bindService()</code> 启动。</li>\n</ul>\n<p>必须在 Manifest 中注册：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;service android:name=<span class=\"string\">&quot;.DemoService&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;service.DemoService&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/service&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以 start 方式启动 Service：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoService.class);</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\">stopService(intent);</span><br></pre></td></tr></table></figure>\n\n<p>如果要通过 bind 方式绑定 Service，需要在 Service 中返回 Binder 类的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义 Service 类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinderInstance</span> <span class=\"keyword\">extends</span> <span class=\"title\">Binder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DemoService <span class=\"title\">getServiceInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DemoService.<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过 Binder 实现 Client 和 Service 之间的通信</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BinderInstance binderInstance = <span class=\"keyword\">new</span> BinderInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">super</span>.onCreate(); &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123; <span class=\"keyword\">return</span> START_NOT_STICKY; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 在 Service 被绑定时返回 Binder 的实例对象，并通过 Binder 的实例对象进一步返回 Service 的实例对象，从而直接调用 Service 中的方法进行通信。</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;<span class=\"keyword\">return</span> binderInstance; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">super</span>.onDestroy(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以由外部调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMission</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 Actiivty 中获取 Binder 和 Service 的实例对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绑定 Service 的 Actiivty</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoService demoService = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection serviceConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder binder)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取 Binder 实例对象</span></span><br><span class=\"line\">            DemoService.BinderInstance binderInstance = (DemoService.BinderInstance) binder;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 获取 Service 实例对象</span></span><br><span class=\"line\">            DemoService.BinderInstance = binderInstance.getServiceInstance();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 直接指定 Service</span></span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, DemoService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 或使用 action 过滤</span></span><br><span class=\"line\">        intent.setAction(<span class=\"string\">&quot;service.DemoService&quot;</span>);</span><br><span class=\"line\">        bindService(intent, serviceConnection, BIND_AUTO_CREATE);</span><br><span class=\"line\">        unbindService(serviceConnection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了使用 Binder 方式以外，Activity 与 Service 之间的通信还能通过 BroadCastReceiver 以及 EventBus 的方式实现。</p>\n","categories":["Android"],"tags":["Android","四大组件","Service","前台服务","后台服务"]},{"title":"Android-SharedPreference","url":"/post/android/android-sharedpreference/","content":"<span id=\"more\"></span>\n\n<p>Android 中获取 SharedPreferences 的方式有 3 种：</p>\n<p>（1）Context 中的 <code>getSharedPreferences(String name, int mode)</code></p>\n<p>name 用于指定 SharedPreference 的文件名，如果不存在则创建。mode 用于指定操作模式，有以下几种选择：</p>\n<ul>\n<li>Context.MODE_PRIVATE：只能被本应用程序读、写。</li>\n<li>Context.MODE_WORLD_READABLE：能被其他应用程序读，但不能写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_WORLD_WRITEABLE：能被其他应用程序读、写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_APPEND：检查文件是否存在，存在则追加内容，否则创建新文件。</li>\n</ul>\n<p>（2）Activity 中的 <code>getPreferences(int mode)</code><br>与 <code>getSharedPreferences()</code> 类似，但自动将当前活动的类名作为 SharedPreferences 的文件名。</p>\n<p>（3）PreferenceManager 中的 <code>getDefaultSharedPreferences(Context context)</code><br> 这是一个静态方法，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。</p>\n<hr>\n<h1 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h1><p>SP的本质是HashMap，存储的是键值对数据，在本地存储中以xml文件的形式保存。</p>\n<p>SP本身是线程安全的，读写都用synchronized锁住了，但由于每次修改都会生成一个EditorImpl对象，因此最好是批量处理，最后统一提交。</p>\n<p>提交时有两种方案，commit在UI线程，apply在子线程，使用commit如果耗时太长超过5s，会导致ANR，使用commit，如果提交时关闭Activity，会检查一个工作任务队列sPendingWorkFinishers中的任务是否全部完成，如果有未完成的任务，就会一直等待，所以如果commit太大量的数据导致Activity结束时等待超过5s，一样会导致ANR。</p>\n<p>由于读取本地文件的性能开销很大，所以SP读取数据后，会一直保存在内存，因此如果存放了过大的数据，会导致频繁GC甚至OOM。</p>\n<p>如果SP数据较多，频繁读取的数据和非频繁读取的数据最好分成不同的SP文件。</p>\n","categories":["Android"],"tags":["Android","五大存储","SharedPreference"]},{"title":"Android-SQLite","url":"/post/android/android-sqlite/","content":"<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h1><p>（1）插入数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> TableName <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"string\">&#x27;data&#x27;</span>, ...);</span><br></pre></td></tr></table></figure>\n\n<p>（2）删除数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> TableName <span class=\"keyword\">WHERE</span> attr<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>（3）更新数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE TableName <span class=\"keyword\">set</span> attr1<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span> <span class=\"keyword\">WHERE</span> attr2<span class=\"operator\">=</span><span class=\"string\">&#x27;data2&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>（4）查询数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> TableName;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> attr1, attr2 <span class=\"keyword\">FROM</span> TableName <span class=\"keyword\">WHERE</span> attr<span class=\"operator\">=</span><span class=\"string\">&#x27;data&#x27;</span>;</span><br></pre></td></tr></table></figure>","categories":["Android"],"tags":["Android","五大存储","SQLite"]},{"title":"ML入门-机器学习简介","url":"/post/machinelearning/ml-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-什么是机器学习\"><a href=\"#1-什么是机器学习\" class=\"headerlink\" title=\"1. 什么是机器学习\"></a>1. 什么是机器学习</h1><p>机器学习是人工智能的一个分支，主要关于构造和研究可以从数据中学习的系统。</p>\n<p>这也说明，机器学习的本质是通过数据实现的，更进一步讲，是从大量无法手动推算出规律、分布、结构的数据中，利用 CPU 强大的计算能力、通过迭代等科学的计算方法来自动计算出某种类型数据的共性，并使用这些共性为新来的数据假设、模拟出其可能的结果。</p>\n<p>机器学习的数据通常包括训练数据和校验数据，其中：</p>\n<ul>\n<li>训练数据用于建立机器学习模型，通常包括：①输入：特征 <strong>X</strong> 和 ②输出：标签 y。<br>注意：此处黑体 <strong>X</strong> 表示矩阵，且有一些模型可以没有输出 y。</li>\n<li>校验数据用于在模型初步建立完毕后检验模型的效果，常常从训练数据中分割一部分作为校验数据，与训练数据具有相同的分布和格式。</li>\n</ul>\n<hr>\n<h1 id=\"2-机器学习的学习类型：\"><a href=\"#2-机器学习的学习类型：\" class=\"headerlink\" title=\"2. 机器学习的学习类型：\"></a>2. 机器学习的学习类型：</h1><ol>\n<li>监督学习[Supervised Learning]：从带标签的数据中学习。例：房价预测、邮件识别等。</li>\n<li>非监督学习[Unsupervised Learning]：从无标签的数据中学习蕴含的结构。例：文档聚类等。</li>\n<li>强化学习[Reinforcement Learning]：通过曾经执行的动作及带来的奖惩进行学习，强化学习的标签 y 具有延迟性。例：AI 下棋等，当前棋子带来的影响需要经过一段时间才会表现出来。</li>\n</ol>\n<h2 id=\"2-1-监督学习\"><a href=\"#2-1-监督学习\" class=\"headerlink\" title=\"2.1 监督学习\"></a>2.1 监督学习</h2><ol>\n<li><p>两种任务类型：</p>\n<p> ①回归任务[Regression]：输出 $y\\in R$ 为连续值。<br> ②分类任务[Classification]：输出 y 为离散值。</p>\n</li>\n<li><p>学习目的：学习到一个 <strong>X</strong> 到 y 的映射 f，从而对新输入的 <strong>X</strong> 预测其输出</p>\n<blockquote>\n<p>$\\hat{y}=f(\\textbf{X})$。</p>\n</blockquote>\n</li>\n<li><p>监督学习的训练数据包含标签 y，即标签在训练数据中是可见变量。</p>\n</li>\n<li><p>数据样式：</p>\n<blockquote>\n<p>$D={\\textbf{X}<em>i, y_i}</em>{i=1}^N$<br>其中 D 为数据集，<strong>X<sub>i</sub></strong> 与 y<sub>i</sub> 为第 i 个样本的输入与输出，N 为样本总数。</p>\n</blockquote>\n</li>\n<li><p>Scikit-Learn 中监督学习的大致流程：<br> ①estimator.fit(X_train, y_train)<br> ②estimator.predict(X_test)<br> ③estimator.score(X_test, y_test)</p>\n</li>\n</ol>\n<h2 id=\"2-2-非监督学习\"><a href=\"#2-2-非监督学习\" class=\"headerlink\" title=\"2.2 非监督学习\"></a>2.2 非监督学习</h2><p>（1）两种任务类型：</p>\n<blockquote>\n<p>①聚类[Clustering]<br>②降维[Dimension Reduction]</p>\n</blockquote>\n<p>（2）学习目的：发现数据中的“有意义的模式”，亦称为“知识发现”。</p>\n<p>（3）非监督学习的训练数据不包含标签 y，即标签在训练数据中为隐含变量。</p>\n<p>（4）数据样式：</p>\n<blockquote>\n<p>$D={\\textbf{X}<em>i}</em>{i=1}^N$</p>\n</blockquote>\n<p>（5）Scikit-Learn 中非监督学习的大致流程：</p>\n<ul>\n<li>①<code>transformer.fit(X_train)</code></li>\n<li>②<code>X_train_trans = transformer.transform(X_train)</code></li>\n<li>③<code>X_test_trans = transformer.transform(X_test)</code></li>\n</ul>\n<h2 id=\"2-3-增强学习\"><a href=\"#2-3-增强学习\" class=\"headerlink\" title=\"2.3 增强学习\"></a>2.3 增强学习</h2><p>（1）学习目的：从行为的反馈（奖励或惩罚）中学习，以找到一条回报值最大的路径。</p>\n<p>（2）步骤：设计一个回报函数[Reward Function]，若 Learning Agent 在执行一个动作后获得了较好的结果，则给予一些奖励（例如：回报函数为正），否则给予一些惩罚（例如：回报函数为负），驱使 Learning Agent 寻找出一条最终获得回报总和最高的学习路径。</p>\n","categories":["MachineLearning"],"tags":["AI","MachineLearning","人工智能","机器学习"]},{"title":"Java-finally关键字","url":"/post/java/java-finally/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-finally和return的执行顺序\"><a href=\"#1-finally和return的执行顺序\" class=\"headerlink\" title=\"1. finally和return的执行顺序\"></a>1. finally和return的执行顺序</h1><p>一句话总结：当 <code>try - catch</code> 中使用 <code>break</code> 或 <code>return</code> 返回时，<code>finally</code> 会执行，当调用了 <code>System.exit(0)</code> 退出时，由于直接终止了 JVM，因此 <code>finally</code> 不会执行。</p>\n<p>在 try - catch 中的 return 语句执行之后、方法返回之前，程序会将 return 的返回值写入内存中，然后等待 finally 语句执行完，如果在 finally 代码块中，只改变了引用（例如对变量重新赋值），由于 return 时已经将返回值写入了内存中，则不会改变，而如果是改变了同一个变量的值，则会改变。如果 finally 中包含 return 语句，则会覆盖原本的return。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 10。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 20。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringBuilder <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;AAA&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sb.append(<span class=\"string\">&quot;BBB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;CCC&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 “AAABBBCCC”。</p>\n","categories":["Java"],"tags":["Java","finally"]},{"title":"JVM的GC策略","url":"/post/java/java-gc/","content":"<span id=\"more\"></span>\n\n<p>前言：GC 即：Garbage Collection 垃圾回收，是 JVM 中非常必要的一个机制，之所以需要 GC，是因为程序在运行中，会产生很多 Garbage，而 JVM 的内存是有限制的，如果不及时对这些 Garbage 进行整理和清除，会使得内存占用越来越大，最后导致没有足够的内存生成新的对象。GC 中有一个很重要的前提：Stop-The-World，也即：JVM 由于要执行 GC 而停止了应用程序的执行。当 GC 发生时，除了 GC 所需的线程外，其他所有线程都处于等待状态直到 GC 任务完成。而通常做 GC 优化的目的，就是减少 GC 发生，以减少卡顿。</p>\n<hr>\n<h1 id=\"1-GC的两种核心判定原则\"><a href=\"#1-GC的两种核心判定原则\" class=\"headerlink\" title=\"1. GC的两种核心判定原则\"></a>1. GC的两种核心判定原则</h1><h2 id=\"1-1-引用计数\"><a href=\"#1-1-引用计数\" class=\"headerlink\" title=\"1.1 引用计数\"></a>1.1 引用计数</h2><p>引用计数也即：为实际内存中存储的对象所具有引用记录引用数，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略类 A 和 B 之间的关系</span></span><br><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b = a;</span><br></pre></td></tr></table></figure>\n\n<p>此时，<code>new A()</code> 执行后在内存中实际存储的对象数据，就具有了 <code>a</code> 和 <code>b</code> 两个引用，则其引用计数为 2，而 <code>new B()</code> 生成的实际对象数据则引用计数为 0。</p>\n<p>引用计数法的核心思想即：一个对象，每增加一个引用，则引用计数 +1，每减少一个引用，则引用计数 -1，任何时刻，计数值为 0 的对象，就是不可再使用的（例如，<code>b = a;</code> 后，原本 <code>new</code> 出来的 <code>B</code> 对象，就无法再通过代码获取到了），即可马上将自己当做空闲空间链接到空闲链表。</p>\n<h2 id=\"1-2-引用链\"><a href=\"#1-2-引用链\" class=\"headerlink\" title=\"1.2 引用链\"></a>1.2 引用链</h2><p>提出一个初始根节点对象的概念：GC Root，当一个对象产生时，会将其建立与 GC Root 的直接或间接连接，例如一个外部类可能直接连接 GC Root，而该类的子类则先连接到该类，再连接到 GC Root。也就是说，GC Root 本身也是对象，只是这些对象，在整个程序运行期间，都有用或不会被销毁，那么与这些对象相连接的对象，则说明是有用的，则不需要被回收。而某些对象与这些 GC Roots 没有连接，则说明这些对象不是必要的，则 GC 可以回收。这些引用关系，被称为：<font color=#EB6D39>引用链</font>。</p>\n<p>例如：通常一个 Java 程序，都是从 <code>main</code> 方法开始执行，可以将 <code>main</code> 方法的实际内存引用作为 GC Root，如果在 <code>main</code> 方法中声明两个对象：<code>A a;</code> 和 <code>B b;</code>，则 <code>a</code> 和 <code>b</code> 都是与 <code>main</code> 相连接的平行平级的对象，这时如果执行：<code>b = a;</code>，则将内存中 <code>a</code> 的实际引用（指向内存中的实际数据）赋值给了 <code>b</code>，则原本 <code>b</code> 的引用（内存中实际的一个 <code>B</code> 的对象）被中断，此时的引用链则是：</p>\n<p><code>main</code> 连接到平行平级的 <code>a</code> 和 <code>b</code>，然后 <code>a</code> 和 <code>b</code> 同时连接到内存中 <code>A</code> 的实际对象，而内存中 <code>B</code> 的实际对象则失去任何引用。</p>\n<p>当一个对象，可以连接到 GC Root，则称之为是“可达的”，或“具有可达性”，否则为“不可达”或“不具有可达性”。</p>\n<hr>\n<h1 id=\"2-常见的GC算法\"><a href=\"#2-常见的GC算法\" class=\"headerlink\" title=\"2. 常见的GC算法\"></a>2. 常见的GC算法</h1><p>常见的 GC 算法有：引用计数法、标记清除法、复制法、标记整理法、分代收集法。</p>\n<h2 id=\"2-1-引用计数法\"><a href=\"#2-1-引用计数法\" class=\"headerlink\" title=\"2.1 引用计数法\"></a>2.1 引用计数法</h2><p>即是通过判断引用计数是否为 0 来决定是否回收，引用计数法最致命的缺点，是当发生循环引用时，无法回收无用对象。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">a.friend = b;</span><br><span class=\"line\">b.friend = a;</span><br></pre></td></tr></table></figure>\n\n<p>则 <code>a</code> 和 <code>b</code> 二者互相引用，执行完这段代码后，其引用计数始终不为 0，则 GC 始终无法回收。</p>\n<h2 id=\"2-2-标记清除法\"><a href=\"#2-2-标记清除法\" class=\"headerlink\" title=\"2.2 标记清除法\"></a>2.2 标记清除法</h2><p>标记清除法分为“标记”和“清除”两个阶段。</p>\n<ul>\n<li><p>标记阶段，从 GC Root 出发，遍历所有的子节点，并将所有可达的对象进行标记。</p>\n</li>\n<li><p>清除阶段，遍历所有的对象，将未标记的对象回收。</p>\n</li>\n</ul>\n<p>标记清除法最致命的缺点是：多次 GC 会导致内存碎片化，即空闲内存在实际内存中不是连续的，导致当有大内存对象产生时，无法找到足够的连续内存而又一次触发 GC。</p>\n<h2 id=\"2-3-复制法\"><a href=\"#2-3-复制法\" class=\"headerlink\" title=\"2.3 复制法\"></a>2.3 复制法</h2><p>将内存划分为大小相等的两个区域，每次只使用其中一半，当 GC 发生时，找出其中存活的对象，按照顺序复制到另一半内存中连续的区域，然后直接把之前的一半内存清空，这样就不会出现内存碎片的情况。这种方案适用于大部分对象生命周期都比较短的情况，例如新生代中的对象，而当遇到极端情况，例如一半的内存中，在 GC 时所有的对象都存活，则直接把这一半内存全部复制到另一半，结果还是全部存活，又要复制回来···，实际上就是浪费了 50% 的空间，所以像老年代（存放经过多次 GC 后仍然存活的对象，所以这些对象被 GC 后仍然存活的几率很高）就不能用这种方案。</p>\n<h2 id=\"2-4-标记整理法\"><a href=\"#2-4-标记整理法\" class=\"headerlink\" title=\"2.4 标记整理法\"></a>2.4 标记整理法</h2><p>标记整理法和标记清除法类似，都是通过遍历标记所有可达的对象，但不是直接清理掉不可达对象，而是将所有含有标记的对象，向内存的一侧移动，用空闲指针来标记最后一个存活对象，然后清理掉空闲指针之后的内存空间，这样清理后的空闲内存则是连续的一段。</p>\n<h2 id=\"2-5-分代收集法\"><a href=\"#2-5-分代收集法\" class=\"headerlink\" title=\"2.5 分代收集法\"></a>2.5 分代收集法</h2><p>首先需要明确的是，分代收集法本质上并不是一种 GC 算法，对于一个复杂的系统，例如 JVM，只是用一种单一的 GC 算法是不足以应对所有场景的，因此需要针对多个场景制定一套算法，而分代收集法就是基于这个理念创立的。</p>\n<p>堆区本身有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n","categories":["Java"],"tags":["Java","GC","垃圾回收"]},{"title":"Java-HashMap","url":"/post/java/java-hashmap/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-哈希散列表\"><a href=\"#1-哈希散列表\" class=\"headerlink\" title=\"1. 哈希散列表\"></a>1. 哈希散列表</h1><p>HashMap的最基本原理就是哈希表，哈希表也就是，把一组不相干的数据，通过哈希函数计算后，映射到一个数组中，这样通过数组下标就能直接确认原来数据的存储位置。但哈希映射有可能会导致哈希碰撞，解决方案有：开放定址法、再散列函数法、链地址法，而HashMap采用的是链地址法。</p>\n<h2 id=\"1-1-开放定址法\"><a href=\"#1-1-开放定址法\" class=\"headerlink\" title=\"1.1 开放定址法\"></a>1.1 开放定址法</h2><p>开放定址法的核心思想就是增加偏移量，其中增加偏移量的方法有多种：线性探测、平方探测等，但整体思路是类似的。当插入一个新的数据时，发现经过哈希计算后，原Key的目标插入节点已经被占用了，发生碰撞，则向后偏移一位，再次检测，如果仍旧发生碰撞则继续偏移，直到到达数组尾端，根据不同的策略，可以绕回到数组头（负偏移）或扩大散列表。</p>\n<p>线性探测会导致元素聚集，这和哈希散列表的初衷不符。</p>\n<p>平方探测则是用：1, -1, 4, -4 … 这样的方式进行左右跳跃性查找。</p>\n<p>伪随机探测，即一开始就定义一个伪随机数列，每次发生冲突即从伪随机数列中取出下一个伪随机数作为偏移量。</p>\n<h2 id=\"1-2-再散列函数法\"><a href=\"#1-2-再散列函数法\" class=\"headerlink\" title=\"1.2 再散列函数法\"></a>1.2 再散列函数法</h2><p>也即每次发生冲突时，就再用哈希函数散列一次。缺点是增大计算量。</p>\n<h2 id=\"1-3-链地址法\"><a href=\"#1-3-链地址法\" class=\"headerlink\" title=\"1.3 链地址法\"></a>1.3 链地址法</h2><p>也即，哈希表的主体是一个数组，数组的每一个结点，都是一个链表，当发生哈希碰撞时，后插入的Key则插入到对应结点的链表的末端。</p>\n<p>如果不存在哈希冲突，也即 HashMap 数组中不包含链表，则每次添加、查找都是单次寻址，时间复杂度为 O(1)。如果目标节点存在哈希冲突，则添加、查找都需要遍历整个链表，时间复杂度为 O(n)，其中：查找时，通过 key 对象的 equals 方法逐一比较，相同则返回；新增时，遍历链表，若存在相同 key，则覆盖，否则新增至链表末端。</p>\n<p>hashMap 与 hashTable 其中不同的一点是 HashMap 允许 key 为 null，把 key 为 null 的对象存在数组首位（<code>table[0]</code>）。</p>\n<hr>\n<h1 id=\"2-HashMap源码分析\"><a href=\"#2-HashMap源码分析\" class=\"headerlink\" title=\"2. HashMap源码分析\"></a>2. HashMap源码分析</h1><h2 id=\"2-1-静态内部类Entry\"><a href=\"#2-1-静态内部类Entry\" class=\"headerlink\" title=\"2.1 静态内部类Entry\"></a>2.1 静态内部类Entry</h2><p>HashMap 有一个静态内部类 Entry，其源码清晰描述了 HashMap 数组 + 链表 的数据结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 存储指向下一个Entry的引用，单链表结构</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Creates new entry.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">        next = n;</span><br><span class=\"line\">        key = k;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">          V oldValue = value;</span><br><span class=\"line\">          value = newValue;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-HashMap的重要成员变量\"><a href=\"#2-2-HashMap的重要成员变量\" class=\"headerlink\" title=\"2.2 HashMap的重要成员变量\"></a>2.2 HashMap的重要成员变量</h2><ul>\n<li><code>transient Entry[] table;</code>：实际存储键值对的表。</li>\n</ul>\n<p><code>transient</code> 关键字仅可修饰成员变量，表示“禁止序列化该数据”，其意义是：HashMap 本身的数组，通常会有很多空闲的节点，对空闲的节点空间序列化没有意义，所以其手动实现了 <code>writeObject()</code> 方法进行实际的序列化。<code>table</code>、<code>size</code>、<code>modCount</code> 都被 <code>transient</code> 关键字修饰，是因为每次 HashMap 执行 put 或 remove 操作后，三者都会发生变化，由于三者状态常变，所以没有必要在默认序列化类对象时将其指代入。</p>\n<ul>\n<li><p><code>static final int DEFAULT_INITIAL_CAPACITY = 16;</code>：默认初始容量为 16，必须为 2 的幂。</p>\n</li>\n<li><p><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：最大容量，必须为 2 的幂且要小于 2 的 30 次方，传入大于该值的参数将被该值替换。</p>\n</li>\n<li><p><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>：默认加载因子。</p>\n</li>\n<li><p><code>final float loadFactor;</code>：实际加载因子。</p>\n</li>\n</ul>\n<p>为了降低哈希冲突的概率，默认当 HashMap 中的键值对达到数组大小的 75% 时，会触发扩容操作。因此如果预估容量是 100，即需要设定 100 / 0.75 ＝ 134 的数组大小。</p>\n<ul>\n<li><p><code>transient int size</code>：Map 中实际存储的键值对个数。</p>\n</li>\n<li><p><code>threshold</code>：阈值。</p>\n</li>\n<li><p><code>transient volatile int modCount;</code>：HashMao 被改变的次数，用于快速失败。</p>\n</li>\n</ul>\n<blockquote>\n<p>@注：<code>volatile</code> 关键字修饰的成员变量，可以阻禁止代码重排序，保证所有的写操作都在读操作之前，使得变量在内存中的变化可以被多线程所知。由于 HashMap 线程不安全，<code>modCount</code> 用于快速失败机制，所以写线程执行时带来的变化需要及时被读线程所知。</p>\n</blockquote>\n<blockquote>\n<p>@注：put 操作时，若 key 已存在替换 value 时，<code>modCount</code> 不会增加，不存在新增时才会增加。也即，只有 HashMap 中元素的数量增多或减少时，才认为 HashMap 的结构发生了变化。</p>\n</blockquote>\n<h2 id=\"2-3-HashMap长度必须为2的幂\"><a href=\"#2-3-HashMap长度必须为2的幂\" class=\"headerlink\" title=\"2.3 HashMap长度必须为2的幂\"></a>2.3 HashMap长度必须为2的幂</h2><p>HashMap 在将一个 key 经过 hash 后映射进数组节点中时，经过了如下运算：</p>\n<ul>\n<li><p>① 计算 key 的 二次 hash；</p>\n</li>\n<li><p>② 将 hash 值的二进制与 HashMap 的 (length - 1) 的二进制进行 &amp; 与运算；</p>\n</li>\n<li><p>③ 得出的结果即为需要存进的数组节点下标。</p>\n</li>\n</ul>\n<p>如果数组长度为 2 的幂，则 (length - 1) 的二进制一定是各个位都是 1，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">4</span> - <span class=\"number\">1</span> = <span class=\"number\">15</span>(d) = <span class=\"number\">1111</span>(b)</span><br><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">5</span> - <span class=\"number\">1</span> = <span class=\"number\">31</span>(d) = <span class=\"number\">11111</span>(b)</span><br></pre></td></tr></table></figure>\n\n<p>由于与运算是“两位为 1 才为 1”，因此用 hash 的二进制和 (length - 1) 的二进制做与运算，其结果就完全取决于 hash 的二进制数。例如：</p>\n<ul>\n<li><p>若 hash = 1011011，(length - 1) = 1111，则 hash &amp; (length - 1) = 1011。</p>\n</li>\n<li><p>若 hash = 1101100010，(length - 1) = 11111，则 hash &amp; (length - 1) = 10。</p>\n</li>\n</ul>\n<p>这样可以使得键值对尽可能均匀的分布在 HashMap 数组的各个节点。并且在扩容时，由于二进制的每一位只有可能是 1 或者 0，且扩容后的 (length - 1) 依然是各个位全为 1 的二进制数，也即经过与运算后，有一半几率该点依然位于原来的数组节点（而在链表中的位置则不确定），另一半的几率会被重新分配到其他的数组节点，从而可以保障扩容后键值对存储位置的均衡性。</p>\n<font color=red>\n\n<p>假如 HashMap 的长度不是 2 的幂，也即 (length - 1) 的二进制中可能存在 0，例如：</p>\n<ul>\n<li><p>若 hash = 1011011，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</p>\n</li>\n<li><p>若 hash = 1101101111，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</p>\n</li>\n</ul>\n<p>不仅会导致哈希碰撞的概率增大，并且在上例中，由于 (length - 1) = 1001，则注定任何一个 hash 与之做与运算，其第 2、3 位都一定是 0，也即有些 HashMap 的数组节点则一定不会被用到。比如上例中当数组长度为 10 时，(length - 1) = 1001，则下标为：<code>0111(b) = 7(d)</code>、<code>0101(b) = 5(d)</code>、<code>0011(b) = 3(d)</code>、<code>0010(b) = 2(d)</code> 的数组节点一定不会被用于存储，这是显然不符合 Hash 散列表特性的。</p>\n</font>\n\n<hr>\n<h1 id=\"3-HashMap流程\"><a href=\"#3-HashMap流程\" class=\"headerlink\" title=\"3. HashMap流程\"></a>3. HashMap流程</h1><p>在向 HashMap 存储数据时，会首先判断 key 是否为 null，如果为 null，则直接存入 <code>table[0]</code> 中，每次存储都会直接覆盖。若 key 不为 null，则会对 key 进行重哈希，也即哈希两次：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hash = hash(key.hashCode());</span><br></pre></td></tr></table></figure>\n\n<p>通过计算出来的 hash 值，判断该键值对的目标数组节点下标：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>\n\n<p>然后遍历该节点中的链表，依次与之比较 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    Object k;</span><br><span class=\"line\">    <span class=\"comment\">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">        V oldValue = e.value;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若遍历链表中已存储的键值对对象 e 时发现已存在，即：<code>e.hash == hash</code>，则直接用新的 <code>value</code> 取代旧的并退出，否则也即遍历 <code>e = e.next</code> 直到 <code>e == null</code>，则调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">addEntry(hash, key, value, i);</span><br></pre></td></tr></table></figure>\n\n<p>将当前键值对存储到链表末端，并使前一个 <code>e.next</code> 指向该新键值对。</p>\n<hr>\n<h1 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h1><p><code>HashMap.get(key)</code> 方法返回 <code>null</code> 时，可能是 key 对应的 value 为 <code>null</code>，也可能是没有找到对应的 key，因此判断 HashMap 中是否含有某个 key 时，应调用 <code>containsKey()</code> 方法。</p>\n<p>HashMap 是线程不安全的，其迭代器是 Fail-Fast（快速失败）的，也即：当有其他线程改变了 HashMap 的结构（增加或移除了元素），则有可能抛出 <code>ConcurrentModificationException</code> 异常，但迭代器本身的 <code>remove()</code> 则不会引起该异常。</p>\n<hr>\n<h1 id=\"5-附录-参考指导\"><a href=\"#5-附录-参考指导\" class=\"headerlink\" title=\"5. 附录[参考指导]\"></a>5. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_40118851/article/details/82804510\" title=\"@LINK\">【1】HashMap底层实现原理（作者：Right_Boy）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Java"],"tags":["Java","HashMap","集合框架"]},{"title":"Java-ThreadLocal","url":"/post/java/java-threadlocal/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-认识ThreadLocal\"><a href=\"#1-认识ThreadLocal\" class=\"headerlink\" title=\"1. 认识ThreadLocal\"></a>1. 认识ThreadLocal</h1><p>ThreadLocal 是 Java 中一种很重要的机制 / 数据处理方式，尤其在并发中，数据是否共有、唯一，会直接影响项目的运行逻辑。一般情况下，防止并发冲突或数据不安全的做法是给对象、方法加同步锁 <code>synchronized</code>。但同步锁并不是万能的，例如同步锁会降低批量处理的效率，或者当业务需要保证数据的隔离性，使用同步锁则需要在方法内频繁销毁、重建对象，如果数据使用独立的处理模块，还会破坏模块化，提高耦合。为此，JDK 1.2 增加了一个工具类：即 **<code>ThreadLocal</code>**。</p>\n<hr>\n<h1 id=\"2-不使用ThreadLocal的问题\"><a href=\"#2-不使用ThreadLocal的问题\" class=\"headerlink\" title=\"2. 不使用ThreadLocal的问题\"></a>2. 不使用ThreadLocal的问题</h1><p>为了更好地理解 ThreadLocal 的设计理念，首先考虑以下两个更普遍一些的场景：</p>\n<ul>\n<li><ol>\n<li>一个客户端，需要并发地和服务器交互，并且每个连接都需要持久化（需要保存 Cookie）。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>一个客户端，需要并发地存取数据库，并且每个连接都可能会提交超过一个操作。</li>\n</ol>\n</li>\n</ul>\n<p>（1）如果按最简单的方式来做，每个线程都维护一套自己的网络请求框架，确实不会导致什么异常，但是第一：实际项目中不可能采用这个方案，第二：这么做简直就是“高耦合低内聚”的代表，第三：重新参考以上两条。项目中，绝大部分情况下，一个连接会话会在一个独立的线程内执行，这个线程需要维护一个仅对自己可见的 Cookie，不仅对其他会话不可见，同时也要确保只能获取到自己的 Cookie。</p>\n<p>（2）同样，每个线程都独立维护一套数据库会话管理是不现实的，通常会封装到一个工具类中，从工具类中获取、开启、关闭会话以及提交事务等。假如有一个业务：当修改用户信息时，把这个操作记录保存下来。假如每一次的操作都从连接池获取 Connection，就有可能一个操作执行了另一个可能因为某些原因没有执行，所以一般通过以下方式来获取管理 Connection：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection connection;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(driver);</span><br><span class=\"line\">            connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后用 Transaction 统一提交事务。到目前为止，如果是单线程做这个操作，那是没问题的，但是如果出现并发的情况呢？如果并发很低并且操作轻量，给这个业务方法上同步锁，也是没有问题的，但是如果并发稍微高一些，就不可能放个同步锁了，这时如果还使用这个方案，很有可能会出现 <code>No operations allowed after connection closed</code> 错误，这是因为连接是共享的，如果后启动的线程 2 先执行完并且关闭了连接，先启动的线程 1 再执行相关操作时连接已经被关闭了。</p>\n<hr>\n<h1 id=\"3-ThreadLocal如何解决问题\"><a href=\"#3-ThreadLocal如何解决问题\" class=\"headerlink\" title=\"3. ThreadLocal如何解决问题\"></a>3. ThreadLocal如何解决问题</h1><p>ThreadLocal 为每个线程分配了一个独立的资源副本，并在内部通过一个 Table 表来维护每个线程和其拥有的独立资源副本的映射关系，所有的线程共享这个 Table。简单点说，ThreadLocal 中通过 <code>set()</code> 方法存入对象，通过 <code>get()</code> 方法取出对象，且线程存入的对象只有该线程自己可以获取到，，每个线程也只能获取到自己之前存入的对象，如果没有存入则调用 <code>get()</code> 返回的是 <code>null</code>。</p>\n<p>因此针对以上两个场景，用 ThreadLocal 就可以很好地解决痛点。</p>\n<p>（1）首先是会话连接的持久化，每个线程在建立连接后，调用 <code>set()</code>将自己的 Cookie 存入，并在需要的时候调用 <code>get()</code> 获取即可，对于每个会话线程，<code>get()</code> 到的都只是自己的 Cookie。</p>\n<p>（2）第二个数据库连接管理，也可以把共用的 Connection 放进 ThreadLocal 中管理，改成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Connection&gt; localConnection = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(connection == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Class.forName(driver);</span><br><span class=\"line\">                connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.set(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个新线程调用 <code>DBUtil.getConnection()</code> 时，会先判断当前线程是否已经存入了一个连接，如果已经存入则直接获取并返回，否则创建一个新的连接，关闭连接时同理。这样，线程之间的连接都是自己的独立对象，不会互相影响。</p>\n<hr>\n<h1 id=\"4-ThreadLocal和同步锁的比较\"><a href=\"#4-ThreadLocal和同步锁的比较\" class=\"headerlink\" title=\"4. ThreadLocal和同步锁的比较\"></a>4. ThreadLocal和同步锁的比较</h1><p>当然，ThreadLocal 并不是万能的，相比较同步锁方式，由于每个线程都拥有自己的资源副本，因此消耗的内存也更多，需要根据具体的业务确定方案。详细分析将在之后重新整理一份独立文章。</p>\n<hr>\n<h1 id=\"5-ThreadLocal源码分析\"><a href=\"#5-ThreadLocal源码分析\" class=\"headerlink\" title=\"5. ThreadLocal源码分析\"></a>5. ThreadLocal源码分析</h1><p>暂未完成</p>\n","categories":["Java"],"tags":["Java","源码","ThreadLocal"]},{"title":"Mac编译FFmpeg踩坑记录","url":"/post/note/note-build-ffmpeg/","content":"<span id=\"more\"></span>\n\n<p>前言：实际上网上关于如何编译 FFmpeg 的文章已经相当多了，但是等到自己真的要用的时候才发现，能找到的大部分文章多少都有些不够完善，或是有遗漏的说明，或是版本、环境太久远，为此踩了不少的坑，最后发现还是读官方文档最省事。特地记录一篇文章，并尽可能详细地写出具体步骤。</p>\n<hr>\n<h1 id=\"1-环境和所需的文件\"><a href=\"#1-环境和所需的文件\" class=\"headerlink\" title=\"1. 环境和所需的文件\"></a>1. 环境和所需的文件</h1><p>先是环境：</p>\n<ul>\n<li>FFmpeg：3.3.9</li>\n<li>NDK：android-ndk-r14b</li>\n<li>系统：MacOS 10.15</li>\n<li>编译目标：给 Android 用的 ARM 平台</li>\n</ul>\n<p>再给出几个下载链接：</p>\n<ul>\n<li>FFmpeg：<a href=\"https://ffmpeg.org/download.html#releases\" title=\"@LINK\">点此下载</a></li>\n<li>NDK：<a href=\"https://developer.android.google.cn/ndk/downloads/index.html\" title=\"@LINK\">点此下载</a></li>\n</ul>\n<blockquote>\n<p>@注：<font color=red>不建议使用 AndroidStudio 自带的 ndk-bundle 编译，不建议使用最新版 FFmpeg，不建议使用最新版 NDK，理由不明（笑）。</font></p>\n</blockquote>\n<p>使用最新的 FFmpeg 4.x，按照网上主流的做法，修改 <code>configure</code> 文件然后新建脚本 <code>build_android.sh</code> 的方法，会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\">Makefile:67: /common.mak: No such file or directory</span><br><span class=\"line\">Makefile:114: /libavutil/Makefile: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">C compiler <span class=\"built_in\">test</span> failed.</span><br><span class=\"line\"></span><br><span class=\"line\">If you think configure made a mistake, make sure you are using the latest</span><br><span class=\"line\">version from Git.  If the latest version fails, report the problem to the</span><br><span class=\"line\">ffmpeg-user@ffmpeg.org mailing list or IRC <span class=\"comment\">#ffmpeg on irc.freenode.net.</span></span><br><span class=\"line\">Include the <span class=\"built_in\">log</span> file <span class=\"string\">&quot;config.log&quot;</span> produced by configure as this will <span class=\"built_in\">help</span></span><br><span class=\"line\">solve the problem.</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">make: *** No rule to make target `/tests/Makefile<span class=\"string\">&#x27;.  Stop.</span></span><br></pre></td></tr></table></figure>\n\n<p>报了一堆 <code>No such file or directory</code> 错误，第一行的 <code>config.mak</code> 也可能是 <code>ffbuild/config.mak</code>，带着错误去搜也搜不到什么头绪，根据报错信息去 FFmpeg 的根目录下或者 <code>ffbuild/</code> 下也确实找不到所谓的 <code>config.mak</code>，一个解决方案是：</p>\n<ul>\n<li><ol>\n<li>先不要修改 <code>configure</code> 文件，直接执行：<code>./configure</code>，但是大概率会报这个错误：</li>\n</ol>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nasm/yasm not found or too old. Use --disable-x86asm <span class=\"keyword\">for</span> a crippled build.</span><br></pre></td></tr></table></figure>\n\n<p>  只要按照提示加上 <code>--disable-x86asm</code> 参数即可，重新执行完会自动生成缺失的文件。</p>\n<ul>\n<li><ol start=\"2\">\n<li>再重新执行脚本：<code>sudo ./build_android.sh</code>。</li>\n</ol>\n</li>\n</ul>\n<p>但是这么做，如果是最新的 NDK 或者最新的 FFmpeg，执行完倒是不报错，但是并不会编译输出 SO 文件，所以还是老老实实用已有方案的版本吧！</p>\n<hr>\n<h1 id=\"2-编译SO文件\"><a href=\"#2-编译SO文件\" class=\"headerlink\" title=\"2. 编译SO文件\"></a>2. 编译SO文件</h1><h2 id=\"2-1-配置NDK\"><a href=\"#2-1-配置NDK\" class=\"headerlink\" title=\"2.1 配置NDK\"></a>2.1 配置NDK</h2><p>首先，NDK 下载好后，放到自定义目录中，需要添加到环境变量中去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果用的是 bash 终端：</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果用的是 zsh 终端：</span></span><br><span class=\"line\">vim ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量（按照实际目录）：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> NDK_HOME=/Applications/AndroidStudio/android-ndk-r14b/build</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;NDK_HOME&#125;</span>:<span class=\"variable\">$&#123;PATH&#125;</span>:</span><br></pre></td></tr></table></figure>\n\n<p>保存退出，然后刷新并测试环境变量，执行：<code>ndk-build</code>，如果有类似以下输出则表明配置成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android NDK: Could not find application project directory !</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>还需要给所有文件加上权限，进入 NDK 的目录并执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod -R 777 ./*</span><br></pre></td></tr></table></figure>\n\n<p><font color=red>温馨提示：可千万不要把 <code>./*</code> 给打错了，要是不小心把“.”漏了可就麻烦了（请务必不要尝试）。</font></p>\n<h2 id=\"2-2-配置FFmpeg\"><a href=\"#2-2-配置FFmpeg\" class=\"headerlink\" title=\"2.2 配置FFmpeg\"></a>2.2 配置FFmpeg</h2><p>把下载好的 FFmpeg 源码解压到任意目录，同样也按上述操作给所有文件加上权限，接下来再在 FFmpeg 根目录下创建一个脚本（命名随意）：<code>build_android.sh</code>，修改内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以实际自定义临时目录为准，必须指定否则报错：Unable to create temporary file in</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> TMPDIR=/....../TEMP</span><br><span class=\"line\"><span class=\"comment\"># 以 NDK 实际路径为准</span></span><br><span class=\"line\">NDK=/Applications/Androidstudio/android-ndk-r14b</span><br><span class=\"line\"><span class=\"comment\"># 编译目标平台，本例选择最低 API 22 的 ARM 平台，输出 SO 文件放在 Android 项目的 libs/armeabi/ 目录下</span></span><br><span class=\"line\"><span class=\"comment\"># x86 架构则选择 arch-x86</span></span><br><span class=\"line\">PLATFORM=<span class=\"variable\">$NDK</span>/platforms/android-22/arch-arm</span><br><span class=\"line\"><span class=\"comment\"># 编译所需工具链，arm-linux-androideabi 对应上面的 ARM 平台，4.9 为版本号，以 NDK 中的实际版本为准</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64</span><br><span class=\"line\"><span class=\"keyword\">function</span> build_one</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">./configure \\</span><br><span class=\"line\">    --prefix=<span class=\"variable\">$PREFIX</span> \\</span><br><span class=\"line\">    --target-os=linux \\</span><br><span class=\"line\">    --cross-prefix=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \\</span><br><span class=\"line\">    --arch=arm \\</span><br><span class=\"line\">    --sysroot=<span class=\"variable\">$PLATFORM</span> \\</span><br><span class=\"line\">    --extra-cflags=<span class=\"string\">&quot;-I<span class=\"variable\">$PLATFORM</span>/usr/include&quot;</span> \\</span><br><span class=\"line\">    --cc=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-gcc \\</span><br><span class=\"line\">    --nm=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-nm \\</span><br><span class=\"line\">    --disable-shared \\</span><br><span class=\"line\">    --enable-runtime-cpudetect \\</span><br><span class=\"line\">    --enable-gpl \\</span><br><span class=\"line\">    --enable-small \\</span><br><span class=\"line\">    --enable-cross-compile \\</span><br><span class=\"line\">    --disable-debug \\</span><br><span class=\"line\">    --enable-static \\</span><br><span class=\"line\">    --disable-doc \\</span><br><span class=\"line\">    --disable-asm \\</span><br><span class=\"line\">    --disable-ffmpeg \\</span><br><span class=\"line\">    --disable-ffplay \\</span><br><span class=\"line\">    --disable-ffprobe \\</span><br><span class=\"line\">    --disable-ffserver \\</span><br><span class=\"line\">    --disable-postproc \\</span><br><span class=\"line\">    --disable-avdevice \\</span><br><span class=\"line\">    --disable-symver \\</span><br><span class=\"line\">    --disable-stripping \\</span><br><span class=\"line\"><span class=\"variable\">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINT 0/HAVE_LRINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUND 0/HAVE_ROUND 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_CBRT 0/HAVE_CBRT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_RINT 0/HAVE_RINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make -j4</span><br><span class=\"line\">make install</span><br><span class=\"line\"><span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-ld \\</span><br><span class=\"line\">-rpath-link=<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PREFIX</span>/lib \\</span><br><span class=\"line\">-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \\</span><br><span class=\"line\"><span class=\"variable\">$PREFIX</span>/libffmpeg.so \\</span><br><span class=\"line\">    libavcodec/libavcodec.a \\</span><br><span class=\"line\">    libavfilter/libavfilter.a \\</span><br><span class=\"line\">    libswresample/libswresample.a \\</span><br><span class=\"line\">    libavformat/libavformat.a \\</span><br><span class=\"line\">    libavutil/libavutil.a \\</span><br><span class=\"line\">    libswscale/libswscale.a \\</span><br><span class=\"line\">    -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \\</span><br><span class=\"line\">    <span class=\"variable\">$TOOLCHAIN</span>/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 平台类型，可以是 arm 或 armv7-a 或 x86 等</span></span><br><span class=\"line\">CPU=armv7-a</span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出 SO 的目录</span></span><br><span class=\"line\">PREFIX=./android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">ADDITIONAL_CONFIGURE_FLAG=</span><br><span class=\"line\">build_one</span><br></pre></td></tr></table></figure>\n\n<p>接下来在当前目录执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按实际创建的脚本名</span></span><br><span class=\"line\">./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>需要等一段编译时间，但总之是成功编译了，脚本配置中的“编译后 SO 文件输出目录” <code>PREFIX=./android/$CPU-vfp</code> 表示：<code>当前目录/android/平台类型</code>，比如我当前目录为 <code>/Applications/FFmpeg</code>，平台类型是 <code>arm</code>，则输出目录为：<code>/Applications/FFmpeg/android/arm/</code>。</p>\n<p>编译完可能会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">install: /usr/<span class=\"built_in\">local</span>/share/man/man1/ffmpeg.1: Permission denied</span><br><span class=\"line\">make: *** [install-man] Error 71</span><br></pre></td></tr></table></figure>\n\n<p>权限错误，也可能是 <code>man3</code> 报的错，简便一点的方法就是直接用 Super User 权限安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，在 FFmpeg 根目录下的 <code>android/armv7-a/</code> 下即可看到 <code>libffmpeg.so</code> 文件，复制到 Android 项目中再配置 NDK 即可。</p>\n<hr>\n<h1 id=\"3-附录-参考指导\"><a href=\"#3-附录-参考指导\" class=\"headerlink\" title=\"3. 附录[参考指导]\"></a>3. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/dfe9404e001a\" title=\"@LINK\">【1】Android Studio下编译FFmpeg so文件（作者：Galaxy北爱）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/vichild/article/details/82686343\" title=\"@LINK\">【1】win10子系统编译ffmpeg for android遇到的问题记录（作者：wellchang）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.jianshu.com/p/c8ad83dd5585\" title=\"@LINK\">【1】Android编译ffmpeg常见错误（作者：JXiaoNiu）<sup>【注】</sup></a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015631928\" title=\"@LINK\">【1】Mac中编译FFmpeg教程(Android版)（作者：码出世界）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Note"],"tags":["FFMPEG","SO库","编译"]},{"title":"常用Git命令","url":"/post/note/note-git/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-基本Git操作指令\"><a href=\"#1-基本Git操作指令\" class=\"headerlink\" title=\"1. 基本Git操作指令\"></a>1. 基本Git操作指令</h1><h2 id=\"1-1-创建仓库\"><a href=\"#1-1-创建仓库\" class=\"headerlink\" title=\"1.1 创建仓库\"></a>1.1 创建仓库</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将当前目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在当前目录下创建一个新的目录，并新目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init [new dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库克隆到本地</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> [url]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-查看仓库配置\"><a href=\"#1-2-查看仓库配置\" class=\"headerlink\" title=\"1.2 查看仓库配置\"></a>1.2 查看仓库配置</h2><p>Git 配置分为全局配置、以及各个仓库自己的局部配置，仓库的局部配置会与全局配置合并去重，重复的配置项以仓库局部配置为准。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全局 Git 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 全局 Git 配置保存在 ~/.gitconfig</span></span><br><span class=\"line\">git config --global --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前目录下仓库的 Git 局部配置</span></span><br><span class=\"line\"><span class=\"comment\"># 当前仓库的 Git 配置保存在 [仓库目录]/.git/config</span></span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看接的远程仓库</span></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看连接的远程仓库的地址</span></span><br><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-分支管理\"><a href=\"#1-3-分支管理\" class=\"headerlink\" title=\"1.3 分支管理\"></a>1.3 分支管理</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从远程连接仓库拉取最新数据到本地仓库</span></span><br><span class=\"line\">git fetch [name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有远程分支</span></span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地以及远程的分支</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但不切换</span></span><br><span class=\"line\">git branch [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到新的分支，并更新工作区文件（切换到新分支的改动记录）</span></span><br><span class=\"line\">git checkout [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该新分支，同时更新工作区文件</span></span><br><span class=\"line\">git checkout -b [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将指定的本地分支连接到远程分支</span></span><br><span class=\"line\">git branch --set-upstream [<span class=\"built_in\">local</span> branch name] [remote branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个本地分支</span></span><br><span class=\"line\">git branch -d [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同时从本地和远程删除一个分支</span></span><br><span class=\"line\">git branch -dr [remote/branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将另一个本地分支的改动合并到当前分支</span></span><br><span class=\"line\">git merge [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下的某个改动提交记录同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下多个改动提交记录同时同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id1] [commit id2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左开右闭（即不包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]..[commit id5]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左闭右闭（包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]^..[commit id5]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-提交变更\"><a href=\"#1-4-提交变更\" class=\"headerlink\" title=\"1.4 提交变更\"></a>1.4 提交变更</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将改动文件提交到暂存区</span></span><br><span class=\"line\">git add [file1] [file2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将某个目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区的所有改动提交到仓库</span></span><br><span class=\"line\">git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区并同时显示每个改动的 Diff</span></span><br><span class=\"line\">git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有文件变更状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录，并显示每次提交时发生变更的文件</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"2-常见的跨仓库设置\"><a href=\"#2-常见的跨仓库设置\" class=\"headerlink\" title=\"2. 常见的跨仓库设置\"></a>2. 常见的跨仓库设置</h1><h2 id=\"2-1-同时Push到多个仓库\"><a href=\"#2-1-同时Push到多个仓库\" class=\"headerlink\" title=\"2.1 同时Push到多个仓库\"></a>2.1 同时Push到多个仓库</h2><p>通过 <code>git remote -v</code> 可以查看当前仓库拉取（fetch）和推送（push）的远程仓库的链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin\thttps://XXX.git (fetch)</span><br><span class=\"line\">origin\thttps://XXX.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>如果想同时 Push 到多个仓库可以通过如下方式添加多个目标仓库地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add [name] [url]</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>[name]</code> 对应的是远程仓库的别名，例如上述的 <code>origin</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add origin https://new-push-url.git</span><br></pre></td></tr></table></figure>\n\n<p>设置后再次用 <code>git remote -v</code> 查看远程仓库链接，即可看到已经有两个 Push 地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin\thttps://XXX.git (fetch)</span><br><span class=\"line\">origin\thttps://XXX.git (push)</span><br><span class=\"line\">origin\thttps://new-push-url.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>实际上也可以通过直接修改当前仓库的局部配置文件添加，修改 <code>仓库目录/.git/config</code> 文件，在 <code>[remote]</code> 部分内添加一个 <code>url</code> 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[core]</span><br><span class=\"line\">        ......</span><br><span class=\"line\">[remote <span class=\"string\">&quot;origin&quot;</span>]</span><br><span class=\"line\">        url = https://XXX.git</span><br><span class=\"line\">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class=\"line\">        url = https://new-push-url.git</span><br><span class=\"line\">[branch <span class=\"string\">&quot;master&quot;</span>]</span><br><span class=\"line\">        ......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-同时连接到多个远程仓库\"><a href=\"#2-2-同时连接到多个远程仓库\" class=\"headerlink\" title=\"2.2 同时连接到多个远程仓库\"></a>2.2 同时连接到多个远程仓库</h2><p>假如有一个本地仓库，出于容灾、备份、等目的，同时推送到了两个远程托管平台，以 GitHub 和 Coding 为例：</p>\n<ul>\n<li><p>假设 GitHub 上的远程仓库地址为 <code>https://XXX.github.git</code></p>\n</li>\n<li><p>假设 Coding 上的远程仓库地址为 <code>https://XXX.coding.git</code>。</p>\n</li>\n</ul>\n<p>而其他人分别基于不同的平台各自推送了特性分支，此时两个远程仓库的分支列表分别为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GitHub 的分支列表：</span></span><br><span class=\"line\">* develop</span><br><span class=\"line\">  main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Coding 的分支列表：</span></span><br><span class=\"line\">* release</span><br><span class=\"line\">  main</span><br></pre></td></tr></table></figure>\n\n<p>假设基于 GitHub 的远程仓库克隆了本地仓库，此时如果直接在 <code>develop</code> 分支上尝试合并 <code>release</code> 分支，会因为找不到 <code>release</code> 分支而失败：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">merge: release - not something we can merge</span><br></pre></td></tr></table></figure>\n\n<p>想要对这两个来自不同平台的独立的分支做合并，就需要让本地仓库同时连接多个远程仓库了。</p>\n<p>通过 <code>git remote -v</code> 查看本地仓库当前的远程连接地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin\thttps://XXX.github.git (fetch)</span><br><span class=\"line\">origin\thttps://XXX.github.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>给本地仓库再添加 Coding 的远程仓库连接地址，为了方便区分将新的远程仓库命名为 <code>coding</code>，则对应命令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git remote add &lt;option&gt; [name] [url]</span></span><br><span class=\"line\">git remote add coding https://XXX.coding.git</span><br></pre></td></tr></table></figure>\n\n<p>再次通过 <code>git remote -v</code> 即可看到该本地仓库已经同时连接到了两个远程仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin\thttp://XXX.github.git (fetch)</span><br><span class=\"line\">origin\thttp://XXX.github.git (push)</span><br><span class=\"line\">coding\thttps://XXX.coding.git (fetch)</span><br><span class=\"line\">coding\thttps://XXX.coding.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>接下来同时把两个远程仓库的数据都拉取下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取名为 origin 的仓库，即 GitHub 上的</span></span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取名为 coding 的仓库，即 Coding 上的</span></span><br><span class=\"line\">git fetch coding</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试在 <code>develop</code> 分支上合并 <code>release</code> 分支即可正常合并，当然如果有冲突也会进入常规流程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 develop 分支</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并 release 分支</span></span><br><span class=\"line\">git merge release</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-3-跨仓库Cherry-Pick\"><a href=\"#2-3-跨仓库Cherry-Pick\" class=\"headerlink\" title=\"2.3 跨仓库Cherry-Pick\"></a>2.3 跨仓库Cherry-Pick</h2><p>通常来说 Cherry-Pick 发生在仓库内的不同分支，用于将其他分支的改动同步到当前分支。</p>\n<p>如果一个仓库 <code>GitHub</code> 想要在 Cherry-Pick 另一个仓库 <code>Coding</code> 的提交（例如 commit123fromsource），就会报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">fatal: bad revision <span class=\"string\">&#x27;commit123fromsource&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果这两个仓库是 Fork 的关系，或者只是同一个仓库在不同托管平台的备份，本质上它们是同源的，想要互相支持 Cherry-Pick 的话就需要通过上文 2.2 中的方法，给本地仓库同时添加两份远程仓库的连接，然后就能随意 Cherry-Pick 了，当然如果发生冲突也会进入常规流程。</p>\n<p>实际上，一个本地仓库可以随意添加多个远程仓库的地址，然后就能随意操作其他仓库的分支或 Commit，但是 Cherry-Pick 需要满足一定的条件，例如涉及到的改动文件具有同源的改动记录，否则就会失败，只能从最开始文件创建的时候开始 Cherry-Pick 才行。</p>\n","categories":["Note"],"tags":["Git","Cherry-Pick","仓库","分支"]},{"title":"ML入门-损失和正则的概率解释","url":"/post/machinelearning/ml-linear/ml-linear-loss-regular/","content":"<span id=\"more\"></span>\n\n<p>结论：最小 L2、L1 损失均等价于极大似然估计；带正则的回归等价于贝叶斯估计。</p>\n<hr>\n<h1 id=\"1-损失函数的概率解释\"><a href=\"#1-损失函数的概率解释\" class=\"headerlink\" title=\"1. 损失函数的概率解释\"></a>1. 损失函数的概率解释</h1><h2 id=\"1-1-L2损失与极大似然估计\"><a href=\"#1-1-L2损失与极大似然估计\" class=\"headerlink\" title=\"1.1 L2损失与极大似然估计\"></a>1.1 L2损失与极大似然估计</h2><p>对采用 L2 损失的模型，目标函数为：</p>\n<p>$$<br>J(W) = RSS(W) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>在回归任务重，令模型中的真实值 $y_i$ 和预测值 $\\hat{y_i}$ 之间的差异为白噪声 $\\varepsilon$，假设噪声（随机变量）$\\varepsilon$ 符合 0 均值的正态分布：$\\varepsilon \\sim N(0, \\sigma^2)$。</p>\n<p>用 $y | X$ 表示给定输入 $X$ 的情况下的输出 $y$，当输入$X$ 给定时，$f(X) = W^T X$ 是一个常数，因此 $y = f(X) + \\varepsilon$ 也是一个随机变量：$y | X \\sim N(f(X), \\sigma^2)$</p>\n<blockquote>\n<p>@注：随机变量加上一个常数，只改变分布的均值，不改变分布的方差。</p>\n</blockquote>\n<p>对于正态分布，其概率密度函数为：</p>\n<p>$$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {\\left( y - f(X) \\right)^2} {2 \\sigma^2} \\right)<br>$$</p>\n<blockquote>\n<p>@注：很多分布的概率密度函数为指数函数形式，因此通常取 log 运算，log 函数为单调函数，对似然函数取 log 不影响极值点位置。</p>\n</blockquote>\n<p>似然函数（Likelihood）为：$likelihood(f) = p(D)$，定义为数据出现的概率。在回归任务中，通常假定所有数据都是独立同分布的，因而对所有数据 $D$，其联合概率等于每个独立样本概率的积：</p>\n<p>$$<br>p(D) = \\prod^N_{i = 1} p(y_i | x_i)<br>$$</p>\n<p>对似然函数取 $\\log$ 运算（$\\log$ 是单调函数，不改变极值点位置，与似然函数等价）得到 $\\log$ 似然函数（积取 log 等于 log 再取和，）即为：</p>\n<p>$$<br>\\begin{aligned}<br>l(f) &amp;= \\log p(D) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ (2 \\pi)^{- \\dfrac {1} {2}} \\cdot \\sigma^{-1} \\cdot \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\<br>&amp;= \\sum^N_{i = 1} \\left[ - \\dfrac {1} {2} \\log (2 \\pi) - \\log \\sigma - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right]<br>\\<br>&amp;= - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$$</p>\n<p>去掉 $l(f)$ 中常数项（不影响极值点位置），当 $l(f)$ 取最大值时可得 **<font color=EB6D39>极大似然估计</font>**：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)<br>\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\<br>= &amp; \\dfrac {1} {2 \\sigma^2} \\min \\sum^N_{i = 1} (y_i - f(x_i))^2<br>\\end{aligned}<br>$$</p>\n<p>同样，去掉系数 $\\dfrac {1} {2 \\sigma^2}$ 不影响极值点位置，而其中的似然项</p>\n<p>$<br>\\sum^N_{i = 1} (y_i - f(x_i))^2 = RSS(f)<br>$</p>\n<p>恰好 是残差平方和 / 训练集上的 L2 损失和，因此：</p>\n<p>$$<br>\\begin{aligned}<br>\\max l(f) &amp;<br>\\<br>极大似然估计 &amp;<br>\\end{aligned}<br>\\begin{aligned}<br>\\Longleftrightarrow \\min \\sum^N_{i = 1} (y_i - f(x_i))^2 \\Longleftrightarrow<br>\\<br>\\quad<br>\\end{aligned}<br>\\begin{aligned}<br>&amp; \\min RSS(f)<br>\\<br>&amp; 最小二乘<br>\\end{aligned}<br>$$</p>\n<center>\n\n<p><strong><font color=red>极大似然估计等价于最小二乘。</font></strong></p>\n</center>\n\n<p>又由于 log 似然即：$l(f)$，与极大似然有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)：极大似然估计<br>\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\<br>= &amp; \\min - l(f)：负 log 似然最小<br>\\end{aligned}<br>$$</p>\n<center>\n\n<p><strong><font color=red>极大似然估计等价于负 log 似然最小。</font></strong></p>\n</center>\n\n<p>因此负 log 似然也被成为一种损失函数：负 log 似然损失。</p>\n<ul>\n<li>L2 损失是负 log 似然损失。</li>\n<li>分类任务中的 Logistic 回归使用的也是负 log 似然损失。</li>\n</ul>\n<p>将上述极大似然估计推广为一般形式：</p>\n<p>$$<br>l(\\theta) = \\log (D | \\theta) = \\sum^N_{i = 1}\\log p(X_i | \\theta)<br>$$</p>\n<p>其中 $\\theta$ 为需要求解的分布的参数，$X$ 为每条样本。</p>\n<p>统计中需要根据观测数据 $D= { X_i }^N_{i = 1}$ 估计分布的参数 $\\theta$，一种常用的参数估计即为 **<font color=EB6D39>极大似然估计</font>**，即，使得 log 似然函数 $l(f)$ 最大时的 $\\theta$ 作为估计值：</p>\n<p>$$<br>\\hat{\\theta} = \\arg_{\\theta} \\max l(\\theta)<br>$$</p>\n<h2 id=\"1-2-L1-损失与极大似然估计\"><a href=\"#1-2-L1-损失与极大似然估计\" class=\"headerlink\" title=\"1.2 L1 损失与极大似然估计\"></a>1.2 L1 损失与极大似然估计</h2><p>L1 损失最小也等价于极大似然估计，此时噪声模型为 Laplace 分布：</p>\n<p>$$<br>\\varepsilon \\sim Laplace(\\mu, b) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|x - \\mu|} {b} \\right)<br>$$</p>\n<hr>\n<h1 id=\"2-正则项的概率解释\"><a href=\"#2-正则项的概率解释\" class=\"headerlink\" title=\"2. 正则项的概率解释\"></a>2. 正则项的概率解释</h1><h2 id=\"2-1-L2正则与正态分布先验\"><a href=\"#2-1-L2正则与正态分布先验\" class=\"headerlink\" title=\"2.1 L2正则与正态分布先验\"></a>2.1 L2正则与正态分布先验</h2><p>在损失函数的概率解释中已经推出：假设数据产生模型为</p>\n<p>$<br>y = f(X) + \\varepsilon, \\quad \\varepsilon \\sim N(0, \\sigma^2)<br>$</p>\n<p>则 $y | X \\sim N(f(X; W), \\sigma^2)$，即</p>\n<p>$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y - f(X; W))^2} {2 \\sigma^2} \\right)<br>$</p>\n<p><strong><font color=EB6D39>似然函数为：</font></strong></p>\n<p>$$<br>似然 \\quad likelihood(f) = p(D | W) = \\prod^N_{i = 1} p(y_i | x_i) = \\prod^N_{i = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x_i; W))^2} {2 \\sigma^2} \\right)<br>$$</p>\n<p>为了模型不太复杂，增加一个参数的先验：$w_j$ 的值不能太大，也即 $w_j$ 取 0 附近的值概率更高，假设 $W$ 为独立同分布，此时可用正态分布来表示 $w_j$ 的取值分布：$w_j \\sim N(0, \\tau^2)$</p>\n<center>\n\n<p><img data-src=\"./w_distribution.png\" alt=\"W 取值分布\" title=\"@ASSET\"></p>\n</center>\n\n<p>则对每一个 $w_j$，其概率密度函数为：</p>\n<p>$<br>p(w_j) = \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$</p>\n<p>因此对 $W$，其联合概率密度函数即为 **<font color=EB6D39>先验</font>**：</p>\n<p>$$<br>先验 \\quad p(W) = \\prod^D_{j = 1} p(w_j) = \\prod^D_{j = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$$</p>\n<p>根据 <a href=\"https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F\" title=\"@LINK\">贝叶斯公式</a>，参数的 <strong><font color=EB6D39>后验分布</font></strong> 正比于 **<font color=EB6D39>先验 x 似然</font>**：</p>\n<p>$$<br>后验 \\quad p(W | D) \\propto p(W) p(D | W)<br>$$</p>\n<p>去掉正比系数（不影响极值点位置）并两边同取 log 运算可得：</p>\n<p>$<br>\\begin{aligned}<br>&amp; \\log p(W | D) = \\log p(W) + \\log p(D | W)<br>\\<br>&amp;= - \\dfrac {D} {2} \\log (2 \\pi) - D \\log \\tau - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$</p>\n<p>贝叶斯最大后验估计（Maximun A Posteriori estimation, MAP）为</p>\n<p>$<br>\\hat{W} = \\arg_W \\max \\log p(W | D)<br>$</p>\n<p>将上述 $\\log p(W | D)$ 代入并去掉与 $W$ 无关的常数项（不影响极值点位置）后得：</p>\n<p>$<br>\\begin{aligned}<br>\\hat{W} &amp;= \\arg_W \\max \\log p(W | D)<br>\\<br>&amp;= \\arg_W \\max \\left( - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\<br>&amp;= \\arg_W \\min \\left( \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} + \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\<br>乘以 2 \\sigma^2 &amp;= \\arg_W \\min \\left( \\dfrac {\\sigma^2} {\\tau^2} \\sum^D_{j = 1} w^2_j + \\sum^N_{i = 1} (y_i - f(x_i; w))^2 \\right)<br>\\end{aligned}<br>$</p>\n<p>上式令 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 得：</p>\n<p>$$<br>\\hat{W} = \\arg_W \\min \\left( \\sum^N_{i = 1} (y_i - f(x_i; w))^2 + \\lambda \\sum^D_{j = 1} w^2_j \\right)<br>$$</p>\n<p><strong>等价于岭回归的目标参数</strong>，因此有结论：</p>\n<center>\n\n<p><strong><font color=red>L2 正则等价于正态分布先验 $N(0, \\tau^2)$。</font></strong></p>\n</center>\n\n<p>由于 $\\sigma^2$ 控制了噪声分布，而 $\\tau^2$ 控制了先验，因此 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 实际上控制了先验的强度（$w_j$ 靠近 0 的程度）。</p>\n<h2 id=\"2-2-L1正则与Laplace分布先验\"><a href=\"#2-2-L1正则与Laplace分布先验\" class=\"headerlink\" title=\"2.2 L1正则与Laplace分布先验\"></a>2.2 L1正则与Laplace分布先验</h2><p>L1 正则等价于 Laplace 先验，此时先验分布为 Laplace 分布：</p>\n<p>$$<br>p(w_j) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|w_j|} {b} \\right)<br>$$</p>\n<center>\n\n<p><img data-src=\"./laplace_distribution.png\" alt=\"Laplace 分布\" title=\"@ASSET\"></p>\n</center>","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-多类分类任务","url":"/post/machinelearning/ml-logistic/ml-logistic-multiclassify/","content":"<span id=\"more\"></span>\n\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-类别样本不均衡问题","url":"/post/machinelearning/ml-logistic/ml-logistic-unbalanced/","content":"<span id=\"more\"></span>\n\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-模型性能评价指标","url":"/post/machinelearning/ml-model/ml-model-performance/","content":"<span id=\"more\"></span>\n\n<p>前言：一个机器学习模型训练好后，需要采用一些度量准则评价模型预测的效果。根据任务的种类可以分为回归模型评价指标和分类模型评价指标。</p>\n<hr>\n<h1 id=\"1-回归模型性能评价指标\"><a href=\"#1-回归模型性能评价指标\" class=\"headerlink\" title=\"1. 回归模型性能评价指标\"></a>1. 回归模型性能评价指标</h1><h1 id=\"1-1-常见的-6-种评价指标\"><a href=\"#1-1-常见的-6-种评价指标\" class=\"headerlink\" title=\"1.1 常见的 6 种评价指标\"></a>1.1 常见的 6 种评价指标</h1><p>（1）开放均方误差（Rooted Mean Squared Error, RMSE）：</p>\n<p>$<br>RMSE(y, \\hat{y}) = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i, \\hat{y_i})^2}<br>$</p>\n<p>开放的目的在于使得 RMSE 的返回值与 $y$ 的单位一致。</p>\n<p>（2）平均绝对值误差（Mean Absolute Error, MAE）：</p>\n<p>$<br>MAE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} |y_i - \\hat{y_i}|<br>$</p>\n<p>（3）绝对误差中值（Median Absolute Error, MedAE）：</p>\n<p>$<br>MedAE(y, \\hat{y}) = median(|y_1 - \\hat{y_1}|, \\cdots, |y_N - \\hat{y_N}|)<br>$</p>\n<p>相对于均值，中值对噪声点较不敏感。</p>\n<p>（4）平均平方 $\\log$ 误差（Mean Squared Logarithmic Error, MSLE）：</p>\n<p>$<br>MSLE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} \\left( \\log (1 + y_i) - \\log (1 + \\hat{y_i}) \\right)^2<br>$</p>\n<p>当 $y$ 呈指数增长时可以使用，如计数、一年的平均销量、价格等。$1 + y_i$ 与 $1 + \\hat{y_i}$ 的目的是为了确保 $\\log$ 计算有意义（当 $y_i / \\hat{y_i} = 0$ 时，$\\log 0$ 无意义）。</p>\n<p>（5）$R^2$ 分数（$R^2$ Score）：</p>\n<p>$<br>\\begin{aligned}<br>&amp; SS_{res}(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2<br>\\<br>&amp; SS_{tot}(y) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\bar{y})^2<br>\\<br>&amp; R^2(y, \\hat{y}) = 1 - \\dfrac {SS_{res}(y, \\hat{y})} {SS_{tot}(y)}<br>\\end{aligned}<br>$</p>\n<p>$R^2$ 分数既考虑了预测值与真实值之间的差异，又考虑了问题本身针织之间的差异，是 Scikit-Learn 线性回归模型的默认评价准则。当 $SS_{res} = 0$ 时，$R^2 = 1$ 为最佳分数，分数越低则模型性能越差，可能为负值。</p>\n<p>（6）已解释的访查分数（Explained variance socre）：</p>\n<p>$<br>explained_variance(y, \\hat{y}) = 1 - \\dfrac {Var(y - \\hat{y})} {Var { y } }<br>$</p>\n<h2 id=\"1-2-Scikit-Learn中的评价指标\"><a href=\"#1-2-Scikit-Learn中的评价指标\" class=\"headerlink\" title=\"1.2 Scikit-Learn中的评价指标\"></a>1.2 Scikit-Learn中的评价指标</h2><p>Scikit-Learn 中有三种评价模型性能的方式，但基本都是通过上述 6 种计算方式实现的。</p>\n<p>（1）每个学习器 Estimator 自己的 <code>score</code> 方法，提供一个默认的评估方法（回归为 $R^2$ 分数）。</p>\n<p>（2）Metric：<code>sklearn.metrics</code> 模块实现了一些函数，用来评估预测误差。</p>\n<p><code>sklearn.metrics</code> 中的回归评价指标：</p>\n<p>① <code>metrics.explained_variance_score(y_true, y_pred)</code>：Explained variance regression score function<br>② <code>metrics.mean_absolute_error(y_true, y_pred)</code>：Mean-Absolute-Error regression loss<br>③ <code>metrics.mean_squared_error(y_true, y_pred[, ...])</code>：Mean-Squared-Error regression loss<br>④ <code>metrics.mean_squared_log_error(y_true, y_pred)</code>：Mean-Squared-Logarithmic-Error regression loss<br>⑤ <code>metrics.median_absolute_error(y_true, y_pred)</code>：Median-Absolute-Error regression loss<br>⑥ <code>metrics.r2_score(y_true, y_pred[, ...])</code>：$R^2$ (coefficient of determination) regression score function.</p>\n<p>（3）Scoring 参数：使用交叉验证评估模型的工具有 Scoring 参数，与 Metrics 一一对应。</p>\n<p>① <code>explained_variance</code>；metrics.explained_variance_score<br>② <code>neg_mean_absolute_error</code>：metrics.mean_absolute_error<br>③ <code>neg_mean_squared_error</code>：metrics.mean_squared_error<br>④ <code>neg_mean_squared_log_error</code>：metrics.mean_squared_log_error<br>⑤ <code>neg_median_absolute_error</code>：metrics.median_absolute_error<br>⑥ <code>r2</code>：metrics.r2_score</p>\n<p>Scoring 越高代表模型性能越好，其中 explained_variance 和 $R^2$ 本来即越高越好，因此 Scoring 可直接使用。第 ②、③、④、⑤ 个参数取“error”对应 误差 / 损失，因此对 error 取负数“neg_”。</p>\n<hr>\n<h1 id=\"2-分类模型性能评价指标\"><a href=\"#2-分类模型性能评价指标\" class=\"headerlink\" title=\"2. 分类模型性能评价指标\"></a>2. 分类模型性能评价指标</h1>","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","评价指标"]},{"title":"Hexo博客DIY（1）建立基于Hexo的静态博客","url":"/post/blogdiy/blogdiy-1-create/","content":"<span id=\"more\"></span>\n\n<p>前言：作为一个码畜，各类博客应该是离不了手的，看着别人的博客花花绿绿，我想很多人都会想过自己写写博客。但是现在写博客面临着一些问题，第一个是免费博客网页越来越少了，新浪网易都已关停，另一个是支持好的博客系统，其自定义性又远不及自建博客，比如 CSDN。为此，作为 ___全球最大的同性交友平台—— GitHub___，其提供托管的静态页面 GitHub Page 就是一个非常好的选择，配合 Hexo 即可实现丰富的博客自定义功能。本文记录如何从零开始建立个人博客页，更多 DIY 选项欢迎参考：<a href=\"/categories/BlogDIY/\">博客 DIY 系列</a>。</p>\n<hr>\n<h1 id=\"1-建立静态博客仓库\"><a href=\"#1-建立静态博客仓库\" class=\"headerlink\" title=\"1. 建立静态博客仓库\"></a>1. 建立静态博客仓库</h1><p>我的博客选择的是 GitHub 托管、Hexo 生成静态页的形式，因此本文将基于这种模式介绍。</p>\n<p>首先，在 GitHub 上建立一个个人博客页，非常简单，直接新建一个仓库，名称为 <code>xxx.github.io</code>，其中 <code>xxx</code> 为自己的 GitHub 用户名，要注意是用户名而不是名字，用户名是可以用来登录的那个。创建好了之后就已经可以通过 xxx.github.io 来访问了，初始页面大概长这个样子：</p>\n<center>\n\n<p><img data-src=\"./default_github_page.png\" alt=\"初始 GitHub Page\" title=\"@ASSET\"></p>\n</center>\n\n<p>需要注意的是，这个仓库和将来存放、自定义博客功能的文件夹不是同一个目录，这个仓库仅用来部署博客的最终效果。比如，在本地我的博客及相关功能管理目录在 A 文件夹，每次修改完之后，通过 Hexo 部署到 GitHub，会从 A 文件夹内自动获取相关设置再部署到 xxx.github.io 仓库内，但是 A 文件夹和这个仓库的文件并不是 Git 同步关系，仓库内的文件仅仅包含了最终网页显示需要的部分文件，而 A 文件夹则包括了所有建立和维护博客相关的文件。如果想要对 A 文件夹做 Git 备份，可以再新建一个仓库专门用来同步这个文件夹。</p>\n<hr>\n<h1 id=\"2-连接SSH\"><a href=\"#2-连接SSH\" class=\"headerlink\" title=\"2. 连接SSH\"></a>2. 连接SSH</h1><p>GitHub 中提供了一些便捷更换的主题，可以根据自己的喜好切换。Jekyll 主题部署快速，点几下鼠标即可，但由于 Hexo 主题具有更加自由的编辑性，因此还是选择后者。为了能在本地使用更方便的工具编写博客、定制外观，需要将这个仓库 Clone 到本地，而且使用 Hexo 驱动时，还需要和 GitHub 建立远程安全连接。建立连接的过程大致如下：</p>\n<ol>\n<li>在 Github 设置中点击新建SSH公钥</li>\n<li>查看本地是否存在目录 <code>~/.ssh</code></li>\n<li>若存在，建议删除后重新建立</li>\n<li>执行命令：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># xxx@yyy.com 输入自己的 GitHub 账号邮箱</span></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&quot;xxx@yyy.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>  回车执行后根据提示输入自己的账号密码，若提示 id 文件已保存，则创建成功</p>\n<ol start=\"5\">\n<li>目录下将生成两个文件：<code>id_rsa.pub</code> 和 <code>id_rsa</code></li>\n<li>打开 id_rsa.pub，复制其内容并粘贴到 GitHub 新建公钥的 Key 栏并保存，Title 可随意输入</li>\n</ol>\n  <center>\n\n<p>  <img data-src=\"./github_add_ssh_key.png\" alt=\"粘贴 SSH 密钥\" title=\"@ASSET\"></p>\n  </center>\n\n<ol start=\"7\">\n<li>本地终端验证密钥，执行命令：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">shh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>  若显示 <code>Hi XXX! You&#39;ve successfully authenticated...</code> 则连接成功</p>\n<hr>\n<h1 id=\"3-安装必要环境\"><a href=\"#3-安装必要环境\" class=\"headerlink\" title=\"3. 安装必要环境\"></a>3. 安装必要环境</h1><p>由于需要在本地对博客进行管理，因此本地环境的重要性不言而喻。通常，基于 Hexo 驱动的静态博客，只需要这三个环境就够了：<code>Git</code>、<code>Hexo</code>、<code>Node.JS</code>，其中 Node.JS 主要是使用其内含的包管理器 <code>npm</code>，通过这个管理器可以为博客部署很多有意思的插件。另外有个小提示，如果在国内使用感觉网速太慢的话，可以用 <code>cnpm</code> 命令替换。</p>\n<ol>\n<li>Git 下载地址：<a href=\"https://git-scm.com/downloads\" title=\"@LINK\">Git 下载</a></li>\n<li>Node.JS下载地址：<a href=\"https://nodejs.org/en/download/\" title=\"@LINK\">Node.JS 下载</a></li>\n<li>终端安装 Hexo 命令（在安装完 Node.JS 之后）：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>  如果安装结果出现红字报错无权限的情况，可以尝试以下两个命令其中一个：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 尝试1：</span></span><br><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试2：</span></span><br><span class=\"line\">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>检查环境安装情况：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Git 环境检查：</span></span><br><span class=\"line\">git --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Node.JS 环境检查：</span></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hexo 环境检查：</span></span><br><span class=\"line\">hexo --Version</span><br></pre></td></tr></table></figure>\n\n<p>  如果均能输出对应版本号即表示环境配置成功。</p>\n<hr>\n<h1 id=\"4-初始化本地静态博客页\"><a href=\"#4-初始化本地静态博客页\" class=\"headerlink\" title=\"4. 初始化本地静态博客页\"></a>4. 初始化本地静态博客页</h1><p>Hexo 环境安装完以后，就可以在本地建立管理目录了。在终端进入想要作为博客维护目录的路径，并执行以下命令初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n\n<p>执行完之后，目录下应该会出现大致如下的文件及文件夹：</p>\n<center>\n\n<p><img data-src=\"./hexo_folder.png\" alt=\"Hexo 目录\" title=\"@ASSET\"></p>\n</center>\n\n<p>简单介绍一下：</p>\n<ul>\n<li><strong>node_modules</strong> 是模块目录，包含了博客基础和自定义功能所需的组件</li>\n<li><strong>public</strong> 就是生成最终部署到网页上去所需文件的目录</li>\n<li><strong>scaffolds</strong> 是博客一些页面的模板，修改这里面的文件可以自定义新增对应类别的文件时默认的格式</li>\n<li><strong>source</strong> 就是博客内所有页面包括的文件了，包括文章、分类、标签等等</li>\n<li><strong>themes</strong> 就是博客的主题，目录内可以包括各种不同的主题，并且可以在博客设置文件内随时更换</li>\n</ul>\n<p>这些不同的目录及包括的文件、对应 DIY 会在下文更详细地介绍。</p>\n<p>Hexo 目录初始化完毕后，通过命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以一键式安装所有必须的组件，为了能通过 Hexo 部署到 GitHub 上去，还要再额外安装 Git Deploy 组件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"5-常用Hexo命令\"><a href=\"#5-常用Hexo命令\" class=\"headerlink\" title=\"5. 常用Hexo命令\"></a>5. 常用Hexo命令</h1><p>常用的 Hexo 命令大致有如下数条：</p>\n<ul>\n<li><code>hexo init [folder]</code>：初始化本地项目，可指定路径 folder，或默认为当前目录</li>\n<li><code>hexo generate</code>：（可简写为 <code>hexo g</code>）生成本地静态文件</li>\n<li><code>hexo server</code>：（可简写为 <code>hexo s</code>）启动本地服务器，启动后可在 localhost:4000 查看页面效果</li>\n<li><code>hexo deploy</code>：（可简写为 <code>hexo d</code>）部署到 Github（或其他代码托管网站），由根目录下的 <strong>_config.yml</strong> 文件设定</li>\n<li><code>hexo clean</code>：清理缓存文件</li>\n<li><code>hexo new [layout] &lt;title&gt;</code>：新建文件（夹），可指定文件类型 layout，或默认由 <strong>_config.yml</strong> 中的 default_layout 决定。必填项 title 用于指定文章标题，若参数值中含有空格，需使用英文双引号包括</li>\n<li><code>hexo --safe</code>：安全模式，禁用加载插件和脚本，可在安装新插件遇到问题时启用</li>\n<li><code>hexo --debug</code>：调试模式，用于将消息详细记录到终端和 debug.log 文件</li>\n<li><code>hexo --silent</code>：静默模式，用于静默输出到终端</li>\n</ul>\n<p>其中最最最常用的三个命令为：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>，每一次对博客进行修改后，都需要用这三个命令（每条命令分别执行）清理之前的博客缓存、重新构建新博客页面、开启本地服务器并在本地预览效果，如果效果符合预期，就可以把 <code>hexo s</code> 替换为 <code>hexo d</code>，再重新执行这三个命令（也就是：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>）。当需要连续执行 <code>hexo g</code> 和 <code>hexo d</code> 时，可以用 <code>hexo g -d</code> 这一条命令代替前两条（也就是：<code>hexo clean</code>、<code>hexo g -d</code>）。</p>\n<hr>\n<h1 id=\"6-部署博客基本功能\"><a href=\"#6-部署博客基本功能\" class=\"headerlink\" title=\"6. 部署博客基本功能\"></a>6. 部署博客基本功能</h1><p>到上一步为止，博客是已经建立完基础功能了，但此时本地博客和 GitHub 上的静态托管还没有建立联系，想要在本地维护的博客能同步到 GitHub 仓库上，使得外网能通过 xxx.github.io 网页形式访问，还需要配置一下本地的配置文件 ___config.yml__，改文件位于本地博客文件夹的根目录下面，使用任何一个文本编辑器打开，找到以下片段：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>在其中的 <code>repository</code> 后面填写自己的博客页托管仓库地址：<code>https://github.com/xxx/xxx.github.io</code>，将其中的 xxx 替换为自己的 GitHub 用户名。修改完保存，至此即可通过上文讲述的 Hexo 命令将本地博客部署到 GitHub 上了。</p>\n<p>另外还可以预先安装站点地图和百度站点地图生成插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-generator-sitemap</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install --save hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>\n\n<p>并在站点配置文件中进行如下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成sitemap</span></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<p>这样在部署后就会自动在博客根目录下生成对应的文件，可通过 <code>博客地址/sitemap.xml</code> 或 <code>博客地址/baidusitemap.xml</code> 访问。</p>\n<hr>\n<h1 id=\"7-引入Next主题\"><a href=\"#7-引入Next主题\" class=\"headerlink\" title=\"7. 引入Next主题\"></a>7. 引入Next主题</h1><p>默认的博客页使用的主题叫做“landscape”，可以在博客目录下的 themes 文件夹内找到，Hexo 官方的主题列表：<a href=\"https://hexo.io/themes/\" title=\"@LINK\">Themes | Hexo</a>，具体哪个主题好看就仁者见仁了，我自己在经过一段时间的搜索后找到两个比较心仪的，一个是简约风的 <a href=\"https://github.com/aircloud/hexo-theme-aircloud\" title=\"@LINK\">AirCloud</a>，一个是偏浪漫的 <a href=\"http://theme-next.iissnan.com/\" title=\"@LINK\">Next</a>，后来觉得 AirCloud 实在是过于简约了（逃），最终选择后者。此外，除了 Hexo 平台，Next 主题还支持 Farbox 和 Jekyll 平台。部署主题的方式很简单，都是下载主题文件（<a href=\"https://github.com/theme-next/hexo-theme-next/releases\" title=\"@LINK\">Next 主题下载</a>），然后放进 themes 文件夹中，并在博客根目录下的配置文件 _config.yml 中选择上这个主题：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extensions</span></span><br><span class=\"line\"><span class=\"comment\">## Plugins: https://hexo.io/plugins/</span></span><br><span class=\"line\"><span class=\"comment\">## Themes: https://hexo.io/themes/</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">next</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>next</code> 是主题文件夹的名字，主题文件夹的名字可以随便改（比如加上版本号，next711），只要这里同步更改即可。</p>\n<p><em><strong>注意：由于在主题内，有许多设置或文件与博客站点的设置或文件有重名、覆盖等，因此从下文开始，一些名词的定义如下：</strong></em></p>\n<ul>\n<li><font color=#EB6D39>站点根目录</font>：表示最开始新建博客时选择的那个目录，整个博客文件夹的根目录，在路径中用 <strong>blog/…</strong> 表示，比如博客文章的目录即为：blog/source/_post/</li>\n<li><font color=#EB6D39>主题根目录</font>：表示下载的主题文件夹的目录，我的主题是 Next，其所属位置即 blog/themes/next/，在下文路径中将用 <strong>next/…</strong> 表示，比如 Next 主题文件中的语言包目录即为：next/languages/</li>\n<li><font color=#EB6D39>站点配置文件</font>：表示站点根目录下的 <code>_config.yml</code> 文件</li>\n<li><font color=#EB6D39>主题配置文件</font>：表示主题根目录下的 <code>_config.yml</code> 文件</li>\n<li><font color=#EB6D39>安装组件</font>：表示在站点根目录下通过终端命令安装指定组件/模块</li>\n<li><font color=#EB6D39>Hexo 命令三连</font>：表示依次执行：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>，这三步仅是开启本地测试，可以在 <code>localhost:4000</code> 处查看效果，如果认为效果合意，请根据实际情况自行决定是否执行 <code>hexo d</code> 部署到仓库中</li>\n</ul>\n<p><a href=\"http://theme-next.iissnan.com/theme-settings.html#tags-page\" title=\"@LINK\">Hexo-Next 官方网站</a>已经提供了很多基础个性化配置，包括主题样式、分类及标签、设置字体、RSS、代码块样式、公益 404、友链、搜索、打赏、背景等等，内置配置已经足够个性化，如果不追求更多自定义选项，现在的博客页面已经比较美观，想要写博客，只需要在博客根目录下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;XXXXX&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>XXXXX</code> 是新建的博客标题，同时也是文章的文件名，建议这里使用英文，不然博客文章的链接 URL 会有中文显得略不美观，如果想要正文标题是中文，只需要在：<code>blog/source/_post/</code> 下找到刚才新建的文件，打开并修改上方 <code>title</code> 后面的文字即可，不会影响 URL 链接。在下方输入博客内容，完成后保存 + Hexo 命令三连即可。文章使用 MarkDown 格式编写，如果还不是很熟悉，可以搜索参照各种 MarkDown 格式介绍的文章，本文就不多做讲解了。</p>\n<hr>\n<h1 id=\"8-解决low-severity-vulnerability\"><a href=\"#8-解决low-severity-vulnerability\" class=\"headerlink\" title=\"8. 解决low severity vulnerability\"></a>8. 解决low severity vulnerability</h1><p>有时，在通过 <code>npm install</code> 或 <code>npm install xxx</code> 安装完包以后，终端会出现大致如下的信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">audited 6879 packages <span class=\"keyword\">in</span> 2.402s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>提示“有一个低严重性的漏洞”，根据提示输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix</span><br><span class=\"line\"></span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.185s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>很明显并没有用，反馈大致意思是“有 1 个漏洞需要人工检查，且无法更新”，使用强制修复试试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix --force</span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN using --force I sure hope you know what you are doing.</span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.242s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>看来强制修复也不行，那就只好按它的建议手动查看了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit</span><br><span class=\"line\"></span><br><span class=\"line\">                       === npm audit security report ===</span><br><span class=\"line\">                                                                                </span><br><span class=\"line\">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│                                Manual Review                                 │</span><br><span class=\"line\">│            Some vulnerabilities require your attention to resolve            │</span><br><span class=\"line\">│                                                                              │</span><br><span class=\"line\">│         Visit https://go.npm.me/audit-guide <span class=\"keyword\">for</span> additional guidance          │</span><br><span class=\"line\">└──────────────────────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">┌───────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│ Low           │ Regular Expression Denial of Service                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Package       │ marked                                                       │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Patched <span class=\"keyword\">in</span>    │ &gt;=0.7.0                                                      │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Dependency of │ hexo-renderer-marked                                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Path          │ hexo-renderer-marked &gt; marked                                │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ More info     │ https://npmjs.com/advisories/1076                            │</span><br><span class=\"line\">└───────────────┴──────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">found 1 low severity vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability requires manual review. See the full report <span class=\"keyword\">for</span> details.</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>这些信息似乎是和版本号有关，顺手打开给出来的网址：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">More info</a>，看到如下信息：</p>\n<center>\n\n<p><img data-src=\"./more_info.png\" alt=\"More info 网页信息\" title=\"@ASSET\"></p>\n</center>\n\n<p>果然，NPM 官方给出的解决方案也是升级 marked 版本到 0.7.0，先看看当前的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>果不其然版本不是 0.7.0，先尝试更新后再次查看版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm update</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>依然无法手动更新，那就手动把这个 <code>Blog/node_modules/marked</code> 目录删掉：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── UNMET DEPENDENCY marked@0.6.3 </span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! missing: marked@0.6.3, required by hexo-renderer-marked@1.0.1</span><br></pre></td></tr></table></figure>\n\n<p>提示依赖包 marked 被删除了，然后再重新安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor and audited 6879 packages <span class=\"keyword\">in</span> 2.442s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>仍然是 0.6.3 版本！内心是崩溃的，干脆直接覆盖安装一次 marked，再查看版本信息。执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save marked</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">├─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">│ └── marked@0.6.3</span><br><span class=\"line\">└── marked@0.7.0</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了，从层级结构上来看，手动执行安装后 Hexo 装了两个 marked，手动安装的这个 marked 是最新的 0.7.0 版本，被放在了原来老版本的目录下：<code>Blog/node_modules/marked</code>，而原本隶属于 <code>hexo-renderer-marked</code> 下面的老版本依赖包，由于被 <code>hexo-renderer-marked</code> 依赖，且手动安装了另一版本，导致其位置被自动放到：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code> 目录下。</p>\n<p><strong><font color=EB6D39>也就是说，这个老版本的 marked，其版本并不是由 npm 管理的，所以 update 和 删掉重新 install 都无法更新，而手动安装的 marked 是直接由 npm 管理的，因此默认会安装最新版。这也说明被依赖的 marked 的版本号是在 hexo-renderer-marked 渲染引擎中控制的。</font></strong></p>\n<p>为了防止冲突，先卸载手动安装的 marked：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm uninstall --save marked</span><br></pre></td></tr></table></figure>\n\n<p>现在 <code>Blog/node_modules/</code> 下已经没有 <code>marked</code> 目录了，同时也手动删掉老版本的 marked 目录：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code>。</p>\n<p>然后 再到之前的网页：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">点击这里</a> 内点击 <code>Versions</code> 栏查看最新的 marked 版本：</p>\n<center>\n\n<p><img data-src=\"./marked_newest_version.png\" alt=\"marked 最新版本\" title=\"@ASSET\"></p>\n</center>\n\n<p>接着找到 <code>Blog/node_modules/hexo-renderer-marked/package.json</code>，修改其中的依赖部分：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;hexo-util&quot;: &quot;^0.6.2&quot;,</span><br><span class=\"line\">  &quot;marked&quot;: &quot;^0.6.1&quot;,</span><br><span class=\"line\">  &quot;strip-indent&quot;: &quot;^2.0.0&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>&quot;marked&quot;</code> 字段后面的 <code>&quot;^0.6.1&quot;</code> 强制改为 <code>&quot;^0.7.0&quot;</code>，，最后再次执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor, removed 1 package and audited 6879 packages <span class=\"keyword\">in</span> 3.168s</span><br><span class=\"line\">found 0 vulnerabilities</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>看到这个结果说明已经没有报“低严重性漏洞”了，再查看一下版本号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 /Users/slliu/Downloads/Temp</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.7.0</span><br><span class=\"line\"></span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p>OK！成功更新到 0.7.0 版本！**<font color=EB6D39>假如执行这两步的时候依然报之前的信息，如果可以确保之前的步骤都是对的，可以暂时不管，通常是缓存信息还没有更新的缘故，把这两步执行完之后，退出并重新打开终端再查看 <code>npm ls marked</code> 即可看到已经更新。假如出现错误信息显示被删除，再执行一次 <code>npm install</code> 即可。</font>**</p>\n<p>其实挺简单的一个问题，由于没有经验导致折腾了这么久，记录在此望读者少走弯路。另外，此时由于已经卸载了之前手动安装的 marked，因此这个依赖包的位置又回到了：<code>Blog/node_modules/marked</code> 下。</p>\n<hr>\n<h1 id=\"9-解决FontAwesome不显示\"><a href=\"#9-解决FontAwesome不显示\" class=\"headerlink\" title=\"9. 解决FontAwesome不显示\"></a>9. 解决FontAwesome不显示</h1><p>某些情况下，在构建博客后，会出现图标不显示的问题，例如正常情况下我的博客应该是如下图所示：</p>\n<center>\n\n<p><img data-src=\"./fontawesome_normal.png\" alt=\"FontAwesome 正常显示\" title=\"@ASSET\"></p>\n</center>\n\n<p>但可能会出现如下图所示的情况：</p>\n<center>\n\n<p><img data-src=\"./fontawesome_error.png\" alt=\"FontAwesome 显示异常\" title=\"@ASSET\"></p>\n</center>\n\n<p>同时，在页面上检查元素会出现一个报错信息：</p>\n<center>\n\n<p><img data-src=\"./fontawesome_error_info.png\" alt=\"FontAwesome 显示异常\" title=\"@ASSET\"></p>\n</center>\n\n<p>原因是没找到目录下 FontAwesome 的 CSS 文件，但其实我们并不需要手动下载，Next 主题在生成部署时会动态到 FontAwesome 网站上下载相关样式，这时就考虑可能是 FontAwesome 的某个 CDN 连接挂了，可以在 Next 的主题配置文件 <code>next/_config.yml</code> 中切换一下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Internal version: 4.6.2</span></span><br><span class=\"line\"><span class=\"comment\"># See: https://fontawesome.com</span></span><br><span class=\"line\"><span class=\"comment\"># Example:</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"attr\">fontawesome:</span> <span class=\"string\">https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure>\n\n<p>重新部署，恢复正常。</p>\n<hr>\n<h1 id=\"9-基于对象存储建立博客\"><a href=\"#9-基于对象存储建立博客\" class=\"headerlink\" title=\"9. 基于对象存储建立博客\"></a>9. 基于对象存储建立博客</h1><p>未完待续</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（4）在线聊天和文章评论","url":"/post/blogdiy/blogdiy-4-chat-comment/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-DaoVoice免登陆聊天功能\"><a href=\"#1-DaoVoice免登陆聊天功能\" class=\"headerlink\" title=\"1. DaoVoice免登陆聊天功能\"></a>1. DaoVoice免登陆聊天功能</h1><p>在我博客的右下角有一个悬浮聊天窗，点击即可直接发起会话，当我不在线时，后台会将消息发送到我的邮箱，这是基于 <a href=\"http://www.daovoice.io/\" title=\"@LINK\">DaoVoice</a> 的实现方案。</p>\n<p>开启 DaoVoice 也比较简单，首先去<a href=\"http://www.daovoice.io/\" title=\"@LINK\">官网</a>注册一个账号然后登录，进入控制台，点击左侧“应用设置”，并在子菜单选择“安装到网站”：</p>\n<center>\n\n<p><img data-src=\"./daovoice_apply_to_web.png\" alt=\"DaoVoice 安装到网站\" title=\"@ASSET\"></p>\n</center>\n\n<p>在图里中间那个红框处标记了一个 app_id，把它记下来，接着到主题配置文件中，随表找一个地方顶格添加以下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Daovoice</span></span><br><span class=\"line\"><span class=\"attr\">daovoice:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">app_id:</span> <span class=\"string\">xxxxxxxx</span></span><br></pre></td></tr></table></figure>\n\n<p><code>daovoice_app_id</code> 就填写刚才控制台获得的那个。接下来，将图中上下两个红框那里的代码整体复制下来，找到并打开 <code>next/layout/_partials/head/head.swig</code>，在里面随便找一个顶格的空位粘贴进去，不过需要修改一点，在外层加一个 <code>if</code> 判断是否开启，然后在 app_id 处将固定的你的 id 改为从配置文件中读取，这样以后想要临时关闭 DaoVoice 时只需要把配置文件中 DaoVoice 的 <code>enable</code> 设置为 <code>false</code> 即可，更换了 DaoVoice 账号也只需要更新一下配置文件中 DaoVoice 的 <code>app_id</code> 即可。也可以直接复制我下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.daovoice.enable %&#125;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class=\"string\">&quot;DaoVoiceObject&quot;</span>]=r;i[r]=i[r]||<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class=\"built_in\">arguments</span>)&#125;,i[r].l=<span class=\"number\">1</span>*<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class=\"number\">0</span>];a.async=<span class=\"number\">1</span>;a.src=g;a.charset=<span class=\"string\">&quot;utf-8&quot;</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class=\"built_in\">window</span>,<span class=\"built_in\">document</span>,<span class=\"string\">&quot;script&quot;</span>,(<span class=\"string\">&#x27;https:&#x27;</span> == <span class=\"built_in\">document</span>.location.protocol ? <span class=\"string\">&#x27;https:&#x27;</span> : <span class=\"string\">&#x27;http:&#x27;</span>) + <span class=\"string\">&quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;</span>,<span class=\"string\">&quot;daovoice&quot;</span>)</span><br><span class=\"line\">  daovoice(<span class=\"string\">&#x27;init&#x27;</span>, &#123;</span><br><span class=\"line\">      app_id: <span class=\"string\">&quot;&#123;&#123;theme.daovoice.app_id&#125;&#125;&quot;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  daovoice(<span class=\"string\">&#x27;update&#x27;</span>);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后，在 DaoVoice 控制台的 应用设置 - 聊天设置 中可以自定义欢迎语以及按钮的位置、颜色等。</p>\n<hr>\n<h1 id=\"2-Gitalk评论\"><a href=\"#2-Gitalk评论\" class=\"headerlink\" title=\"2. Gitalk评论\"></a>2. Gitalk评论</h1><p>文章评论也有多种方案，Disqus、友言、畅言、Valine（基于 Leancloud）、Gitment、Gitalk 等，不过 Disqus 是韩国的，虽说国内是能有的不过有时候还是会莫名其妙像被墙起来了一样，友言和畅言已经停止维护，<a href=\"https://github.com/theme-next/hexo-theme-next/releases/tag/v7.2.0\" title=\"@LINK\">最新版的 Next</a> 也把 Gitment 移除支持了，不过 Gitalk 和 Gitment 比较类似，都是基于 GitHub 的 Issue 实现的，我个人认为，使用 GitHub 托管的博客，使用 GitHub 自己的 Issue 服务来实现也相当契合，何况 GitHub 不仅免费的已经相当够用，而且还没有流量限制。</p>\n<p>Next 主题本身是支持 Gitalk 的，所以引入 Gitalk 只需要像 LeanCloud 和 DaoVoice 一样申请一个 app_id 即可。而由于 Gitalk 本身是基于 GitHub 实现的，所以我们甚至都不需要再另行注册一个账号！</p>\n<p>首先在 GitHub 新建一个仓库，用于存储评论的 Issue，当然如果你愿意也可以直接使用博客的仓库。然后在 GitHub 的设置里面，进入最下面的 __Developer settings__，然后再选择 __OAuth Apps__，然后点击右上角 “New OAuth App” 新建一个应用：</p>\n<center>\n\n<p><img data-src=\"./github_oauth_apps.png\" alt=\"GitHub OAuth Apps\" title=\"@ASSET\"></p>\n</center>\n\n<p>在接下来的界面里，输入应用名和博客地址：</p>\n<center>\n\n<p><img data-src=\"./github_new_oauth_app.png\" alt=\"Add a GitHub OAuth Apps\" title=\"@ASSET\"></p>\n</center>\n\n<p>这里需要注意：<font color=#EB6D39>博客地址是你访问时的真实地址，也就是进入自己的博客首页之后地址栏里的 URL，需要带上 https（或 https，根据自己的实际情况），如果购买绑定了自定义域名，需要填写自定义域名</font>。比如，我的博客绑定了域名为：<code>www.liushulun.cn</code>，由于我开启了强制 HTTPS，因此这里两个需要填写地址的地方，我都需要输入：<code>https://www.liushulun.cn</code>。</p>\n<p>新建好了应用后，在应用信息界面就能找到 <code>client_id</code> 和 <code>client_secret</code>：</p>\n<center>\n\n<p><img data-src=\"./github_oauth_app_info.png\" alt=\"GitHub OAuth Apps Info\" title=\"@ASSET\"></p>\n</center>\n\n<p>复制下来，然后在主题配置文件中找到 Gitalk 相关的配置部分：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Gitalk</span></span><br><span class=\"line\"><span class=\"comment\"># Demo: https://gitalk.github.io</span></span><br><span class=\"line\"><span class=\"attr\">gitalk:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">github_id:</span>  <span class=\"comment\"># Github repo owner</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span>  <span class=\"comment\"># Repository name to store issues</span></span><br><span class=\"line\">  <span class=\"attr\">client_id:</span>  <span class=\"comment\"># Github Application Client ID</span></span><br><span class=\"line\">  <span class=\"attr\">client_secret:</span>  <span class=\"comment\"># Github Application Client Secret</span></span><br><span class=\"line\">  <span class=\"attr\">admin_user:</span>  <span class=\"comment\"># GitHub repo owner and collaborators, only these guys can initialize github issues</span></span><br><span class=\"line\">  <span class=\"attr\">distraction_free_mode:</span> <span class=\"literal\">true</span> <span class=\"comment\"># Facebook-like distraction free mode</span></span><br><span class=\"line\">  <span class=\"attr\">per_page:</span> <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"comment\"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class=\"line\">  <span class=\"comment\"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class=\"line\">  <span class=\"comment\"># Available values: en, es-ES, fr, ru, zh-CN, zh-TW</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>enable</code>：是否打开 Gitalk 评论功能</li>\n<li><code>github_id</code>：刚才申请 OAuth App 时所用的 GitHub 用户名，注意是用户名而不是地址，用来验证 OAuth App 密钥</li>\n<li><code>repo</code>：刚才新建的（或是已有的）用于保存评论 Issue 的仓库名，注意是仓库名而不是地址，用于指定评论保存在哪个仓库内</li>\n<li><code>client_id</code>：新建的 OAuth App 里面的 client_id 复制过来</li>\n<li><code>client_secret</code>：新建的 OAuth App 里面的 client_secret 复制过来</li>\n<li><code>admin_user</code>：<font color=#EB6D39>重要：这里填你自己的 GitHub 用户名（不是地址），默认情况下新发表的文章 Gitalk 评论是未初始化的状态，需要这里指定的 GitHub 用户才能初始化开启</font></li>\n<li><code>per_page</code>：评论列表一页显示几条评论</li>\n</ul>\n<p>由于是基于 GitHub Issue 的实现，Gitalk 评论支持使用 MarkDown 格式，交流代码会方便很多。不过缺点就是，任何人想要评论则必须使用 GitHub 账号登陆才行。</p>\n<hr>\n<h1 id=\"3-Valine评论\"><a href=\"#3-Valine评论\" class=\"headerlink\" title=\"3. Valine评论\"></a>3. Valine评论</h1><h2 id=\"3-1-开启Valine\"><a href=\"#3-1-开启Valine\" class=\"headerlink\" title=\"3.1 开启Valine\"></a>3.1 开启Valine</h2><p>Gitalk 评论虽然最符合程序员的喜好，毕竟基于 GitHub 的 Issue，可以自由改动、打 Tag等，但是缺点就是必须登录 GitHub 账号，有时候有些小问题就显得麻烦了，后来发现 LeanCloud 除了可以实现文章阅读统计外，还支持 Valine 评论功能，最关键的是免登陆，而且免费（目前）！于是我的博客最终选择了 Valine 作为评论引擎。</p>\n<p>首先 Valine 评论和 LeanCloud 阅读统计同时开启会有冲突（2019-12-04 无意间发现已经不会冲突了），解决方案是关掉 LeanCloud 独立的阅读统计，并在 Valine 设置项中开启统计功能即可，Valine 相关设置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Valine</span></span><br><span class=\"line\"><span class=\"comment\"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class=\"line\"><span class=\"comment\"># More info available at https://valine.js.org</span></span><br><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppID</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppKey</span></span><br><span class=\"line\">  <span class=\"attr\">notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># mail notifier, See: https://github.com/xCss/Valine/wiki</span></span><br><span class=\"line\">  <span class=\"attr\">verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Verification code</span></span><br><span class=\"line\">  <span class=\"attr\">placeholder:</span> <span class=\"string\">Nice</span> <span class=\"string\">!</span> <span class=\"comment\"># comment box placeholder</span></span><br><span class=\"line\">  <span class=\"comment\"># avatar: mm # gravatar style</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">retro</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># custom comment header</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">5</span> <span class=\"comment\"># pagination size</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span> <span class=\"comment\"># language, available values: en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">true</span> <span class=\"comment\"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same asleancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">false</span> <span class=\"comment\"># if false, comment count will only be displayed in post page, not in home page</span></span><br></pre></td></tr></table></figure>\n\n<p><code>appid</code>、<code>appkey</code> 的设置可以参照系列第三篇中 LeanCloud 阅读统计部分：《<a href=\"/post/blogdiy/blogdiy-3-counter/blogdiy-3-counter/#2-%E8%AE%BF%E5%AE%A2%E4%B8%8E%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1\" title=\"@LINK\">访客与阅读量统计</a>》，其他各个字段的含义在 Valine 官网配置详解（<a href=\"https://valine.js.org/quickstart.html,\" title=\"@LINK\">点此直达</a>）中都有说明了，很详细。</p>\n<p>但是当开启了 Valine 并部署后，会发现评论处只支持用户输入昵称评论，不能自己输入邮箱、网址等等，效果如下：</p>\n<center>\n\n<p><img data-src=\"./valine_only_nick.png\" alt=\"Valine 只能输入昵称\" title=\"@ASSET\"></p>\n</center>\n\n<p>而官网提供的评论框可以同时输入昵称、邮箱、链接：</p>\n<center>\n\n<p><img data-src=\"./valine_nick_email_link.png\" alt=\"官网 Valine 可输入全部信息\" title=\"@ASSET\"></p>\n</center>\n\n<p>这样当需要使用邮件沟通时，就比较麻烦了。后来通过查看官网的配置信息，以及查看了 Next 主题源码之后发现，原来是 Next 源码直接限制了只能输入昵称，找到 <code>next/layout/_third-party/comments/valine.swig</code>，可以发现源码里面有这么一段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">  guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">    verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">    notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">    appId: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    appKey: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    placeholder: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    avatar: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    guest_info:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br><span class=\"line\">    meta: guest,</span><br><span class=\"line\">    pageSize: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">    visitor: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">    lang: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>重点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">guest_info:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是这里写死了只能输入昵称，其实作者的本意应该是，怕游客以为要全部输入才能评论，所以只开放一个昵称栏，这里到底是否需要设置其他信息可以自行决定，我是为了方便起见使用了昵称 + 邮箱的方式，首先看到 主题配置文件 <code>next/_config.yml</code> 中 Valine 的设置部分有这么个属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># custom comment header</span></span><br></pre></td></tr></table></figure>\n\n<p>这个属性对应在源码 <code>next/layout/_third-party/comments/valine.swig</code> 中传递给了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">meta: guest,</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用也就是从主体配置文件中获取 <code>guest_info</code> 属性，然后以 ‘,’ 分隔开，再从 <code>[&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]</code> 中分别获取对应的字符串并组成数组，然后传给 <code>meta</code>。查看 Valine 官网资料可知，这个 <code>meta</code> 属性是 LeanCloud 存储评论的头部信息，方案 ① 就是输入框直接使用相同的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">guest_info: guest,</span><br><span class=\"line\">meta: guest,</span><br></pre></td></tr></table></figure>\n\n<p>但是可能我希望所有的评论，在存储到 LeanCloud 中时都带有全部 3 个属性，但用户评论时只可以输入 1 或 2 个信息（比如我），总之就是用户可以输入的信息和 LeanCloud 存储的信息不一致，那么就需要自定义一个属性了。</p>\n<p>首先在主题配置文件 <code>next/_config.yml</code> 的 Valine 设置部分添加一个自定义属性（命名可自定义）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Valine</span></span><br><span class=\"line\"><span class=\"comment\"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class=\"line\"><span class=\"comment\"># More info available at https://valine.js.org</span></span><br><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"string\">5s8VV1vNdnt4bKoTcocYcY0U-gzGzoHsz</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"string\">YRRibTsHhmelPnfq41YO6B1r</span></span><br><span class=\"line\">  <span class=\"attr\">notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># mail notifier, See: https://github.com/xCss/Valine/wiki</span></span><br><span class=\"line\">  <span class=\"attr\">verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Verification code</span></span><br><span class=\"line\">  <span class=\"attr\">placeholder:</span> <span class=\"string\">Nice</span> <span class=\"string\">!</span> <span class=\"comment\"># comment box placeholder</span></span><br><span class=\"line\">  <span class=\"comment\"># avatar: mm # gravatar style</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">retro</span></span><br><span class=\"line\">  <span class=\"attr\">guest_header:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># 用户可以自定义输入的信息</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># custom comment header</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">5</span> <span class=\"comment\"># pagination size</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span> <span class=\"comment\"># language, available values: en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">true</span> <span class=\"comment\"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">false</span> <span class=\"comment\"># if false, comment count will only be displayed in post page, not in home page</span></span><br></pre></td></tr></table></figure>\n\n<p>重点：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">guest_header:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># 用户可以自定义输入的信息</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在 Next 的 Valine 部署源码 <code>next/layout/_third-party/comments/valine.swig</code> 中修改这一部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ↓↓↓↓↓ 重点是以下这部分 ↓↓↓↓↓</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> guest_header = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_header &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest_header = guest_header.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ↑↑↑↑↑ 重点是以上这部分 ↑↑↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">  verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">  notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">  appId: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  appKey: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  placeholder: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  avatar: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓↓↓ 重点是以下这部分 ↓↓↓↓↓</span></span><br><span class=\"line\">  guest_info: guest_header,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑↑↑ 重点是以上这部分 ↑↑↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  meta: guest,</span><br><span class=\"line\">  pageSize: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">  visitor: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">  lang: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>主要就是获取主题配置文件中设置的 <code>guest_header</code> 然后组合成数组再传给 <code>guest_info</code> 即可。重新部署，效果如下：</p>\n<center>\n\n<p><img data-src=\"./valine_guest_info_custom.png\" alt=\"Valine 自定义用户可输入信息\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"3-2-隐藏Valine系统信息\"><a href=\"#3-2-隐藏Valine系统信息\" class=\"headerlink\" title=\"3.2 隐藏Valine系统信息\"></a>3.2 隐藏Valine系统信息</h2><p>常规配置好 Valine 后，会发现评论时自动读取了用户的系统信息等，不仅不美观而且暴露隐私，非常不友好：</p>\n<center>\n\n<p><img data-src=\"./valine_show_system_info.png\" alt=\"Valine 显示系统信息\" title=\"@ASSET\"></p>\n</center>\n\n<p>想要隐藏系统信息可修改 <code>next/source/css/_custom/custom.styl</code>，在末尾添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Valine 隐藏系统信息</span></span><br><span class=\"line\">.vsys&#123;</span><br><span class=\"line\">  display:none !important;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：<code>custom.styl</code> 这个文件会在 <code>next/source/css/main.styl</code> 中被引入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom Layer</span></span><br><span class=\"line\"><span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">&quot;_custom/&quot;</span> + $custom_styles;</span><br></pre></td></tr></table></figure>\n\n<p>隐藏后的效果：</p>\n<center>\n\n<p><img data-src=\"./valine_hide_system_info.png\" alt=\"Valine 隐藏系统信息\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"3-3-文末增加留言区跳转\"><a href=\"#3-3-文末增加留言区跳转\" class=\"headerlink\" title=\"3.3 文末增加留言区跳转\"></a>3.3 文末增加留言区跳转</h2><p>附加一个小记录，当文章未开启评论功能时，在文首显示一条跳转留言区的功能。我个人是放在了文章最底部，和有评论时的位置相同，并且复用了博客首页文章列表底下的“页码导航栏”的样式，直接放进一个链接即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% macro render(post, is_index, post_extra_class) %&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">  &lt;article&gt;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  &lt;/article&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;####################&#125;</span><br><span class=\"line\">  &#123;##### 留言提示 ######&#125;</span><br><span class=\"line\">  &#123;####################&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> not post.comments and not is_index %&#125;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;pagination&quot;</span>&gt;</span><br><span class=\"line\">      &lt;style type=<span class=\"string\">&quot;text/css&quot;</span>&gt;</span><br><span class=\"line\">        .toContact &#123;</span><br><span class=\"line\">            color: #EB6D39;</span><br><span class=\"line\">            border-bottom-color: #EB6D39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .toContact:hover &#123;</span><br><span class=\"line\">          color: #000000;</span><br><span class=\"line\">          border-bottom-color: #000000;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &lt;/style&gt;</span><br><span class=\"line\">      &lt;a href=<span class=\"string\">&quot;/about/&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;toContact&quot;</span>&gt;本文未开启评论，点击前往留言区&lt;/a&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<center>\n\n<p><img data-src=\"./go_to_contact_at_bottom.png\" alt=\"文末跳转留言区\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"4-二级标题替换为留言链接\"><a href=\"#4-二级标题替换为留言链接\" class=\"headerlink\" title=\"4. 二级标题替换为留言链接\"></a>4. 二级标题替换为留言链接</h1><p>Next 主题的博客二级标题其实就是正标题下面的这一小段文字：</p>\n<center>\n\n<p><img data-src=\"./blog_subtitle.png\" alt=\"Next 主题二级标题\" title=\"@ASSET\"></p>\n</center>\n\n<p>但是像我的博客其实并没有二级标题的必要，所以如图所示设置的和博客描述是一样的。但是这个标题区作为一个信息展示栏可以起到置顶的作用，根据我的个人需求，将二级标题改成了“留言区”的引导链接。</p>\n<p>首先需要注意的地方是，通常为了使得博客能被搜索到，都会在主题配置文件 <code>next/_config.yml</code> 中开启 SEO：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Change headers hierarchy on site-subtitle (will be main site description) and on all post / page titles for better SEO-optimization.</span></span><br><span class=\"line\"><span class=\"attr\">seo:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>因此这个二级标题还是不要直接删掉的好，可以通过让它在网页上不显示，而在页面元素中依然存在的方式巧妙地隐藏掉。在 <code>/next/layout/_partials/header/brand.swig</code> 中找到二级标题相关部分的源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> subtitle %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> theme.seo %&#125;</span><br><span class=\"line\">    &lt;h1 <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-subtitle&quot;</span> itemprop=<span class=\"string\">&quot;description&quot;</span>&gt;&#123;&#123; subtitle &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">    &lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-subtitle&quot;</span>&gt;&#123;&#123; subtitle &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把其中的 <code>&lt;h1&gt;</code> 标签和 <code>&lt;p&gt;</code> 标签使用的样式 <code>site-subtitle</code> 替换掉，改为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> subtitle %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> theme.seo %&#125;</span><br><span class=\"line\">    &lt;h1 style=<span class=\"string\">&quot;opacity: 0; font-size: 0px; margin: 0px;&quot;</span> itemprop=<span class=\"string\">&quot;description&quot;</span>&gt;&#123;&#123; subtitle &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">    &lt;p style=<span class=\"string\">&quot;opacity: 0; font-size: 0px; margin: 0px;&quot;</span>&gt;&#123;&#123; subtitle &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是改成透明，且去掉四周边距，这样在网页上就不会显示了，但实际上在页面元素中还是存在的，这样就不会影响 SEO 了：</p>\n<center>\n\n<p><img data-src=\"./hide_subtitle.png\" alt=\"隐藏二级标题\" title=\"@ASSET\"></p>\n</center>\n\n<p>然后仿照二级标题的方式，首先在博客站点配置文件 <code>blog/_config.yml</code> 中增加两个字段：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Custom Subtitle</span></span><br><span class=\"line\"><span class=\"attr\">titleContact:</span> <span class=\"string\">&quot;&amp;ensp;留 言&amp;ensp;&quot;</span></span><br><span class=\"line\"><span class=\"attr\">titleContact_url:</span> <span class=\"string\">/about/</span></span><br></pre></td></tr></table></figure>\n\n<p>这里具体显示名称和链接地址以自定义的为准。然后再在 <code>next/source/css/_common/components/header/site-meta.styl</code> 中增加一个 CSS 样式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.site-titleContact &#123;</span><br><span class=\"line\">  font-size: $subtitle-font-size;</span><br><span class=\"line\">  color: #EB6D39;</span><br><span class=\"line\">  border-bottom-color: #EB6D39;</span><br><span class=\"line\">  &amp;:hover &#123;</span><br><span class=\"line\">    color: $subtitle-color;</span><br><span class=\"line\">    border-bottom-color: $subtitle-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这里的样式也可以随意根据自己的喜好调整。其中 <code>subtitle-font-size</code> 和 <code>subtitle-color</code> 都是原本二级标题已经定义好的变量，可以直接用。</p>\n<p>最后在 <code>/next/layout/_partials/header/brand.swig</code> 中增加一条链接，使用上面定义的样式和数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;custom-logo-site-title&quot;</span>&gt;</span><br><span class=\"line\">......</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;## 博客标题栏中的留言链接 ##&#125;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;&#123;&#123; config.titleContact_url &#125;&#125;&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-titleContact&quot;</span>&gt;&#123;&#123; config.contact &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> subtitle %&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>放的位置以自定义为准。重新部署即可看到效果：</p>\n<center>\n\n<p><img data-src=\"./custom_subtitle.png\" alt=\"自定义二级标题\" title=\"@ASSET\"></p>\n</center>\n\n<p>到这一步其实基本效果已经实现了，但是还有个问题：页面上的其他元素都有个加载进来的动画效果，而这个自定义的 <code>site-titleContact</code> 会导致刚打开页面就显示“留 言”，而其他元素过一会才显示，显得不和谐，因此需要为这个自定义的 CSS 样式添加一个动画效果。首先在 <code>next/source/css/_common/components/header/site-meta.styl</code> 中找到最下面 <code>use-motion</code> 部分，这里定义的是需要动画的元素的初始状态。默认的动画是顶部间距从 -10 渐进到 0，如果想用默认动画，则只需要把 <code>site-titleContact</code> 加到列表中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use-motion &#123;</span><br><span class=\"line\">  .brand &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .logo, .site-title, .site-subtitle, .custom-logo-image, .site-titleContact &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我这个链接是从 -5 渐进到 5，因此需要单独设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use-motion &#123;</span><br><span class=\"line\">  .brand &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .logo, .site-title, .site-subtitle, .custom-logo-image &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .site-titleContact &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -5px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后找到动画脚本文件 <code>next/source/js/motion.js</code>，先在本地变量定义区定义好这个 CSS 样式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">NexT.motion.middleWares = &#123;</span><br><span class=\"line\">  logo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">integrator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sequence = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $brand = $(<span class=\"string\">&#x27;.brand&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $image = $(<span class=\"string\">&#x27;.custom-logo-image&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $title = $(<span class=\"string\">&#x27;.site-title&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $subtitle = $(<span class=\"string\">&#x27;.site-subtitle&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $logoLineTop = $(<span class=\"string\">&#x27;.logo-line-before i&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $logoLineBottom = $(<span class=\"string\">&#x27;.logo-line-after i&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 定义本地变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleContact = $(<span class=\"string\">&#x27;.site-titleContact&#x27;</span>)</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后实现动画效果（为了表示层级关系，保留几个方法，但省略了内部源码）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">NexT.motion.middleWares = &#123;</span><br><span class=\"line\">  logo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">integrator</span>) </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// ============== 定义本地变量 ==============</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleContact = $(<span class=\"string\">&#x27;.site-titleContact&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ========================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    $brand.length &gt; <span class=\"number\">0</span> &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasElement</span>(<span class=\"params\">$elements</span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMistLineSettings</span>(<span class=\"params\">element, translateX</span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushImageToSequence</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NexT.utils.isMist() &amp;&amp; hasElement([$logoLineTop, $logoLineBottom])</span><br><span class=\"line\">    &amp;&amp; sequence.push(</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    );</span><br><span class=\"line\">    NexT.utils.isMuse() &amp;&amp; hasElement($image) &amp;&amp; pushImageToSequence();</span><br><span class=\"line\">    hasElement($title) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    hasElement($subtitle) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============ 透明度从 0 渐进到 1 ============</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 顶间距从 -5 渐进到 5 ===========</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 动画时间为 100 毫秒 ============</span></span><br><span class=\"line\">    hasElement($titleContact) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      e: $titleContact,</span><br><span class=\"line\">      p: &#123;<span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">top</span>: <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">      <span class=\"comment\">// o: &#123;duration: 200&#125;</span></span><br><span class=\"line\">      o: &#123;<span class=\"attr\">duration</span>: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// ===========================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>再次部署，动画效果已经加上了，一切和谐。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo博客DIY（7）文章置顶和公告栏","url":"/post/blogdiy/blogdiy-7-top/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-文章置顶\"><a href=\"#1-文章置顶\" class=\"headerlink\" title=\"1. 文章置顶\"></a>1. 文章置顶</h1><p>Hexo 本身并没有内置文章置顶功能，因此需要自行安装。不过 Hexo 本身有一个对文章排序的组件，也就是在站点配置文件内的 <code>index_generator</code> 选项，置顶功能其实就是每次排序的时候，把其中的置顶文章排在最前，本质上是一个排序组件，Hexo 默认的是 <code>hexo-generator-index</code>，所以先卸载再重新安装一个可以置顶的排序组件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先卸载</span></span><br><span class=\"line\">npm uninstall --save hexo-generator-index</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 再安装</span></span><br><span class=\"line\">npm install --save hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>\n\n<p>从插件名字上就能看得出来支持置顶了。该插件的 GitHub 地址：<a href=\"https://github.com/netcan/hexo-generator-index-pin-top\" title=\"@LINK\">hexo-generator-index-pin-top</a>。插件安装完之后，只需要在文章头部信息栏内设置 <code>top</code> 属性即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo博客DIY（7）文章置顶和公告栏</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019-01-10 07:31:04</span></span><br><span class=\"line\"><span class=\"attr\">top:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>这样这篇文章就具有置顶效果了。不过，仅仅只是这么做，文章虽然确实置顶了，但是从文章列表上来看，和普通的文章没什么不同。如果不特意去对比文章发布时间，可能会以为只是最新的文章而已。例如一些说明、通知之类的，为了能有个比较突出的标志，可以在 <code>next/layout/_macro/post.swig</code> 文件中找到以下位置并添加代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta&quot;</span>&gt;</span><br><span class=\"line\">  <span class=\"comment\">// 加在这里</span></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.top %&#125;</span><br><span class=\"line\">    &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-thumb-tack&quot;</span> style=<span class=\"string\">&quot;color: #EB6D39&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">    &lt;font color=EB6D39&gt;置顶&lt;/font&gt;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-time&quot;</span>&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>这里的图标、文字、以及各自对应的颜色都可以自定义。完成后的效果就是：</p>\n<center>\n\n<p><img data-src=\"./top_with_icon.png\" alt=\"文章置顶效果\" title=\"@ASSET\"></p>\n</center>\n\n<hr>\n<h1 id=\"2-公告栏\"><a href=\"#2-公告栏\" class=\"headerlink\" title=\"2. 公告栏\"></a>2. 公告栏</h1><p>现在文章置顶已经成功实现了，但是还有个问题，比如像我的博客置顶的这篇文章是类似于一个窗格的形式，更符合“置顶公告栏”这么一个设定，没有标题、没有分类和标签、没有日期等等，但是如果不填写 title 栏，仍然会显示一个默认的“未命名”标题：</p>\n<center>\n\n<p><img data-src=\"./untitle_post.png\" alt=\"无标题文章\" title=\"@ASSET\"></p>\n</center>\n\n<p>而且会导致搜索无法使用，因此如果想实现这种：</p>\n<center>\n\n<p><img data-src=\"./quote_post.png\" alt=\"公告栏\" title=\"@ASSET\"></p>\n</center>\n\n<p>就需要在文章的头部信息栏加入一个 <code>type</code> 属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo博客DIY（7）文章置顶和公告栏</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019-01-10 07:31:04</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">&quot;quote&quot;</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>并且取值为 “quote”，这样文章就会变成一个完全没有标题和各种属性的引用块了。</p>\n<hr>\n<h1 id=\"3-增加版本记录\"><a href=\"#3-增加版本记录\" class=\"headerlink\" title=\"3. 增加版本记录\"></a>3. 增加版本记录</h1><p>目前主流的两个博客部署平台就是 GitHub Page 和 Coding 了，Coding 的部署速度还算比较快，GitHub 因为某些特殊原因，部署完之后实际内容生效时间的间隔有些长，表现为从本地 Hexo 部署到 Page 后，需要过几分钟网络上的内容才生效。有时做了一些小改变，也不知道到底是延迟未生效，还是改动本身没有作用。因此可以增加一个版本标志，每次部署的时候手动 +1，并显示在博客内，这样即可通过版本号是否一致来判断当前网络上的是否最新版本了。</p>\n<p>首先在站点配置文件 <code>blog/_config.yml</code> 中增加一个字段：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Update Version</span></span><br><span class=\"line\"><span class=\"comment\">## Custom tag for last update recording</span></span><br><span class=\"line\"><span class=\"attr\">latestVersion:</span> <span class=\"number\">627</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在需要显示的地方使用以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;span style=<span class=\"string\">&quot;color: #666666;font-size:10px;&quot;</span>&gt;V&#123;&#123; config.latestVersion &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体的显示信息可以自己 DIY，如果想使用局部变量来获取这个数值，可以在 <code>themes/next/layout/_layout.swig</code> 中找到如下位置添加变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;# Language &amp; Config #&#125;</span><br><span class=\"line\">&#123;% set title = __(<span class=\"string\">&#x27;title&#x27;</span>) !== <span class=\"string\">&#x27;title&#x27;</span> &amp;&amp; __(<span class=\"string\">&#x27;title&#x27;</span>) || config.title %&#125;</span><br><span class=\"line\">&#123;% set subtitle = __(<span class=\"string\">&#x27;subtitle&#x27;</span>) !== <span class=\"string\">&#x27;subtitle&#x27;</span> &amp;&amp; __(<span class=\"string\">&#x27;subtitle&#x27;</span>) || config.subtitle %&#125;</span><br><span class=\"line\">&#123;% set author = __(<span class=\"string\">&#x27;author&#x27;</span>) !== <span class=\"string\">&#x27;author&#x27;</span> &amp;&amp; __(<span class=\"string\">&#x27;author&#x27;</span>) || config.author %&#125;</span><br><span class=\"line\">&#123;% set description = __(<span class=\"string\">&#x27;description&#x27;</span>) !== <span class=\"string\">&#x27;description&#x27;</span> &amp;&amp; __(<span class=\"string\">&#x27;description&#x27;</span>) || config.description %&#125;</span><br><span class=\"line\">&#123;% set latestVersion = __(<span class=\"string\">&#x27;latestVersion&#x27;</span>) !== <span class=\"string\">&#x27;latestVersion&#x27;</span> &amp;&amp; __(<span class=\"string\">&#x27;latestVersion&#x27;</span>) || config.latestVersion %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在需要使用的地方直接使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123; latestVersion &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引用即可，当然，使用类似的方法也可以显示在侧栏、标题栏等位置，出于这个主题手机版不会显示侧栏，因此可以选择同时显示在悬浮侧栏和置顶公告栏的最顶处，或同时显示在悬浮侧栏和博客标题栏。</p>\n<p>（1）在置顶公告栏处显示的效果如下图所示：</p>\n<center>\n\n<p><img data-src=\"./latest_version_in_post.png\" alt=\"置顶公告栏显示博客版本\" title=\"@ASSET\"></p>\n</center>\n\n<p>这个效果是通过判断文章是否是”置顶公告栏“来设置的，可以先给置顶的公告栏增加一个自定义属性：<code>latestVersion</code>，然后在 <code>next/layout/_macro/post.swig</code> 文件中找到 <code>Post Body</code> 部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-body&#123;% if theme.han %&#125; han-init-context&#123;% endif %&#125;&#123;% if post.direction &amp;&amp; post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot;</span> itemprop=<span class=\"string\">&quot;articleBody&quot;</span>&gt;</span><br><span class=\"line\">  &#123;# Gallery support #&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.photos and post.photos.length %&#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;############### ↓↓↓↓↓ 在置顶公告栏文中添加版本标识 ↓↓↓↓↓ ###############&#125;</span><br><span class=\"line\">  &#123;## 显示版本标识 ##&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> post.latestVersion %&#125;</span><br><span class=\"line\">    &lt;span style=<span class=\"string\">&quot;color: #666666;font-size:10px;&quot;</span>&gt;V&#123;&#123; config.latestVersion &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">  &#123;############### ↑↑↑↑↑ 在置顶公告栏文中添加版本标识 ↑↑↑↑↑ ###############&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> is_index %&#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>（2）悬浮侧栏的显示效果如下图所示：</p>\n<center>\n\n<p><img data-src=\"./latest_version_in_sidebar.png\" alt=\"悬浮侧栏显示博客版本\" title=\"@ASSET\"></p>\n</center>\n\n<p>这个效果需要在文件 <code>next/layout/_macro/sidebar.swig</code> 里找到 <code>if theme.site_state</code> 并修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.site_state %&#125;</span><br><span class=\"line\">  &lt;nav <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state motion-element&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;############### ↓↓↓↓↓ 在侧栏中添加版本标识 ↓↓↓↓↓ ###############&#125;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state-item&quot;</span>&gt;</span><br><span class=\"line\">      &#123;########## 显示版本标识 ##########&#125;</span><br><span class=\"line\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state-item-count&quot;</span>&gt;&#123;&#123; config.latestVersion &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state-item-name&quot;</span>&gt;&#123;&#123; __(<span class=\"string\">&#x27;state.latestVersion&#x27;</span>) &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &#123;############### ↑↑↑↑↑ 在侧栏中添加版本标识 ↑↑↑↑↑ ###############&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> config.archive_dir != <span class=\"string\">&#x27;/&#x27;</span> and site.posts.length &gt; <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> site.categories.length &gt; <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> site.tags.length &gt; <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在 <code>next/languages/</code> 目录下，找到 <code>en.yml</code> 和 <code>zh-CN.yml</code> 这两个语言文件（根据自己的博客语言需求修改对应的文件即可），分别在里面找到 <code>state</code> 字段并增加一个 <code>latestVersion</code> 属性：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 中文语言文件修改如下</span></span><br><span class=\"line\"><span class=\"attr\">state:</span></span><br><span class=\"line\">  <span class=\"attr\">latestVersion:</span> <span class=\"string\">版本</span></span><br><span class=\"line\">  <span class=\"attr\">posts:</span> <span class=\"string\">文章</span></span><br><span class=\"line\">  <span class=\"attr\">pages:</span> <span class=\"string\">页面</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">标签</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">分类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 英文语言文件修改如下</span></span><br><span class=\"line\"><span class=\"attr\">state:</span></span><br><span class=\"line\">  <span class=\"attr\">latestVersion:</span> <span class=\"string\">Version</span></span><br><span class=\"line\">  <span class=\"attr\">posts:</span> <span class=\"string\">posts</span></span><br><span class=\"line\">  <span class=\"attr\">pages:</span> <span class=\"string\">pages</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">categories</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）在菜单栏小事的效果如下图所示：</p>\n<center>\n\n<p><img data-src=\"./menu_badges.png\" alt=\"菜单栏右侧小标记\" title=\"@ASSET\"></p>\n</center>\n\n<p>可以通过修改 <code>next/layout/_macro/menu/menu-badge.swig</code> 实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% macro render(name) %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% set badges = &#123;</span><br><span class=\"line\">    home: config.latestVersion,</span><br><span class=\"line\">    archives: site.posts.length,</span><br><span class=\"line\">    categories: site.categories.length,</span><br><span class=\"line\">    tags: site.tags.length &#125;</span><br><span class=\"line\">  %&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">for</span> menu, count <span class=\"keyword\">in</span> badges %&#125;</span><br><span class=\"line\">    &#123;% <span class=\"keyword\">if</span> name == menu %&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> menu == <span class=\"string\">&quot;home&quot;</span> %&#125;</span><br><span class=\"line\">        &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;badge&quot;</span>&gt;V&#123;&#123; count &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">        &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;badge&quot;</span>&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">  &#123;% endfor %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endmacro %&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>（4）在博客标题栏显示的效果如下图所示：</p>\n<center>\n\n<p><img data-src=\"./latest_version_in_title.png\" alt=\"博客标题栏显示博客版本\" title=\"@ASSET\"></p>\n</center>\n\n<p>首先在 <code>next/source/css/_common/components/header/site-meta.styl</code> 中添加需要显示的效果样式（根据自己的喜好自定义）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.site-titleVersion &#123;</span><br><span class=\"line\">  font-size: 10px;</span><br><span class=\"line\">  opacity: <span class=\"number\">0.5</span>;</span><br><span class=\"line\">  margin: 0px;</span><br><span class=\"line\">  padding: 0px;</span><br><span class=\"line\">  gravity: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在博客标题栏中添加版本信息，修改：<code>next/layout/_partials/header/brand.swig</code>，在主标题下面增加一行文字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;custom-logo-site-title&quot;</span>&gt;</span><br><span class=\"line\">......</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;## 博客标题栏中的站点版本 ##&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-titleVersion&quot;</span>&gt;V&#123;&#123; config.latestVersion &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;## 博客标题栏中的留言链接 ##&#125;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;&#123;&#123; config.titleContact_url &#125;&#125;&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-titleContact&quot;</span>&gt;&#123;&#123; config.contact &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> subtitle %&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的样式和放置的位置可以根据喜好调整代码。此时博客标题栏中已经可以显示版本信息了，但是在页面加载或刷新时，其他的元素都有一个渐进的效果，为了不违和，也可以给博客标题栏中的版本信息增加相同的效果。还是在 <code>next/source/css/_common/components/header/site-meta.styl</code> 中，在最下面找到 <code>use-motion</code> 部分，这里定义的是需要动画的元素的初始状态。默认的动画是顶部间距从 -10 渐进到 0，如果想用默认动画，则只需要把 <code>site-titleVersion</code> 加到列表中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use-motion &#123;</span><br><span class=\"line\">  .brand &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .logo, .site-title, .site-subtitle, .custom-logo-image, .site-titleVersion &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我自己想让版本信息和下面的留言板链接统一，都从 -5 渐进到 5，因此需要单独设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use-motion &#123;</span><br><span class=\"line\">  .brand &#123; <span class=\"attr\">opacity</span>: <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .logo, .site-title, .site-subtitle, .custom-logo-image &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .site-titleVersion, .site-titleContact &#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0</span>;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    top: -5px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后找到动画脚本文件 <code>next/source/js/motion.js</code>，先在本地变量定义区定义好这个 CSS 样式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">NexT.motion.middleWares = &#123;</span><br><span class=\"line\">  logo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">integrator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sequence = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $brand = $(<span class=\"string\">&#x27;.brand&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $image = $(<span class=\"string\">&#x27;.custom-logo-image&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $title = $(<span class=\"string\">&#x27;.site-title&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $subtitle = $(<span class=\"string\">&#x27;.site-subtitle&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $logoLineTop = $(<span class=\"string\">&#x27;.logo-line-before i&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $logoLineBottom = $(<span class=\"string\">&#x27;.logo-line-after i&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 定义本地变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleVersion = $(<span class=\"string\">&#x27;.site-titleVersion&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleContact = $(<span class=\"string\">&#x27;.site-titleContact&#x27;</span>)</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后实现动画效果（为了表示层级关系，保留几个方法，但省略了内部源码）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">NexT.motion.middleWares = &#123;</span><br><span class=\"line\">  logo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">integrator</span>) </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// ============== 定义本地变量 ==============</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleVersion = $(<span class=\"string\">&#x27;.site-titleVersion&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $titleContact = $(<span class=\"string\">&#x27;.site-titleContact&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ========================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    $brand.length &gt; <span class=\"number\">0</span> &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasElement</span>(<span class=\"params\">$elements</span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMistLineSettings</span>(<span class=\"params\">element, translateX</span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushImageToSequence</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NexT.utils.isMist() &amp;&amp; hasElement([$logoLineTop, $logoLineBottom])</span><br><span class=\"line\">    &amp;&amp; sequence.push(</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    );</span><br><span class=\"line\">    NexT.utils.isMuse() &amp;&amp; hasElement($image) &amp;&amp; pushImageToSequence();</span><br><span class=\"line\">    hasElement($title) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    hasElement($subtitle) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============ 透明度从 0 渐进到 0.5 ============</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 顶间距从 -5 渐进到 5 ===========</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 动画时间为 100 毫秒 ============</span></span><br><span class=\"line\">    hasElement($titleVersion) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      e: $titleVersion,</span><br><span class=\"line\">      p: &#123;<span class=\"attr\">opacity</span>: <span class=\"number\">0.5</span>, <span class=\"attr\">top</span>: <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">      <span class=\"comment\">// o: &#123;duration: 200&#125;</span></span><br><span class=\"line\">      o: &#123;<span class=\"attr\">duration</span>: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// ===========================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============ 透明度从 0 渐进到 1 ============</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 顶间距从 -5 渐进到 5 ===========</span></span><br><span class=\"line\">    <span class=\"comment\">// ============ 动画时间为 100 毫秒 ============</span></span><br><span class=\"line\">    hasElement($titleContact) &amp;&amp; sequence.push(&#123;</span><br><span class=\"line\">      e: $titleContact,</span><br><span class=\"line\">      p: &#123;<span class=\"attr\">opacity</span>: <span class=\"number\">1</span>, <span class=\"attr\">top</span>: <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">      <span class=\"comment\">// o: &#123;duration: 200&#125;</span></span><br><span class=\"line\">      o: &#123;<span class=\"attr\">duration</span>: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// ===========================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>再次部署，动画效果已经加上了，一切和谐。</p>\n<hr>\n<h1 id=\"4-从侧栏去掉文章计数（已弃用）\"><a href=\"#4-从侧栏去掉文章计数（已弃用）\" class=\"headerlink\" title=\"4. 从侧栏去掉文章计数（已弃用）\"></a>4. 从侧栏去掉文章计数（已弃用）</h1><p>正常情况下，Next 主题侧栏会有一个显示文章、分类、标签的计数，但是如果我们创建了一个上文所示的“公告栏”，而只是用来做一些通知、信息展示等功能，可能就并不想把这些文章算进去。想要减掉这部分的文章数量，可以在 <code>next/layout/_macro/sidebar.swig</code> 文件里找到 <code>if theme.site_state</code> 的部分并修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> theme.site_state %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;########## 去掉侧栏中对博客置顶公告栏文章计数 ##########&#125;</span><br><span class=\"line\">    &#123;##########          该方法已弃用          ##########&#125;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state-item-count&quot;</span>&gt;&#123;&#123; site.posts.length - <span class=\"number\">1</span> &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;site-state-item-name&quot;</span>&gt;&#123;&#123; __(<span class=\"string\">&#x27;state.posts&#x27;</span>) &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是直接把 <code>site.posts.length</code> 减掉了 1 而已，方法是笨方法，因为如果删掉了那篇文章，或者新增了一篇，还要再改一次源码，不过这是个备用方法，<code>site</code> 属性是 Hexo 提供的，似乎没法用简单的办法修改其计算逻辑。</p>\n<hr>\n<h1 id=\"5-从“归档”去掉文章（已弃用）\"><a href=\"#5-从“归档”去掉文章（已弃用）\" class=\"headerlink\" title=\"5. 从“归档”去掉文章（已弃用）\"></a>5. 从“归档”去掉文章（已弃用）</h1><p>如果选择从侧栏的文章计数中去掉了某篇文章，可能也会希望“归档”里同样不记录，同样，归档里也有一个文章计数，还另有一个所有文章的列表，可以看到我的归档里并不包括置顶那个“公告栏”的文章，修改的方式也很类似，找到 <code>next/layout/archive.swig</code> 文件中 <code>ARCHIVE BLOCK</code> 部分并修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;### ARCHIVE BLOCK ###&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-block archive&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> theme.cheers %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;archive-page-counter&quot;</span>&gt;</span><br><span class=\"line\">      &#123;% set posts_length = site.posts.length %&#125;</span><br><span class=\"line\">      &#123;########## 设置 post_length 以修改归档页上方的文章计数 ##########&#125;</span><br><span class=\"line\">      &#123;##########               该方法已弃用               ##########&#125;</span><br><span class=\"line\">      &#123;&#123; _p(<span class=\"string\">&quot;counter.archive_posts&quot;</span>, site.posts.length - <span class=\"number\">1</span>) &#125;&#125;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，直接把 <code>site.posts.length</code> 减掉了 1 来去掉计数。</p>\n<p>同样在 <code>ARCHIVE BLOCK</code> 部分，再在刚才的代码下面找到循环遍历所有文章的部分并修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">for</span> post <span class=\"keyword\">in</span> page.posts %&#125;</span><br><span class=\"line\">  &#123;########## 增加 if 判断文章是否设置字段 billboard: true ##########&#125;</span><br><span class=\"line\">  &#123;% <span class=\"keyword\">if</span> not post.billboard %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;########## 把原本 for 循环里面的代码放进这个 if 里面来 ##########&#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% endif %&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，只要我们在文章的头部信息栏内增加一个 <code>billboard</code> 标签（可以自定义，只要代码里和文章里一致即可），就能从“归档”的列表中去掉这篇文章！同理，也可以增加任意约束，比如去掉日期早于某个时候的文章、去掉带有某个标签的文章等等，只要把约束全部加进 <code>if</code> 里去即可。不过这里的修改只影响到“归档”中的列表，博客首页的所有文章还是会显示的，想要博客不加载某篇文章会在以后介绍。</p>\n<hr>\n<h1 id=\"6-在归档中禁止进入\"><a href=\"#6-在归档中禁止进入\" class=\"headerlink\" title=\"6. 在归档中禁止进入\"></a>6. 在归档中禁止进入</h1><p>上面说了两个方法，分别减掉侧栏和归档中的“博客公告栏”的计数，但如果再开启博客菜单栏右侧的小标记：</p>\n<center>\n\n<p><img data-src=\"./menu_badges.png\" alt=\"菜单栏右侧小标记\" title=\"@ASSET\"></p>\n</center>\n\n<p>按照上面的方法，又要修改一次 <code>next/layout/_macro/menu/menu-badge.swig</code> 中的代码，所以是个治标不治本的办法。为此，干脆不改变计数，而是在归档中禁止点击进入“博客公告栏”的实际文章地址，并且在“博客公告栏”的上一篇和下一篇文章中，禁止通过“上一篇”或“下一篇”进入，禁止“上一篇”或“下一篇”进入会在下一节详解。</p>\n<p>首先观察 <code>next/layout/archive.swig</code> 中的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;##### ↓↓↓关键代码↓↓↓ #####&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">import</span> <span class=\"string\">&#x27;_macro/post-collapse.swig&#x27;</span> <span class=\"keyword\">as</span> post_template %&#125;</span><br><span class=\"line\">&#123;##### ↑↑↑关键代码↑↑↑ #####&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% <span class=\"keyword\">for</span> post <span class=\"keyword\">in</span> page.posts %&#125;</span><br><span class=\"line\">  &#123;# Show year #&#125;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  &#123;# endshow #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;##### ↓↓↓关键代码↓↓↓ #####&#125;</span><br><span class=\"line\">  &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class=\"line\">  &#123;##### ↑↑↑关键代码↑↑↑ #####&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现了一个很关键的依赖文件 <code>next/layout/_macro/post-collapse.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% macro render(post) %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;&#123;% <span class=\"keyword\">if</span> theme.seo %&#125;h3&#123;% <span class=\"keyword\">else</span> %&#125;h2&#123;% endif %&#125; <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-title&quot;</span>&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">          &#123;##### ↓↓↓关键代码↓↓↓ #####&#125;</span><br><span class=\"line\">          &lt;a <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-title-link&quot;</span> href=<span class=\"string\">&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;</span> itemprop=<span class=\"string\">&quot;url&quot;</span>&gt;</span><br><span class=\"line\">            &#123;% <span class=\"keyword\">if</span> post.type === <span class=\"string\">&#x27;picture&#x27;</span> %&#125;</span><br><span class=\"line\">              &#123;&#123; post.content &#125;&#125;</span><br><span class=\"line\">            &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">              &lt;span itemprop=<span class=\"string\">&quot;name&quot;</span>&gt;&#123;&#123; post.title | <span class=\"keyword\">default</span>(__(<span class=\"string\">&#x27;post.untitled&#x27;</span>)) &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">            &#123;% endif %&#125;</span><br><span class=\"line\">          &lt;/a&gt;</span><br><span class=\"line\">          &#123;##### ↑↑↑关键代码↑↑↑ #####&#125;</span><br><span class=\"line\">        &#123;% endif %&#125;</span><br><span class=\"line\">      &lt;/&#123;% <span class=\"keyword\">if</span> theme.seo %&#125;h3&#123;% <span class=\"keyword\">else</span> %&#125;h2&#123;% endif %&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      ......</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  &lt;/article&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>标记了“关键代码”的这一段，就是“归档”中实际显示每一篇文章的代码了，稍作修改，根据文章是否有 <code>billboard: true</code> 属性来做不同的处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% macro render(post) %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;&#123;% <span class=\"keyword\">if</span> theme.seo %&#125;h3&#123;% <span class=\"keyword\">else</span> %&#125;h2&#123;% endif %&#125; <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-title&quot;</span>&gt;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">          &#123;##### ↓↓↓关键代码修改后↓↓↓ #####&#125;</span><br><span class=\"line\">          &#123;% <span class=\"keyword\">if</span> post.billboard %&#125;</span><br><span class=\"line\">            &lt;a <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-title-link&quot;</span> href=<span class=\"string\">&quot;javascript:void(0)&quot;</span> itemprop=<span class=\"string\">&quot;url&quot;</span>&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;</span><br><span class=\"line\">          &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">            &lt;a <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-title-link&quot;</span> href=<span class=\"string\">&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;</span> itemprop=<span class=\"string\">&quot;url&quot;</span>&gt;</span><br><span class=\"line\">                &#123;% <span class=\"keyword\">if</span> post.type === <span class=\"string\">&#x27;picture&#x27;</span> %&#125;</span><br><span class=\"line\">                &#123;&#123; post.content &#125;&#125;</span><br><span class=\"line\">                &#123;% <span class=\"keyword\">else</span> %&#125;</span><br><span class=\"line\">                &lt;span itemprop=<span class=\"string\">&quot;name&quot;</span>&gt;&#123;&#123; post.title | <span class=\"keyword\">default</span>(__(<span class=\"string\">&#x27;post.untitled&#x27;</span>)) &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">                &#123;% endif %&#125;</span><br><span class=\"line\">            &lt;/a&gt;</span><br><span class=\"line\">          &#123;% endif %&#125;</span><br><span class=\"line\">          &#123;##### ↑↑↑关键代码修改后↑↑↑ #####&#125;</span><br><span class=\"line\">        &#123;% endif %&#125;</span><br><span class=\"line\">      &lt;/&#123;% <span class=\"keyword\">if</span> theme.seo %&#125;h3&#123;% <span class=\"keyword\">else</span> %&#125;h2&#123;% endif %&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      ......</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  &lt;/article&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于含有 <code>billboard: true</code> 属性的文章，保持和其他文章的样式一样，但是却把链接改成 <code>javascript:void(0)</code>，这样就变成一个“死链接”了，怎么点都没有效果。</p>\n<hr>\n<h1 id=\"7-禁止通过“上-下一篇”进入\"><a href=\"#7-禁止通过“上-下一篇”进入\" class=\"headerlink\" title=\"7. 禁止通过“上/下一篇”进入\"></a>7. 禁止通过“上/下一篇”进入</h1><p>通过上文的修改，这篇置顶的公告栏已经无法从“归档”和文章列表里进入了，但是还有一个方法可以进入，就是先点击进入这篇置顶公告栏的 前/后 一篇文章，然后通过“上/下一篇”的链接进入：</p>\n<center>\n\n<p><img data-src=\"./billboard_from_next_post.png\" alt=\"点击“下一篇”进入\" title=\"@ASSET\"></p>\n</center>\n\n<p>这样就能以普通文章的形式查看了：</p>\n<center>\n\n<p><img data-src=\"./billboard_post.png\" alt=\"查看置顶公告栏\" title=\"@ASSET\"></p>\n</center>\n\n<p>但其实因为这篇文章只是用来作为置顶公告栏使用，既没有标题又没有什么有价值的内容，这么显示出来挺不美观的，因此可能不希望让读者不经意间进入这篇文章的详细内容，为此可以修改 <code>themes/next-711/layout/_macro/post.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;### Prev and Last ###&#125;</span><br><span class=\"line\">&#123;#####################&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> not is_index and (post.prev or post.next) %&#125;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;### 后一篇 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-next post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">      &#123;### ↓↓↓重点修改下面这行↓↓↓ ###&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> post.next and not post.next.billboard %&#125;</span><br><span class=\"line\">      &#123;### ↑↑↑重点修改上面这行↑↑↑ ###&#125;</span><br><span class=\"line\">        &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;next&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.next.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">          &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-left&quot;</span>&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-divider&quot;</span>&gt;&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;### 前一篇 ###&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-nav-prev post-nav-item&quot;</span>&gt;</span><br><span class=\"line\">      &#123;### ↓↓↓重点修改下面这行↓↓↓ ###&#125;</span><br><span class=\"line\">      &#123;% <span class=\"keyword\">if</span> post.prev and not post.prev.billboard %&#125;</span><br><span class=\"line\">      &#123;### ↑↑↑重点修改上面这行↑↑↑ ###&#125;</span><br><span class=\"line\">        &lt;a href=<span class=\"string\">&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot;</span> rel=<span class=\"string\">&quot;prev&quot;</span> title=<span class=\"string\">&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;</span>&gt;</span><br><span class=\"line\">          &#123;&#123; post.prev.title &#125;&#125; &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;fa fa-chevron-right&quot;</span>&gt;&lt;/i&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% set isLast = loop.index % page.per_page === <span class=\"number\">0</span> %&#125;</span><br><span class=\"line\">&#123;% <span class=\"keyword\">if</span> is_index and not isLast %&#125;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;post-eof&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面第 4 条中，去掉“归档”内的置顶公告栏文章，用到了文章内的自定义属性 <code>billboard</code>，这里也同样适用。在 <code>if</code> 判断上一篇和下一篇文章是否为空的地方，加一个 <code> and not post.prev.billboard</code>，表示 <code>当 上一篇 / 下一篇 文章不为空，并且 上一篇 / 下一篇 文章的 billboard 不为 true 时</code>，这样只要置顶公告栏文章设置了 <code>billboard: true</code> 就能同时从“归档”和“上一篇 / 下一篇”里消失了！不过这里有一个小小的坑，代码里面的 <code>prev</code> 直译过来应该是“前一个”，但在文章的“上一篇/下一篇”中对应的是右边那个，也是时间上更晚的一个，从直觉的角度来看或许更应该叫“下一个”。而 <code>next</code> 直译过来是“下一个”，但在文章的“上一篇/下一篇”中对应的是左边那个，时间上是更早的一个，从直觉上来看反倒应该是“前一个”才对，不知道是不是开发人员搞混了哈哈，记录一下以防踩坑。</p>\n<hr>\n<p>更多进一步的个性化欢迎参考：<a href=\"/categories/BlogDIY/\" title=\"@LINK\">博客 DIY 系列</a></p>\n","categories":["BlogDIY"],"tags":["Hexo","自定义"]},{"title":"Android-Handler","url":"/post/android/android-handler/","content":"<span id=\"more\"></span>\n\n<p>前言：本文是针对 Handler 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h1 id=\"1-Handler的实例化和初始化\"><a href=\"#1-Handler的实例化和初始化\" class=\"headerlink\" title=\"1. Handler的实例化和初始化\"></a>1. Handler的实例化和初始化</h1><p>Handler 在 Android 开发中还是相当相当常见的，其涉及到了很多 Android 和 Java 的数据结构。Handler 的源码并不复杂，原理也很有意思，常用的方法里实例化和初始化就占了很大一部分，消息 Message 的传递也占了很大一部分，本文主要也是分析这两点，剩下的用的不是太多，直接阅读源码也很快，在本文就不分析了。通过阅读 Handler 以及相关类的源码，可以深刻体会到 Android 的一些通用设计理念。</p>\n<h2 id=\"1-1-什么是Handler\"><a href=\"#1-1-什么是Handler\" class=\"headerlink\" title=\"1.1 什么是Handler\"></a>1.1 什么是Handler</h2><p>在 Handler 的源码中，有一段很长的注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A Handler allows you to send and process &#123;<span class=\"doctag\">@link</span> Message&#125; and Runnable</span></span><br><span class=\"line\"><span class=\"comment\"> * objects associated with a thread&#x27;s &#123;<span class=\"doctag\">@link</span> MessageQueue&#125;.  Each Handler</span></span><br><span class=\"line\"><span class=\"comment\"> * instance is associated with a single thread and that thread&#x27;s message</span></span><br><span class=\"line\"><span class=\"comment\"> * queue.  When you create a new Handler, it is bound to the thread /</span></span><br><span class=\"line\"><span class=\"comment\"> * message queue of the thread that is creating it -- from that point on,</span></span><br><span class=\"line\"><span class=\"comment\"> * it will deliver messages and runnables to that message queue and execute</span></span><br><span class=\"line\"><span class=\"comment\"> * them as they come out of the message queue.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and</span></span><br><span class=\"line\"><span class=\"comment\"> * runnables to be executed at some point in the future; and (2) to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * an action to be performed on a different thread than your own.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Scheduling messages is accomplished with the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #post&#125;, &#123;<span class=\"doctag\">@link</span> #postAtTime(Runnable, long)&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #postDelayed&#125;, &#123;<span class=\"doctag\">@link</span> #sendEmptyMessage&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessage&#125;, &#123;<span class=\"doctag\">@link</span> #sendMessageAtTime&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessageDelayed&#125; methods.  The &lt;em&gt;post&lt;/em&gt; versions allow</span></span><br><span class=\"line\"><span class=\"comment\"> * you to enqueue Runnable objects to be called by the message queue when</span></span><br><span class=\"line\"><span class=\"comment\"> * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * a &#123;<span class=\"doctag\">@link</span> Message&#125; object containing a bundle of data that will be</span></span><br><span class=\"line\"><span class=\"comment\"> * processed by the Handler&#x27;s &#123;<span class=\"doctag\">@link</span> #handleMessage&#125; method (requiring that</span></span><br><span class=\"line\"><span class=\"comment\"> * you implement a subclass of Handler).</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When posting or sending to a Handler, you can either</span></span><br><span class=\"line\"><span class=\"comment\"> * allow the item to be processed as soon as the message queue is ready</span></span><br><span class=\"line\"><span class=\"comment\"> * to do so, or specify a delay before it gets processed or absolute time for</span></span><br><span class=\"line\"><span class=\"comment\"> * it to be processed.  The latter two allow you to implement timeouts,</span></span><br><span class=\"line\"><span class=\"comment\"> * ticks, and other timing-based behavior.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When a</span></span><br><span class=\"line\"><span class=\"comment\"> * process is created for your application, its main thread is dedicated to</span></span><br><span class=\"line\"><span class=\"comment\"> * running a message queue that takes care of managing the top-level</span></span><br><span class=\"line\"><span class=\"comment\"> * application objects (activities, broadcast receivers, etc) and any windows</span></span><br><span class=\"line\"><span class=\"comment\"> * they create.  You can create your own threads, and communicate back with</span></span><br><span class=\"line\"><span class=\"comment\"> * the main application thread through a Handler.  This is done by calling</span></span><br><span class=\"line\"><span class=\"comment\"> * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from</span></span><br><span class=\"line\"><span class=\"comment\"> * your new thread.  The given Runnable or Message will then be scheduled</span></span><br><span class=\"line\"><span class=\"comment\"> * in the Handler&#x27;s message queue and processed when appropriate.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概翻译一下，这段注释基本也介绍清楚了 Handler 的工作流程：</p>\n<ul>\n<li>（1）Handler 允许你发送和处理和线程的 MessageQueue 相关联的 Message 和 Runnable 对象。每个 Handler 实例对象都只和一个线程以及该线程的消息队列。当创建一个 Handler 实例时，这个 Handler 会与线程以及这个线程创建的消息队列绑定，这之后，这个 Handler 会负责给 MessageQueue 传送 Message 和 Runnable，或者负责处理从 MessageQueue 中取出的 Message 和 Runnable。</li>\n<li>（2）Handler 有 2 个主要的用途：① 给 Message 和 Runnable 安排一个未来执行的时间（可以是相差 0，表示立即执行）；② 将一个事务提交到另一个不同的线程处理。</li>\n<li>（3）Handler 通过 <code>post</code>，<code>postAtTime(Runnable, long)</code>，<code>postDelayed</code>，<code>sendEmptyMessage</code>，<code>sendMessage</code>，<code>sendMessageAtTime</code>，<code>sendMessageDelayed</code> 方法（具体在：《<a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a>》有详细介绍）调度 Message。<code>post</code> 方式允许发送一个 Runnable 对象并在被 MessageQueue 接收后调用。<code>shendMessage</code> 方式允许发送一个包括了一个 Bundle 形式的数据的 Message，并且在 <code>Handler.handleMessage()</code> 方法中处理（要求实现一个 Handler 的子类）。</li>\n<li>（4）不论使用 <code>post</code> 还是 <code>send</code> 方式发送消息，都可以让这些消息在 MessageQueue 可用时立即处理，或者指定一个延时间隔来延迟处理，或者指定一个具体的处理事件。后面二者可以通过：延迟、具体时间、或其他基于时间的行为来实现。</li>\n<li>（5）当 App 的进程被创建时，它的主线程则专门用来运行一个管理顶层应用对象的 MessageQueue，这些顶层应用对象可以是例如：Activity，BroadcastReceiver 等等，或是他们创建的其他 Windows。你可以创建自己的子线程，并通过 Handler 与主线程通信，只需要在子线程中调用上述的 <code>send</code> 类型或 <code>post</code> 类型的方法即可，发送的 Message 或 Runnable 将在 Handler 的 MessageQueue 合适的时候被调度和处理。</li>\n</ul>\n<p>需要注意的几个重点：① Handler 可以用来发送消息也可以用来处理消息；② 发送消息有两种类型的方式，处理消息可以跨进程；③ Handler 的实例是和当前线程以及当前线程的 MessageQueue 绑定的；④ MessageQueue 中维护的单链表只支持 Message 对象，因此 Runnable 是通过封装进 Message 来实现的。</p>\n<h2 id=\"1-2-Handler构造方法\"><a href=\"#1-2-Handler构造方法\" class=\"headerlink\" title=\"1.2 Handler构造方法\"></a>1.2 Handler构造方法</h2><p>Handler 内部有多个不同参数的构造方法，依次看看：</p>\n<ul>\n<li>① 无参默认构造方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Default constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该构造方法会使得 Handler 与当前线程的 Looper 关联，如果当前线程没有 Looper，则 Handler 将无法接收消息，从而抛出异常。</p>\n<ul>\n<li>② 1 个参数（<code>Callback</code>）的构造方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread and takes a callback interface in which you can handle</span></span><br><span class=\"line\"><span class=\"comment\">  * messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过重写了接收消息后处理的回调方法 <code>handleMessage</code>。</p>\n<ul>\n<li>③ 1 个参数（<code>async</code>）的构造方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过指定了通过这个 Handler 发送的消息为异步消息（Async）。</p>\n<ul>\n<li>④ 以上 ①、②、③ 最终均调用了 2 个参数（<code>Callback, async</code>）的构造方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 《<a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a>》 一文可以知道，<code>Looper.myLooper()</code> 就是返回了当前线程中的 Looper 实例对象，如果当前线程不具备处理消息的功能，也即没有 Looper 实例，则返回 <code>null</code>，接下来也就是当存在 Looper 实例对象时，获取并绑定其消息队列 MessageQueue，处理事件的回调 Callback，以及设置是否异步 async。</p>\n<ul>\n<li>⑤ 1 个参数（<code>Looper</code>）的构造方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>手动指定这个 Handler 需要绑定的线程，当我们需要从子线程更新 UI 时，通常会使用如下方法来实例化一个 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Handler handler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure>\n\n<p>这其实就是调用的这个构造方法，而 <code>Looper.getMainLooper()</code> 返回的就是主线程的 Looper 实例对象。</p>\n<ul>\n<li>⑥ 2 个参数（<code>Looper, Callback</code>）的构造方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时指定 Looper 和 Callback。</p>\n<ul>\n<li>⑦ 以上 ⑤、⑥ 最终均调用了 3 个参数的构造方法：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.  Also set whether the handler</span></span><br><span class=\"line\"><span class=\"comment\">  * should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by conditions such as display vsync.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    mQueue = looper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个构造方法则是最详细的，可以同时指定 Looper，Callback，以及是否异步 async。</p>\n<p>通过查看以上 7 种构造方法，可以总结出 Handler 的实例化过程：如果没有显式传入任何参数，则默认绑定当前线程的 Looper，使用默认 Callback，发送同步消息，否则按照对应显式传入的参数手动指定。</p>\n<hr>\n<h1 id=\"2-Handler发送Message\"><a href=\"#2-Handler发送Message\" class=\"headerlink\" title=\"2. Handler发送Message\"></a>2. Handler发送Message</h1><h2 id=\"2-1-源码分析\"><a href=\"#2-1-源码分析\" class=\"headerlink\" title=\"2.1 源码分析\"></a>2.1 源码分析</h2><p>在平时开发中 Handler 最主要的用途就是在子线程中更新 UI，两种方式：</p>\n<ul>\n<li><p><code>send</code> 方式，包括：</p>\n<ul>\n<li><ol>\n<li><code>sendMessage</code> 或 <code>sendEmptyMessage</code></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><code>sendMessageDelayed</code> 或 <code>sendEmptyMessageDelayed</code></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><code>sendMessageAtTime</code> 或 <code>sendEmptyMessageAtTime</code></li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li><code>sendMessageAtFrontOfQueue</code>（比较特殊，会在后面详细讲解）</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><code>post</code> 方式，包括：</p>\n<ul>\n<li><ol>\n<li><code>post</code></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><code>postDelayed</code></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><code>postAtTime</code></li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li><code>postAtFrontOfQueue</code></li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>其中，通过查看 <code>post</code> 方式的源码可以发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delayed</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@hide</span> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(Runnable r, <span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r).setWhat(what), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r, token), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtTime</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtFrontOfQueue</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上 <code>post</code> 方式最终都是通过 <code>send</code> 方式实现的。再看一下各个 <code>send</code> 方式的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> what)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendEmptyMessageDelayed(what, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageAtTime</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上源码中可以看到一个参数：<code>uptimeMillis</code>，这个参数是从开机到当前时刻的时间间隔（毫秒，当设备处于睡眠时不计算），表示消息需要被处理时的时间，任意不同时刻获取到的该值都是不同的，<code>uptimeMillis</code> 越小表示消息越早处理。<strong>消息在添加到消息队列中时，是按照实际处理的时间从先到后按顺序排列的</strong>，详细的处理机制可参考：<a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a>。并且除了 <code>sendMessageAtFrontOfQueue</code> 方法之外，其他 <code>send</code> 方式本质都是通过这一个方法发送的：<code>sendMessageAtTime</code>，而这两个方法最终都调用了 <code>enqueueMessage</code>，看看这个方法内部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> MessageQueue queue, <span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法每一句都说明了 Message 的一个性质：</p>\n<ul>\n<li><code>msg.target = this;</code> 这句把 Message 和 Handler 绑定在了一起。</li>\n<li><code>msg.workSourceUid = ThreadLocalWorkSource.getUid();</code> 这句是获取到了当前线程的 Uid，也就是和当前线程绑定在了一起。</li>\n<li><code>msg.setAsynchronous(true);</code> 这句是设置为异步，<code>if</code> 也表示默认情况下的 Message 是同步的。</li>\n</ul>\n<p>最后调用了 <code>MessageQueue.enqueueMessage</code> 方法把 Message 插入到消息队列中。</p>\n<h2 id=\"2-2-流程总结\"><a href=\"#2-2-流程总结\" class=\"headerlink\" title=\"2.2 流程总结\"></a>2.2 流程总结</h2><p>通过以上源码分析，Handler 在发送一个消息后的流程也就清楚了：</p>\n<font color=#EB6D39>\n\n<ul>\n<li>① 接收一个 Message，并根据设置的延时，设置 Message 的 <code>when</code></li>\n<li>② 根据情况设置 Message 的类型，默认情况下为同步消息</li>\n<li>③ 将 Message 的 <code>target</code> 设置为自己</li>\n<li>④ 调用 MessageQueue 的 <code>enqueueMessage</code> 方法</li>\n<li>⑤ <code>MessageQueue.enqueueMessage</code> 方法中，根据 <code>when</code> 从小到大的顺序将 Message 插入到单链表对应位置</li>\n<li>⑥ 根据条件唤醒 Native 层的消息队列</li>\n</ul>\n</font>\n\n<hr>\n<h1 id=\"3-Handler机制总结\"><a href=\"#3-Handler机制总结\" class=\"headerlink\" title=\"3. Handler机制总结\"></a>3. Handler机制总结</h1><p>通过分析 Handler 的实例化和初始化，以及 Handler 发送消息的流程，可以总结出 Handler 的工作机制：</p>\n<ul>\n<li>① Handler 默认和当前线程以及当前线程的 MessageQueue 绑定，默认发送同步消息。</li>\n<li>② 可以手动指定 Handler 的线程、重写接收消息后的回调方法 <code>Callback.handleMessage()</code>。</li>\n<li>③ 可以手动指定发送的消息类型，但一个 Handler 只能发送一种消息，不能交替发送。</li>\n<li>④ Handler 所在线程由实例化时的 Looper 有关，且只能接收到与之绑定的线程中的消息，如果线程不具备处理消息的功能，则 Handler 无法接收消息且会抛出异常。</li>\n<li>⑤ Handler 有两种发送消息的方式，但本质上都是 <code>send</code> 方式。</li>\n<li>⑥ Handler 可以发送 Message，也可以发送 Runnable，但由于 MessageQueue 维护的单链表元素是 Message，因此 Runnable 实际上是封装在 message 中的。</li>\n</ul>\n","categories":["Android"],"tags":["Android","源码","Handler"]},{"title":"Android-MessageQueue","url":"/post/android/android-messagequeue/","content":"<span id=\"more\"></span>\n\n<p>前言：本文是针对 MessageQueue 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h1 id=\"1-认识MessageQueue\"><a href=\"#1-认识MessageQueue\" class=\"headerlink\" title=\"1. 认识MessageQueue\"></a>1. 认识MessageQueue</h1><p>在分析 MessageQueue 之前，首先要了解到一个消息队列的误区：MessageQueue 从名字上看来是一个“队列”，主要是其处理消息的方式比较像一个队列。实际上，因为会频繁地出现 Message 的插入和删除等操作，如果是用传统的“队列”来存放 Message，插入、删除的效率会很低，因此 MessageQueue 采用单链表的形式（单链表插入、删除只需要变动两个节点对象的连接目标即可）来管理 Message。</p>\n<p>MessageQueue 源码里的注释对其一些性质进行了说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Low-level class holding the list of messages to be dispatched by a</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper&#125;.  Messages are not added directly to a MessageQueue,</span></span><br><span class=\"line\"><span class=\"comment\">  * but rather through &#123;<span class=\"doctag\">@link</span> Handler&#125; objects associated with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;You can retrieve the MessageQueue for the current thread with</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper#myQueue() Looper.myQueue()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概意思是：</p>\n<blockquote>\n<p>MessageQueue 是一个持有 Message 的低等级类，它所持有的 Message 由 Looper 分发。Message 并不是直接被添加到 MessageQueue 中的，而是通过 Handler 的对象与 Looper 绑定起来。</p>\n<p>你可以通过 <code>Looper.myQueue()</code> 方法取回当前线程的 MessageQueue。</p>\n</blockquote>\n<p>这段注释特别关键，以至于我觉得已经足以说明整个 MessageQueue 的工作方式了，上半段概括了 MessageQueue 如何管理 Message，下半段概括了 MessageQueue、Looper 以及线程的关系。</p>\n<hr>\n<h1 id=\"2-MessageQueue管理Message\"><a href=\"#2-MessageQueue管理Message\" class=\"headerlink\" title=\"2. MessageQueue管理Message\"></a>2. MessageQueue管理Message</h1><h2 id=\"2-1-添加Message\"><a href=\"#2-1-添加Message\" class=\"headerlink\" title=\"2.1 添加Message\"></a>2.1 添加Message</h2><p>（1）当一个 Message 产生并且被发送时，通过 Handler 的对象将这个 Message 和当前线程绑定，再插入到 MessageQueue 单链表中。</p>\n<p>通过 Handler 源码可知，一个消息被发送后，Handler 最终会调用 <code>MessageQueue.enqueueMessage(Message msg, long when)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">&quot; This message is already in use.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这句也就是在 《<a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a>》 一文的“障栅消息”中，手动将 <code>Message.target</code> 设置为 <code>null</code> 会报异常的原因。其余部分也就是根据 Message 的 <code>when</code> 来将 Message 插入到 MessageQueue 的指定位置，并且根据情况唤醒 Native 层的消息队列。</p>\n<h2 id=\"2-2-移除Message\"><a href=\"#2-2-移除Message\" class=\"headerlink\" title=\"2.2 移除Message\"></a>2.2 移除Message</h2><p>移除消息有两个不同参数的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用自定义回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, Runnable r, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span> || r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.callback == r</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.callback == r</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实对应的是初始化 Handler 时，一个是使用默认回调，一个是使用自定义回调的情况，具体移除消息的过程几乎是一样的，都是单链表从中移除一个节点的逻辑。</p>\n<h2 id=\"2-3-移除BarrierMessage\"><a href=\"#2-3-移除BarrierMessage\" class=\"headerlink\" title=\"2.3 移除BarrierMessage\"></a>2.3 移除BarrierMessage</h2><p>源码是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@TestApi</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和发送一个障栅消息一样，这个方法也加了 <code>@hide</code> 注解，移除的过程和移除普通消息比较类似，也是单链表移除节点的逻辑。</p>\n<hr>\n<h1 id=\"3-MessageQueue和线程的交互\"><a href=\"#3-MessageQueue和线程的交互\" class=\"headerlink\" title=\"3. MessageQueue和线程的交互\"></a>3. MessageQueue和线程的交互</h1><p>MessageQueue 中有一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Callback interface for discovering when a thread is going to block</span></span><br><span class=\"line\"><span class=\"comment\">  * waiting for more messages.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">      * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">      * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">      * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">      * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过注释可以知道：</p>\n<ul>\n<li><p>这个接口的作用是：找出一个线程什么时候阻塞并等待更多（新的）消息。</p>\n</li>\n<li><p><code>queueIdle()</code> 的作用是：当一个消息队列处理完全部消息，并且将进入等待的状态时调用。返回 <code>true</code> 则激活 Idle Handler，返回 <code>false</code> 则在执行完后将其移除。如果一个消息队列中还存在消息，但在当前时间之后的所有消息，均已经被计划好了分发的时间（也即这些消息都属于 Delay 型的消息，因此在执行到这些消息之前，线程也处在没有消息需要处理的状态），则该方法仍然可能被调用。</p>\n</li>\n</ul>\n<p>具体的意义如下：</p>\n<p>Handler 本身除了可以用来发送消息之外，另一个很重要的功能就是去处理接收到的消息，也就是 <code>handleMessage</code> 方法，普通的 Handler 只会处理人为指定的消息，这些消息对应的事务优先级比较高，因此当消息队列中存在 Message 时，线程会优先处理。但是不论是 Dalvik 还是 JVM，都有一些自己的管理事务，这些事务的优先级不是特别高，或者是不可预期的，但依然需要占用线程才能处理（毕竟线程是 CPU 调度的基本单位），比如 GC，内存碎片整理等，这些事务在非紧急情况下，只会在线程中没有消息时处理，此时处理这些事务的就是 Idle Handler。Idle Handler 并不是一个独立的类型，只需要实现 <code>IdleHandler</code> 接口即可。</p>\n<h2 id=\"3-1-添加IdleHandler\"><a href=\"#3-1-添加IdleHandler\" class=\"headerlink\" title=\"3.1 添加IdleHandler\"></a>3.1 添加IdleHandler</h2><p>既然 <code>IdleHandler</code> 只是一个接口，那如何让 MessageQueue 在空闲时可以唤起呢？以下方法即可添加一个 IdleHandler 到 IdleHandler 的 ArrayList 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Add a new &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; to this message queue.  This may be</span></span><br><span class=\"line\"><span class=\"comment\">  * removed automatically for you by returning false from</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> IdleHandler#queueIdle IdleHandler.queueIdle()&#125; when it is</span></span><br><span class=\"line\"><span class=\"comment\">  * invoked, or explicitly removing it with &#123;<span class=\"doctag\">@link</span> #removeIdleHandler&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be added.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.add(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释的大致意思是：将一个 IdleHandler 添加到 MessageQueue 中，如果 <code>IdleHandler.queueIdle()</code> 返回 <code>false</code>，或者直接调用 <code>removeIdleHandler()</code> 方法，则会移除这个 IdleHandler。</p>\n<h2 id=\"3-2-移除IdleHandler\"><a href=\"#3-2-移除IdleHandler\" class=\"headerlink\" title=\"3.2 移除IdleHandler\"></a>3.2 移除IdleHandler</h2><p>移除 IdleHandler 的方法也很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Remove an &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; from the queue that was previously added</span></span><br><span class=\"line\"><span class=\"comment\">  * with &#123;<span class=\"doctag\">@link</span> #addIdleHandler&#125;.  If the given object is not currently</span></span><br><span class=\"line\"><span class=\"comment\">  * in the idle list, nothing is done.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be removed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.remove(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-调用IdleHandler\"><a href=\"#3-3-调用IdleHandler\" class=\"headerlink\" title=\"3.3 调用IdleHandler\"></a>3.3 调用IdleHandler</h2><p>添加和移除 Idle Handler 都已经清楚了，Idle Handler 具体使用的地方，在 MessageQueue 实际处理消息的方法 <code>next()</code> 里，在默认情况下，每一次调用 <code>next</code> 就会返回一个 Message，这个 Message 就是下一个需要分发的消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mPtr 是通过调用 nativeInit() 获取的返回值</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以认为这个是 Native 层 MessageQueue 初始化后的指针地址</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 重点是 msg.target == null，如果满足说明这个 msg 是一个障栅消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么就要阻塞这条消息之后的所有同步消息，而放行异步消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 循环结束后有两种情况：</span></span><br><span class=\"line\">                <span class=\"comment\">// ① 整个消息队列中都没有异步消息，则终止条件为：msg == null</span></span><br><span class=\"line\">                <span class=\"comment\">// ② 找到了异步消息，则终止条件为：msg.isAsynchronous() == true</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// msg != null 有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// ① 消息队列没阻塞，msg 是一条同步消息</span></span><br><span class=\"line\">                <span class=\"comment\">// ② 消息队列被障栅消息阻塞了，但是找到了异步消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明还没到需要分发消息的时候，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 则计算到需要分发消息中间的间隔，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 在间隔时间后再唤醒消息队里进行分发</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明到了需要分发消息的时候</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 开始分发消息了，不是阻塞状态</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于将这条消息分发出去了，相当于要从链表里去掉这个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// 需要判断当前消息是不是第一个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// prevMsg 表示该 msg 的前一个消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于该消息即将被分发出去，因此该消息的下一条就没用了</span></span><br><span class=\"line\">                    <span class=\"comment\">// 置为空，去掉无用引用，防止内存溢出</span></span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 把该 msg 标识为“使用中”</span></span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回这条 msg 作为需要处理的消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 说明 msg == null，此时有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// ① 已经没有消息需要分发</span></span><br><span class=\"line\">                <span class=\"comment\">// ② 当前队列被障栅消息阻塞了，却又没有异步消息（不论是否有同步消息）</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前消息队列是正在退出的状态</span></span><br><span class=\"line\">                <span class=\"comment\">// 则调用 dispose() 销毁 Native 层的消息队列</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\">            <span class=\"comment\">// 以下为 IdleHandler 部分</span></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本的解读都在代码注释中了，还是比较通俗易懂的。重点注意专门加的这句注释：<code>// 以下为 IdleHandler 部分</code>，可以看看这句注释以上的部分，首先是判断了下一条消息，然后判断了当前消息队列是否正在退出，这个 <code>next()</code> 方法基本上要么返回了下一条需要分发的 Message，要么返回了 <code>null</code>，只有以下几种情况时才能执行到这句注释的地方：</p>\n<ul>\n<li>（1）当前消息队列没有任何消息了，且不在退出状态。</li>\n<li>（2）当前消息队列没有被障栅消息阻塞，且没有同步消息，也没有异步消息，且不在退出状态。</li>\n<li>（3）当前消息队列没有被障栅消息阻塞，没有同步消息，虽然有异步消息，但还没有到需要分发的时间，且不在退出状态。</li>\n<li>（4）当前消息队列被障栅消息阻塞了，但没有异步消息（不论是否有同步消息），且不在退出状态。</li>\n<li>（5）当前消息队列被障栅消息阻塞了，虽然有异步消息（不论是否有同步消息），但还没有到需要分发的时间，且不在退出状态。</li>\n</ul>\n<p>以上几种情况中，（2）和（3）其实可以归到一起，（3）和（4）也可以归到一起，再进一步合并逻辑，其实就代表了这么一种状态：消息队列当前没有任务，而且也不在退出状态。只有这个状态下，才会调用 <code>IdleHandler.queueIdle</code>，具体的任务则由 <code>IdleHandler</code> 接口的具体实现决定了。消息队列中对 IdleHandler 的处理比较简单，注释也已经讲得比较详细，就不另行分析了。</p>\n<hr>\n<h1 id=\"4-MessageQueue总结\"><a href=\"#4-MessageQueue总结\" class=\"headerlink\" title=\"4. MessageQueue总结\"></a>4. MessageQueue总结</h1><p>通过以上的源码分析，MessageQueue 的工作流程也就清楚了：</p>\n<font color=#EB6D39>\n\n<ul>\n<li>① 初始化 MessageQueue，同时初始化 Native 层的 MessageQueue。</li>\n<li>② 通过 Handler 添加或移除 Message。</li>\n<li>③ 线程执行的过程中，不断调用 <code>next()</code> 方法来获取需要分发处理的消息。</li>\n<li>④ 如果线程中有需要分发处理的消息，则正常分发。</li>\n<li>⑤ 如果线程中已经没有或暂时没有需要分发处理的普通消息，则去处理 Idle 事务。</li>\n<li>⑥ 如果既没有普通消息需要分发处理，也没有 Idle 事务，则阻塞消息队列，使其进入等待新消息的状态。</li>\n<li>⑦ 如果需要退出消息队列，则调用 <code>dispose()</code> 方法同步销毁 Native 层的 MessageQueue。</li>\n</ul>\n</font>","categories":["Android"],"tags":["Android","源码","MessageQueue","消息队列"]},{"title":"JVM内存模型和内存分区","url":"/post/java/java-jvm/","content":"<span id=\"more\"></span>\n\n<p>前言：Java 和 Android 面试中，堆、栈、JVM 内存模型等几乎是必问题，但其实平时口头上，对堆、栈、堆栈、堆区、栈区、内存模型等等的概念是混淆的，因此专门用一篇文章来记录总结。</p>\n<hr>\n<h1 id=\"1-堆、栈和队列\"><a href=\"#1-堆、栈和队列\" class=\"headerlink\" title=\"1. 堆、栈和队列\"></a>1. 堆、栈和队列</h1><p>首先需要明确的是，堆、栈、队列是数据结构，堆是一种优先队列，可以采用二叉树实现；栈是一种线性表，其特点是：后进先出（Last In First Out，LIFO）；队列也是一种线性表，其特点是：先进先出（First In First Out，FIFO）。</p>\n<h2 id=\"1-1-堆（Heap）\"><a href=\"#1-1-堆（Heap）\" class=\"headerlink\" title=\"1.1 堆（Heap）\"></a>1.1 堆（Heap）</h2><p>堆（Heap）总是一颗完全二叉树，且某个节点的值总是不大于或不小于父节点的值。若某节点总是不大于父节点的值（即父节点大于等于子节点），称为最大堆或大根堆（Max Heap）；反之称为最小堆或小根堆（Min Heap）。常见的堆有：二叉堆、斐波那契堆等。</p>\n<blockquote>\n<p>@注：完全二叉树可以这么理解：如果有一棵二叉树，只有最末端的节点可以有 0、1、2 个子节点，倒数第二层的节点要么没有子节点，要么必须有 2 个子节点，并且末端的节点都集中在左侧若干位置上，则该树称为完全二叉树。完全二叉树如下图所示：</p>\n</blockquote>\n<center>\n\n<p><img data-src=\"./complete_binary_tree.jpg\" alt=\"完全二叉树图示\" title=\"@ASSET\"></p>\n</center>\n\n<p>完全二叉树的详细解释可参考：<a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\" title=\"@LINK\">《百度百科——完全二叉树》</a> 或 <a href=\"https://blog.csdn.net/qq_22642239/article/details/80774013\" title=\"@LINK\">《完美二叉树, 完全二叉树和完满二叉树》</a>。</p>\n<h2 id=\"1-2-栈（Stack）\"><a href=\"#1-2-栈（Stack）\" class=\"headerlink\" title=\"1.2 栈（Stack）\"></a>1.2 栈（Stack）</h2><p>栈（Stack）是一种运算受限的线性表，其限制在于：仅允许从表的一端进行插入和删除操作。插入到栈中（入栈）的操作叫压栈（Push），从栈中删除（出栈）的操作叫弹出（Pop）。后入栈的数据先出栈（LIFO），类似于枪械弹匣，最后一颗压进弹匣的子弹在最上面，是第一发被打出去的。</p>\n<h2 id=\"1-3-队列（Queue）\"><a href=\"#1-3-队列（Queue）\" class=\"headerlink\" title=\"1.3 队列（Queue）\"></a>1.3 队列（Queue）</h2><p>队列（Queue）和栈类似，都是线性表，不同的是数据存取的顺序。队列中插入数据和取出数据分别在表的两端，且先插入的数据最先被取出。</p>\n<hr>\n<h1 id=\"2-JVM内存模型\"><a href=\"#2-JVM内存模型\" class=\"headerlink\" title=\"2. JVM内存模型\"></a>2. JVM内存模型</h1><p>首先需要强调一点：<font color=#EB6D39>JVM 的内存模型和 JVM 的内存分区（内存结构）<font color=red>不是一回事</font>！</font></p>\n<p>JVM 内存模型描述了 Java 程序各类型变量的访问规则，以及在 JVM 中将变量从内存中存储或读取的底层标准。</p>\n<p>JVM 内存模型有两个重要准则：</p>\n<ul>\n<li><p>所有的变量都存储在主内存中。</p>\n</li>\n<li><p>每个线程都有自己的工作内存，里面保存了该线程使用到的变量在主内存中的一个副本。</p>\n</li>\n</ul>\n<p>并且 JVM 的内存模型还规定：</p>\n<ul>\n<li><p>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</p>\n</li>\n<li><p>不同线程之间无法访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p>\n</li>\n</ul>\n<p>为了在多个线程访问同一个共享变量时，能保证共享变量具有实时性，JVM 内存模型还遵循：缓存一致性协议。该协议规定，如果一个线程将共享变量回写进主内存，该动作会导致其他线程中的该共享变量的 Cache 失效，但线程在修改完一个共享变量时，并不一定会马上将其回写进主内存，而 <code>volatile</code> 修饰符即是用来声明，一个变量在被修改（写入）后，立即回写进主内存，并更新到其他线程中。</p>\n<p>可参考：<a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"TOLINSK\">什么是Java内存模型</a></p>\n<hr>\n<h1 id=\"3-JVM中的5个区\"><a href=\"#3-JVM中的5个区\" class=\"headerlink\" title=\"3. JVM中的5个区\"></a>3. JVM中的5个区</h1><p>在 JDK 1.8（不含）之前，JVM 的内存分为 5 个区：堆区、栈区、方法区、本地方法区、程序计数器。</p>\n<p>堆区（Heap）和栈区（Stack）是内存模型，虽然英文一样，而且也常常被简称为堆和栈，但实际上他们和数据结构中的堆、栈是完全不一样的概念，底层也并不是直接使用数据结构中的堆和栈的存储方式来实现，只是比较类似。</p>\n<p>堆区是存储的单位，而栈区是运行时的单位。通俗地说：堆区解决程序数据存储的问题，负责管理数据怎么放、放在哪；而栈区解决程序运行的问题，负责管理程序怎么运行、怎么处理堆中的数据。</p>\n<h2 id=\"3-1-堆区（Heap-Area）\"><a href=\"#3-1-堆区（Heap-Area）\" class=\"headerlink\" title=\"3.1 堆区（Heap Area）\"></a>3.1 堆区（Heap Area）</h2><p>堆区通常和进程相关，进程建立初始化时会分配默认堆区，运行过程中也可以申请额外的堆区空间，但在需要手动释放，否则会导致内存泄漏，未释放的内存在进程结束时由 OS 回收。堆区分为全局堆和局部堆，全局堆就是所有未分配的堆区空间，局部堆则是用户分配的堆区空间。多个线程可以访问同一个堆区，当然也可以申请额外的堆区空间。</p>\n<p>在 Android 中，堆是 Dalvik 的内存数据区，用于存储：对象实例数据、方法内部的复杂类型变量、动态属性。</p>\n<ul>\n<li>（1）对象实例数据：包括对象实例的属性、属性类型、对象本身的类型标记等，但是并不会保存对象实例的方法（类方法），实例方法属于数据指令，保存在方法区中。</li>\n<li>（2）方法内部的复杂类型变量：例如方法内使用了自定义类的实例对象等。</li>\n<li>（3）动态属性：没有使用 <code>static</code> 修饰的类成员属性，因为这些属性可能是自定义类的实例对象，这些对象的内存大小是不可预估、动态变化的。需要注意的是，类成员的基本数据类型，也是存放在堆中。</li>\n</ul>\n<font color=#EB6D39>\n\n<p>堆区的内存是不连续且无序的，分配和释放内存的成本都比较高。例如在分配堆内存时，可能需要在堆区搜索多个空间，如果内存碎片（多次分配和释放后，会造成占用内存和可用内存互相掺杂）太多，则会消耗较长时间来搜索可用内存区，甚至需要向 OS 申请分配新的堆区空间，因此堆区的效率较低，但是内存分配更加自由，内存的分配和释放可以手动控制。</p>\n<blockquote>\n<p>@注：实际上，如果 JVM 开启了 <strong>逃逸分析（Escape Analysis）</strong>，会在满足一定条件时，将本应存在堆区中的变量存在栈区，便于内存的释放。例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本来，<code>demoClass.demoData</code> 虽然是基本数据类型 int，但由于它是一个类成员动态属性，因此随所属对象 <code>demoClass</code> 被分配在堆区。如果 JVM 开启了逃逸分析，则优化后会将该段代码转换为如下的形式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> demoData = <span class=\"number\">5</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就将 <code>demoData</code> 存在了栈区，提高了内存分配和回收的效率。但是逃逸分析优化有一定的前提：原本存在堆区的对象，仅在方法体内部有效。如果该对象与方法体外部有交互（即逃逸），则不会优化。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> demoClass.demoData;  <span class=\"comment\">// 逃逸到外部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</font>\n\n<p>另外，堆区本身又有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n<h2 id=\"3-2-栈区（Stack-Area）\"><a href=\"#3-2-栈区（Stack-Area）\" class=\"headerlink\" title=\"3.2 栈区（Stack Area）\"></a>3.2 栈区（Stack Area）</h2><p>栈区和线程相关，每个线程有自己独立的栈区且不共享，因此栈区是线程安全的。OS 在切换线程时会自动切换栈区（即切换 SS / ESP 寄存器）。栈区内存不需要手动分配和释放。</p>\n<p>在 Android 中，栈是 Dalvik 的内存指令区，用于存储：基本数据类型、方法内部的简单类型变量、对象地址。</p>\n<ul>\n<li>（1）基本数据类型：包括 byte，short，int，long，float，double，char，boolean，需要注意的是，直接在类成员变量中声明的基本数据类型属性，依然随对象实例一起存放在堆中。</li>\n<li>（2）方法内部的简单类型变量：例如基本数据类型。</li>\n<li>（3）对象地址：通常大多数对象都会存在堆区中，而把对象的引用（即对应在堆中的地址）存在栈区，当调用一个对象时，就可以快速地从栈区找到该对象的引用，并通过引用找到堆区中的实例。</li>\n</ul>\n<p>栈区存放的是多个栈帧，每个栈帧对应了可以被线程调用的一个方法，栈帧中包括：局部变量表（Local Variables）、操作数栈（Operand Stack）、指向当前方法所属类的运行时常量池的引用（Reference to Runtime Constant Pool，当方法内有 String 类型变量时，用于查询常量池中是否已经存在常量）、方法返回地址（Return Address）、以及一些额外的附加信息。当线程执行一个方法时，就会创建对应的栈帧，并将其压栈。方法执行完毕后即弹出。因此，线程当前执行的方法一定在栈区的顶部，而递归方法时，也相对更容易出现栈区内存溢出的情况。</p>\n<font color=#EB6D39>\n\n<p>由于栈区中存储的都是内存占用较小，且固定长度的变量，例如基本数据类型、对象的引用（仅仅只是一个地址，通常为 4 位，指向堆区或常量池中实际存放的对象），因此栈区的内存是连续、且在创建栈帧时就提前分配好的，所以栈区的内存不需要也无法手动管理，当调用所需变量时，仅需将指针按预定义的长度移动即可，因此分配和释放内存的效率都比堆区快得多。</p>\n<blockquote>\n<p>@注：Java 中，对于 byte、short、char 这些基本数据类型，本来比 int 占用的内存更少，对一些标志位、临时变量等，使用这些代替 int 似乎应该效率更高，实际上 JVM 中，在处理这些数据的加法操作时，会先隐式转换成 int 类型再操作。例如以下代码会编译报错：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> c = a + b;  <span class=\"comment\">// 编译报错：Type mismatch: cannot convert from int to byte</span></span><br></pre></td></tr></table></figure>\n\n<p>这么做的意义其实是在于，Java 中 int 和 float 是 4 字节 32 位，long 和 double 是 8 字节 64 位，这些类型都能以 4 字节为单位，位移 1 倍或 2 倍得到，而 byte、short、char 分别只有 1、2、2 字节，如果先统一转为 4 字节 int 类型，寻址的时候就能极大提高效率。当然选择 int 作为标准的原因主要也是因为 int 的长度在中间，如果选择 8 字节的 long 或 double，则会大量浪费内存空间，选择 2 字节的 char 或 short，则很多变量都需要不止一个内存块来存储，降低效率。</p>\n</font>\n\n<h2 id=\"3-3-方法区（Method-Area）\"><a href=\"#3-3-方法区（Method-Area）\" class=\"headerlink\" title=\"3.3 方法区（Method Area）\"></a>3.3 方法区（Method Area）</h2><p>方法区和堆一样，是线程间共享的。方法区用于存放：类的信息、静态成员变量、运行时常量池等。</p>\n<ul>\n<li>（1）类的信息：包括类名、方法信息、字段信息等，调用 <code>Class.getName()</code> 和 <code>Class.isInterface</code> 等方法时返回的数据都是来自方法区。</li>\n<li>（2）静态成员变量：Java 局部变量没有静态的概念，只有成员变量、成员方法可以设置为静态。</li>\n<li>（3）运行时常量池：类和接口被记载到 JVM 时，就会创建对应的运行时常量池。</li>\n</ul>\n<font color=#EB6D39>\n\n<p>不论是否静态，方法都存放在方法区，非静态的方法，Dalvik 会将其对象实例在 Stack 中的引用地址（指向了 Heap 中存储的实例），作为隐含的参数传入，这样在非静态方法在需要调用其实例对象的其他数据时，可以确保总能找到在 Heap 中存放的实例数据。因此，调用一个非静态方法，必须首先 new 一个实例对象，也即创建一个实例对象在 Stack 中的引用地址，然后再调用。而静态方法不需要传入隐含参数，因为方法区是线程间公开共享的，而且存放的都是相对唯一、不变的数据，因此静态方法可以直接通过 <code>Class.method()</code> 的形式调用。当然，由于没有传入隐含的 Stack 引用地址，也就无法找到 Heap 中存放的实例数据，静态方法内部是无法获取到实例对象的其他非静态数据的，这也是为什么静态方法中不能调用非静态方法、非静态成员变量，而非静态方法可以直接调用静态方法、静态成员变量的原因。</p>\n<p>静态成员变量只在 JVM 第一次载入类时加载，也因此内存中只会保留一份数据，因此也是存放在方法区中的，这也是为什么作用域比较小、使用频率比较低的一些标志位等等不建议设置成 <code>public static</code> 的形式，因为这会导致很多临时才使用的变量被加载进了方法区而不释放（JDK 1.7 之后在满足一定条件下，方法区也会 GC，但是相比栈区和堆区，方法区 GC 的频率很低，因此仍然不建议大量使用静态成员变量）。</p>\n<p>运行时常量池并不一定质保函 Class 文件常量池中的内容，也即并非只有代码中显示定义了 <code>final</code> 的成员变量才会进入常量池。例如 <code>String.intern()</code> 方法，其作用就是：如果一个字符串存在常量池中，则直接返回常量池中的引用，否则将该字符串存入常量池，再返回其引用。</p>\n<p>常量池的意义非常重要，之所以 String 内部都要做成常量，主要是因为字符串的重复率特别高，因此如果字符串不可变，常量池才便于管理。而且由于 String 的不可变性，HashMap、HashTable 等使用 String 作为 Key 时，JVM 可以在缓存 String 对象时缓存其 HashCode，极大提高执行效率。</p>\n</font>\n\n<h2 id=\"3-4-本地方法栈（Native-Method-Stack）\"><a href=\"#3-4-本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"3.4 本地方法栈（Native Method Stack）\"></a>3.4 本地方法栈（Native Method Stack）</h2><p>本地方法区和方法栈（也即栈区）比较类似，区别在于栈区是针对普通方法的，而本地方法栈是针对 Native 方法的。JVM 规范中没有强行规定本地方法栈的实现方式和数据结构，虚拟机可以自由实现，HotSpot 虚拟机就直接把栈区和本地方法栈合二为一。</p>\n<h2 id=\"3-5-程序计数器（Program-Counter-Register）\"><a href=\"#3-5-程序计数器（Program-Counter-Register）\" class=\"headerlink\" title=\"3.5 程序计数器（Program Counter Register）\"></a>3.5 程序计数器（Program Counter Register）</h2><p>JVM 中的程序计数器和汇编中的程序计数器（CPU 中的寄存器）概念类似，都是用于指示下一条需要执行的指令，只不过 JVM 中的程序计数器并不是指向物理意义上的真实 CPU 内存地址。JVM 中的程序计数器是线程独有的，指向的是当前线程正在执行的字节码代码的行号，如果当前线程执行的是 Native 方法，则值为 <code>null</code>。</p>\n<hr>\n<h1 id=\"4-JVM中的4个Segment\"><a href=\"#4-JVM中的4个Segment\" class=\"headerlink\" title=\"4. JVM中的4个Segment\"></a>4. JVM中的4个Segment</h1><p>如果在网上查阅 JVM 分区的内容，会出现两种回答：</p>\n<ul>\n<li>（1）JVM 内存模型分为 4 个区：Heap、Stack、Data Segment、Code Segment</li>\n<li>（2）JVM 内存模型分为 5 个区：Heap、Stack、Method、Native Method、Program Counter Register</li>\n</ul>\n<p>其实这两种分法都对，只不过是针对不同的场景分的，个人认为分为 5 个区的更加全面一些。两种分类中，Heap 和 Stack 都是一一对应的，关键是其他部分，方法区是一个特例。在 HotSpot 虚拟机中，由于早期（JDK 1.8（不含）之前）是直接将方法区设置为永久代（Permanent Generation），也即方法区内的所有数据都不会被 GC，因此方法区也被习惯称为永久代。而方法区同时对应了 Data Segment 和 Code Segment，方法区中存储字节码的位置称为 代码段（Code Segment），存储静态常量和字符串常量的位置称为数据段（Data Segment）。</p>\n<hr>\n<h1 id=\"5-JDK8内存分区的变化\"><a href=\"#5-JDK8内存分区的变化\" class=\"headerlink\" title=\"5. JDK8内存分区的变化\"></a>5. JDK8内存分区的变化</h1><p>在 JDK 1.8 中，对之前 5 个内存区的划分做了一些改变。</p>\n<p>首先是使用 <font color=#EB6D39>元数据区 </font> 取代了方法区，但实际上元数据区的作用和原来方法区的作用是几乎一样的，只不过不再是永久代（针对 HotSpot 虚拟机，其他虚拟机例如 Oracle 的 JRockit 和 IDM 的 J9 本来就没有永久代）。</p>\n<p>其次，元数据区不再存放在虚拟机内存中了，而是直接使用本地内存（由 OS 管理的内存）。</p>\n<p>另外，原来的字符串常量池存放在方法区中，新版 JDK 放到了堆区。</p>\n<hr>\n<h1 id=\"6-附录-参考指导\"><a href=\"#6-附录-参考指导\" class=\"headerlink\" title=\"6. 附录[参考指导]\"></a>6. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"TOLINSK\">【1】什么是Java内存模型（作者：占小狼）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Java"],"tags":["Java","数据结构","内存模型","JVM内存区"]},{"title":"HashingEncoder-多进程支持","url":"/post/python/python-hashingencoder-optimization/","content":"<span id=\"more\"></span>\n\n<p>前言：HashingEncoder 对大数据量编码时速度很慢且 CPU 利用率并不高，瞎研究半天写了一个多 <strong>进程</strong> 版的 HashingEncoder，记录一下踩坑历史。本文代码均为伪代码，改进和源码已收录于 Github 上 scikit-learn 工具包，详情参考 <a href=\"https://github.com/scikit-learn-contrib/categorical-encoding\" title=\"@LINK\">scikit-learn-contrib</a>，建议先阅读：<a href=\"https://github.com/liushulun/MPHashingEncoder\" title=\"@LINK\">使用文档</a>。</p>\n<hr>\n<h1 id=\"1-源码\"><a href=\"#1-源码\" class=\"headerlink\" title=\"1. 源码\"></a>1. 源码</h1><p>有一次在做哈希编码的时候，因为数据量比较大，试了好几种方案，最快都要十二个小时才仅能编码完一个特征，还有 8 个嗷嗷待哺的小特征在后面排队等着我 <em><del>鞭挞</del></em> 编码，电脑已经能烤猪蹄了，这可如何是好。<br>正愁着莫非要升级一波配置，转头监视器一看，CPU 利用率才 16% 上下，这我可就。。。服务器搞起！阿里云太贵，亚马逊麻烦，TinyMind <em><del>辣鸡</del></em> 真辣鸡！华为云好像还不错（我的配置才 3+ 元每小时，不要求最低账内金额），8x3.1GHz + 32G 走你！但是第二个特征依然耗费了 10 个小时才编码完。</p>\n<p>受困于编码时间过长。迫于无奈找了找 sklearn 中 HashingEncoder 的 api，没有类似于 n_thread 之类的参数，又看了看源码，从 Pycharm 中一级级往上点，找到了 HashingEncoder 的核心源码部分如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hashing_trick</span>(<span class=\"params\">X_in, hashing_method=<span class=\"string\">&#x27;md5&#x27;</span>, N=<span class=\"number\">2</span>, cols=<span class=\"literal\">None</span>, make_copy=<span class=\"literal\">False</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A basic hashing implementation with configurable dimensionality/precision</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Performs the hashing trick on a pandas dataframe, `X`, using the hashing method from hashlib</span></span><br><span class=\"line\"><span class=\"string\">    identified by `hashing_method`.  The number of output dimensions (`N`), and columns to hash (`cols`) are</span></span><br><span class=\"line\"><span class=\"string\">    also configurable.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Parameters</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    X_in: pandas dataframe</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    hashing_method: string, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    N: int, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    cols: list, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    make_copy: bool, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Returns</span></span><br><span class=\"line\"><span class=\"string\">    -------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    out : dataframe</span></span><br><span class=\"line\"><span class=\"string\">        A hashing encoded dataframe.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    References</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\">    Cite the relevant literature, e.g. [1]_.  You may also cite these</span></span><br><span class=\"line\"><span class=\"string\">    references in the notes section above.</span></span><br><span class=\"line\"><span class=\"string\">    .. [1] Kilian Weinberger; Anirban Dasgupta; John Langford; Alex Smola; Josh Attenberg (2009). Feature Hashing</span></span><br><span class=\"line\"><span class=\"string\">    for Large Scale Multitask Learning. Proc. ICML.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hashing_method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> hashlib.algorithms_available:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Available. Please use one from: [%s]&#x27;</span> % (</span><br><span class=\"line\">                hashing_method,</span><br><span class=\"line\">                <span class=\"string\">&#x27;, &#x27;</span>.join([<span class=\"built_in\">str</span>(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> hashlib.algorithms_available])</span><br><span class=\"line\">            ))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            _ = hashlib.new(hashing_method)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Found.&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> make_copy:</span><br><span class=\"line\">        X = X_in.copy(deep=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        X = X_in</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cols <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        cols = X.columns.values</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hash_fn</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">        tmp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> x.values:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> val <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                hasher = hashlib.new(hashing_method)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sys.version_info[<span class=\"number\">0</span>] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">str</span>(val))</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">bytes</span>(<span class=\"built_in\">str</span>(val), <span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">                tmp[<span class=\"built_in\">int</span>(hasher.hexdigest(), <span class=\"number\">16</span>) % N] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pd.Series(tmp, index=new_cols)</span><br><span class=\"line\"></span><br><span class=\"line\">    new_cols = [<span class=\"string\">&#x27;col_%d&#x27;</span> % d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X.loc[:, cols]</span><br><span class=\"line\">    X_num = X.loc[:, [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> X.columns.values <span class=\"keyword\">if</span> x <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> cols]]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X_cat.apply(hash_fn, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">    X_cat.columns = new_cols</span><br><span class=\"line\"></span><br><span class=\"line\">    X = pd.concat([X_cat, X_num], axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> X</span><br></pre></td></tr></table></figure>\n\n<p>好吧，还真是一个 for 循环往下读啊。这十个小时才跑一个特征，服务器的成本有点担不起啊！看来只好曲线救国了。虽然 Python 本身在执行的时候对 CPU 就有个动态调度，但因为 GIL全局锁 的原因，大多数情况下 Python 都是在单核模式运行的。我对 GIL 有一点点自己的理解，从我的角度出发，个人认为 GIL 还是利大于弊的，何况在 Python3 中已经对对线程/多进程提供了挺不错的额外支持，不过本文不深入探讨 GIL 的内容。</p>\n<hr>\n<h1 id=\"2-改进思路\"><a href=\"#2-改进思路\" class=\"headerlink\" title=\"2. 改进思路\"></a>2. 改进思路</h1><h2 id=\"2-1-理论支持\"><a href=\"#2-1-理论支持\" class=\"headerlink\" title=\"2.1 理论支持\"></a>2.1 理论支持</h2><p>关于什么是哈希编码的内容网上有很多了，在一开始做这个之前，我考虑过一个问题：按顺序依次编码，和多进程分别编码再按原序拼接，最后的结果是一样的吗？如果多进程编码会导致结果变化，那一切都是白费功夫。之所以对此担心，有一个原因是 <code>我曾经把哈希编码当成了“集合操作”，如果一开始输入的集合不一致就会导致最后的编码结果不一致</code>。当然，事后证明我的想法是错误的，为此我找了一些哈希编码的文章来看，幸运的是，只要规定好输入特征和输出维度，最后的结果和编码的顺序并没有关系。许多篇文章都对哈希编码做了很详尽的说明，我选出来五篇自己看完最有心得的放在附录【12】~【16】中。</p>\n<p>再经过他人文章的点拨后，我认为多进程实现是可能且符合要求的。把其核心思想总结一下大致可以这么理解：</p>\n<blockquote>\n<ol>\n<li>哈希表把输入散列到指定的输出范围内</li>\n<li>对于不在训练数据的散列表中的输入，依然可以通过同样的哈希算法计算出散列值</li>\n<li>只要指定了相同的散列范围，新的输入也会具有相同的输出特征维度</li>\n<li>新输入可以直接进行哈希编码，而不需要再对整体数据重新处理，因此支持在线学习</li>\n<li>只有原始值非零，哈希编码才有效，因此可以保持编码前后的稀疏性</li>\n</ol>\n</blockquote>\n<p>也就是说，每一次送去编码的进程，其数据都是独立的，并且完全可以分开编码而不需要考虑别的数据，只要给每个进程设置相同的编码算法和输出维度，最后再将每个独立的数据块按照原数据的顺序重新排列即可。</p>\n<h2 id=\"2-2-代码思想\"><a href=\"#2-2-代码思想\" class=\"headerlink\" title=\"2.2 代码思想\"></a>2.2 代码思想</h2><p>既然是多核性能没发挥出来，那就从并行的角度出发，大致的实现逻辑如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multithreading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashingEncoder</span>:</span></span><br><span class=\"line\">    self.multi_data = []</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 每个线程调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">        get_data() <span class=\"comment\"># 每个线程都从整体数据中获取一部分数据</span></span><br><span class=\"line\">        hashing_data = hashing() <span class=\"comment\"># 每个线程都单独进行哈希编码</span></span><br><span class=\"line\">        self.multi_data.append(hashing_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> multi_num</span><br><span class=\"line\">            multithreading.Thread.Thread(target=work).start</span><br><span class=\"line\"></span><br><span class=\"line\">        data = pandas.concat(multi_data, ignore_index=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>省略了大量代码，单从逻辑来看，我的需求就是：</p>\n<ol>\n<li>允许用户自定义并行线程数以及每个线程每次编码的样本数</li>\n<li>根据参数创建 n 个进程</li>\n<li>每个线程都依次从所有数据中不重复地顺序取出参数定义数量的数据</li>\n<li>每个线程都独立对自己取到的数据进行哈希编码</li>\n<li>每个线程哈希编码完后将返回数据存储进一个列表内</li>\n<li>将列表内的数据拼接成回一个整体。</li>\n</ol>\n<hr>\n<h1 id=\"3-过程中的坑\"><a href=\"#3-过程中的坑\" class=\"headerlink\" title=\"3. 过程中的坑\"></a>3. 过程中的坑</h1><p>以下每个小节都是一个记录的坑，为了文章更有逻辑，有些坑我合并成了一节来写。</p>\n<h2 id=\"3-1-多线程和多进程问题\"><a href=\"#3-1-多线程和多进程问题\" class=\"headerlink\" title=\"3.1 多线程和多进程问题\"></a>3.1 多线程和多进程问题</h2><p>最早第一次改进时，我仅仅只是用多线程式：multithreading 模块，在一个小型计算 Demo 上尝试过，表面上来看似乎确实是并行处理，所以我想当然地认为多线程可以解决多核 CPU 利用率的问题，因此我写出了第一个版本的改进代码后，欣喜若狂，然而上数据一测编码时间几乎没有什么缩减，后来再看监视器，发现 CPU 利用率依然还处在单核上，这个结果一度让我差点放弃，好在研究了一下 multiprocessing 的内容，由此进而了解到了 multiprocessing 模块，这两者非常类似，调用方式也几乎一样，最大的区别就是：①multithreading 本质是 threading 线程、②multiprocessing 本质是 processing 进程。<br>进程和线程的关系想必大家都知道，一个进程可以包括多个线程，而<a href=\"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin\" title=\"@LINK\">进程</a>是 CPU 资源分配和调度的基本单位，因此从通俗的话来讲，是进程向 CPU 申请资源，然后再提供给线程使用，对于常见的 CPU 而言，通常一个物理核心就对应了一个（支持超线程的 CPU 则对应多个，但 CPU 的线程和应用的线程不是一回事） <strong>可并行处理的</strong> 进程，因此想要发挥出 <strong>多核</strong> 的优势，就要调用 __多进程__。还好，正如上文所说，multiprocessing 和 multithreading 的 API 还是基本类似的，因此下文的坑将直接按照多进程的实现模式举例。</p>\n<h2 id=\"3-2-并行顺序读取数据问题\"><a href=\"#3-2-并行顺序读取数据问题\" class=\"headerlink\" title=\"3.2 并行顺序读取数据问题\"></a>3.2 并行顺序读取数据问题</h2><p>首先，Python 中多进程有两种常用方式，第一个是生成多个进程并分别执行，第二个是利用进程池的方式，在很多时候进程池其实是更好的方案，因为进程池可以不必手动管理每个进程的周期，也不用手动安排进程的工作流程，只需要指定最大进程数即可，而且还支持异步获取每个进程执行完后的返回值，<font color=#EB6D39>但是！</font>进程池方式比手动方式稍慢一些，由于追求速度，因此最终采取手动管理方式。<br>现在假设我们开启 4 个进程同时执行一个任务，代码应该大致如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">    get_data() <span class=\"comment\"># 每个线程都从整体数据中获取第 index 部分的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">process_list = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br></pre></td></tr></table></figure>\n\n<p>由于多进程是并行的，因此尽管循环是依次添加并开启进程，实际上仍然会发生后创建的进程先取数据的情况。有两个思路可以避免这个情况：（1）在创建进程前就先计算好该进程需要选择的数据范围、（2）在进程执行任务时自行选择需要选择的数据范围。<br>方式（1）其实也就是提前限定，因此不需要判断进程获取数据的先后顺序。但由于使用的多进程方案为手动管理方式，而限定数据范围对“需求 1：用户调用时自定义参数”并不友好。例如：当 100 条样本设置了 3 个进程，且每个进程单次编码 13 条数据时，编码的过程则应该是：0 ~ 13; 13 ~ 26; …; 91 ~ 100 共 8 轮。但因为采用了手动管理方式，意味着在开启新进程时，要么①使用多个循环：每个循环开启三个进程，直到所有样本均被遍历，且还需要在循环内判断当前样本是否已经全部遍历完（在本例中，第三个循环只需要循环两次即遍历完所有样本）而跳过，要么②创建进程时给每个进程传递参数，用来告知每个进程分别需要取几次值，每次又分别取什么范围的数据…不论哪种方式，我想都非常不优雅，所以最终我选择了使用方式（2）实现。</p>\n<p>而为了确保每个进程能自己判断所需的数据范围，就需要一个变量用于存放已被读取的范围，则每个进程只需要从还未被读取的数据内选择指定量的数据即可。为此，还需要一个进程锁来确保每个进程在计算数据范围的时候不会因为进程的先后顺序导致重复选择、漏选等情况。这里有一个要注意的点：加锁操作应当只锁住获取起始下标和计算读取范围的部分，其他不会引起冲突的耗时操作例如取出数据和进行编码，则应当在锁释放后执行，否则会导致锁住非冲突耗时操作引起效率降低甚至变成单线程模式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, done_index</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():</span><br><span class=\"line\">        start = done_index</span><br><span class=\"line\">        end = done_index + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        done_index = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">done_index = <span class=\"number\">0</span>  <span class=\"comment\"># 初始化下标为从 0 开始</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=(done_index)))</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>省略了一些判断、具体实现，下同。事实上这里的 <code>done_index</code> 一点作用都没有，每一个进程执行到 <code>start = done_index</code> 时获取到的值都是 0。因为进程被创建时，直接传进去的值属于每个子进程自己的独立空间，如果加上一条 <code>print(id(done_index))</code> 就会发现所有子进程的 done_index 都不一样，同理，无论是用成员变量的方式 <code>self.done_index</code> 也好，还是全局变量的方式 <code>global done_index</code> 也好，结果都是一样的。为了在进程间共享一个数据，可以使用 <code>multiprocessing.Value()</code> 来实现，搭配进程锁起到共享数据且不冲突的作用。另外，当子进程编码完了当前分配的任务数据后，还有未处理的数据，那么就自己再调用一次分配任务，由于锁和共享数据的存在，也不用担心会出现重复读取的问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\">    self.done_index = multiprocessing.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    self.data_lines = <span class=\"built_in\">len</span>(data)  <span class=\"comment\"># 样本总数目</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():  <span class=\"comment\"># 加锁，已确保自己获取到的 done_index 是最新的</span></span><br><span class=\"line\">        start = self.done_index.value</span><br><span class=\"line\">        end = start + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        self.done_index.value = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release() <span class=\"comment\"># 释放锁，允许其他进程操作更新 done_index</span></span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end &lt; self.data_lines:  <span class=\"comment\"># 尚有未完成的数据，再次调用分配</span></span><br><span class=\"line\">            self.work()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-编码后数据的保存问题\"><a href=\"#3-3-编码后数据的保存问题\" class=\"headerlink\" title=\"3.3 编码后数据的保存问题\"></a>3.3 编码后数据的保存问题</h2><p>现在，并行也跑起来了，子进程也能正确获取到数据了，编码也顺利完成后，主进程怎么收集这个数据呢？毕竟手动管理模式并没有返回值，借鉴上面的方法，想使用一个共享变量来存放，但查了一下 Api，发现 Value() 只支持几种基本类型，但需要收集的数据类型复杂（图片来源：附录【1】）：</p>\n<center>\n\n<p><img data-src=\"./multiprocessing_value_type.png\" alt=\"multiprocessing_value_type\" title=\"@ASSET\"></p>\n</center>\n\n<p>实际上，multiprocessing 提供了一个非常好的内置方案：队列 Queue。Queue 允许进程按先进先出的顺序使用 <code>put()</code> 存、使用 <code>get()</code> 取对象，且允许设置读、写超时，一旦读、写超过超时时间，则中断锁并放弃操作。Queue 在读取完当前对象后会将其从队列中删除，既能保证数据读取的不重复，还能缩减内存：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    self.hashing_parts.put(data)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主线程等待所有子线程执行完毕</span></span><br><span class=\"line\">list_data = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.append(hashing_parts.get())</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-结果数据顺序问题\"><a href=\"#3-4-结果数据顺序问题\" class=\"headerlink\" title=\"3.4 结果数据顺序问题\"></a>3.4 结果数据顺序问题</h2><p>到这一步，已经可以顺利获取到所有编码完成后的返回值了，都存在 <code>list_data</code> 列表里面，只需要使用 <code>pandas.concat(list_data, ignore_index = 0)</code> 就能把所有数据拼起来成为完整的编码后数据，<font color=#EB6D39>但是！</font>并行编码进程完成的顺序并不能预先确定，很可能后开始的进程先编码完并存进 list_data 内，直接拼接会导致与源数据样本顺序不一致，导致的后果是在一开始提交 PR 时管理员告诉我的：</p>\n<blockquote>\n<p>With return_df=False, a different ordering of the samples could lead into nasty surprises, because numpy.ndarray doesn’t preserve index -&gt; the training data would not be aligned with the labels anymore.</p>\n</blockquote>\n<p>意思就是，如果 HashingEncoder 设置参数 <code>return_df=False</code>, 其返回值是一个 numpy 的 ndarray 类型数据，和 DataFrame 不同，ndarray 是不保留索引的，因此特征哈希后顺序与源数据不一致会导致和标签 y 的对应关系被打乱。</p>\n<p>确实一开始我没有想到这个问题，Queue 本身其实是顺序存储，但在这里，它保障的是编码完成的顺序，而不是编码的数据的顺序，如果对数据顺序有要求，使用字典是一个很好的办法，用 key 来存放当前数据的索引位置，用 value 存放每一组数据，最后主进程获取所有的字典数据，并按照键值顺序排序后再拼接：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    start = ...  <span class=\"comment\"># 当前数据块起始下标</span></span><br><span class=\"line\">    end = ...  <span class=\"comment\"># 当前数据块结束下标</span></span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    part_index = <span class=\"built_in\">int</span>(math.ceil(end_index / self.max_sample))</span><br><span class=\"line\">    self.return_data.put(&#123;part_index: data&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">list_data = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.update(hashing_parts.get())  <span class=\"comment\"># 取出所有的代码块（无序状态）</span></span><br><span class=\"line\">sort_data = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> part_index <span class=\"keyword\">in</span> <span class=\"built_in\">sorted</span>(list_data):  <span class=\"comment\"># 将所有字典型数据块按照 key 排序后把 value 取出</span></span><br><span class=\"line\">    sort_data.append(list_data[part_index])</span><br><span class=\"line\">data = pandas.concat(sort_data, ignore_index=<span class=\"literal\">True</span>)  <span class=\"comment\"># 拼接数据</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>part_index</code> 的算法是用当前已完成的下标除以每个进程单次处理的下标，并向上取整（为了让结果更直观地从 1 开始），来作为当前数据块的定位。</p>\n<h2 id=\"3-5-子进程调用问题\"><a href=\"#3-5-子进程调用问题\" class=\"headerlink\" title=\"3.5 子进程调用问题\"></a>3.5 子进程调用问题</h2><p>到了这一步，整体逻辑已经和最终版本差异不大了，从 Demo 测试的结果来看也没有什么问题，不过毕竟这是一个面向公众的平台，不能只是写个 Demo 编译通过就了事，还得通过一定的测试验证。sklearn-category_encoders 采用的是 CI 测试部署方案，在本地可以用 nose 进行单元测试。但是在单元测试中报了这么一个错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime Error: Lock objects should only be shared between processes through inheritance.</span><br></pre></td></tr></table></figure>\n\n<p>单从报错信息来看，是提醒我们：<code>进程锁只能通过继承的方式在进程间共享</code>，好吧，helpful hah?</p>\n<p>后来我在附录【2】文中找到了有用的答案：</p>\n<blockquote>\n<p>进程锁作为一个不可直接打包的资源是没有办法作为一个参数直接给Pool的map方法里的函数传参的</p>\n</blockquote>\n<p>虽然问题并不完全一样，而且就目前来说，直接在代码中引用是可以运行的，不过我认为这是一个启发点。根据作者提供的解决方案，由于没有采用 Pool 的多进程方式，因此选择了使用 Manager 来管理共享变量：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-深拷贝问题\"><a href=\"#3-6-深拷贝问题\" class=\"headerlink\" title=\"3.6 深拷贝问题\"></a>3.6 深拷贝问题</h2><p>OK！完成了上面这些步骤，可以说，最本质的代码层和逻辑层已经完成，CI 测试也已经通过，不过命运就是这么反复无常——category_encoders 的管理员告诉我，使用这套 HashingEncoder 运行一个大数据量的基准测试时，multiprocessing 的 Manager 报错了（省略部分信息）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">180</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = _reconstruct(x, memo, *rv)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">280</span>, <span class=\"keyword\">in</span> _reconstruct</span><br><span class=\"line\">        state = deepcopy(state, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">150</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = copier(x, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">240</span>, <span class=\"keyword\">in</span> _deepcopy_dict</span><br><span class=\"line\">        y[deepcopy(key, memo)] = deepcopy(value, memo)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">multiprocessing.managers.RemoteError:</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">Unserializable message: Traceback (most recent call last):</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/managers.py&quot;</span>, line <span class=\"number\">289</span>, <span class=\"keyword\">in</span> serve_client</span><br><span class=\"line\">        send(msg)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/connection.py&quot;</span>, line <span class=\"number\">206</span>, <span class=\"keyword\">in</span> send</span><br><span class=\"line\">        self._send_bytes(_ForkingPickler.dumps(obj))</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/reduction.py&quot;</span>, line <span class=\"number\">51</span>, <span class=\"keyword\">in</span> dumps</span><br><span class=\"line\">        cls(buf, protocol).dump(obj)</span><br><span class=\"line\">TypeError: can<span class=\"string\">&#x27;t pickle _thread.lock objects</span></span><br></pre></td></tr></table></figure>\n\n<p>下栏中的 Traceback 真是让我一头雾水！点进源码里面看了半天也不知所以然，不过我注意到了上面一栏中，有一个非常关键的错误信息：<font color=#EB6D39>deepcopy！</font>为了验证是不是深拷贝带来的问题写个小测试：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\">he = HashingEncoder()</span><br><span class=\"line\">he_cp = deepcopy(he)</span><br></pre></td></tr></table></figure>\n\n<p>报错复现！看来主要问题就出在深拷贝上了！从网上找了找，发现这个报错的内容比较少，不过参考的附录【3】和【4】中都指出了一个关键因素：</p>\n<blockquote>\n<ul>\n<li>进程池内部处理使用了 pickle 模块(用于 python 特有的类型和 python 的数据类型间进行转换)中的 dump(obj, file, protocol=None,) 方法对参数进行了封装处理</li>\n<li>在实现多进程的参数中，初始化了自定义类对象</li>\n</ul>\n</blockquote>\n<p>有共性就好找原因，虽然从这两篇文章来看和我本身的情况又是如此不一致，不过我似乎联想到了什么：</p>\n<p>既然造成这个错误的原因是开启子进程时，参数带有自定义类对象（通常是不可被 pickle 的），那我就从子进程的参数开始入手：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock ...</span><br><span class=\"line\">    self.hashing_parts ...</span><br><span class=\"line\">    self.done_index ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我好像发现了什么：进程锁 <code>lock</code>，数据队列 <code>hashing_parts</code>，完成下标 <code>done_index</code>，都是在 HashingEncoder 初始化时定义的，虽然这些都不是我的自定义类对象，但回顾参考一下报错信息的最后一行：</p>\n<blockquote>\n<p>TypeError: can’t pickle _thread.lock objects</p>\n</blockquote>\n<p>明确指出：进程锁 Lock 是不能被 pickle 转化的，事实上，另外两种 Value 和 Queue 都不可以，只不过因为执行到 pickle Lock 的时候就报错中断了而已。因此，把这些 Manager() 下的对象都放到创建子进程之前，并通过参数传递进去即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, _lock, _hashing_parts, _done_index</span>):</span></span><br><span class=\"line\">    _lock ...</span><br><span class=\"line\">    _hashing_parts ...</span><br><span class=\"line\">    _done_index ...</span><br><span class=\"line\"></span><br><span class=\"line\">lock = multiprocessing.Manager.Lock()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">hashing_parts = multiprocessing.Manager.Queue()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(</span><br><span class=\"line\">        <span class=\"comment\"># 通过参数传递</span></span><br><span class=\"line\">        multiprocessing.Process(target=work,</span><br><span class=\"line\">                                args=(lock, hashing_parts, done_index)))</span><br></pre></td></tr></table></figure>\n\n<p>大功告成！至此，目前所踩的坑都已解决，提交 PR，回家睡觉！</p>\n<p>另外，在查找 multiprocessing 相关内容的时候，无意间看到一个因为 <code>logging</code> 导致多进程死锁的问题，出现概率较低，记录在附录【10】。作者自己的解答为：</p>\n<blockquote>\n<p>由于主进程中使用了thread+mutiprocessing(fork)，导致logging出现死锁，现象就是遇到子进程里第一句logging就hang住。问题只会发生在Linux下。</p>\n</blockquote>\n<p>以及在本地进行单元测试时通常使用 nose 模块测试，但在提交 PR 时测试是部署在 CI 上进行的，这里面也遇到了一些问题，例如代码文件内的 example 的输入和输出必须是真实运行结果，CI 检测时会真实运行 example 的输入，并且所写的输出也要和 CI 运行结果一致。又或者由于最终提交的工具包需要面向各种环境的使用者，所以 CI 上还部署了 Python2 环境下的测试，这就使得代码必须要做兼容，例如 <code>print(Str, flush=boolean)</code> 这个简单常见的方法是基于 Python3 的，在提交的 CI 检测中就会报错，因此在本地也需要添加对应的环境自行检测，等等。对于单元测试这一部分，通过<a href=\"https://www.jianshu.com/p/8978aceac3b6\" title=\"@LINK\">基于travis-ci的单元自测（作者：lewzylu）</a>这篇文章亦获得了不少帮助，记录在附录【11】中供参考。</p>\n<hr>\n<h1 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/chenyulancn/article/details/77836593\" title=\"@LINK\">【1】python多进程共享变量Value使用tips（作者：chenyulancn）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/qq_27292549/article/details/78929296\" title=\"@LINK\">【2】python中的multiprocessing在map函数中的加锁lock处理方式（作者：qq_27292549）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/weixin_41935140/article/details/81153611\" title=\"@LINK\">【3】使用进程池时遇到的坑…（作者：Kepner）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/qq_38765321/article/details/88376031\" title=\"@LINK\">【4】TypeError: can’t pickle _thread.lock objects（作者：voyagerlll）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/SuKiWX/p/8804974.html\" title=\"@LINK\">【5】python中的GIL详解（作者：背着吉他的王小可）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/kaituorensheng/p/4445418.html\" title=\"@LINK\">【6】Python多进程编程（作者：jihite）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/gengyi/p/8647950.html\" title=\"@LINK\">【7】python学习笔记——multiprocessing 多进程组件-队列Queue（作者：耕毅）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/u013066730/article/details/82763115\" title=\"@LINK\">【8】python多进程（multiprocessing）中的Queue，Pipe（作者：mjiansun）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/sch01ar/p/8215042.html\" title=\"@LINK\">【9】Python多进程-进程间数据的传递（作者：Sch01aR#）<sup>【注】</sup></a></li>\n<li><a href=\"https://segmentfault.com/q/1010000005919174\" title=\"@LINK\">【10】使用multiprocessing.Process调用start方法后，有较小的几率子进程中run方法未执行（作者：从星空仰望地球）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.jianshu.com/p/8978aceac3b6\" title=\"@LINK\">【11】基于travis-ci的单元自测（作者：lewzylu）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33762321/article/details/88275111\" title=\"@LINK\">【12】数据特征处理之特征哈希（Feature Hashing）（作者：weixin_33762321）<sup>【注】</sup></a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1593454269874725931&wfr=spider&for=pc&isFailFlag=1\" title=\"@LINK\">【13】人工智能之机器学习篇——哈希学习learning to hash（作者：人工智能产业研究院）<sup>【注】</sup></a></li>\n<li><a href=\"http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html\" title=\"@LINK\">【14】特征哈希（Feature Hashing）（作者：Breezedeus）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.datalearner.com/blog/1051537932880901\" title=\"@LINK\">【15】数据特征处理之特征哈希（Feature Hashing）（作者：小木）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/laolu1573/article/details/79410187\" title=\"@LINK\">【16】Feature hashing(特征哈希)（作者：大师鲁）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/vim_wj/article/details/78300239\" title=\"@LINK\">【17】github—-向开源框架提交pr的过程（作者：vim_wj）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Python"],"tags":["AI","SKLearn","HashingEncoder","哈希编码","多线程"]},{"title":"Python中的下划线与函数的花式调用","url":"/post/python/python-underline/","content":"<span id=\"more\"></span>\n\n<p>前言：今天在看一个 TF 程序的时候，发现很多例程都喜欢把 main 函数定义为：main(_)，而不是 main(argv=None)，当然对于一个 Python 程序而言，一切皆为对象，用下划线当做参数变量并没什么好奇怪的（毕竟连 <code>...</code> 都是一个 Ellipsis 对象，甚至可以修改其默认值），但如此广泛应用，应当是有一定原因的，找了找论坛和 SOF，简略看了一下 TF 中 run() 函数的源码（主要是复杂的看不懂），算是初步了解了 Python 中下划线的应用，而且还无意间看到了一篇关于 Python 函数“花式”调用的文章，受益匪浅。</p>\n<hr>\n<h1 id=\"1-来源\"><a href=\"#1-来源\" class=\"headerlink\" title=\"1. 来源\"></a>1. 来源</h1><p>最开始有这个疑问是因为今天 <del>突发奇想心血来潮自我膨胀差点上天的</del> 看了看 TinyMind 里面的云平台，进去还送了 2 点平台点数，本着不用白不用的心态，想想亚马逊和阿里比较昂贵的价格，准备试试看这里效果怎么样，然后点开官方文档就看到了一个巨经典的例程：mnist 手写识别，虽然写是写过，不过自己是基于 C++ 写的，Python 的代码还是可以好好看看，这一看就发现了简介中的现象，作为一个码（fei）农（zhai），遇到问题当然是问。。哦对了，千万不要再汤很凉上搜索“_”这个关键词。</p>\n<hr>\n<h1 id=\"2-Python基础语法中的下划线\"><a href=\"#2-Python基础语法中的下划线\" class=\"headerlink\" title=\"2. Python基础语法中的下划线\"></a>2. Python基础语法中的下划线</h1><p>如果写过 Python，其他下划线不多说，至少 _<em>name_</em> 和 _<em>init</em>_ 是见过的，以前只想过这是语法规定以及一点都不优雅，这回是好好整理了一把，先列出 Python 中可能存在的 5 种下划线的情况：</p>\n<ol>\n<li>单前下划线：_sample</li>\n<li>单后下划线：sample_</li>\n<li>双前下划线：__sample</li>\n<li>前后双下划线：_<em>sample</em>_</li>\n<li>单独下划线：_</li>\n</ol>\n<h2 id=\"2-1-单前下划线：-sample\"><a href=\"#2-1-单前下划线：-sample\" class=\"headerlink\" title=\"2.1 单前下划线：_sample\"></a>2.1 单前下划线：_sample</h2><p>单前下划线的写法非常“约定俗成”——纯粹只是一种习惯和写法的延续，用于表示该变量是个 函数/类 的内部变量，写不写完全看个人习惯。但在一种特殊情况下，单前下划线是有特殊作用的，下面用代码说明。<br>首先定义一个类 ClassA，重写构造方法并定义两个变量：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.normal + <span class=\"string\">&quot; | &quot;</span> + a._pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal | PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>运行输出也很正常，这说明单前下划线并不影响一个变量被访问，这时我们考虑一种情况，假设在一个 module：im_module.py 中有两个函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># im_module.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normal_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pre_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;PreUnderline&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接着在别的地方把这个 module 导入并调用其函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> im_module <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">NameError: <span class=\"string\">&quot;name &#x27;_pre_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一种虽然不好但很常见的导入方式，但结果呢？是的，在使用通配符 * 导入的时候，解释器会过滤掉单前下划线的成员。 <strong>但！</strong> 前文也说了，通配符导入并不是良好的编码习惯，这种导入方式非常容易导入 无关/冲突/未知/… 的部分，因此通常还是应该手动选择需要导入的部分，如果需要导入全体，则应该使用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> im_module</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>这次的输出结果一切正常。<font color=#EB6D39>也就是说，除非使用通配符 * 的方式进行导入，会导致单前下划线修饰的成员被忽略，否则与不带下划线的成员没有区别。</font>除了这种特殊情况之外，就像 Java 中喜欢用 m 前缀来表示成员变量一样，这仅仅只是一种提醒功能，具体好不好、对不对、有没有用呢，那就仁者见仁了，一般是根据团队项目最初定的标准来决定，个人项目就纯粹看习惯了。顺便提一句，在 Google 官方的 <a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">Java Style Guide</a> 中并不推荐这种写法，当然这也跟如今 IDE 的智能有关，如果使用的编辑器没有代码高亮或者提示功能，还是建议加上吧，这篇文档的中译版可参考附录【2】。</p>\n<h2 id=\"2-2-单后下划线：sample\"><a href=\"#2-2-单后下划线：sample\" class=\"headerlink\" title=\"2.2 单后下划线：sample_\"></a>2.2 单后下划线：sample_</h2><p>单后下划线相对而言可能使用场景还比较多，它的主要功能是“规避”关键字冲突。Python 中有许多关键字，例如 <code>class</code>，<code>sum</code>，<code>len</code>，<code>type</code> 等，但在许多时候，我们自己定义的变量、方法等，很难找到更适合的表示单词，或是改变写法又太麻烦/不直观，例如学校、师生类中的“班级属性 class”，商品的“种类 type”，这时候如果我们不想费时间写出像 class_num 或者 type_name 这样的标识符，或许可以直接用 class_ 和 type_ 代替，<font color=#ED6B39>这样既避免了和关键字的冲突，又能很直观地表示其含义。</font></p>\n<h2 id=\"2-3-双前下划线：-sample\"><a href=\"#2-3-双前下划线：-sample\" class=\"headerlink\" title=\"2.3 双前下划线：__sample\"></a>2.3 双前下划线：__sample</h2><p>这个就有点意思了，用双前下划线标识的属性，解释器会重写名称，以避免子类中的命名冲突，其效果对属性和函数是一样的，以下代码仅用属性举例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;DoublePreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用 dir() 函数查看 ClassA 对象的属性</span></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">dir</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>, <span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ge__&#x27;</span>, <span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init__&#x27;</span>, <span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__module__&#x27;</span>, <span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce_ex__&#x27;</span>, <span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__str__&#x27;</span>, <span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在输出的结尾，_pre 和 normal 都在，唯独不见了 __double_pre？其实并不是没有，而是解释器自动改变了其内部形式，就在输出的第一个：_ClassA__double_pre，解释器自动为这个属性增加了一个当前所属类的类名标识 _ClassA，<font color=#EB6D39>这也意味着，即使在 ClassA 所在的当前 module 内，如果需要调用这个属性，用 <code>ClassA().__double_pre</code> 也会报错 <code>AttributeError: &quot;&#39;ClassA&#39; object has no attribute &#39;__double_pre&#39;&quot;</code> ，而应该使用 <code>ClassA()._ClassA__double_pre</code> 的方式调用。</font>为什么要这样，又有什么用呢，用下面的代码就可以说明：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span>(<span class=\"params\">ClassA</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 继承自 ClassA</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>(ClassB, self).__init__()</span><br><span class=\"line\">        <span class=\"comment\"># 也可以直接覆写</span></span><br><span class=\"line\">        <span class=\"comment\"># super().__init__()</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;_ClassB__double_pre&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>, <span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>, <span class=\"string\">&#x27;__ge__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>, <span class=\"string\">&#x27;__init__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>, <span class=\"string\">&#x27;__module__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>, <span class=\"string\">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>, <span class=\"string\">&#x27;__str__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>不论是继承自 ClassA 也好，还是直接覆写也好，其最终的输出中都既有 _ClassA__double_pre，也有 _ClassB__double_pre，同样，也是因为解释器自动给 __double_pre 增加了一个当前所属类的类名标识 _ClassB，因此父类 ClassA 中的 __double_pre 并不会被重写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(b.normal)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassA__double_pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassB__double_pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Override</span><br><span class=\"line\">Override</span><br><span class=\"line\">DoublePreUnderline</span><br><span class=\"line\">Override</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，被前双下划线标识的属性是不会被重写的</p>\n<p>此外，还有一个特别有意思的应用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ClassC__double_pre = <span class=\"string\">&quot;DoublePreinClassC&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassC</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> __double_pre</span><br><span class=\"line\"></span><br><span class=\"line\">ClassC.call()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">DoublePreinClassC</span><br></pre></td></tr></table></figure>\n\n<p>乍一看在 ClassC 的 call() 方法中返回的 __double_pre 根本没有定义啊，应该报 NameError 错误才对，实际上，因为在上面手动定义的 _ClassC__double_pre 具有 _ClassC 前缀，因此程序调用 call 方法的时候，解释器会自动给 __double_pre 加上 _ClassC 前缀，而又恰好存在这么个变量，因此可以正常输出。<font color= EB6D39>这也说明，如果某个类内有属性/方法是以双前下划线修饰，则解释器会自动给双前下划线的成员添加其所属类的前缀，这种转换适用于整个类内所有以双前下划线开头的任何名称，而不论它是一个变量还是方法还是其他。</font></p>\n<h2 id=\"2-4-前后双下划线：-sample\"><a href=\"#2-4-前后双下划线：-sample\" class=\"headerlink\" title=\"2.4 前后双下划线：_sample_\"></a>2.4 前后双下划线：_<em>sample</em>_</h2><p>这个就好解释多了，也常见的多了，Python 保留了许多用前后双下划线修饰的属性/方法，像 _<em>name_</em> 或是 _<em>init</em>_()，当然只要我们愿意，并且命名不冲突，我们也可以自行定义前后双下划线修饰的成员，这本身是没有错的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">__test__ = <span class=\"string\">&quot;Test&quot;</span></span><br><span class=\"line\">__test__</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Test</span><br></pre></td></tr></table></figure>\n\n<p>但不太推荐这么做，主要原因是 Python 官方保留了这么命名的做法，因此可能现在没有发生冲突的一些命名，在未来 Python 经过更新后由于官方加入了对应的保留成员而导致冲突，<font color=#ED6B39>因此，干脆就不要使用自定的前后双下划线成员，并且记住这样修饰的都是 Python 保留命名就好了。</font>不过我觉得一般也没什么人愿意如此麻烦的加上四个下划线吧，说不定 Python 当年就是考虑到这个才这么设计呢（逃）。</p>\n<h2 id=\"2-5-单下划线：\"><a href=\"#2-5-单下划线：\" class=\"headerlink\" title=\"2.5 单下划线：_\"></a>2.5 单下划线：_</h2><p>说实话我第一次见到这个写法的时候还以为是源码写错了，不过其实通俗的讲，既然 Python 一切皆为对象，当然也就可以把 _ 当做很普通的成员使用，事实也确实如此：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ = <span class=\"string\">&quot;Underline&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">_ = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a + b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Underline</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\">ab</span><br></pre></td></tr></table></figure>\n\n<p>玩上瘾了，我相信如果你在团队项目里面大量使用 _ 作为变量/方法名，明年就该有坟头草了。<br>正经的解释：如果某个变量、方法、参数没有实际用途，可以使用 _ 来代替，以表明这是个可以忽略的部分。说起来好像没什么用，其实在真正的源码中，这个用法可以大幅提高阅读感，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">user = (<span class=\"string\">&#x27;ZhangSan&#x27;</span>, <span class=\"string\">&#x27;20岁&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>, <span class=\"string\">&#x27;80分&#x27;</span>, <span class=\"string\">&#x27;野鸡大学&#x27;</span>, <span class=\"string\">&#x27;计算机专业&#x27;</span>, <span class=\"string\">&#x27;物联网工程&#x27;</span>)</span><br><span class=\"line\">name, _, _, _, college, _, _ = user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(college)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ZhangSan</span><br><span class=\"line\">野鸡大学</span><br><span class=\"line\">物联网工程</span><br></pre></td></tr></table></figure>\n\n<p>这么写出来的代码，阅读时可以非常直观地看出来，这些消息里面我关注的只有 name 和 college，其中 _ 被多次赋值，因此输出的值是最后一次赋值“物联网工程”。<br>另外，_ 还是大多数 Python REPL 中的一个特殊变量，它不仅可以当做普通的变量、方法正常调用，还会自动保存你最后一次计算的结果，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;ABCD&quot;</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">list</span>()</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">_.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p>但是 <strong>注意：如果你已经手动给 _ 赋值，则它在当前上下文范围内不会再自动保存你的计算结果</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">a</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ = <span class=\"string\">&quot;A&quot;</span></span><br><span class=\"line\">a += <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n<p><font color=#ED6B39>也就是说，_ 在未被手动赋值前，当前上下文内每次计算的记过都会赋值给 _，直到你手动给 _ 赋值使其称为一个常规成员。</font></p>\n<h2 id=\"2-6-name-的应用\"><a href=\"#2-6-name-的应用\" class=\"headerlink\" title=\"2.6 __name__的应用\"></a>2.6 __name__的应用</h2><p>_<em>name</em>_ 可以说是 Python 中的一大常客了，最常见的形式就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>通常这个语句会作为一个程序的入口，但为什么会有这么奇怪的一个条件语句呢？用代码一下就能解释明白。首先创建一个 module：rate.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">LEARNING_RATE = <span class=\"number\">1.005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call_rate</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Rate is :&quot;</span>, LEARN_RATE)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Value of __name__ :&quot;</span>, __name__)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    call_rate()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果：</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : __main__</span><br><span class=\"line\">Rate <span class=\"keyword\">is</span> : <span class=\"number\">1.005</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到此时 _<em>name_</em> 的值就是 “__main__”，如果再新建一个 module：test.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> rate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(rate.LEARNING_RATE * <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : rate</span><br><span class=\"line\"><span class=\"number\">2.01</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，rate.py 中的 _<em>name_</em> 变成了 “rate”，因此条件语句没有执行，<font color=#ED6B39>因此，_<em>name</em>_ 可以用来判断该 module 是直接执行的还是被其他 module 引入后执行的。</font></p>\n<h2 id=\"2-7-TensorFlow中的run-方法\"><a href=\"#2-7-TensorFlow中的run-方法\" class=\"headerlink\" title=\"2.7 TensorFlow中的run()方法\"></a>2.7 TensorFlow中的run()方法</h2><p>先来看看 TF 中 run() 方法的源码：</p>\n<center>\n\n<p><img data-src=\"./code_of_run_in_tf.png\" alt=\"TF 中 run() 方法源码\" title=\"@ASSET\"></p>\n</center>\n\n<p>从图中可以看出来，当传的参数 main 为空时，跳过执行，如果不为空，则调用 main 函数，因此想要调用 tf.app.run() 方法，则需要在模型程序中定义 main(argv) 函数，并且接收参数 args，如果模型不需要使用这些参数，就可以用 main(_) 来表示，也就回答了最开始的问题。</p>\n<hr>\n<h1 id=\"3-Python中方法的花式调用\"><a href=\"#3-Python中方法的花式调用\" class=\"headerlink\" title=\"3. Python中方法的花式调用\"></a>3. Python中方法的花式调用</h1><p>首先，几乎在所有的程序中，调用函数/方法的步骤无非就两个：①定义，②调用，在 Python 中也是如此，使用关键字 def 来声明一个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n<p>似乎我们所熟知的函数/方法调用也就只有这一种，但 Python 还有一种很好玩的调用方式：根据名称调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_a</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function A&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_b</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function B&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_c</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function C&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;func_a&quot;</span>)()</span><br><span class=\"line\"><span class=\"built_in\">locals</span>()[<span class=\"string\">&quot;func_b&quot;</span>]()</span><br><span class=\"line\"><span class=\"built_in\">globals</span>()[<span class=\"string\">&quot;func_c&quot;</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Method function A</span><br><span class=\"line\">Method function B</span><br><span class=\"line\">Method function C</span><br></pre></td></tr></table></figure>\n\n<p>eval() 函数可以直接转换成函数调用，而 locals() 和 globals() 可以通过字典的方式访问局部、全局变量。之所以 Python 支持这种形式的调用，是因为 Python 使用 <strong><font color=#ED6B39>名字空间</font></strong> 来记录变量的变化。每个函数都有自已的名字空间，称为局部名字空间，其记录了函数的变量，包括函数的参数和局部定义的变量；每个 module 也都有自已的名字空间，称为全局名字空间，其记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量；还有一个内置名字空间，任何 module 均可访问，其存放了内置的函数和异常。名字空间是一个字典，键 key 就是变量名，值 value 就是变量的值，名字空间就像 Python 的普通字典一样可以进行访问。当某行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：</p>\n<ol>\n<li>局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python 将使用这个变量，然后停止搜索。</li>\n<li>全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用这个变量然后停止搜索。</li>\n<li>内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。</li>\n</ol>\n<p>如果Python在这些名字空间找不到 x，就会放弃查找并引发一个 NameError 的异常，同时传递 “There is no variable named ‘x’” 错误信息。</p>\n<p>在 Java 或 C/C++ 等编译语言中，编译器会将代码编译为二进制文件执行，在程序内部，是没有“变量名”这个概念的，所以我们的代码只能通过变量名取值，而不能通过具体的变量获得变量名（当然可以用 Map 的方式手动保存，但这本身脱离了原意），但在 Java 中，有一种很类似的样例就是 <a href=\"/post/android/android-objectanimator/android-objectanimator\" title=\"@LINK\">ObjectAnimator</a> 中的属性名 Attr，调用该方法会通过设置的属性名去获取对应控件下的 setAttr() 方法，和此处的命名空间有着异曲同工之妙。</p>\n<hr>\n<h1 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">【1】Google Java Style Guild（作者：Google）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/harrytsz/article/details/63328086\" title=\"@LINK\">【2】Google Java Style Guide中文版（作者：Harrytsz）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/amou/p/9530932.html\" title=\"@LINK\">【3】18式优雅你的Python（作者：梁云）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Python"],"tags":["Python","Underline","下划线","同名函数"]},{"title":"Linux云服务器远程任务随笔","url":"/post/note/note-cloud-server/","content":"<span id=\"more\"></span>\n\n<p>前言：由于本地设备的性能限制，通常一些大型科学计算都会用到云服务器来解决算力问题。不过在使用过程中遇到了不少问题比如内存不够、断连、jupyter notebook 启动失败等，都将记录在本文。</p>\n<hr>\n<h1 id=\"1-云服务器的选择\"><a href=\"#1-云服务器的选择\" class=\"headerlink\" title=\"1. 云服务器的选择\"></a>1. 云服务器的选择</h1><p>国内比较知名的几个云服务器大概有：腾讯云、阿里云、百度云、华为云，还有比较知名的亚马逊和谷歌，但总觉得有点水土不服。其他的一些云服务器我也没有每个都探索一遍，如果发现有更实惠的选择再更新进来吧。</p>\n<p>先说说这四个国内云服务器给我的第一感吧。总体来说，BAT 三家云服务器还是让我感觉到了作为国内互联网三巨头的一股气势，单从我个人感受而言，似乎给我一种“你爱用就用”的态度，当然，文档详尽、自定义性高等各方面条件都是相当优秀的，不过在用户引导这个方面仍然感觉略有不足，其中腾讯云要稍微好一些，阿里次之，当然我不是有意黑百度。最开始我已经准备入坑阿里云，资料、认证都已经完成，但是在选配置的时候遇到一个很尴尬的问题：阿里云的按需计费模式，需要预充 50 元以上，但是对于首次使用的我来说，我其实只是想花个几块钱，就用一个小时尝试一下预期配置的效果，尽管四大云都提供了免费试用，但免费提供的服务器配置并达不到我的要求，所以基于这一点，我 Pass 了阿里云（当然我认为就服务器整体实力而言，阿里云应是最强的）。如果要长期使用并且对维护要求比较高的，我个人还是更推荐阿里云一些，可能质量上而言这几个服务器差别都不会太大，但是阿里云的应用量是远超其他几个云的，从服务案例、维护参考等角度出发，使用阿里云，至少出了问题你能在网上搜到最多的答案。</p>\n<p>第二次我搜索云服务器的时候，度娘给我推荐的第一条搜索结果居然是 <strong>华为云</strong>，抱着试试看的心态点进去看了看，惊喜的发现：华为云按需计费是不需要预充金额（其他两家没有尝试）的！这直接导致了我后续选择华为云作为服务器的结果。</p>\n<p>说完第一感，再来浅略谈谈这几个云服务器的选择。首先，腾讯云和百度云是没有 <strong>ECS 弹性云服务器</strong> 这么个独立选项的，最后在腾讯找到了 <em>云服务器 CVM</em>，在百度找到了 <em>云服务器 BCC</em>，看起来跟配置 ECS 差不多，也就权当是不同叫法了。此外，还有一点需要提一下，只有阿里云里面选择配置的时候，是有详细配置参数的，包括 CPU 主频等：</p>\n<center>\n\n<p><img data-src=\"./ali_ecs_detail.png\" alt=\"阿里云详细配置参数\" title=\"@ASSET\"></p>\n</center>\n\n<p>而且整体配置选择界面一目了然，各种搭配方案覆盖面也很广，用起来给我个人感觉是最好的。其次是华为云，虽然没有标出主频参数，但至少还能看出 CPU 的规格信息，还能直接搜出来具体的参数：</p>\n<center>\n\n<p><img data-src=\"./huawei_ecs_detail.png\" alt=\"华为云详细配置参数\" title=\"@ASSET\"></p>\n</center>\n\n<p>其他两家就差了一些，只告诉我这是几核的，配多大内存，虽然也对 CPU 根据用途做了分类，但终归不直观：</p>\n<center>\n\n<p><img data-src=\"./other_ecs_detail.png\" alt=\"其他云详细配置参数\" title=\"@ASSET\"></p>\n</center>\n\n<p>此外，在价格上各家也有差异，由于我自己的需求是约 8 核以上 CPU + 约 32G 以上内存，再加上只是临时跑一下数据，所以选择按需计费，并且都转换成以下标准配置再进行价格对比：</p>\n<ul>\n<li>地区：广州（华南地区）</li>\n<li>CPU：8核 2xlarge.4（3.1GHz 高性能计算型）</li>\n<li>内存：32G</li>\n<li>硬盘：50G 普通硬盘</li>\n<li>带宽：5Mbps</li>\n<li>系统：Ubuntu</li>\n<li>公网：无</li>\n<li>时长：1小时</li>\n</ul>\n<p>各个云的价格计算器链接：<a href=\"https://buy.cloud.tencent.com/price/cvm/calculator\" title=\"@LINK\">腾讯云</a>、<a href=\"https://cloud.baidu.com/calculator.html#/bcc/price\" title=\"@LINK\">百度云</a>、<a href=\"https://tco.aliyun.com/tco/ecs/calculator\" title=\"@LINK\">阿里云</a>、<a href=\"https://www.huaweicloud.com/pricing.html#/ecs\" title=\"@LINK\">华为云</a>。</p>\n<p>根据这个选择，得到费用表如下（单位：元 / 小时）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">腾讯云</th>\n<th align=\"center\">百度云</th>\n<th align=\"center\">阿里云</th>\n<th align=\"center\">华为云</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">无公网</td>\n<td align=\"center\">6.58</td>\n<td align=\"center\">3.6721</td>\n<td align=\"center\">4.7874</td>\n<td align=\"center\">2.73</td>\n</tr>\n<tr>\n<td align=\"center\">有公网</td>\n<td align=\"center\">6.58</td>\n<td align=\"center\">3.6721</td>\n<td align=\"center\">4.7874</td>\n<td align=\"center\">3.05</td>\n</tr>\n</tbody></table>\n<p>当看到腾讯云价格的时候，我有一点吃惊，但是仔细看了一下，我确定我选择的是 SkyLake 架构 3.2GHz 规格的 CPU，应该是 Xeon E5-2667v4，这款在阿里云的价格平均下来要 7.11 元 / 小时，所以这个价格也还差不多，不过相比标准配置，相同架构，提高 0.1 主频就要贵这么多，还是略不值得。另外，阿里云原本是支持按小时计费，但是这次没找到，因此按照月费用除以 31 天计算。</p>\n<p>从价格表也基本可以看出来，华为云的价格优势还是很大的，综合不需要预充值、引导友好等特点，最终入了华为云的坑。</p>\n<hr>\n<h1 id=\"2-连接远程服务器\"><a href=\"#2-连接远程服务器\" class=\"headerlink\" title=\"2. 连接远程服务器\"></a>2. 连接远程服务器</h1><p>云服务器给的 Linux 系统通常是命令行形式的，也就是所有的操作都使用 Linux 命令完成，当然有些云也提供支持视图模式的选项，但通常伴随着较高的价格。</p>\n<p>连接远程服务器有两种方式：（1）用远程连接工具、（2）用系统自带工具</p>\n<ol>\n<li>远程连接工具有很多    - Mac 下有 <a href=\"https://www.ssh.com/ssh/cyberduck\" title=\"@LINK\">CyberDuck</a>、<a href=\"http://www.openssh.com/portable.html\" title=\"@LINK\">OpenSSH</a> 等    - Win 下有 <a href=\"https://www.netsarang.com/zh/xshell/\" title=\"@LINK\">XShell</a>、<a href=\"https://www.ssh.com/ssh/winscp/\" title=\"@LINK\">WinSCP</a> 等    - 跨平台的有 <a href=\"https://www.vandyke.com/products/securecrt/\" title=\"@LINK\">SecureCRT</a>、<a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/\" title=\"@LINK\">PuTTY</a>、<a href=\"https://www.ssh.com/products/tectia-ssh/\" title=\"@LINK\">Tectia</a> 等</li>\n<li>系统自带工具不依赖额外的软件，因此更适合仅需要建立连接而不需要集群管理等高级功能的情况    - Mac 下的“终端”    - Win 下的 CMD 和 PowerShell</li>\n</ol>\n<p>由于我只是为了利用云 ECS 的算力和持续运行，因此不需要什么高级功能，选择系统自带工具就足够了。命令格式为：<code>ssh [用户名]@[服务器地址]</code>，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh root@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n<p>对于新建的云 ECS，通常都有一个内网 ip 地址，但仅有这个地址的时候是无法远程访问的，还需要购买一个 弹性公网ip，华为云在默认情况下会选择购买，阿里云默认情况下不购买，需要自己区分。以下是华为云在购买 ECS 时弹性公网 IP （红圈所标）的设置部分：</p>\n<center>\n\n<p><img data-src=\"./buy_ip.png\" alt=\"购买弹性公网 IP\" title=\"@ASSET\"></p>\n</center>\n\n<p>关于 ECS 的内网 IP 和公网 IP，可以这么粗略理解：公网 IP 是通过远程连接等利用公网访问云、或从云访问公网时必须用到的，内网 IP 通常是集群服务器间，某些云没有联网需求，但需要和其他同属一个网段的云（例如都是华为云，或都是阿里云等）交互数据，那么这些云就可以不购买公网 IP 而仅通过内网 IP 通信。</p>\n<p>有了公网 IP 后，就能同过命令行进行远程连接了。如果设置了连接密码，则会在下一条命令中提示输入，注意输入该密码时屏幕上不会显示输入过程，输完回车即可，密码也即在购买服务器时设置登录账户时输入的密码：</p>\n<center>\n\n<p><img data-src=\"./set_login_user.png\" alt=\"远程连接密码\" title=\"@ASSET\"></p>\n</center>\n\n<p>在 Mac 下，如果不想每次都手输这个命令，可以右键“终端”，选择“新建远程连接”：</p>\n<center>\n\n<p><img data-src=\"./new_ssh_connection.jpg\" alt=\"新建远程连接\" title=\"@ASSET\"></p>\n</center>\n\n<p>然后在弹出窗口内左侧选择服务为 __SSH__，在下面输入连接用户，并输入服务器的地址：</p>\n<center>\n\n<p><img data-src=\"./add_ssh.png\" alt=\"添加 SSH 服务\" title=\"@ASSET\"></p>\n</center>\n\n<p>通常连接用户是 root，如果想减少权限以防意外操作，要先以 root 用户登录一次，再在 Linux 系统内新建一个普通用户，下一次即可选择新用户登录。</p>\n<hr>\n<h1 id=\"3-配置服务器环境\"><a href=\"#3-配置服务器环境\" class=\"headerlink\" title=\"3. 配置服务器环境\"></a>3. 配置服务器环境</h1><p>到这一步，云服务器已是可用状态，通过 SSH 登录后，会新开一个 SSH 终端用于操作云上的 Linux 系统，就和自己手动操作时时一样的。不过需要注意的是，SSH 云服务器的终端只有一个，当然还有一些别的技巧可以达到类似多开终端的效果，会在后面介绍。</p>\n<p>既然是要在云上跑训练集，当然 Python 环境、各种科学计算工具包是必不可少的，我个人更推荐直接使用 Anaconda 一次性集成开发环境。</p>\n<h2 id=\"3-1-下载安装Anaconda\"><a href=\"#3-1-下载安装Anaconda\" class=\"headerlink\" title=\"3.1 下载安装Anaconda\"></a>3.1 下载安装Anaconda</h2><p>首先在任何一个可以联网的设备上进入 <a href=\"https://repo.continuum.io/archive/index.html\" title=\"@LINK\">Anaconda 安装包归档</a>，并找到自己想要安装的版本，以 Linux 下 64 位集成 Python3 环境的最新版本为例，其安装包名称为：<code>Anaconda3-2019.03-Linux-x86_64.sh</code>，在 SSH 终端中输入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装包（默认在用户目录下，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">wget https://repo.continuum.io/archive/Anaconda3-2019.03-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 Anaconda（默认在用户目录内，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">bash Anaconda3-5.0.1-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量：</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .bashrc</span><br></pre></td></tr></table></figure>\n\n<p>完成后，在 SSH 终端内输入 <code>python</code>，正确进入 Python 编辑环境则表示安装成功。某些情况下，可能需要手动配置环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑环境变量（所有用户有效）：</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 编辑环境变量（仅当前用户有效）：</span></span><br><span class=\"line\"><span class=\"comment\"># vim .bash_profile</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件末尾添加一行（用户名和安装目录请按实际路径填写）：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/home/root/anaconda3/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存并使其生效（所有用户有效）：</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 保存并使其生效（仅当前用户有效）：</span></span><br><span class=\"line\"><span class=\"comment\"># source .bash_profile</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-配置Jupyter-Notebook\"><a href=\"#3-2-配置Jupyter-Notebook\" class=\"headerlink\" title=\"3.2 配置Jupyter Notebook\"></a>3.2 配置Jupyter Notebook</h2><p>使用命令 <code>pip install jupyter</code> 安装 Jupyter 到当前环境中，如果需要切换环境，可以先在 Anaconda 中新建环境并切换至新环境后执行命令。</p>\n<p>安装好 Jupyter 后，像往常一样输入 <code>jupyter notebook</code> 启动，结果却发现连不上 Jupyter 服务，这是因为服务器上的 Jupyter 还没有配置外网访问。配置方式如下：</p>\n<ol>\n<li>生成 Jupyter 配置文件：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config --allow-root</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>打开ipython，创建一个登录jupyter的密码:</li>\n</ol>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 ipython 环境</span></span><br><span class=\"line\">ipython</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入 password 模块</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> notebook.auth <span class=\"keyword\">import</span> passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改密码</span></span><br><span class=\"line\">passwd()</span><br></pre></td></tr></table></figure>\n\n<p>  然后会要求输入一次密码和一次确认密码，同样，输入过程屏幕上不会有任何显示。正确输入密码后，会输出一个哈希值（省略后半部分），请复制或记录这个值：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改 Jupyter 配置：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">vi ~/.jupyter/jupyter_notebook_config.py</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># vi /root/.jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>\n\n<p>  在打开的配置中添加以下参数：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.NotebookApp.ip=<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">c.NotebookApp.password = u<span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure>\n\n<p>  其中 <code>password</code> 项输入上一步复制的哈希值，<code>port</code> 项推荐使用默认的 8888 端口，也可以自己定义。</p>\n<h2 id=\"3-3-配置服务器端口\"><a href=\"#3-3-配置服务器端口\" class=\"headerlink\" title=\"3.3 配置服务器端口\"></a>3.3 配置服务器端口</h2><p>至此服务器上的环境均已配置就绪，但如果这时候在 SSH 终端使用命令打开 Jupyter Notebook：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">jupyter notebook</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># jupyter notebook --allow-root</span></span><br></pre></td></tr></table></figure>\n\n<p>或是在浏览器通过：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://公网ip:端口</span><br><span class=\"line\"><span class=\"comment\"># 例：http://127.0.0.1:8888</span></span><br></pre></td></tr></table></figure>\n\n<p>仍然会出现无法连接的情况，这是因为 ECS 的安全组还没有配置，8888 端口（或自己设置的端口号）还没有开放给公网。设置安全组的过程如下：</p>\n<ol>\n<li>进入云服务器控制台</li>\n<li>进入安全组设置</li>\n<li>添加安全组规则</li>\n<li>选择协议类型为 __自定义 TCP__，输入端口号为 8888（或自定义端口号），授权 IP 设置为 0.0.0.0（即不限访问 IP，不论哪里的网络都可以连接访问云服务器的 Jupyter）</li>\n</ol>\n<p>配置完成后，即可通过 SSH 终端或浏览器输入地址的方式进入服务器的 Jupyter Notebook 了！如果仍旧提示无法访问，且云服务器所选的 Linux 系统为 Ubuntu（其他系统没试过），或许是因为防火墙的缘故，通过以下方式关闭：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ufw <span class=\"built_in\">disable</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来尽情享受云服务器带来的快感吧！</p>\n<h2 id=\"3-4-保持SSH会话\"><a href=\"#3-4-保持SSH会话\" class=\"headerlink\" title=\"3.4 保持SSH会话\"></a>3.4 保持SSH会话</h2><p>在使用云服务器的过程中，有时去做别的事了过了一段时间后再看 SSH 终端，发现先是没反应，无法输入，再过一会儿就提示连接已断开，这是因为默认情况下 SSH 会话有一个连接时间，一段时间后就会断开会话。如果需要处理一个耗时很长的事件，这可不是什么好事。为此，可以通过以下方式修改时间，以达到 SSH  会话保活的目的：</p>\n<ol>\n<li>登陆远程服务器后在 SSH 终端输入：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">TMOUT=0</span><br></pre></td></tr></table></figure>\n\n<p>  该方式方便、快捷，但缺点是仅对本次登陆有效，退出 SSH 后重新登录则需要再次设置。</p>\n<ol start=\"2\">\n<li>修改ssh配置文件：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打开配置文件</span></span><br><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveInterval，该参数指定了服务器端向客户端请求消息的时间间隔。默认是0，不发送</span></span><br><span class=\"line\"><span class=\"comment\"># 修改 ClientAliveInterval 的值，单位为秒。如设置 600，即每 10 分钟发送一次请求保持会话。</span></span><br><span class=\"line\">ClientAliveInterval = 600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveCountMax，该参数表示允许超时的次数。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果发现客户端没有响应，则判断一次超时，请根据实际需要进行设置。比如设置为10，表示允许超时6000 秒 = 100 分钟。</span></span><br><span class=\"line\">ClientAliveCountMax = 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-本地与云的文件传输\"><a href=\"#3-5-本地与云的文件传输\" class=\"headerlink\" title=\"3.5 本地与云的文件传输\"></a>3.5 本地与云的文件传输</h2><p>为了使用云服务器跑数据，还需要在云服务器上准备一份数据文件。由于提高网络带宽的价格并不便宜，而且使用云跑数据本身对带宽并没有什么要求，因此我比较推荐在将数据上传至云或从云上下载时，临时提高 ECS 的带宽，并在完成之后重新恢复较低带宽以节省成本。数据文件比较大时，临时提高带宽更划算一些。文件总量比较大时，临时购买流量更划算一些。本地与服务器的文件拷贝指令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本地文件复制到服务器：</span></span><br><span class=\"line\">scp [本地文件路径] [服务器登录用户名]@[服务器地址]:[服务器文件存储路径]</span><br><span class=\"line\"><span class=\"comment\"># 例如将本地用户目录下的 test.txt 复制到服务器 root 用户目录下并重命名为 db.txt：</span></span><br><span class=\"line\">scp /Users/user/test.txt root@127.0.0.1:/root/db.txt</span><br><span class=\"line\"><span class=\"comment\"># 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r /Users/user/<span class=\"built_in\">test</span> root@127.0.0.1:/root/db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务器复制到本地：</span></span><br><span class=\"line\">scp [服务器登录用户名]@[服务器地址]:[服务器文件存储路径] [本地文件路径]</span><br><span class=\"line\"><span class=\"comment\"># 例如将服务器 root 用户目录下的 db.txt复制到本地用户目录下并重命名为 test.txt ：</span></span><br><span class=\"line\">scp root@127.0.0.1:/root/db.txt /Users/user/test.txt</span><br><span class=\"line\"><span class=\"comment\"># 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r root@127.0.0.1:/root/db /Users/user/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-服务器后台运行Jupyter\"><a href=\"#3-6-服务器后台运行Jupyter\" class=\"headerlink\" title=\"3.6 服务器后台运行Jupyter\"></a>3.6 服务器后台运行Jupyter</h2><p>在选择云服务器训练数据时，除了考虑到算力的问题，当然也有持续运行的问题。尽管通过设置 SSH 的会花时间已经可以使得服务器的 Jupyter 一直在激活状态，但如果是自己的工作电脑，甚至办公本，平时还有大量的工作需要使用电脑，，一直在本地挂着一个 SSH 会话不能关机不能断开，总还是不妥，更何况如果遇到突然断网、突然死机等问题时，会话一关就中断运行，想想就让人抓狂。为此，给服务器的当前任务配置一个后台运行就显得尤为必要了。</p>\n<p>通常，在 Linux 中，可以用 <code>nohup [command]</code> 来保持一项任务不被挂起，使用 <code>nohup [command] &amp;</code> 来将任务转至后台并保持不被挂起。指令执行后，Linux 会立即将任务转至后台运行，且返回输出一个进程号：PID，当我们需要手动停止该进程时，可以通过 <code>kill -TRM [PID]</code> 来终止该进程。同时，该进程的所有输出均会默认存储至当前目录下的 <code>nohup.out</code> 文件中，使用命令 <code>tail -f nohup.out</code> 来实时查看动态输出，或者也可以使用：<code>nohup [command] &gt; out.log &amp;</code> 命令将输出重定向至自定义的文件（本例为out.log）并查看。</p>\n<p>这对于 Jupyter 任务来说也是一样的，我们可以通过将 Jupyter 任务转至后台持续运行来释放本地电脑的工作压力：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">nohup jupyter notebook &amp;</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># nohup jupyter notebook --allow-root &amp;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，当我们在 Jupyter 开始一项耗时任务后，即可直接断开 SSH 会话。<font color=#EB6D39>注意：在本地需要离线时，不能终止 Jupyter 的进程，而应该直接断开 SSH 连接。</font></p>\n<p>另外还有一点，由于 Jupyter 本身的局限性，当一个正在运行任务的 Jupyter 页面被关闭（而没有关闭服务）后，再次打开，只能保留前一次的结果，而不能恢复任务运行过程，因此，使用 nohup 命令转至后台的 Jupyter 任务应当是具有完整结果的，而不能再带有需要交互的部分，例如：</p>\n<ol>\n<li>将某个数据集预先确定好的特征进行哈希编码，并将编码完的数据重新输出存储。</li>\n<li>将某个数据集预先确定好的特征进行哈希编码，并询问我是否存储，根据选择完成相应任务。</li>\n</ol>\n<p>假设在任务开始后，本地立即断开 SSH 连接，并等待任务完成后再重新连接。那么：<br>任务 1 是合理的，因为任务过程不需要交互，重新连接后，可以在服务器的本地找到输出的已完成哈希编码的数据集。<br>任务 2 是不合理的，因为任务执行完编码后，不能完成交互因此任务将直接运行结束，重新连接后相当于白费力气。</p>\n<p>另外，除了基本的后台防挂起 nohup 外，还有一些工具也可以用来保持任务现场并恢复，例如：screen 和 tmux，可参考附录【7】、【8】，但终究因为 Jupyter 本身的原因，还是不太适合这种长时间可恢复的后台运行模式，我的建议是通过 Python 脚本进行长时间的后台操作，并尽量减少交互部分，及时将后续可能要用的数据保存成文件，而在 Jupyter 上仅作为一些可视化或测试、调整等的工具使用。</p>\n<h2 id=\"3-7-调整服务器的虚拟内存\"><a href=\"#3-7-调整服务器的虚拟内存\" class=\"headerlink\" title=\"3.7 调整服务器的虚拟内存\"></a>3.7 调整服务器的虚拟内存</h2><p>终于可以随心所欲折腾服务器的算力了，但在运行大量数据集的时候，很有可能报这个错：<code>Memory Error</code>，这个错在 Python 里面也不算罕见了，一般表示瞬间内存占用超过了可用内存总和导致代码崩了，但同样的代码，在本地运行成功，在配置更高的服务器却反而失败？后来通过 <code>free -m</code> 命令查看内存时发现原因其实很简单，就是因为 ECS 给我们的系统太纯净、太初始化了，以至于连交换内存都没有，所以即便是选购了 32G 的服务器，当进行一些编码、训练等大数据量任务时，瞬时内存占用会一下飙升，导致内存不足。好在现在的 ECS 大多都使用了固态硬盘，即便默认非固态硬盘的，升级成本也比较低，因此可以拿出一部分硬盘作为交换内存使用（参考附录【9】）。</p>\n<ol>\n<li>创建swap文件：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 /usr 目录下创建交换内存文件</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr</span><br><span class=\"line\">mkdir swap</span><br><span class=\"line\"><span class=\"built_in\">cd</span> swap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看目前总用量</span></span><br><span class=\"line\">ll</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个循环，每次复制 1024 字节，共复制 1024000 次（10G）并输出为 swapfile1 文件</span></span><br><span class=\"line\">dd <span class=\"keyword\">if</span>=/dev/zero of=/usr/swap/swapfile1 bs=1024 count=1024000</span><br></pre></td></tr></table></figure>\n\n<p>  最后的 <code>dd</code> 命令中，if 表示 infile，of 表示 outfile，bs=1024 表示写入的每个块的大小为 1024B，即 1KB。<br>  2. 查看刚才创建的 swap 文件大小即路径：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -sh /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>将目标文件设置为 swap 分区文件：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkswap /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>激活 swap，立即启用交换分区文件：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapon /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<p>  至此交换内存已经设置好了，并已激活可用，但仅限本次开机可用，想要每次开机都自动加载这个交换内存，则需要修改 <code>/etc/fstab</code> 文件</p>\n<ol start=\"5\">\n<li>编辑文件 <code>/etc/fstab</code> 中的 <code>swap</code> 行：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/fstab</span><br></pre></td></tr></table></figure>\n\n<p>  在 <code>/etc/fstab</code> 编辑状态下（UUID 省略后半部分），添加下面这段的最后一行：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/dev/mapper/vg_localhost-lv_root   /         ext4    defaults        1 1</span><br><span class=\"line\">UUID=cef520a0-df77-4........       /boot     ext4    defaults        1 2</span><br><span class=\"line\"><span class=\"comment\"># /dev/mapper/vg_localhost-lv_swap   swap      swap    defaults        0 0</span></span><br><span class=\"line\"><span class=\"comment\"># 下面这行是关键：</span></span><br><span class=\"line\">/usr/swap/swapfile1                swap      swap    defaults        0 0</span><br></pre></td></tr></table></figure>\n\n<p>保存并重启系统生效。</p>\n<h2 id=\"3-8-验证服务器\"><a href=\"#3-8-验证服务器\" class=\"headerlink\" title=\"3.8 验证服务器\"></a>3.8 验证服务器</h2><p>重启系统后，再次输入 <code>free -m</code> 命令，发现多了一个 <code>swap</code> 内存，大小为 10G，设置成功，服务器的基本配置已全部完成！</p>\n<hr>\n<h1 id=\"4-附录-参考指导\"><a href=\"#4-附录-参考指导\" class=\"headerlink\" title=\"4. 附录[参考指导]\"></a>4. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/mypath/articles/7877493.html\" title=\"@LINK\">【1】linux下安装Anaconda（作者：猪啊美）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/m0_37748303/article/details/78764625\" title=\"@LINK\">【2】阿里云连接jupyter notebook的步骤（作者：半监督）<sup>【注】</sup></a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/25475.html?spm=a2c4e.11153940.blogcont98527.62.4d126b80ucvIpF#h2-url-6\" title=\"@LINK\">【3】安全组应用案例六：允许公网远程连接实例（作者：阿里云）<sup>【注】</sup></a></li>\n<li><a href=\"https://support.huaweicloud.com/trouble-ecs/zh-cn_topic_0138293301.html\" title=\"@LINK\">【4】怎样长时间保持SSH会话连接不断开？（作者：华为云）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/ludongdong/article/details/78524653\" title=\"@LINK\">【5】mac 本地文件与服务器Linux文件之间的相互传输（作者：binary101010）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.jianshu.com/p/6d1a48cc6ce2\" title=\"@LINK\">【6】如何不挂起后台，继续运行jupyter（作者：aoaocool）<sup>【注】</sup></a></li>\n<li><a href=\"https://help.aliyun.com/knowledge_detail/42523.html\" title=\"@LINK\">【7】云服务器 ECS Linux SSH 客户端断开后保持进程继续运行配置方法（作者：阿里云）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.jianshu.com/p/300333a3f2ba\" title=\"@LINK\">【8】使用tmux保持远程ssh连接（作者：步晓德）<sup>【注】</sup></a></li>\n<li><a href=\"https://www.cnblogs.com/llkmst/p/4684097.html\" title=\"@LINK\">【9】Linux 修改swap虚拟内存大小（作者：L.L.K）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Note"],"tags":["Server","Linux","Cloud","云服务器","远程连接"]},{"title":"ML入门-线性回归简介","url":"/post/machinelearning/ml-linear/ml-linear-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-什么是回归\"><a href=\"#1-什么是回归\" class=\"headerlink\" title=\"1. 什么是回归\"></a>1. 什么是回归</h1><p>假设有一数据集 $D = { X_i, y_i }^N_{i = 1}$，其中 N 为训练样本数目，i 为样本索引，$X_i$ 为第 i 个样本的输入特征，$y_i$ 为第 i 个样本的输出/响应，那么：</p>\n<p><strong>根据训练样本 D，学习一个从输入 $X$ 到输出 $y$ 的映射 $f$，使得 $y_i = f(X_i)$，<font color=EB6D39>且 $y_i \\in R$</font>，这就是回归任务。</strong></p>\n<blockquote>\n<p>@注：没有特殊说明的情况下，$W$、$X$、$y$ 等均为矩阵（一维矩阵有时作为向量使用）形式，在强调向量性质时使用 $\\vec{X}$、$\\vec{W}$、$\\vec{y}$ 表示。</p>\n</blockquote>\n<p>回归任务的一个重要特征即为 $y_i \\in R$，当 $y_i$ 取类别型数值时，就变成了分类任务。</p>\n<p>当学习到回归任务的映射 f 后，即可对新的输入数据 $X$ 预测其输出 $\\hat{y} = f(X)$。</p>\n<hr>\n<h1 id=\"2-什么是线性回归\"><a href=\"#2-什么是线性回归\" class=\"headerlink\" title=\"2. 什么是线性回归\"></a>2. 什么是线性回归</h1><p>线性回归是最简单的回归模型之一：即从输入 $X$ 到输出 $y$ 的映射 $f$ 为线性关系：</p>\n<p>$<br>\\begin{aligned}<br>y &amp;= f(X) = W^T X<br>\\ &amp;= [w_0, w_1, …, w_D] \\begin{bmatrix} 1 \\ x_1 \\ … \\ x_D \\end{bmatrix} = w_0 + \\sum^D_{j = 1} w_j x_j<br>\\end{aligned}<br>$</p>\n<p>$X = (1, x_1, …, x_D)^T$</p>\n<p>其中，$w_0$ 为截距项/偏置（bias），$w_j$ 为第 j 维特征的权重/回归系数，$x_j$ 为第 j 维特征，D 为特征维数，j 为特征索引，$X$ 为特征向量。</p>\n<p>$X$ 在 D 维特征的基础上，再增加一个常数项1，与 $w_0$ 相乘作为截距项，是为了表达式更简洁。也即，$b（bias）= w_0$。</p>\n<p>假设有这么一个例子：根据在线广告投入费用预测每月电子商务销售量，其数据分布和预测直线如下图所示：</p>\n<center>\n\n<p><img data-src=\"./linear_predict.png\" alt=\"线性回归模型例\" title=\"@ASSET\"></p>\n</center>\n\n<p>在 Scikit-Learn 中，线性回归模型的建立过程大致如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用默认参数初始化</span></span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 训练</span></span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>\n\n<p>在图例中，所有的广告费用构成了 <code>X_train</code>，所有的销售量构成了 <code>y_train</code>，将数据对应输入到 <code>fit()</code> 方法中即可，以例中的数据解得最后的直线方程为：</p>\n<p>$$<br>y = 123.94 + 167.89 \\cdot x<br>$$</p>\n<p>其中 $w_0 = 123.94$，将需要预测的的输入 <code>2.8</code> 代入 x 即可求得 $\\hat{y} = 593.78$。</p>\n<p>不过需要注意的一点是，Scikit-Learn 中训练数据 $X$ 是一个二维数组，在本例中，输入只是长度为 6 的一维数组，因此需要先转换成 n 行 m 列的形式，使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">X_train = X_train.reshape(-<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>来指定列数为 1，行数自动调整。</p>\n<p><code>fit()</code> 完后，<code>lr</code> 这个实例化的线性回归模型对象内就会具有一个默认配置的线性回归参数 $W$，这些参数在经过 <code>fit()</code> 训练后就存在了 <code>lr</code> 对象内部，根据这些参数生成的直线即为图中绿色直线，这就是一个简单的线性回归模型了。</p>\n<hr>\n<h1 id=\"3-线性回归损失函数\"><a href=\"#3-线性回归损失函数\" class=\"headerlink\" title=\"3. 线性回归损失函数\"></a>3. 线性回归损失函数</h1><p>仍然以 “广告投入 - 销售量” 为例，在上文使用默认配置训练后得到了绿色的直线，假设通过手动配置，训练出了另一条蓝色直线：</p>\n<center>\n\n<p><img data-src=\"./two_predict_lines.png\" alt=\"两条回归直线\" title=\"@ASSET\"></p>\n</center>\n\n<p>显然，蓝色直线也是符合线性回归的定义的，因此需要使用预测残差来评价哪个线性模型更优。</p>\n<h2 id=\"3-1-预测残差\"><a href=\"#3-1-预测残差\" class=\"headerlink\" title=\"3.1 预测残差\"></a>3.1 预测残差</h2><p>根据例中表格数据可以求得：</p>\n<ul>\n<li>绿色直线在训练集上的预测残差为：-41.20, -35.64, 33.92, -8.92, -11.08, 62.91</li>\n<li>蓝色直线在训练集上的预测残差为：14, 10, 70, 204, 25, 142</li>\n</ul>\n<center>\n\n<p><img data-src=\"./two_lines_residual.png\" alt=\"两条直线预测残差\" title=\"@ASSET\"></p>\n</center>\n\n<p>由于绿色直线的预测残差有负值，在计算残差总和时会发生抵消，因此考虑使用平方计数，也就得到残差平方：</p>\n<p>$$<br>r^2 = (y - \\hat{y})^2<br>$$</p>\n<p>用残差平方来计算残差总和，就得到残差平方和 RSS（Residual Sum of Squares），根据定义显然可得其表达式为：</p>\n<font color=Eb6D39>\n\n<p>$$<br>RSS = \\sum^N_{i = 1} r^2_i = \\sum^N_{i = 1} (y_i - \\hat{y}_i)^2<br>$$</p>\n</font>\n\n<p>根据定义求得：</p>\n<ul>\n<li>绿色直线 RSS = 8277.32</li>\n<li>蓝色直线 RSS = 67601</li>\n</ul>\n<p>RSS 可以表示模型预测的整体性能，RSS 最小亦称为为最小二乘 OLS（Ordinary Least Square）。RSS 越小的直线预测越准确，因此显然，绿色直线比蓝色直线要好得多。</p>\n<h2 id=\"3-2-三种损失函数\"><a href=\"#3-2-三种损失函数\" class=\"headerlink\" title=\"3.2 三种损失函数\"></a>3.2 三种损失函数</h2><p>在机器学习中，用<font color=EB6D39>损失函数 L（Loss Function）</font>来<strong>度量</strong>样本真实值与模型预测值之间的差异，该差异用预测残差 r（Residual）来表示：$r = y - \\hat{y}$。</p>\n<p>常见的损失函数有三种：</p>\n<ul>\n<li>L2 损失</li>\n<li>L1 损失</li>\n<li>Huber 损失</li>\n</ul>\n<p>损失函数的意义在于，使得模型趋向于<strong>最小训练集上的损失（经验风险最小）</strong>，也即在模型训练时给予一个训练目标，使得训练出来的模型在训练集上的损失总和最小。由于模型的参数即为 $W$，因此定义一个目标函数：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i)<br>$$</p>\n<p>则模型训练的目标也就是求：$J(W)$ 最小。</p>\n<h3 id=\"3-2-1-L2损失\"><a href=\"#3-2-1-L2损失\" class=\"headerlink\" title=\"3.2.1 L2损失\"></a>3.2.1 L2损失</h3><p>在前面的例中，当损失函数采用 RSS 时，损失函数为二次函数，范数为 2，因此也称为 L2 损失（差的平方即为距离的 L2 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = (y - \\hat{y})^2 = r^2<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}<em>i) = \\sum^N</em>{i = 1} r^2_i<br>$$</p>\n<p>L2 损失是二次函数，因此最大的优点就是：处处可导，优化计算方便。但缺点也很明显：对噪声敏感。若数据中某点的预测残差 r 特别大（下图红点），经过平方放大后 $ r^2 $ 会更大，则会在模型中占主导作用，由于模型的训练目标是使得目标函数最小，在 L2 损失的模型中，也即使得 RSS 最小，因此会导致模型向该噪声点偏移（变为下图橙线）：</p>\n<center>\n\n<p><img data-src=\"./noise_in_l2.png\" alt=\"L2 损失对噪声敏感\" title=\"@ASSET\"></p>\n</center>\n\n<p>Scikit-Learn 中使用 L2 损失的线性回归模型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 L2 损失（线性回归默认使用 L2 损失）</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_lr = lr.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-L1损失\"><a href=\"#3-2-2-L1损失\" class=\"headerlink\" title=\"3.2.2 L1损失\"></a>3.2.2 L1损失</h3><p>为了减弱噪声点对模型的影响，同时保留损失函数“避免抵消正负”的特性，除了采用平方之外，还可以采用绝对值。当损失函数采用绝对值计量预测误差总和时，损失函数为绝对值函数，范数为 1，因此也称为 L1 损失（差的绝对值即为距离的 L1 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = |y - \\hat{y}| = |r|<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}<em>i) = \\sum^N</em>{i = 1} |r|_i<br>$$</p>\n<p>L1 函数是绝对值函数，因此最大的有点是：对噪声不敏感：</p>\n<center>\n\n<p><img data-src=\"./l2_l1_residual.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n</center>\n\n<p>但缺点同样明显：在零点处左右导数不相等，因此不可导，不便于优化计算。</p>\n<h3 id=\"3-2-3-Huber损失\"><a href=\"#3-2-3-Huber损失\" class=\"headerlink\" title=\"3.2.3 Huber损失\"></a>3.2.3 Huber损失</h3><p>为了结合 L2 和 L1 损失的优点，同时规避二者的缺点，可以考虑选择一个新的损失函数：其在靠近零点处表达式为 L2 损失，具有“可导”的优点，在远离零点处表达式为 L1 损失，具有“抗噪声”的优点，得到如下表达式：</p>\n<p>$$<br>L_{\\delta} (r) = \\left {<br>\\begin{aligned}<br>&amp; \\frac {1} {2} r^2 &amp;&amp; {|r| \\le \\delta}<br>\\<br>\\delta |r| &amp; - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>或代入预测残差：</p>\n<p>$$<br>L_{\\delta} (r) = \\left {<br>\\begin{aligned}<br>&amp; \\frac {1} {2} (y - \\hat{y})^2 &amp;&amp; {|r| \\le \\delta}<br>\\<br>\\delta |y &amp; - \\hat{y}| - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>Huber 损失的图像如下：</p>\n<center>\n\n<p><img data-src=\"./l1_l2_huber_lines.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n</center>\n\n<p>Huber 表达式中对 L2 和 L1 损失部分均有变形：</p>\n<ul>\n<li>取 L2 损失的部分，添加系数 $\\frac {1} {2}$ 的目的是抵消 $r^2$ 在求导时产生的系数 2。</li>\n<li>取 L1 损失的部分，添加一项 $- \\frac {1} {2} \\delta^2$ 的目的是使得函数在交点 δ 处（图中黑点标识）连续（当取 $|r| = \\delta$ 时，代入函数两段函数值相等）。</li>\n</ul>\n<p>Scikit-Learn 中实现了采用 Huber 损失的回归模型：HuberRegressor，其调用接口几乎相同：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 Huber 损失</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> HuberRegressor</span><br><span class=\"line\">huber = HuberRegressor()</span><br><span class=\"line\">huber.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_huber = huber.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"4-Scikit-Learn中的线性回归\"><a href=\"#4-Scikit-Learn中的线性回归\" class=\"headerlink\" title=\"4. Scikit-Learn中的线性回归\"></a>4. Scikit-Learn中的线性回归</h1><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只考虑了模型对训练样本的拟合程度：</p>\n<p>$$<br>J(W = \\sum^N_{i = 1} L(y_i, f(X_i; W))^2 = ||y - X W||^2_2<br>$$</p>\n<p>其中 $f(X_i; W) = \\hat{y}$</p>\n<p>Scikit-Learn 中的线性回归模型 <code>LinearRegression</code> 就是最小二乘线性回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LinearRegression</span></span><br><span class=\"line\">LinearRegression(fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                 copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）LinearRegression 类参数</strong></p>\n<p><code>fit_intercept</code>：<br>模型是否包含截距项。<br>如果数据在预处理时已经中心化（训练样本集 y 均值为0，则训练结果 $W_0$ 即为0），则可设置为 <code>False</code>。</p>\n<p><code>normalize</code>：<br>是否对输入特征 $X$ 做归一化。<br>对每一条样本，减去均值并除以 L2 模，使得模长变为 1，因此对数据归一化处理会使得超参数学习更加 Robust，且几乎和样本数目没有关系。但在回归中对样本归一化用的比较少，通常对特征标准化。</p>\n<p><code>copy_X</code>：<br>是否拷贝数据 $X$。<br>当设置为 <code>False</code> 时，对 $X$ 的操作会在原始数据集上完成从而覆盖原始数据。当原始数据后续不再需要使用时可以设置为 <code>False</code> 节省内存。</p>\n<p><code>n_jobs</code>：<br>并行计算时使用 CPU 的数目。<br>设置为 -1 表示使用所有 CPU 核，与显示设置为 CPU 核数目的效果相同。</p>\n<p><strong>（2）LinearRegression 类属性</strong></p>\n<p><code>coef_</code>：<br>回归系数，与特征维数相同。<br>也即特征权重 $\\hat{W}_0$，如果是多任务回归，则与标签 y 的维度相同。</p>\n<p><code>intercept_</code>：<br>截距项。<br>也即偏置（bias）：$b = \\hat{W}_0$</p>\n<p><strong>（3）LinearRegression 类方法</strong></p>\n<p><code>fit(X, y[, sample_weight])</code>：<br>训练模型。<br>X, y 为训练特征和标签，可通过 sample_weight 设置每个样本的权重。例如某个数据由多个设备采集，则高精度设备采集到的数据可以提高权重。</p>\n<p><code>predict(X)</code>：<br>使用已训练完成的模型进行预测。<br>输出即为预测值 $\\hat{y}$</p>\n<p><code>score(X, y[, sample_weight])</code>：<br>评估模型性能，返回模型预测的 $R^2$ 分数（y 与 $\\hat{y}$ 的差异）。<br>根据输入 X 利用模型计算出预测值 $\\hat{y}$ 并和真实值 y 比较。详见回归模型评价指标部分。</p>\n<blockquote>\n<p>@注：关于归一化、标准化、中心化的参考理解：</p>\n</blockquote>\n<p>（1）归一化：①把数据映射到区间 (0, 1) 或 (-1, 1)，主要为了数据处理方便。②把有量纲表达式转换为无量纲表达式，便于不同量级或单位的指标能进行比较和加权。</p>\n<p>（2）标准化：将数据转换为均值为 0（每个特征都减掉原始数据中该特征的均值），且标准差为 1。</p>\n<p>（3）中心化：将样本数据的输出 y 转换为均值为 0。</p>\n<hr>\n<h1 id=\"5-欠拟合与过拟合\"><a href=\"#5-欠拟合与过拟合\" class=\"headerlink\" title=\"5. 欠拟合与过拟合\"></a>5. 欠拟合与过拟合</h1><p>OLS 中，目标函数只考虑了模型对 <strong>训练样本</strong> 的拟合程度：</p>\n<p>$$<br>J(f) = RSS(f) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>因此在训练样本集上残差和可以接近甚至等于零。原则上，任意复杂的模型，若能完全拟合训练数据，则称为过拟合。反之若模型连训练样本都无法较好的拟合，则称为欠拟合：</p>\n<ul>\n<li><p>过拟合（Overfitting）：过于复杂的模型与训练数据拟合的太好，导致推广性和扩展性较差，因此和测试数据拟合的较差。</p>\n</li>\n<li><p>欠拟合（Underfitting）：过于简单的模型与训练数据尚且拟合的较差，更加不足以拟合测试数据。</p>\n</li>\n</ul>\n<blockquote>\n<p>@注：线性回归采用的线性模型比较简单，因此当特征维数不太高时，线性回归的过拟合现象通常不太严重。</p>\n</blockquote>\n<h2 id=\"5-1-sin-函数曲线实例\"><a href=\"#5-1-sin-函数曲线实例\" class=\"headerlink\" title=\"5.1 $\\sin$函数曲线实例\"></a>5.1 $\\sin$函数曲线实例</h2><p>假设数据产生模型为：$y = \\sin (2 \\pi x) + \\varepsilon$，其中 $\\sin$ 函数如下：</p>\n<center>\n\n<p><img data-src=\"./sin_function.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n</center>\n\n<p>$\\varepsilon$ 为白噪声（随机噪声），假设方差为 0.03：</p>\n<p>$<br>\\varepsilon \\sim N (0, 0.03^2)<br>$</p>\n<p>通常，$\\sin$ 函数需要使用无穷多阶多项式拟合，在此给定 $N = 10$ 共 10 个样本点，如上图中蓝点所示，采用 M 阶多项式拟合数据：</p>\n<p>$<br>y = \\sum^M_{j = 0} w_j x^j<br>$</p>\n<p>当有 10 个样本时，最多可以解出 10 个未知数（$M = 9$ 时可取 $w_0, …, w_9$ 共 10 个系数），分别取 $M = 0, 1, 3, 9$ 并绘制图形如下：</p>\n<center>\n\n<p><img data-src=\"./different_m_in_sin.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n</center>\n\n<p>（1）当 $M = 0$ 时，$y = w_0$，此时为了使 RSS 最小，则训练结果 $w_0 = \\bar{y}$。</p>\n<p>（2）当 $M = 9$ 时，可看出函数已经完全拟合了所有 10 个样本（函数通过每个样本点），此时训练集上 $RSS = 0$，但显然，该多项式并没有较好地表达数据的分布。</p>\n<h2 id=\"5-2-训练误差与测试误差\"><a href=\"#5-2-训练误差与测试误差\" class=\"headerlink\" title=\"5.2 训练误差与测试误差\"></a>5.2 训练误差与测试误差</h2><p>评价模型性能不能在训练集上评估，而应该在新的测试数据集上评估其 <strong>推广性</strong> / <strong>泛化能力（Generalization）</strong>。理论上，随着模型训练的进行，训练误差总是会越来越小，直到为零。根据如下误差计算公式：</p>\n<p>$$<br>E_{RMS} = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2}<br>$$</p>\n<p>统计各样本点的训练误差和测试误差：</p>\n<center>\n\n<p><img data-src=\"./loss_of_train_and_test.png\" alt=\"训练误差和测试误差\" title=\"@ASSET\"></p>\n</center>\n\n<p>从 $M = 3$ 开始，当模型复杂度继续增加时，训练误差继续下降，甚至为 0，而测试误差反而增大，此时发生了过拟合。在本例中，取 $M = 3$ 时的模型最理想，当 $M \\in [4, 8]$ 时，虽然测试误差没有增加，但模型复杂度增加，这是没有必要的（奥卡姆剃刀原理）。</p>\n<h2 id=\"5-3-过拟合时的模型参数\"><a href=\"#5-3-过拟合时的模型参数\" class=\"headerlink\" title=\"5.3 过拟合时的模型参数\"></a>5.3 过拟合时的模型参数</h2><p>统计当 $M$ 分别取 $0 \\sim 9$ 时训练出来的模型系数 $w_0 \\sim w_M$：</p>\n<center>\n\n<p><img data-src=\"./all_w_in_sin.png\" alt=\"所有 W 取值\" title=\"@ASSET\"></p>\n</center>\n\n<p>可以看到，随着阶数的增加，系数 $W$ 的绝对值越来越大，发生过拟合时，回归系数的 绝对值 / 平方值 很大，即使输入 $x$ 变化很小也可能带来 $y$ 很大的变化，函数的抖动很剧烈。</p>\n<h2 id=\"5-4-抑制过拟合\"><a href=\"#5-4-抑制过拟合\" class=\"headerlink\" title=\"5.4 抑制过拟合\"></a>5.4 抑制过拟合</h2><p>（1）增加训练样本数</p>\n<p>当训练数据增多时，同样使用九阶多项式拟合，也不会产生明显的过拟合现象：</p>\n<center>\n\n<p><img data-src=\"./add_train_data_set.png\" alt=\"增加训练样本\" title=\"@ASSET\"></p>\n</center>\n\n<p>通常，样本数 N 为系数数量（特征维度）D 的 5 ~ 10 倍时训练效果比较好。</p>\n<p>（2）目标函数增加正则项</p>\n<p>在给定有限训练样本数时，可通过在目标增加正则项减弱过拟合现象。同样 10 个样本，使用 9 阶多项式拟合，但加入 <strong>L2 正则项</strong>，即可得到 <strong>岭回归（Ridge Regression）</strong>：</p>\n<p>$$<br>J_{Ridge} (W, \\lambda) = \\sum^N_{i = 0} \\left( y_i - \\sum^M_{j = 0} w_j, x^j_i \\right)^2 + \\lambda \\sum^M_{j = 1} w^2_j<br>$$</p>\n<p>得到的拟合结果如下：</p>\n<center>\n\n<p><img data-src=\"./add_r_function.png\" alt=\"增加正则项\" title=\"@ASSET\"></p>\n</center>\n\n<p>统计模型系数 W 随正则参数 $\\lambda$ 的变化表：</p>\n<center>\n\n<p><img data-src=\"./change_of_w_with_lambda.png\" alt=\"W 随 $\\lambda$ 变化表\" title=\"@ASSET\"></p>\n</center>\n\n<p>当 $\\ln \\lambda = - \\infty$ 时，$\\lambda = 0$，此时相当于没有正则项。从表格可以看出，$\\ln \\lambda$ 越大，也即 $\\lambda$ 越大，对模型复杂度惩罚越多，回归系数的 绝对值 / 平方值 越小，模型越简单。训练误差及测试误差与正则参数的关系如下图：</p>\n<center>\n\n<p><img data-src=\"./loss_with_lambda.png\" alt=\"训练误差和测试误差与 $\\lmabda$ 的关系\" title=\"@ASSET\"></p>\n</center>\n\n<p>常用的正则项如下：</p>\n<p>① L2 正则（L2 范数：平方距离）：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>② L1 正则（L1 范数：绝对值距离）：$R(W) = ||W||<em>1 = \\sum^D</em>{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。<font color=EB6D39>这里需要注意，正则项求和中，只对 $1 \\sim D$ 求和，也即不惩罚截距项（Bias）$b = w_0$，因此在实际任务中，通常需要先对数据作中心化处理，去掉截距项的影响。</font></p>\n<p>还有一种 L0 正则（L0 范数：向量中非零元素数目）：$R(W) = ||W||_0$，但因为 L0 正则是 NP 问题，优化计算不方便，且 L1 范数是 L0 范数的最优凸近似，更方便优化计算，因此常用 L1 正则去近似 L0 正则。</p>\n<p>L1 / L0 正则可以得到稀疏解，因此可以起到特征选择的作用，这是因为当确定某个系数 $w_j = 0$ 时，对应的特征 $x_j$ 是无用的，在某些场景（如医学等）下，下一次采样可考虑去掉该特征。</p>\n<p>（3）减少噪声</p>\n<p>另一种抑制过拟合的方法是减少噪声，但在实际面对的任务中，大部分情况下训练数据是给定的，因此增加或调整正则项是抑制过拟合最常用的手段。</p>\n<blockquote>\n<p>@注：<font color=EB6D39>正则项发挥作用的理解：对于目标函数 $J(W, \\lambda) = Loss + \\lambda R(W)$，若模型过拟合，由于模型的训练目标是目标函数最小，过拟合时虽然 $Loss$ 可能较小，但模型过于复杂，回归系数的 绝对值 / 平方值 过大，导致目标函数整体较大，则增大 $\\lambda$，为了使得目标函数最小，模型会趋于减小 $W$，从而减小模型复杂度（$W$ 元素的值减小或非零元素减少都是减小模型复杂度）。当处于欠拟合状态，则 $Loss$ 较大，模型复杂度尚且不够拟合训练数据，此时减小 $\\lambda$，以增加模型复杂度。通常，训练的过程分为系数 $W$ 的训练和超参数 $\\lambda$ 的训练，使用某个超参数训练出系数后，模型复杂度即确定下来，再去搜索最优的超参数即可。</font></p>\n</blockquote>\n<hr>\n<h1 id=\"6-带正则的线性回归\"><a href=\"#6-带正则的线性回归\" class=\"headerlink\" title=\"6. 带正则的线性回归\"></a>6. 带正则的线性回归</h1><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只包括训练集上的损失和（经验风险），也即仅考虑了模型对训练样本的拟合程度，因此可能会导致模型太过于复杂，甚至训练误差为0，产生过拟合。为此可在原目标函数中加入正则项，使得模型不会太复杂。则目标函数变为损失和 + 正则项：</p>\n<p>$$<br>J(W, \\lambda) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>其中 R 为 Risk，表示 $W$ 复杂度的风险，新的目标函数也称为 <strong>结构风险</strong>。正则项的加入使目标函数符合奥拉姆剃刀（Occam’s Razor）原理：简单有效，选择能解释数据的模型中最简单的一个。</p>\n<p>常用的正则项有：L2 正则、L1 正则。</p>\n<p>（1）L2 正则：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>（2）L1 正则：$R(W) = ||W||<em>1 = \\sum^D</em>{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。</p>\n<h2 id=\"6-1-岭回归\"><a href=\"#6-1-岭回归\" class=\"headerlink\" title=\"6.1 岭回归\"></a>6.1 岭回归</h2><p>岭回归（Ridge）：L2 损失 + L2 正则 + LinearRegression。</p>\n<p>岭回归正则项对截距项不施加惩罚，也即：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} w^2_j，（j 从 1 开始）<br>$$</p>\n<p>线性模型中增加常数项 $x_0 = 1$ 用于表示截距项：</p>\n<p>$$<br>f(X; W) = W^T X = \\sum^D_{j = 0} w_j x_j，（j 从 0 开始）<br>$$</p>\n<p>当 j = 0 时，$x_0 = 1 \\rightarrow w_0 x_0 = w_0$ 作为截距项。因此而得岭回归目标函数（目标函数的损失和部分不惩罚截距项，所以目标函数不需要从 0 开始）：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\ &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\ &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的岭回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=<span class=\"string\">&#x27;auto&#x27;</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）Ridge 类参数</strong></p>\n<p><code>alpha</code>：<br>正则参数，也即正则项中的 λ。<br>目标：求 $\\arg_W \\min (||X W - y||^2_2 + \\alpha ||W||^2_2)$</p>\n<p>部分参数与 LinearRegression 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<p><strong>（2）Ridge 类属性</strong></p>\n<p>与 LinearRegression 相同。</p>\n<p><strong>（3）Ridge 类方法</strong></p>\n<p>与 LinearRegression 相同。</p>\n<h2 id=\"6-2-Lasso\"><a href=\"#6-2-Lasso\" class=\"headerlink\" title=\"6.2 Lasso\"></a>6.2 Lasso</h2><p>Lasso（Least <strong>Absolute</strong> <strong>Shrinkage</strong> and <strong>Selection</strong> Operator）：L2 损失 + L1 正则 + LinearRegression。</p>\n<p>Lasso 有三个关键点：</p>\n<ul>\n<li>Absolute：表示用的是 L1 正则，绝对值的模。</li>\n<li>Shrinkage：相比普通的线性回归，L1 正则会使得 $W$ 有一定收缩。</li>\n<li>Selection：L1 正则可能使得 $W$ 中某些元素变为 0 得到稀疏解，从而起到特征选择的作用。</li>\n</ul>\n<p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\<br>&amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |w_j|<br>\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的 Lasso：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）Lasso 类参数</strong></p>\n<p>大部分与 Ridge 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<p><strong>（2）Ridge 类属性</strong></p>\n<p>与 LinearRegression 相同。</p>\n<p><strong>（3）Ridge 类方法</strong></p>\n<p>与 LinearRegression 相同。</p>\n<h2 id=\"6-3-弹性网络\"><a href=\"#6-3-弹性网络\" class=\"headerlink\" title=\"6.3 弹性网络\"></a>6.3 弹性网络</h2><p>弹性网络：L2 损失 + （L1 正则 + L2 正则） + LinearRegression。</p>\n<p>在 性网络中，使用 ρ 表示 L1 正则所占比例，$\\dfrac {(1 - \\rho)} {2}$ 表示 L2 正则所占比例：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} \\left( \\rho |w_j| + \\dfrac {(1 - \\rho)} {2} w^2_j \\right)<br>$$</p>\n<p>弹性网络的目标函数：</p>\n<p>$$<br>J(W; \\lambda; \\rho) = \\dfrac {1} {2N} ||y - X W||^2_2 + \\lambda \\left( \\rho ||W||_1 + \\dfrac {(1 - \\rho)} {2} ||W||^2_2 \\right),\\ \\ \\ \\ \\ 0 \\le \\rho \\le 1<br>$$</p>\n<p>Scikit-Learn 中使用 ElasticNet 实现弹性网络：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.ElasticNet</span></span><br><span class=\"line\">ElasticNet(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">           l1_ratio=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">           fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">           warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           postive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）ElasticNet 类参数</strong></p>\n<p><code>l1_ratio</code>：<br>即正则比例参数 ρ。</p>\n<p>大部分参数与 Lasso 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<p><strong>（2）ElasticNet 类属性</strong></p>\n<p>与 LinearRegression 相同。</p>\n<p><strong>（3）ElasticNet 类方法</strong></p>\n<p>与 LinearRegression 相同。</p>\n<p>当取 ρ = 0 时，正则项仅为 L2 正则，当取 ρ = 1 时，正则项仅为 L1 正则。弹性网络的正则项有如下效果：</p>\n<ul>\n<li>L2 正则使得线性回归系数 $W$ 收缩，模型稳定。</li>\n</ul>\n<p>当输入特征之间存在共线性时，使用 L2 正则。</p>\n<ul>\n<li>L1 正则也会收缩回归系数 $W$。当正则参数取合适值时，L1 正则使得有些回归系数为 0，得到稀疏模型。</li>\n</ul>\n<p>当输入特征比较多，优先特征和目标便梁志坚相关性很弱时，L1 正则可能只选择强相关的特征，模型解释性较好。若 $\\lambda_{max}$ 为某临界值，当取 $\\lambda \\ge \\lambda_{max}$ 时，$W = 0$。</p>\n<p><strong>注意</strong>：由于正则项中对不同维度的 $W_j$ 同等对待，对输入特征 $X$ 最好做去量纲（Scaling）处理，使得不同维度的特征取值范围大致相同（如标准化：<code>sklearn.preprocessiong.StandardScaler</code>）。</p>\n<blockquote>\n<p>@注：去量纲的常用方法：</p>\n<ul>\n<li><p>归一化（Normalization）：例如 Min-Max Scaler</p>\n</li>\n<li><p>标准化（Standardization）：例如 Z-Score</p>\n</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-线性回归三种求解","url":"/post/machinelearning/ml-linear/ml-linear-solutions/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-解析法\"><a href=\"#1-解析法\" class=\"headerlink\" title=\"1. 解析法\"></a>1. 解析法</h1><p>在给定正则参数（超参数）λ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W)$，满足最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W)} {\\partial W} = 0$。</p>\n<h2 id=\"1-1-OLS最优解析解\"><a href=\"#1-1-OLS最优解析解\" class=\"headerlink\" title=\"1.1 OLS最优解析解\"></a>1.1 OLS最优解析解</h2><p><strong>（1）正规方程组</strong></p>\n<p>对 OLS 目标函数矩阵形式展开：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 = (y - X W)^T (y - X W)<br>\\<br>&amp;= y^T y - y^T X W - W^T X^T y + W^T X^T X W<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的转置运算有：$A^T B = B^T A$，也即 $y^T X W = W^T X^T y$，因此上式等价于：</p>\n<p>$$<br>J(W) = y^T y - 2 W^T X^T y + W^T X^T X W<br>$$</p>\n<p>因此满足 OLS 最优解即：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;\\dfrac {\\partial J(W)} {\\partial W} = 0<br>\\<br>\\Longrightarrow \\quad &amp;\\dfrac { \\partial (y^T y - 2 W^T X^T y + W^T X^T X W)} { \\partial W } = 0 \\quad（0 矩阵）<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的微分运算有：</p>\n<p>$<br>\\begin{aligned}<br>&amp;① \\quad \\dfrac {\\partial (A^T B)} {\\partial A} = B<br>\\<br>&amp;② \\quad \\dfrac {\\partial (A^T B A)} {\\partial A} = (B^T + B) A<br>\\end{aligned}<br>$</p>\n<p>进而得到下式：</p>\n<p>$$<br>0 - 2 X^T y + [ (X^T X)^T + (X^T X) ] W = 0<br>$$</p>\n<p>根据矩阵的运算法则有：</p>\n<p>$<br>\\begin{aligned}<br>\\because \\quad &amp;X^T X = (X)^T (X^T)^T = (X^T X)^T<br>\\<br>\\therefore \\quad &amp;X^T X 为对称矩阵<br>\\<br>\\Longrightarrow \\quad &amp;X^T X = (X^TX)^T<br>\\end{aligned}<br>$</p>\n<p>进一步合并得：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;-2 X^T y + 2 X^T X W = 0<br>\\<br>&amp;\\Longrightarrow X^T X W = X^T y \\quad （正规方程组）<br>\\<br>&amp;\\Longrightarrow \\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>\\end{aligned}<br>$$</p>\n<p>这种求解方式也称为用正规方程组解析求解最小二乘线性回归。但在解析 $ \\hat{W}_{OLS} $ 的过程中涉及到了逆矩阵的计算，应当避免。</p>\n<p><strong>（2）Moore-Penrose广义逆</strong></p>\n<p>通常，训练的目标是 OLS 目标函数 $J(W) = ||y - XW||^2_2$ 最小，通俗来讲也即 $y$ 与 $X W$ 越接近越好，最好的情况即求解：$y = X W$。</p>\n<p>（1）假如 $X$ 为方阵，则可以求其逆：$W = X^{-1} y$，</p>\n<p>（2）假如 $X$ 不为方阵，则求其逆矩阵无意义，可求 Moore-Penrose 广义逆：$W = X^+ y$</p>\n<blockquote>\n<p>@注：广义逆的符号为：</p>\n<p><img data-src=\"./pseudoinverse.png\" alt=\"广义逆符号\" title=\"@ASSET\"> </p>\n<p>LaTeX 代码为 <code>X^&#123;\\dag&#125;</code>，但 Hexo 不支持引入宏包无法显示，因此使用 $X^+$ 代替。</p>\n</blockquote>\n<p>Moore-Penrose 广义逆可采用奇异值分解（Singular Value Decomposition, SVD）实现：</p>\n<p>$<br>\\begin{aligned}<br>&amp;若有：X = U \\Sigma V^T,<br>\\<br>&amp;其中 U, V 为正交阵，\\Sigma 为对角阵（不一定为方阵）<br>\\<br>&amp;则：X^+ = V \\Sigma^+ V^T<br>\\end{aligned}<br>$</p>\n<p>对角阵 $\\Sigma$ 求伪逆，则将非零元素求倒数即可：</p>\n<p>$$<br>\\Sigma = \\left(<br>\\begin{matrix}<br> \\lambda_1 &amp; 0         &amp; \\cdots &amp; 0<br> \\<br> 0         &amp; \\lambda_2 &amp; \\cdots &amp; 0<br> \\<br> \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots<br> \\<br> 0         &amp; 0         &amp; \\cdots &amp; 0<br> \\<br>\\end{matrix}<br>\\right),<br>\\Sigma^+ = \\left(<br>\\begin{matrix}<br> \\dfrac 1 \\lambda_1 &amp; 0                  &amp; \\cdots &amp; 0<br> \\<br> 0                  &amp; \\dfrac 1 \\lambda_2 &amp; \\cdots &amp; 0<br> \\<br> \\vdots             &amp; \\vdots             &amp; \\ddots &amp; \\vdots<br> \\<br> 0                  &amp; 0                  &amp; \\cdots &amp; 0<br> \\<br>\\end{matrix}<br>\\right),<br>$$</p>\n<p>这也是 Scikit-Learn 中 LinearRegression 推荐的求解方式。</p>\n<h2 id=\"1-2-Ridge最优解析解\"><a href=\"#1-2-Ridge最优解析解\" class=\"headerlink\" title=\"1.2 Ridge最优解析解\"></a>1.2 Ridge最优解析解</h2><p>Ridge 比 OLS 多一个 L2 正则，目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\<br>&amp;= (y - X W)^T (y - X W) + \\lambda W^T W<br>\\end{aligned}<br>$$</p>\n<p>其最优解也采用 SVD 分解的方式实现。求解偏导数等于零：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial J(W)} {\\partial W} &amp;= -2 X^T y + 2 (X^T X) W + 2 \\lambda W = 0<br>\\<br>\\Longrightarrow \\hat{W}_{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\<br>&amp;（其中 I 为 D \\times D 的单位阵）<br>\\end{aligned}<br>$$</p>\n<p>对比 OLS 的解：</p>\n<p>$$<br>\\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>$$</p>\n<p>对 Ridge 的解进行变形，配出一个 $\\hat{W}_{OLS}$：</p>\n<p>$$<br>\\begin{aligned}<br>\\hat{W}<em>{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) (X^T X)^{-1} X^T y<br>\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) \\hat{W}</em>{OLS}<br>\\end{aligned}<br>$$</p>\n<p>将 $(X^T X + \\lambda I)^{-1}$ 看成是分母，将 $(X^T X)$ 看成分子，由于 $(X^T X + \\lambda I) &gt; (X^T X)$，因此有 $\\hat{W}<em>{Ridge} &lt; \\hat{W}</em>{OLS}$。</p>\n<p>因此 $\\hat{W}<em>{Ridge} $ 在 $ \\hat{W}</em>{OLS}$ 的基础上进行了收缩，L2 正则也称为权重收缩。</p>\n<h2 id=\"1-3-总结\"><a href=\"#1-3-总结\" class=\"headerlink\" title=\"1.3 总结\"></a>1.3 总结</h2><p>（1）OLS 的解为：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，需要对矩阵 $X^T X$ 求逆。</p>\n<ul>\n<li>当输入特征存在共线性（某些特征可以用其他特征的线性组合表示），矩阵 X 是接近不满秩，矩阵 $X^T X$ 接近奇异，求逆不稳定。</li>\n</ul>\n<p>（2）Ridge 的解为：$\\hat{W}_{Ridge} = (X^T X + \\lambda I)^{-1} X^T y$，需要对矩阵 $(X^T X + \\lambda I)$ 求逆。</p>\n<ul>\n<li>即使输入特征存在共线性，矩阵 $X$ 不满秩，矩阵 $X^T X$ 对角线存在等于 0 或接近于 0 的元素，但 $0 + \\lambda \\ne 0$，$(X^T X + \\lambda I)$ 求逆仍可得到稳定解。因此岭回归 Ridge 在输入特征存在共线性的情况仍然能得到稳定解。</li>\n</ul>\n<p>（3）Lasso 无法无法求得解析解，可以用迭代求解。</p>\n<hr>\n<h1 id=\"2-梯度下降法\"><a href=\"#2-梯度下降法\" class=\"headerlink\" title=\"2. 梯度下降法\"></a>2. 梯度下降法</h1><h2 id=\"2-1-梯度下降法思想\"><a href=\"#2-1-梯度下降法思想\" class=\"headerlink\" title=\"2.1 梯度下降法思想\"></a>2.1 梯度下降法思想</h2><p>解析求解法对 N x D 维矩阵 X 进行 SVD 分解的复杂度为：$O(N^2 D)$。</p>\n<ul>\n<li>当样本数 N 很大或特征维度 D 很大时，SVD 计算复杂度高，或机器的内存根本不够。</li>\n<li>可采用迭代求解的方法：梯度下降法、随机梯度下降法、次梯度法、坐标轴下降法等。</li>\n<li>梯度下降法（Gradient Descent）是求解无约束优化问题最常采用的方法之一。</li>\n</ul>\n<p>在微积分中，一元函数 $f(x)$ 在 $x$ 处的梯度为函数在该点的导数 $\\dfrac {df} {dx}$。</p>\n<p>对应在多元函数 $f(x_1, …, x_D)$ 中，在点 $x = (x_1, …, x_D)$ 处共有 D 个偏导数：$\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D}$。将这 D 个偏导数组合成一个 D 维的矢量 $(\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D})^T$，即称为函数 $f(x_1, …, x_D)$ 在点 $x$ 处的梯度，一般记为 $\\nabla$ 或 $grad$，即：</p>\n<p>$$<br>\\nabla f(x_1, …, x_D) = grad \\ f(x_1, …, x_D) = (\\dfrac {\\partial f} {\\partial x_1}, …, \\dfrac {\\partial f} {\\partial x_D})^T<br>$$</p>\n<p>（1）从几何意义上讲，某点的梯度是函数在该点变化最快的地方。</p>\n<p>（2）沿着梯度方向，函数增加最快，更容易找到函数的最大值</p>\n<p>（3）沿负梯度方向，函数减少最快，更容易找到函数的最小值。</p>\n<blockquote>\n<p>@注：$\\nabla$ 发音为 nabla，表示微分，不属于希腊字符，只是一个记号。</p>\n</blockquote>\n<p>正负梯度的例子如下：</p>\n<center>\n\n<p><img data-src=\"./gradient_demo.png\" alt=\"梯度示意图\" title=\"@ASSET\"></p>\n</center>\n\n\n<p>在计算 $f(x)$ 的最小值时，当函数形式比较简单且数据量小，可用解析计算 $ f’(x) = 0 $，否则可用迭代法求解：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $x^{t = 0}$ 为初始值；</p>\n<p>（2）找到下一个点 $x^{t + 1}$，使得函数值越来越小，即 $f(x^{t + 1}) &lt; f(x^t)$；</p>\n<p>（3）重复，直到函数值不再见小，则已经找到函数的 <strong>局部极小值</strong>。</p>\n<blockquote>\n<p>@注：该方法仅能找到局部极小值。</p>\n</blockquote>\n<p>为此，可以对该迭代方案进行改进：</p>\n<ul>\n<li><p>（1）随机寻找初始值时，初始化多个点；</p>\n</li>\n<li><p>（2）最后从多个局部极小值中取最小的作为最终的极小值。</p>\n</li>\n</ul>\n<h2 id=\"2-2-梯度下降法数学解释\"><a href=\"#2-2-梯度下降法数学解释\" class=\"headerlink\" title=\"2.2 梯度下降法数学解释\"></a>2.2 梯度下降法数学解释</h2><p>对函数 $f(x)$ 进行一节泰勒展开得到：</p>\n<p>$$<br>f(x + \\Delta x) \\approx f(x) + \\Delta x \\nabla f(x)<br>$$</p>\n<p>要找到函数的最小值，也即每一次步进 $\\Delta x$ 后的函数值均小于原函数值，因此有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; f(x + \\Delta x) &lt; f(x)<br>\\<br>\\Longrightarrow &amp; \\Delta x \\nabla f(x) &lt; 0<br>\\end{aligned}<br>$$</p>\n<p>假设令 $\\Delta x = - \\eta \\nabla f(x), \\ \\ (\\eta &gt; 0)$，其中步长 $\\eta$ 为一个较小的正数，从而有：</p>\n<p>$$<br>\\Delta x \\nabla f(x) = - \\eta \\left( \\nabla f(x) \\right)^2 &lt; 0<br>$$</p>\n<p>令 $\\Delta x = - \\eta \\nabla f(x)$ 即可确保 $\\left( \\nabla f(x) \\right)^2 &gt; 0$。</p>\n<p>因此，对 $x$ 的更新为：$x^{t + 1} = x + \\Delta x = x^t - \\eta \\nabla f(x)$，也即 $x$ 向负梯度方向 $- \\eta \\nabla f(x)$ 移动步长 $\\eta$，会使得$f(x^{t + 1}) &lt; f(x^t)$，$\\eta$ 也称为学习率。</p>\n<p>由于只对 $f(x)$ 进行一阶泰勒展开，因此梯度下降法是一阶最优化算法。</p>\n<h2 id=\"2-3-OLS的梯度下降\"><a href=\"#2-3-OLS的梯度下降\" class=\"headerlink\" title=\"2.3 OLS的梯度下降\"></a>2.3 OLS的梯度下降</h2><p>OLS 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\<br>&amp;= ||y - X W||^2_2<br>\\<br>&amp;= (y - X W)^T (y - X W)<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W = -2 X^T (y - X W)<br>$$</p>\n<p>梯度下降：</p>\n<p>$$<br>\\begin{aligned}<br>W^{t + 1} &amp;= W^t - \\eta \\nabla J(W^t)<br>\\<br>&amp;= W^t + 2 \\eta X^T (y - X W^T)<br>\\end{aligned}<br>$$</p>\n<p>其中 $(y - X W^T)$ 即为预测残差 r，说明参数的更新量与输入 X 和预测残差 r 的相关性有关。$X^T$ 与 r 的相关性较强时需要把 $\\eta$ 调大一些，则 r 逐渐与输入 $X^T$ 无关，直到无需再更新 W。</p>\n<p>OLS 的梯度下降过程：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $W^{t = 0}$ 为初始值（或 0）；</p>\n<p>（2）计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$；</p>\n<p>（3）根据学习率 $\\eta$，更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$；</p>\n<p>（4）判断是否满足迭代终止条件。若满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t + 1})$，否则跳转至第 2 步。</p>\n<p>迭代终止条件有：</p>\n<p>（1）迭代次数达到预设的最大次数。</p>\n<p>（2）迭代过程中目标函数的变化值小于预设值：$\\dfrac{J(W^t) - J(W^{t + 1})}{J(W^t)} \\le \\varepsilon$。</p>\n<h2 id=\"2-4-Ridge的梯度下降\"><a href=\"#2-4-Ridge的梯度下降\" class=\"headerlink\" title=\"2.4 Ridge的梯度下降\"></a>2.4 Ridge的梯度下降</h2><p>Ridge 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W + 2 \\lambda W<br>$$</p>\n<p>Ridge 的梯度下降过程与 OLS 的相同。</p>\n<h2 id=\"2-5-Lasso次梯度法\"><a href=\"#2-5-Lasso次梯度法\" class=\"headerlink\" title=\"2.5 Lasso次梯度法\"></a>2.5 Lasso次梯度法</h2><p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |W_j|<br>\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>绝对值函数 &amp;||W||_1&amp; 在原点 $W = 0$ 处不可导，无法使用梯度下降求解。</p>\n<p>（1）可用次梯度概念替换梯度，得到次梯度法。</p>\n<p>（2）或用坐标轴下降求解。</p>\n<h2 id=\"2-6-梯度下降的实用Tips\"><a href=\"#2-6-梯度下降的实用Tips\" class=\"headerlink\" title=\"2.6 梯度下降的实用Tips\"></a>2.6 梯度下降的实用Tips</h2><p>（1）梯度下降中的学习率 η 需要小心设置。太大可能引起目标函数震荡，太小收敛速度过慢，可以采用自适应学习率的方案：</p>\n<center>\n\n<p><img data-src=\"./different_eta.png\" alt=\"不同 η 的影响\" title=\"@ASSET\"></p>\n</center>\n\n<p>（2）梯度下降对特征的取值范围敏感，建议对输入特征 X 做去量纲处理（可用 sklearn.preprocessing.StandardScaler 实现）：</p>\n<p>$$<br>W^{t + 1} = W^t + 2 \\eta X^T (y - X W^t) \\ \\ \\ \\ （与输入 X 的取值有关）<br>$$</p>\n<p>梯度下降算法延伸阅读：<a href=\"https://www.analyticsvidhya.com/blog/2017/03/introduction-to-gradient-descent-algorithm-along-its-variants/\" title=\"@LINK\">Introduction to Gradient Descent Algorithm (along with variants) in Machine Learning</a></p>\n<h2 id=\"2-7-随机梯度下降\"><a href=\"#2-7-随机梯度下降\" class=\"headerlink\" title=\"2.7 随机梯度下降\"></a>2.7 随机梯度下降</h2><p>在机器学习模型中，目标函数形式为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>梯度形式为：</p>\n<p>$$<br>\\nabla J(W^t) = \\sum^N_{i = 1} \\nabla L \\left( y_i, f(X_i; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>当样本中存在信息冗余（正负抵消或梯度相似）时效率不高，因此可以使用随机梯度下降，即每次梯度下降更新时只计算一个样本上的梯度：</p>\n<p>$$<br>\\nabla J(W^t) = \\nabla L \\left( y_t, f(X_t; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>通俗而言，每一次迭代时，随机选择一个样本，向该样本的负梯度方向移动一步。梯度下降法每一次迭代都需要计算所有样本的梯度，随机梯度下降每一次迭代仅需计算单个样本的梯度：</p>\n<p>（1）为了确保收敛，相比于同等条件下的梯度下降，随机梯度下降需要采用更小的步长和更多的迭代轮数。</p>\n<p>（2）相比于非随机算法，随机梯度下降在前期的迭代效果卓越。</p>\n<p>小批量梯度下降法：介于一次使用所有样本（批处理梯度下降）和一次只是用一个样本（随机梯度下降）之间，也即在随机梯度下降中，每次使用一个小批量的样本代替单个样本。实践中常采用小批量样本（mini-batch）下降。</p>\n<blockquote>\n<p>随机梯度下降参考文章：</p>\n<p>① “Stochastic Gradient Descent” L. Bottou - Website, 2010<br>② “The Tradeoffs of Large Scale Machine Learning” L. Bottou - Website, 2011</p>\n</blockquote>\n<h2 id=\"2-8-Ridge和SGDRegressor\"><a href=\"#2-8-Ridge和SGDRegressor\" class=\"headerlink\" title=\"2.8 Ridge和SGDRegressor\"></a>2.8 Ridge和SGDRegressor</h2><h3 id=\"2-8-1-Ridge\"><a href=\"#2-8-1-Ridge\" class=\"headerlink\" title=\"2.8.1 Ridge\"></a>2.8.1 Ridge</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=’auto’,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）其中与优化计算有关的参数如下</strong></p>\n<p><code>max_iter</code>：<br>共轭梯度求解器的最大迭代次数。<br>对于优化算法 solver 为 ‘sparse_cg’ 和 ‘lsqr’，则默认值由 <code>scipy.sparse.linalg</code> 确定，对于 ‘sag’ 求解器，默认值为 1000。</p>\n<p><code>tol</code>：<br>解的精度，判断迭代收敛与否的阈值。<br>当（loss &gt; previous_loss - tol）时迭代终止。</p>\n<p><code>solver</code>：<br>求解最优化问题的算法。<br>可取：’auto’，’svd’，’cholesky’，’lsqr’，’sparse_cg’，’sag’，’saga’。</p>\n<p><code>random_state</code>：<br>数据洗牌时的随机种子。<br>仅用于 ‘sag’ 求解器。</p>\n<p><strong>（2）其中求解器 <code>solver</code> 可选的算法如下</strong></p>\n<p><code>auto</code>：<br>根据数据类型自动选择求解器。<br>默认算法。</p>\n<p><code>svd</code>：<br>使用 X 的奇异值分解来计算 Ridge 系数。<br>对于奇异矩阵，比 ‘cholesky’ 更稳定。</p>\n<p><code>cholesky</code>：<br>使用标准的 <code>scipy.linalg.solve</code> 函数获得解析解。</p>\n<p><code>sparse_cg</code>：<br>使用 <code>scipy.sparse.linalg.cg</code> 中的共轭梯度求解器。<br>对大规模数据，比“cholesky”更合适。</p>\n<p><code>lsqr</code>：<br>使用专用的正则化最小二乘常数 <code>scipy.sparse.linalg.lsqr</code>。<br>速度最快。</p>\n<p><code>sag</code>：<br>使用随机平均梯度下降。<br>当样本数 n_samples 和特征维数 n_feature 都很大时，通常比其他求解器更快。</p>\n<p><code>saga</code>：<br>‘sag’ 的改进算法。<br>当 <code>fit_intercept</code> 为 <code>True</code> 时，’sag’ 和 ‘saga’ 只支持稀疏输入。’sag’ 和 ‘saga’ 快速收敛仅在具有近似相同尺度的特征上被保证，因此数据需要标准化。</p>\n<h3 id=\"2-8-2-SGDRegressor\"><a href=\"#2-8-2-SGDRegressor\" class=\"headerlink\" title=\"2.8.2 SGDRegressor\"></a>2.8.2 SGDRegressor</h3><p>Scikit-Learn 中实现了随机梯度下降回归：SGDRegressor，其对大数据量训练集（n_sample &gt; 10000）的回归问题合适。</p>\n<p>SGDRegressor 的目标函数为：</p>\n<p>$$<br>J(W) = \\dfrac {1} {N} \\sum^N_{i = 1} L \\left( y_i, f(X_i) \\right) + \\alpha R(W)<br>$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDRegressor</span></span><br><span class=\"line\">SGDRegressor(loss=<span class=\"string\">&#x27;squared_loss&#x27;</span>,</span><br><span class=\"line\">             penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">             alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">             l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">             fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">             random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             learning_rate=<span class=\"string\">&#x27;invscaling&#x27;</span>,</span><br><span class=\"line\">             eta0=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">             power_t=<span class=\"number\">0.25</span>,</span><br><span class=\"line\">             warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>（1）参数 <code>loss</code> 支持的损失函数包括：</p>\n<ul>\n<li><code>squared_loss</code>：L2 损失。</li>\n<li><code>huber</code>：Huber 损失。</li>\n<li><code>epsilon_insensitive</code>：ɛ 不敏感损失 (如：SVM)</li>\n<li><code>squared_epsilon_insensitive</code></li>\n</ul>\n<p>（2）参数 <code>penalty</code> 支持的正则函数包括：</p>\n<ul>\n<li><code>none</code>：无正则</li>\n<li><code>l2</code>：L2正则</li>\n<li><code>l1</code>：L1正则</li>\n<li><code>elasticnet</code>：L1 正则 + L2 正则（配合参数 <code>l1_ratio</code> 为 L1 正则的比例）</li>\n</ul>\n<p>（3）参数 <code>epsilon</code> 是某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）需要的额外参数。</p>\n<p>（4）参数 <code>alpha</code> 是正则惩罚系数，也用于学习率计算。</p>\n<p>（5）优化算法有关的参数包括：</p>\n<p><code>max_iter</code>：<br>最大迭代次数（访问训练数据的次数，Epoches 的次数），默认值 5。<br>一个迭代循环只使用一个随机样本的梯度，并且循环所有的样本，则称为一个 Epoches。SGD 在接近 $10^6$ 的训练样本时收敛。因此可将迭代数设置为 np.ceil($10^6$ / 𝑁)，其中 𝑁 是训练集的样本数目。参数 <code>n_iter</code> 意义相同，已被抛弃。</p>\n<p><code>tol</code>：<br>停止条件。<br>如果不为 ‘None’，则当（loss &gt; previous_loss - tol）时迭代终止。</p>\n<p><code>shuffle</code>：<br>每轮 SGD 之前是否重新对数据进行洗牌。</p>\n<p><code>random_state</code>：<br>随机种子，Scikit-Learn 中与随机有关的算法均有此参数，含义相同。<br>当参数 <code>shuffle == True</code> 时使用。如果随机种子相同，每次洗牌得到的结果一样。可设置为某个整数以复现结果。</p>\n<p><code>learning_rate</code>：<br>学习率。<br>支持 3 种选择：<br>① ‘constant’：$\\eta = \\eta_0$。<br>② ‘optimal’：$\\eta = 1.0 / \\alpha * (t + t_0)$，分类任务中随机梯度下降默认值。<br>③ ‘invscaling’：$\\eta = \\eta_0 / pow(t, \\ power_t)$，回归任务重随机梯度下降默认值。</p>\n<p><code>warm_start</code>：<br>是否从之前的结果继续。<br>随机梯度下降中初始值可以是之前的训练结果，支持在线学习，即可以在原来的学习基础上继续学习新加入的样本并更新模型参数（输出）。初始值可在 <code>fit</code> 函数中作为参数传递。</p>\n<p><code>average</code>：<br>是否采用平均随机梯度下降法（ASGD）。</p>\n<hr>\n<h1 id=\"3-次梯度法\"><a href=\"#3-次梯度法\" class=\"headerlink\" title=\"3. 次梯度法\"></a>3. 次梯度法</h1><p>当函数可导时，梯度下降法是非常有效的优化算法。但 Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$，其中正则项 $||W||_1$ 为绝对值函数，在 $W_j = 0$ 处不可导，无法计算梯度，也无法用梯度下降法求解。因此需要将梯度扩展为次梯度，用次梯度法求解该问题。</p>\n<p>为了处理不平滑函数，扩展导数的表示。定义一个凸函数 $f$ 在点 $x_0$ 处的 <strong>次导数</strong> 为一个标量 g，使得：</p>\n<p>$<br>f(x) - f(x_0) \\ge g(x - x_0), \\forall x \\in \\mathrm{I}<br>$</p>\n<p>其中 $\\mathrm{I}$ 为包含 $x_0$ 的某个区间。如下图所示，对于定义域中的任何 $x_0$，总可以做一条直线通过点 $(x_0, f(x_0))$，且直线要么接触 $f$，要么在其下方：</p>\n<center>\n\n<p><img data-src=\"./subderivative.png\" alt=\"次导数\" title=\"@ASSET\"></p>\n</center>\n\n<p>上式等价于：</p>\n<p>$<br>\\Delta f(x) \\ge g \\Delta x \\Rightarrow g \\le \\dfrac {\\Delta f(x)} {\\Delta x}<br>$</p>\n<p>从该直线方程可知，$g$ 也就是在直线 $y = f(x_0)$ 下方的直线的斜率，所有 $g$ 的解（斜率）都称为函数的次导数（Subderivative），所有次导数（$g$ 的解）的集合称为函数 $f$ 在 $x_0$ 处的次微分（Subdifferential），记为 $\\partial f(x_0)$。</p>\n<p>次微分是次导数的集合，定义该集合为区间 $[a, b]$：</p>\n<p>$$<br>a = \\lim_{x \\rightarrow x^-<em>0} \\dfrac {f(x) - f(x_0)} {x - x_0}, \\quad b = \\lim</em>{x \\rightarrow x^+_0} \\dfrac {f(x) - f(x_0)} {x - x_0}<br>$$</p>\n<p>也即 $x_0$ 点的次微分的集合左边界 $a$ 是从点 $x_0$ 的左侧逼近函数值，右边界 $b$ 是从点 $x_0$ 的右侧逼近函数值。<strong>当函数在 $x_0$ 处可导时，该点的次微分只有一个点组成，也就是函数在该点的导数。</strong></p>\n<p>例如求凸函数 $f(x) = |x|$ 的次微分，由于 $f(x)$ 在点 $x = 0$ 处不可导，因此该点的次微分区间左边界为 $f(0^-) = -1$，右边界为 $f(0^+) = 1$：</p>\n<p>$$<br>\\partial f(x) = \\left {<br>\\begin{aligned}<br>{ -1 }, &amp;&amp; {x &lt; 0}<br>\\<br>[-1, +1], &amp;&amp; {x = 0}<br>\\<br>{ +1 }, &amp;&amp; {x &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>若求解多维点的次微分，则分别求解每个分量的次微分并组成向量，即作为函数在该点的次梯度。</p>\n<font color=EB6D39>\n\n<p>对可导函数，最优解的条件为 $f(x) = 0$，对此类仅局部可导，需要使用次微分的函数，最优解的条件为：</p>\n<p>$<br>0 \\in \\partial f(x^*) \\Longleftrightarrow f(x^*) = \\min_x f(x)<br>$</p>\n<p>当且仅当 0 属于函数 $f$ 在点 $x^*$ 处次梯度集合时，$x^*$ 为极值点。当然，因为函数在可导的点的次微分等于其导数，因此该条件可扩展到全局可导函数。</p>\n</font>\n\n<blockquote>\n<p>@注：Python 可用 <code>numpy.sign</code> 函数实现绝对值函数的次梯度。</p>\n</blockquote>\n<p>将梯度下降法中的梯度换成次梯度就得到次梯度法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">梯度下降法</th>\n<th align=\"left\">次梯度法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n</tr>\n<tr>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$</td>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的次梯度：$\\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$</td>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">4. 判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n<td align=\"left\">判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n</tr>\n</tbody></table>\n<font color=EB6D39>\n\n<p>与梯度下降算法不同，次梯度算法并不是下降算法（每次对参数的更新，并不能保证目标函数单调递减）。因此一般情况下会从多个点同时应用次梯度法，最后选择最小值：</p>\n<p>$$<br>f(x^*) = \\min_{1, …, t} f(x^t)<br>$$</p>\n<p>虽然次梯度法不能保证迭代过程中目标函数保持单调下降，但可以证明，满足一定条件的凸函数，次梯度法可以保证收敛，只是收敛速度比梯度下降法慢。因此 Lasso 通常使用 <strong>坐标轴下降法</strong> 求解。</p>\n</font>\n\n<hr>\n<h1 id=\"4-坐标轴下降法求解\"><a href=\"#4-坐标轴下降法求解\" class=\"headerlink\" title=\"4. 坐标轴下降法求解\"></a>4. 坐标轴下降法求解</h1><p>次梯度法收敛速度慢，Lasso 求解推荐使用坐标轴下降法。</p>\n<p>坐标轴下降法即：沿着坐标轴方向搜索。和梯度下降法与随机梯度下降法的概念类似，例如对 D 维样本参数 $W_0, …, W_D$，坐标轴下降法是每次仅对其中一个 $W_j$ 搜索最优值。循环使用不同的坐标轴（不同维度），一个周期的以为搜索迭代过程相当于一个梯度迭代。</p>\n<p>坐标轴下降发利用当前坐标系统进行搜索，无需计算目标函数的导数，只按照某一坐标方向进行搜索最小值，而梯度下降法验目标函数的负梯度方向搜索，因此梯度方向通常不与任何坐标轴平行。</p>\n<p>坐标轴下降法在系数矩阵上的计算速度非常快。</p>\n<h2 id=\"4-1-Lasso坐标轴下降的数学解释\"><a href=\"#4-1-Lasso坐标轴下降的数学解释\" class=\"headerlink\" title=\"4.1 Lasso坐标轴下降的数学解释\"></a>4.1 Lasso坐标轴下降的数学解释</h2><p>Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$。</p>\n<p>将 Lasso 目标函数中的损失和及正则项分别应用坐标轴下降法搜索，每次仅搜索一个维度。定义 $w_{-j}$ 为 $W$ 去掉 $w_j$ 后的剩余 $(D - 1)$ 维向量。</p>\n<p>（1）对 RSS 的第 j 维坐标轴下降（可导，直接计算梯度）：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - (W^T_{-j} X_{i, -j} + w_j x_{ij}))^2<br>\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_j x_{ij})^2<br>\\<br>（复合函数求导） &amp;= -2 \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_i x_{ij}) \\cdot x_{ij}<br>\\<br>&amp;= 2 \\sum^N_{i = 1} x^2_{ij} w_j - 2 \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\ \\<br>令：a_j &amp;= 2 \\sum^N_{i = 1} x^2_{ij}, \\quad c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\ \\<br>\\Longrightarrow \\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= a_j w_j - c_j<br>\\end{aligned}<br>$$</p>\n<p>（2）再对 $R(W)$ 的第 j 维坐标轴下降（计算次梯度）：</p>\n<p>$$<br>\\dfrac {\\partial} {\\partial w_j} R(W) = \\dfrac {\\partial} {\\partial w_j} \\lambda |w_j| =<br>\\left {<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} (- w_j \\lambda) = { - \\lambda }, &amp;&amp; {w_j &lt; 0}<br>\\<br>&amp; [- \\lambda, + \\lambda], &amp;&amp; {w_j = 0}<br>\\<br>&amp; \\dfrac {\\partial} {\\partial w_j} (w_j \\lambda) = { \\lambda }, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>（3）合并为对 $J(W, \\lambda)$ 的第 j 维坐标轴下降：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda) = \\dfrac {\\partial} {\\partial w_j} (RSS + R(W))<br>\\<br>&amp;= \\left {<br>\\begin{aligned}<br>&amp; { a_j w_j - c_j - \\lambda }, &amp;&amp; {w_j &lt; 0}<br>\\<br>&amp; [a_j w_j - c_j - \\lambda, a_j w_j - c_j + \\lambda] = [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\<br>&amp; { a_j w_j - c_j + \\lambda }, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>\\end{aligned}<br>$$</p>\n<p>（4）最优解需满足：$0 \\in \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$，对于可导部分，则为 $0 = \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$：</p>\n<p>$$<br>\\Longrightarrow \\left {<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda, &amp;&amp; {w_j &lt; 0}<br>\\<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\<br>&amp; 0 = a_j w_j - c_j + \\lambda, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>其中：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda]<br>\\<br>&amp; \\Longrightarrow \\left {<br>\\begin{aligned}<br>0 \\ge - c_j - \\lambda<br>\\<br>0 \\le - c_j + \\lambda<br>\\end{aligned}<br>\\right.<br>\\<br>&amp; \\Longleftrightarrow c_j \\in [- \\lambda, \\lambda]<br>\\end{aligned}<br>$</p>\n<p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij} &gt; 0$，</p>\n<p>① 当 $w_j &lt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda<br>\\<br>&amp; w_j = \\dfrac {c_j + \\lambda} {a_j} &lt; 0<br>\\<br>&amp; \\Longrightarrow c_j &lt; - \\lambda<br>\\end{aligned}<br>$</p>\n<p>② 同理，当 $w_j &gt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j + \\lambda<br>\\<br>&amp; w_j = \\dfrac {c_j - \\lambda} {a_j} &gt; 0<br>\\<br>&amp; \\Longrightarrow c_j &gt; \\lambda<br>\\end{aligned}<br>$</p>\n<p>因此可以转换为下式：</p>\n<p>$$<br>\\hat{w_j}(c_j) = \\left {<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<h2 id=\"4-2-Lasso坐标轴下降步骤\"><a href=\"#4-2-Lasso坐标轴下降步骤\" class=\"headerlink\" title=\"4.2 Lasso坐标轴下降步骤\"></a>4.2 Lasso坐标轴下降步骤</h2><p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$ 对于已知的输入 $X$ 是可以预计算的，因此 Lasso 坐标轴下降的步骤如下：</p>\n<p>① 预计算 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$</p>\n<p>② 初始化参数 $W$（全 0 或随机）</p>\n<p>③ 选择变化幅度最大的维度、或随机选择、或轮流选择需要更新的参数 $w_j$</p>\n<p>④ 计算 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$</p>\n<p>⑤ 计算 $\\hat{w_j}(c_j) = \\left {<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.$</p>\n<p>⑥ 重复第 3 ~ 5 步直到收敛</p>\n<p>⑦ 根据训练好的 $W$ 调整 $\\lambda$ 的取值。</p>\n<font color=EB6D39>\n\n<p>注意 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$，其中的 $W^T_{-j} X_{i, -j}$ 本质上是分别从 $W$ 和 $X$ 中各去掉了一维后的向量/矩阵相乘，但从另一方面理解，也可以认为是去掉了第 j 维特征后用剩下的特征计算出来的预测值，因此 $y_i - W^T_{-j} X_{i, -j}$ 实际上也是第 i 个样本的预测残差 $r_i$，而 $c_j = X_j \\cdot r$ 可以表示输入特征 $X$ 和预测残差 $r$ 的相关性。</p>\n</font>\n\n\n<p><strong>（1）当特征与预测残差强相关时，表示该输入特征的取值（实际上由权重 $w_j$ 控制）对预测结果（残差）有很大影响（例如 $r_j$ 下降很快），则说明这个特征很重要（即权重 $w_j$ 是必须的）。</strong></p>\n<p><strong>（2）当特征与预测残差弱相关时，则表示有没有该特征对预测结果没有什么影响，因此直接使得 $w_j = 0$，这也是 L1 正则起到特征选择作用的原理。</strong></p>\n<p><strong>（3）这也印证了目标函数 $J(W, \\lambda) = \\sum Loss + \\lambda R(W)$ 中正则参数 $\\lambda$ 的理解：$\\lambda$ 为正则项的惩罚，$\\lambda$ 越大，对应的 $[ -\\lambda, \\lambda]$ 区间也越宽，则 $w_j = 0$ 的可能性越大，因此得到的解越稀疏，从而 $W$ 的复杂度越低。</strong></p>\n<p><strong>（4）是否 $c_j \\in [- \\lambda, \\lambda]$ 决定了 $w_j$ 是否为 0，而 $c_j$ 同样表示输入特征和预测残差之间的相关性。当 $\\lambda$ 大于某个最值时，会导致所有的权重均为零 $w_j = 0$。这个最大值同样是可以预计算的：当 $\\lambda$ 取最大值时，所有权重均为零，因此每条样本的预测值全为 0，对应的每条样本的预测残差即为真实值本身：$r_i = y_i$，因此 $c_j$ 即可用输入特征和真实值的相关性来代替：$c_j = X^T_{: j} y$，其中 $X_{: j}$ 表示所有样本的第 j 维特征值，因此当 $\\lambda \\ge \\max_j (X^T_{: j} y)$ 时，可得所有 $w_j = 0$。</strong></p>\n<h2 id=\"4-3-Scikit-Learn中的Lasso\"><a href=\"#4-3-Scikit-Learn中的Lasso\" class=\"headerlink\" title=\"4.3 Scikit-Learn中的Lasso\"></a>4.3 Scikit-Learn中的Lasso</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X =<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"number\">1000</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      positive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>precompute</code>：<br>是否使用预计算的 Gram 矩阵来加速计算。<br>可取值：’True’, ‘False’, ‘auto’ 或数组（array-like）。若设置为 ‘auto’ 则由机器决定。</p>\n<p><code>max_iter</code>：<br>最大迭代次数。</p>\n<p><code>tol</code>：<br>解的精度，判断迭代收敛与否的阈值。<br>当更新量小于tol时，优化代码检查优化的 dual gap 并继续直到小于 tol 为止。</p>\n<p><code>warm_start</code>：<br>是否从之前的结果继续。<br>初始值可以是之前的训练结果，支持在线学习。初始值可在 fit 函数中作为参数传递。</p>\n<p><code>positive</code>：<br>是否强制使系数 $W$ 为正。</p>\n<p><code>random_state</code>：<br>随机选择特征的权重进行更新的随机种子。<br>仅当参数 <code>selection == &#39;random&#39;</code> 时有效。</p>\n<p><code>selection</code>：<br>选择特征权重更新的方式。<br>可选项有：<br>① ‘cyclic’：循环更新<br>② ‘random’：随机选择特征进行更新，通常收敛更快，尤其当参数 tol &gt; (10 - 4) 时。</p>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-Logistic回归简介","url":"/post/machinelearning/ml-logistic/ml-logistic-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-Logistic回归简介\"><a href=\"#1-Logistic回归简介\" class=\"headerlink\" title=\"1. Logistic回归简介\"></a>1. Logistic回归简介</h1><p>回归任务和分类任务都属于有监督学习（Supervised Learning），其训练数据的格式为：$D = { X_i, y_i }^N_{i = 1}$。回归任务中 $y_i \\in R$，而分类任务中 $y_i \\in C, C = { 1, \\cdots c }$，任务目标都为：学习一个从输入 $X$ 到输出 $y$ 的映射 $f$。分类任务的图示如下：</p>\n<center>\n\n<p><img data-src=\"./classify_demo.png\" alt=\"分类任务图示\" title=\"@ASSET\"></p>\n</center>\n\n<p>典型的分类任务有：垃圾邮件过滤、手写数字/文本识别、语音识别、人脸识别、医疗诊断、金融风控等。</p>\n<p>贝努力（Bernoulli）分布：$y \\sim Bernoulli(\\mu)$，其中 $\\mu$ 为分布的期望，表示 $y = 1$ 的概率。则该分布的概率密度函数为：</p>\n<p>$<br>p(y; \\mu) = \\mu^y (1 - \\mu)^{(1 - y)}<br>$</p>\n<p>以两类分类为例。两类分类任务中，假设样本的输出为 $y_i \\in { 0, 1 }$，当给定输入 $X$ 的情况下，输出 y 符合贝努力分布：</p>\n<p>$<br>y | X \\sim Bernoulli(\\mu (X))<br>$</p>\n<p>其中期望 $\\mu (X)$ 表示在给定 $X$ 的情况下，$y = 1$ 的概率。则其概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu) = \\mu (X)^y (1 - \\mu (X))^{1 - y}<br>$</p>\n<p>$<br>p(y = 1) = \\mu(X), \\quad p(y = 0) = 1 - \\mu (X)<br>$</p>\n<h2 id=\"1-1-Sigmoid函数\"><a href=\"#1-1-Sigmoid函数\" class=\"headerlink\" title=\"1.1 Sigmoid函数\"></a>1.1 Sigmoid函数</h2><p>当选择最简单的线性模型来表示期望 $\\mu (X)$ 时，即 $\\mu (X) = W^T X$，期望 $\\mu(X)$ 表示 $y = 1$ 的概率，因此 $\\mu (X) \\in [0, 1]$，而 $W^T X \\in (- \\infty, + \\infty)$，因此需要把 $(- \\infty, + \\infty)$ 缩放到 $[0, 1]$：Sigmoid 函数。</p>\n<p>Sigmoid 函数表达式为：$\\sigma (z) = \\dfrac {1} {1 + e^{-z}}$，其图形如下：</p>\n<center>\n\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n</center>\n\n<p><strong>Sigmoid 函数亦被称为 Logistic 函数或 Logit 函数，Logistic 回归亦被称为 Logit 回归。</strong></p>\n<blockquote>\n<p>@注：LogisticRegression 虽然名字上用了“回归”，但实际上是分类算法。</p>\n</blockquote>\n<p>使用 Sigmoid 函数对 $W^T X$ 缩放后得到：</p>\n<p>$<br>p(y = 1 | X) = \\mu (X) = \\sigma (W^T X)<br>$</p>\n<p>$<br>p(y = 0 | X) = 1 - \\mu (x) = 1 - \\sigma (W^T X)<br>$</p>\n<p>定义一个事件的几率（Odd，与概率 Probability 不是一个概念）为该事件发生的概率与不发生的概率的比值：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\dfrac {\\sigma (W^T X)} {1 - \\sigma (W^T X)} = \\dfrac {\\dfrac {1} {1 + e^{- W^T X}}} {\\dfrac {e^{- W^T X}} {1 + e^{- W^T X}}} = e^{W^T X}<br>$</p>\n<p>两边同取 $\\log$ 运算，得到 <strong>对数几率</strong>：$\\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\log (e^{W^T X}) = W^T X$。</p>\n<p>当 $p(y = 1 | X) &gt; p(y = 0 | X)$ 时，如果取最大后验概率，即输入 $X$ 的类别取 $y = 1$，则有：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} &gt; 0, \\Longrightarrow \\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = W^T X &gt; 0<br>$</p>\n<p>  ① 当 $W^T X &gt; 0$ 时，$p(y = 1 | X) &gt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 1$。</p>\n<p>  ② 当 $W^T X &lt; 0$ 时，$p(y = 1 | X) &lt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 0$。</p>\n<p>  ③ 当 $W^T X = 0$ 时，$p(y = 1 | X) = p(y = 0 | X)$，输入 $X$ 对应的类别可以是 1 或 0，此时 $X$ 位于决策面上，可以将 $X$ 分类到任意类别，或拒绝作出判断。</p>\n<p>令决策函数 $f(X) = W^T X$，其根据 $W^T X$ 的符号将输入控件 $X$ 分出两个区域。由于 $W^T X$ 为线性函数，因此 Logistic 回归模型是一个线性分类器。一个线性分类模型实例如下：</p>\n<center>\n\n<p><img data-src=\"./linear_classify.png\" alt=\"线性分类实例\" title=\"@ASSET\"></p>\n</center>\n\n<h2 id=\"1-2-决策边界\"><a href=\"#1-2-决策边界\" class=\"headerlink\" title=\"1.2 决策边界\"></a>1.2 决策边界</h2><p>更一般地：根据需要划分的类别，分类器将输入控件 $X$ 划分为一些互不相交的区域。这些区域的边界叫决策边界（Decision Boundaries）。根据预测函数 $f$ 的不同，会使得决策面或光滑、或粗糙。</p>\n<p>当决策面是输入 $X$ 的线性函数时，称为线性决策面，对应的分类器就是线性分类器。</p>\n<p>分类器为每个类别分配一个判别函数，根据判别函数来判断一个新样本属于该类别的可能性，然后将新样本归类为可能性最大的一类。假设有 C 个类别，则对应有 C 个判别函数：$\\delta_c (X), c \\in { 1, \\cdots, C }$。</p>\n<p>对一个新样本 $X$，通常是找到最大的 $\\delta_c (X)$，即该样本的类别为：</p>\n<p>$$<br>\\hat{y} = \\arg_c \\max \\delta_c (X)<br>$$</p>\n<p>判别函数 $\\delta_c (X)$ 和  $\\delta_k (X)$ 相等的点的集合，就是分类 C 和分类 K 之间的决策面：</p>\n<center>\n\n<p><img data-src=\"./decision_separating_hyperplane.png\" alt=\"分类决策面\" title=\"@ASSET\"></p>\n</center>\n\n<p>例如两类分类问题中，决策函数 $f_1 = p(y = 1 | X)$ 即为类别 $y = 1$ 的判别函数，决策函数 $f_0 = p(y = 0 | X)$ 即为类别 $y = 0$ 的判别函数。若对一新样本 $X$，有 $f_1 (X) &gt; f_0 (X)$，则新样本 $X$ 被分入类别 $y = 1$。</p>\n<hr>\n<h1 id=\"2-Logistic损失函数\"><a href=\"#2-Logistic损失函数\" class=\"headerlink\" title=\"2. Logistic损失函数\"></a>2. Logistic损失函数</h1><h2 id=\"2-1-负log似然损失\"><a href=\"#2-1-负log似然损失\" class=\"headerlink\" title=\"2.1 负log似然损失\"></a>2.1 负log似然损失</h2><p>以两类分类问题为例，直观地，可以定义一种损失：0 / 1 损失，预测类别正确时预测损失为 0，否则为 1。记为：</p>\n<p>$<br>L(y, \\hat{y}) = \\left {<br>\\begin{aligned}<br>0, &amp;&amp; {y = \\hat{y}}<br>\\<br>1, &amp;&amp; {y \\ne \\hat{y}}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>但 0 / 1 损失不连续，优化计算不方便。因此需要寻找其他 <strong>替代损失函数（Surrogate Loss Function）</strong>。替代损失函数应当符合几个特征：</p>\n<ul>\n<li>通常是凸函数，计算方便。</li>\n<li>与 0 / 1 损失函数具有等效性。</li>\n</ul>\n<p>下图列举了几种不同的损失函数：</p>\n<center>\n\n<p><img data-src=\"./some_loss_functions.png\" alt=\"多种损失函数图\" title=\"@ASSET\"></p>\n</center>\n\n<p>图中横轴为 $y \\hat{y}$ 取值，纵轴为损失。</p>\n<p>定义两类分类中，真值 $y$ 只有两种取值：$y \\in { 1, -1 }$，而预测值可取连续值：$\\hat{y} \\in { - \\infty, + \\infty }$，以符号区分预测值的预测类别（正数对应类别 1，负数对应类别 -1），当 $y$ 和 $\\hat{y}$ 符号相同时（即 $y \\hat{y} &gt; 0$，对应图中横坐标右半部分）表示预测正确，此时损失为 0。反之亦然。</p>\n<p>可以看出，浅蓝色曲线 L2 损失并不能很好地代替 0 / 1 损失，因此优化 L2 损失并不能很好地优化模型的准确度。</p>\n<p>整理 Logistic 回归模型：$y | X \\sim Bernoulli (\\mu (X))$，对应的概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu (X)) = \\mu (X)^y (1 - \\mu (X))^{(1 - y)}<br>$</p>\n<p>其中，$\\mu (X)$ 是线性模型经过 Sigmoid 变化而来：$\\mu (X) = \\sigma (W^T X)$。</p>\n<p>Logistic 的似然函数为：$likelihood (f) = p(D) = \\prod^N_{i = 1} p(y_i | x_i)$，则 $\\log$ 似然函数为：</p>\n<p>$<br>\\begin{aligned}<br>l(\\mu) &amp;= \\log p(D) = \\log \\prod^N_{i = 1} p(y_i | x_i) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\<br>&amp;= \\sum^N_{i = 1} \\log \\left( \\mu (X_i)^{y_i} (1 - \\mu (X_i))^{(1 - y_i)} \\right)<br>\\<br>&amp;= \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p>取极大似然估计        ：</p>\n<p>$<br>\\begin{aligned}<br>\\max l(\\mu) &amp;= - \\min l(\\mu)<br>\\<br>&amp;= \\min - \\left( \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i)) \\right)<br>\\<br>&amp;= \\min \\sum^N_{i = 1} - y_i \\log (\\mu (X_i)) - (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p><strong><font color=red>因此极大似然估计等价于最小训练集上的负 $\\log$ 损失。而负 $\\log$ 似然损失亦被称为 Logistic 损失。</font></strong></p>\n<h2 id=\"2-2-交叉熵损失\"><a href=\"#2-2-交叉熵损失\" class=\"headerlink\" title=\"2.2 交叉熵损失\"></a>2.2 交叉熵损失</h2><p>Logistic 损失亦被称为 <strong>交叉熵损失（Corss Entropy Loss, CE）</strong>。</p>\n<p>交叉熵损失：两个分布之间的差异（已知真实分布的情况下，预测分布与真实分布之间的差异）。定义交叉熵 $H(p, q)$ 如下：</p>\n<p>$$<br>\\begin{aligned}<br>H(p, q) &amp;= \\sum_x p(x) \\log (\\dfrac {1} {q(x)})<br>\\<br>&amp;= - \\sum_x p(x) \\log (q(x))<br>\\end{aligned}<br>$$</p>\n<p>假设预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，即 $\\hat{y} \\sim Bernoulli (\\mu (X))$，则预测值 $\\hat{y} = 0$ 的概率为 $1 - \\mu (X)$。</p>\n<p>（1）假设已知真值 $y = 1$，即 $y | X \\sim Bernoulli (1)$，即在已知真值 $y = 1$ 的情况下，$y$ 取 1 的概率 $\\mu = p(y = 1) = 1$，因此 $y = 0$ 的概率 $p(y = 0) = 0$。则这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 1, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\<br>&amp;= - \\log \\mu (X)<br>\\end{aligned}<br>$</p>\n<p>（2）同理，假设已知真值 $y = 0$，即 $y | X \\sim Bernoulli (0)$，因此 $\\mu = p(y = 1) = 0$，$p(y = 0) = 1$，此时这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 0, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\<br>&amp;= - \\log (1 - \\mu (X))<br>\\end{aligned}<br>$</p>\n<p>整理合并得：</p>\n<p>$<br>CE(y, \\hat{y}) = \\left {<br>\\begin{aligned}<br>&amp; - \\log \\mu (X), &amp;&amp; {y = 1}<br>\\<br>&amp; - \\log (1 - \\mu (X)), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>定义 $p_t$（Probability of Ground Truth Class）为：</p>\n<p>$<br>p_t = \\left {<br>\\begin{aligned}<br>&amp; \\mu (X), &amp;&amp; {if (y = 1)}<br>\\<br>&amp; 1 - \\mu (X), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>则可得到交叉熵损失简洁表达式：</p>\n<p>$$<br>CE(y, \\hat{y}) = - \\log (p_t)<br>$$</p>\n<p>交叉熵损失与 $p_t$ 的关系曲线如下：</p>\n<center>\n\n<p><img data-src=\"./cross_entropy_and_pt.png\" alt=\"交叉熵损失曲线\" title=\"@ASSET\"></p>\n</center>\n\n<blockquote>\n<p>@注：<strong>对 $p_t$ 的理解：根据 $p_t$ 的表达式，当真实值 $y = 1$ 时，$p_t = \\mu (X)$。由于 $\\mu (X)$ 表示的是预测值 $\\hat{y} = 1$ 的概率，因此 <font color=EB6D39>$p_t$ 即表示预测分布接近真实分布的概率</font>。因此 $p_t$ 越大，表示预测越准确，同时对应的交叉熵损失 $Loss = - \\log (p_t)$ 也就越小，与图中曲线含义相同。</strong></p>\n</blockquote>\n<hr>\n<h1 id=\"3-Logistic正则项\"><a href=\"#3-Logistic正则项\" class=\"headerlink\" title=\"3. Logistic正则项\"></a>3. Logistic正则项</h1><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失，由于预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，因此可使用 $\\mu (X)$ 表示 $\\hat{y}$：</p>\n<p>$<br>\\begin{aligned}<br>&amp; L(y, \\mu(X)) = -y \\log (\\mu (X)) - (1- y) \\log (1 - \\mu (X))<br>\\<br>&amp; \\mu (X) = \\sigma (W^T X)<br>\\end{aligned}<br>$</p>\n<p>Logistic 回归的目标函数同样包括训练集上的损失和与正则项，正则项同样可选 L1 正则、L2 正则、或 L1 + L2 正则。</p>\n<p>假设有一个两类分类任务，且训练样本完全可分（即所有同类样本均可被分对），为了使 Logistic 损失和最小（完全可分时最小损失和即为 0），则对每个样本有：$L(y_i, \\mu (x_i)) = 0$。当想要使得每个样本损失均为 0 时，即：</p>\n<blockquote>\n<p>① 对于每个真实值 $y_i = 1$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 1（必定预测分类为 1），也即 $\\mu (X) = 1$。</p>\n<p>② 而对于每个真实值 $y_i = 0$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 0（不可能预测分类为 1），也即 $\\mu (X) = 0$。</p>\n</blockquote>\n<p>由于 $\\mu (X) = \\sigma (W^T X)$ 是将线性模型 $W^T X$ 经过 Sigmoid 变化而来，Sigmoid 图形如下：</p>\n<center>\n\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n</center>\n\n<p><strong><font color=EB6D39>当 $\\mu (X)$ 取 $\\pm 1$ 时，$W^T X$ 取 $\\pm \\infty$，也即 $|W_j| = \\infty$，这样的模型是无意义的。</font></strong></p>\n<center>\n\n<p><strong><font color=red>因此 Logistic 回归必须加正则！</font></strong></p>\n</center>\n\n<blockquote>\n<p>@注：Scikit-Learn 中实现的 Logistic 回归 <code>LogisticRegression</code> 默认为 L2 正则。</p>\n</blockquote>\n<p>与 SVM 类似的是，Logistic 回归的超参数 $C$ 加在损失函数上：</p>\n<p>$$<br>J(W; \\lambda) = C \\sum^N_{i = 1} L(y_i, \\mu (x_i; W)) + R(W)<br>$$</p>\n<hr>\n<h1 id=\"4-Scikit-Learn中的Logistic\"><a href=\"#4-Scikit-Learn中的Logistic\" class=\"headerlink\" title=\"4. Scikit-Learn中的Logistic\"></a>4. Scikit-Learn中的Logistic</h1><p>Scikit-Learn 中实现了 3 种 Logistic 回归：</p>\n<ul>\n<li><code>LogisticRegression</code></li>\n<li><code>LogisticRegressionCV</code></li>\n<li><code>SGDClassifier</code></li>\n</ul>\n<p>① <code>LogisticRegression</code> 是最原始的 Logistic 回归模型，超参数调优时需要手动搭配 <code>GridSearchCV</code> 使用。② <code>LogisticRegressionCV</code> 是 Scikit-Learn 提供的已集成了交叉验证的 Logistic 回归模型，可以直接使用内置的交叉验证对超参数调优。③ <code>SGDClassifier</code>（随机梯度下降分类）则是在样本数很大（样本数 $N &gt; 10^5$，特征数 $M &gt; 10^5$）时效果更好。</p>\n<h2 id=\"4-1-LogitsicRegression\"><a href=\"#4-1-LogitsicRegression\" class=\"headerlink\" title=\"4.1 LogitsicRegression\"></a>4.1 LogitsicRegression</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegression</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegression(penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                   dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                   C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                   fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                   intercept_scaling=<span class=\"number\">1</span>,</span><br><span class=\"line\">                   class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   solver=<span class=\"string\">&#x27;liblinear&#x27;</span>,</span><br><span class=\"line\">                   max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                   multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                   verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                   warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）<code>LogitsicRegression</code> 的参数</strong></p>\n<p><code>penalty</code>：<br>惩罚函数 / 正则函数，默认：’L2’。<br>支持 L2 正则和 L1 正则。选择 L1 正则时优化器可选 ‘liblinear’ 和 ‘saga’。</p>\n<p><code>dual</code>：<br>是否是对偶问题求解，默认：<code>False</code>。<br>是原问题（primal）还是对偶问题（dual）求解。对偶问题只支持 L2 正则和 ‘liblinear’ 优化器。</p>\n<p><code>tol</code>：<br>迭代终止判据的误差范围，默认：$10^{-4}$。</p>\n<p><code>C</code>：<br>交叉熵损失函数系数，默认：1。</p>\n<p><code>fit_intercept</code>：<br>是否在决策函数中加入截距项。默认：<code>True</code>。<br>如果数据已经中心化，则不需要拟合截距项。</p>\n<p><code>intercept_scaling</code>：<br>截距缩放因子。<br>当 <code>fit_intercept</code> 为 <code>True</code> 且优化器 <code>solver</code> 设置为 <code>liblinear</code> 时有效。输入为 <code>[X, self.intercept_scaling]</code>，即对输入特征插入 1 维常数项。由于增加的常数项系数也受到 L1 / L2 正则的惩罚，因此要适当增大常数项。</p>\n<p><code>class_weight</code>：<br>不同类别样本的权重。默认：<code>None</code>。<br>可指定每类样本权重，或设置为 ‘balanced’，则每类样本权重与该类别样本数比例成反比。</p>\n<p><code>random_state</code>：<br>随机种子，默认：<code>None</code>。</p>\n<p><code>solver</code>：<br>优化求解算法，默认：’liblinear’。<br>可选：’newton-cg’，’lbfgs’，’liblinear’，’sag’，’saga’。<br>L1 正则优化器仅可选 ‘liblinear’ 和 ‘saga’，L2 正则可使用所有优化器。</p>\n<p><code>max_iter</code>：<br>最大迭代次数，默认：100。<br>仅当 <code>solver</code> 设置为 ‘newton-cg’，’sag’，或 ‘lbfgs’ 时有效。</p>\n<p><code>multi_class</code>：<br>多类分类处理策略，默认：’ovr’。<br>可选：’ovr’，’multinomial’。<br>‘ovr’：One-Versus-Rest，一对多。将 C 类分类问题转化为 C 个两类分类问题，每一次分类当前类别样本为正样本，其余样本视为负样本。<br>‘multinomial’：即 softmax 分类器。使用 ‘multinomial’ 时，优化器仅可选 ‘newton-cg’，’lbfgs’，’sag’。</p>\n<blockquote>\n<p>@注：OVO：One-Versus-One，一对一。</p>\n</blockquote>\n<p>OVR 相对简单但分类效果相对略差。MVM 分类相对精确，但分类速度比 OVR 慢。</p>\n<p><code>verbose</code>：<br>是否详细输出。</p>\n<p><code>warm_start</code>：<br>是否热启动，默认：<code>False</code>。<br><code>solver</code> 设置为 ‘liblinear’ 时无效。</p>\n<p><code>n_jobs</code>：<br>多线程控制，默认：-1.<br>取 -1 时算法自动检测可用 CPU 核，并使用全部核。</p>\n<p><strong>（2）<code>LogitsicRegression</code> 的属性</strong></p>\n<p><code>coef</code>：<br>回归系数 / 权重。<br>与特征的维数相同。如果是多任务回归，标签 $y$ 为 m 维数组，则回归系数也为 m 维数组。</p>\n<p><code>intercept_</code>：<br>截距项。</p>\n<p><code>n_iter_</code>：<br>每个类的迭代此时。</p>\n<p><strong>（3）<code>LogitsicRegression</code> 的方法</strong></p>\n<p><code>fit(X, y[, sample_weight])</code>：<br>模型训练。<br>参数 X，y 为训练数据，也可以通过 <code>sample_weight</code> 设置每个样本的权重。</p>\n<p><code>predict(X)</code>：<br>返回 X 对应的预测值（类别标签）。</p>\n<p><code>predict_log_proba(X)</code>：<br>返回 X 对应的预测值（每个类别对应的概率的 $log$ 值）。</p>\n<p><code>predict_proba(X)</code>：<br>返回 X 对应的预测值（每个类别对应的概率）。</p>\n<p><code>score(X, y[, sample_weight])</code>：<br>评估模型预测性能，返回模型预测的正确率。</p>\n<p><code>decision_function(X)</code>：<br>预测的置信度（样本到分类超平面的带符号距离）。<br>在分对的情况下，正样本得到的应为正值，负样本得到的应为负值。</p>\n<p><code>densify()</code>：<br>如果之前将系数矩阵变成了稀疏模式，再将其变回稠密模式（<code>fit</code> 函数要求系数矩阵为稠密模式）。</p>\n<p><code>sparsify()</code>：<br>将系数矩阵变成了稀疏模式。</p>\n<h2 id=\"4-2-LogisticRegressionCV\"><a href=\"#4-2-LogisticRegressionCV\" class=\"headerlink\" title=\"4.2 LogisticRegressionCV\"></a>4.2 LogisticRegressionCV</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegressionCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegressionCV(Cs=<span class=\"number\">10</span>,</span><br><span class=\"line\">                     fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                     cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                     penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                     scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     solver=<span class=\"string\">&#x27;lbfgs&#x27;</span>,</span><br><span class=\"line\">                     tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                     max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                     class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                     verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                     refit=<span class=\"literal\">True</span>, i</span><br><span class=\"line\">                     ntercept_scaling=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                     multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                     random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）<code>LogisticRegressionCV</code> 的参数</strong></p>\n<p><code>Cs</code>：<br>超参数调优范围。<br>在区间 $[10^{-4}, 10^4]$ 的 $log$ 域均匀取 Cs 个值作为正则参数 C 的搜索空间。</p>\n<p><code>cv</code>：<br>交叉校验划分策略。</p>\n<p><code>solver</code>：<br>与 <code>LogisticRegression</code> 相同，但默认为 ‘lbfgs’。</p>\n<p><code>multi_class</code>：<br>对多类分类问题，采用的是 ‘ovr’ 的方式，用交叉验证得到每个类的最佳正则参数。</p>\n<p>其余参数与 <code>LogisticRegression</code> 相同。</p>\n<p><strong>（2）<code>LogisticRegressionCV</code> 的属性</strong></p>\n<p>与 <code>LogisticRegression</code> 相同。</p>\n<p><strong>（3）<code>LogisticRegressionCV</code> 的方法</strong></p>\n<p>与 <code>LogisticRegression</code> 相同。</p>\n<h2 id=\"4-3-SGDClassifier\"><a href=\"#4-3-SGDClassifier\" class=\"headerlink\" title=\"4.3 SGDClassifier\"></a>4.3 SGDClassifier</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDClassifier</span></span><br><span class=\"line\"></span><br><span class=\"line\">SGDClassifier(loss=<span class=\"string\">&#x27;hinge&#x27;</span>,</span><br><span class=\"line\">              penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">              alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">              l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">              fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">              epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">              n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">              random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              learning_rate=<span class=\"string\">&#x27;optimal&#x27;</span>, </span><br><span class=\"line\">              ta0=<span class=\"number\">0.0</span>,</span><br><span class=\"line\">              power_t=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">              class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）<code>SGDClassifier</code> 的参数</strong></p>\n<p><code>lose</code>：<br>损失函数。<br>可选：’hinge’（合页损失，SVM 中常用），’log’（负 $log$ 似然损失，即 Logistic 回归使用的损失），’modified_huber’（对噪声不损失），’squared_hinge’，’perceptron’，还有回归中使用的损失函数：’squared_loss’，’huber’，’epsilon_insensitive’，’squared_epsilon_insensitive’。<br>使用回归的方式也可以实现分类。在分类中，$f(X)$ 表示样本输入 $X$ 取某个类别的概率，当使用回归的方式进行分类时，$f(X)$ 为一具体数值，可通过数值判断分类。例如二分类任务中，对 $f(X) &gt; 0.5$，分为类别 1，对 $f(X) &lt; 0.5$，分为类别 0。</p>\n<p><code>epsilon</code>：<br>额外参数项。<br>某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）所需要的额外参数。</p>\n<p><code>penalty</code>：<br>正则项。<br>可选：’none’，’l2’，’l1’，’elasticnet’（弹性网络，L1 + L2）。</p>\n<p><code>alpha</code>：<br>正则惩罚系数。<br>对应为目标函数中的 $\\lambda$，也用于学习率的计算。</p>\n<p><code>l1_ratio</code>：<br>L1 正则比例。<br>仅当正则项为 ‘elasticnet’ 时有效，用于控制 L1 正则所占比例。</p>\n<p>优化相关参数如下：</p>\n<p><code>max_iter</code>：<br>最大迭代次数（访问所有训练数据的次数 / epoches 次数），默认：5。<br>SGD 在接近 $10^6$ 的训练样本时收敛，因此可将 <code>max_iter</code> 设置为 <code>np.ceil(10^6 / N)</code>（$\\dfrac {10^6} {N}$），其中 N 为训练集样本数。</p>\n<p><code>tol</code>：<br>迭代停止条件。<br>若非 <code>None</code>，则当 (loss &gt; previous_loss - tol) 时迭代终止。</p>\n<p><code>learning_rate</code>：<br>学习率。<br>对应为迭代优化算法中的 $\\alpha$。<br>可选：’constant’，’optimal’，’invscaling’。<br>‘constant’：eta = eta0<br>‘optimal’：eta = 1.0 / (alpha * (t + t0))<br>‘invscaling’：eta = eta0 / pow(t, power_t)</p>\n<p><code>shuffle</code>：<br>每轮 SGD 之前是否洗牌。<br>默认为 <code>True</code>。</p>\n<p><code>warm_start</code>：<br>是否热启动。<br>随机梯度下降中初始值可以是之前的训练结果，支持在线学习。初始值可在 <code>fit()</code> 函数中作为参数传递。</p>\n<p><code>average</code>：<br>是否采用平均随机梯度下降法（随机梯度下降法的改进）ASGD。</p>\n<p>其他参数与 <code>LogisticRegression</code> 相同。</p>\n<p>关于“随机梯度下降实现”的参考文献：</p>\n<blockquote>\n<ul>\n<li>“Stochastic Gradient Descent” L. Bottou - Website, 2010</li>\n<li>“The Tradeoffs of Large Scale Machine Learning” L. Bottou - Website, 2011</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-Logistic优化求解与牛顿法","url":"/post/machinelearning/ml-logistic/ml-logistic-optimization/","content":"<span id=\"more\"></span>\n\n<p>前言：在机器学习的优化求解算法中，梯度下降法是无约束优化问题优化求解最常用的方法之一，还有一种求解方法就是牛顿法。相比梯度下降法，牛顿法的收敛速度更快，但同时，每次迭代需要的计算量也更大。</p>\n<p>在牛顿法之前，需要先了解：<a href=\"https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/7681487?fr=aladdin\" title=\"@LINK\">泰勒公式</a>。泰勒公式通俗地讲，就是当函数 $f$ 在点 $x$ 处的一阶导数、二阶导数……n 阶导数已知时，即可使用 n 阶泰勒展开来逼近函数 $f$ 在点 $x$ 的 <font color=red>邻域</font> 的函数值，因此泰勒公式求的是一个点的邻域的近似函数值。</p>\n<p>对应优化求解中，通常我们习惯于使用迭代法来求解，而迭代法的本质即：每次向正确的方向移动一小段，直到达到给定条件。这就与泰勒公式不谋而合——每次移动一小段之后的函数值可以使用移动前该点的泰勒展开来逼近，因此牛顿法或拟牛顿法都是在泰勒公式的基础上进行的。</p>\n<hr>\n<h1 id=\"1-牛顿法\"><a href=\"#1-牛顿法\" class=\"headerlink\" title=\"1. 牛顿法\"></a>1. 牛顿法</h1><p>牛顿法（Newton - Raphson，牛顿 - 拉夫逊）是牛顿在 17 世纪提出的用于求解方程的根的方法。其求解思想如下：</p>\n<p>① 假设点 $x^{\\ast}$ 为函数 $f(x)$ 的根，则 $f(x) = 0$。</p>\n<p>② 将函数 $f(x)$ 在点 $x_0$ 处进行一阶泰勒展开有：$f(x) \\approx f(x_0) + (x - x_0) f’(x_0)$</p>\n<p>③ 假设点 $x$ 为 $x_0$ 邻域内一点，且 $x$ 为函数的根，则有：$f(x) \\approx f(x_0) + (x - x_0) f’(x_0) = 0$</p>\n<p>④ 将上式变换即可得：$x = x_0 - \\dfrac {f(x_0)} {f’(x_0)}$</p>\n<p>上述牛顿法得到的结论，拓展到迭代的过程中，假设当前处在迭代第 t 轮，则可以得到下一轮 (t + 1) 时刻的解的表达式为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {f(x^{(t)})} {f’(x^{(t)})}<br>$</p>\n<p>这就是牛顿法优化求解的基本思想。下图展示了牛顿法求解方程 $f(x) = 0$ 的根的过程（图自 Wiki）：</p>\n<center>\n\n<p><img data-src=\"./newton_iteration.png\" alt=\"牛顿法迭代过程\" title=\"@ASSET\"></p>\n</center>\n\n<p>回到最优化问题中，通常会将问题转化成求极小值（误差、损失最小等），极小值对应了函数的导数为 0，因此需要适当调整牛顿法的目标，从求 $f(x) = 0$ 变为求 $f’(x) = 0$，因此原问题变为求 $f’(x)$ 的根。</p>\n<p>令 $g(x) = f’(x)$，则关于 $x$ 的迭代条件变为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {g(x^{(t)})} {g’(x^{(t)})} = x^{(t)} - \\dfrac {f’(x^{(t)})} {f’’(x^{(t)})}<br>$</p>\n<p>在实际问题中，通常输入 $X$ 的维度都大于 1，因此将一阶导数替换为梯度（即 $f$ 分别对每个 $x_i$ 求偏导后组成向量）：</p>\n<p>$<br>\\nabla f(x_1, \\cdots, x_D)<br>$</p>\n<p>将二阶导数替换为海森（Hessian）矩阵 H：</p>\n<p>$<br>H(X) = \\left[<br>\\begin{matrix}<br>\\dfrac {\\partial^2 f} {\\partial^2 x^2_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_D}<br>\\<br>\\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_D}<br>\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots<br>\\<br>\\dfrac {\\partial^2 f} {\\partial x_D \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_D \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_D}<br>\\end{matrix}<br>\\right]<br>$</p>\n<p>Hessian 矩阵即：第 i 行第 j 列的元素为 $f$ 先对 $x_i$ 求偏导后再对 $x_j$ 求偏导。由于 $f$ 先对 $x_i$ 再对 $x_j$ 求偏导和 $f$ 先对 $x_j$ 再对 $x_i$ 求偏导相等，即 $\\dfrac {\\partial^2 f} {\\partial x_i \\partial x_j} = \\dfrac {\\partial^2 f} {\\partial x_j \\partial x_i}$，因此 Hessian 矩阵是对称的。</p>\n<p>这样，牛顿法的迭代公式就变换为：</p>\n<p>$$<br>x^{(t + 1)} = x^{(t)} - H^{-1} (X^{(t)}) \\ \\nabla f(X^{(t)})<br>$$</p>\n<blockquote>\n<p>@注：二阶导转换为 Hessian 矩阵 $H(X^{(t)})$ 后作为分母，使用逆运算 $H^{-1} (X^{(t)})$ 来表示。</p>\n</blockquote>\n<p>总结牛顿法求解目标函数极值的迭代步骤如下：</p>\n<p>① 从 $t = 0$ 开始，初始化 $X^{(0)}$ 为随机值</p>\n<p>② 计算目标函数 $f(X)$ 在点 $X^{(t)}$ 的梯度：$g^{(t)} = \\nabla f(X^{(t)})$，以及 Hessian 矩阵：$H^{(t)} = H(X^{(t)})$</p>\n<p>③ 计算移动方向：$d^{(t)} = (H^{(t)})^{-1} \\ g^{(t)}$</p>\n<p>④ 根据迭代公式更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</p>\n<p>⑤ 判断是否满足迭代终止条件（是否到达最大迭代次数，或相邻两次迭代的相对变化量或绝对变化量小于预设值，通常使用绝对量：$\\dfrac {f(X^{(t + 1)}) - f(X^{(t)})} {f(X^{(t)})} \\le \\varepsilon$），若满足则循环计数，返回最佳参数 $X^{(t + 1)}$ 和目标函数极小值 $f(X^{(t + 1)})$，否则跳转到第 2 步</p>\n<p>其中，第 ③ 步计算移动方向 $d^{(t)}$ 时，由于矩阵的逆求解困难，因此常用线性方程组计算：$H^{(t)} d^{(t)} = g^{(t)}$，当 $X$ 维度比较小时，可采用解析法求解 $d^{(t)}$，当 $X$ 维度比较高时，可采用梯度下降法或共而梯度下降法求解，因此对 $d^{(t)}$ 的求解又是一个迭代的计算过程。</p>\n<p>对比梯度下降法中的移动方向：$d^{(t)} = - \\eta g^{(t)}$，牛顿法：$d^{(t)} = - (H^{(t)})^{-1} \\ g^{(t)}$，Hessian 矩阵相比学习率（步长）$\\eta$ 包含的信息更多，因此牛顿法收敛速度更快，但从上述步骤也可明显看出牛顿法每次迭代的计算量都大幅增加。</p>\n<p>由于梯度下降法仅使用了一阶导数，而牛顿法使用了二阶导数矩阵，因此梯度下降法是一阶最优化算法，而牛顿法是二阶最优化算法。</p>\n<hr>\n<h1 id=\"2-拟牛顿法\"><a href=\"#2-拟牛顿法\" class=\"headerlink\" title=\"2. 拟牛顿法\"></a>2. 拟牛顿法</h1><p>牛顿法虽然收敛速度比梯度下降法更快，但在高维的情况下，计算目标函数二阶偏导数的复杂度很大，而且有时候目标函数的 Hessian 矩阵无法保持正定，不存在逆矩阵，此时牛顿法将不再能使用。</p>\n<p>为此提出：拟牛顿法（Quasi-Newton Methods），拟牛顿法旨在：不用二阶偏导数，而构造出可以近似 Hessian 矩阵（或 Hessian 矩阵的逆矩阵）的正定对称矩阵，再逐步优化目标函数。不同的近似 Hessian 矩阵构造方法产生了不同的拟牛顿法：BFGS / L-BFGS。</p>\n<blockquote>\n<p>扩展阅读：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/aws3217150/article/details/50548177\" title=\"@LINK\">谈谈常见的迭代优化方法</a></li>\n<li><a href=\"https://www.scipy-lectures.org/advanced/mathematical_optimization/\" title=\"@LINK\">Mathematical optimization: finding minima of functions</a></li>\n</ol>\n</blockquote>\n<p>重新考虑迭代条件，假设有某点 $x_0$，目标函数 $f(x)$ 在该点（已知点）进行二阶泰勒展开：</p>\n<p>$<br>f(x) \\approx f(x_0) + f’(x_0) (x - x_0) + \\dfrac {1} {2} f’’(x_0) (x - x_0)^2<br>$</p>\n<p>当 $X$ 为 向量 / 矩阵 时，导数即为梯度，上式转换为：</p>\n<p>$<br>f(X) \\approx f(X_0) + \\nabla f(X_0) (X - X_0) + \\dfrac {1} {2} (X - X_0)^T \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>对上式取梯度运算（$X_0$ 为已知点，因此其与其导数均可视为常数项）得：</p>\n<p>$<br>\\nabla f(X) \\approx \\nabla f(X_0) + \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>由于函数在点 $X_0$ 处的泰勒展开可以近似 $X_0$ 邻域内的函数值，假设 $X_0$ 即为迭代 t 次后得到的 $X^{(t + 1)}$，则迭代前一轮的 $X^{(t)}$ 即为邻域内一点，可用二阶泰勒展开逼近，因此可得迭代关系：</p>\n<p>$<br>\\nabla f(X^{(t)}) \\approx \\nabla f(X^{(t + 1)}) + \\nabla^2 f(X^{(t + 1)}) (X^{(t)} - X^{(t + 1)})<br>$</p>\n<p>再使用 gradiant 和 Hessian 分别表示 $X$ 的一阶梯度和二阶梯度矩阵：$g^{(t)} = \\nabla f(X^{(t)})$，$H^{(t)} = \\nabla^2 f(X^{(t)})$，整理可得：</p>\n<p>$<br>g^{(t + 1)} - g^{(t)} \\approx H^{(t + 1)} (X^{(t + 1)} - X^{(t)})<br>$</p>\n<p>进一步，引入记号：$s^{(t)} = X^{(t + 1)} - X^{(t)}$ 表示 $X$ 的变化量，$y^{(t)} = g^{(t + 1)} - g^{(t)}$ 表示梯度变化量，则可得简洁迭代关系：</p>\n<p>$$<br>y^{(t)} \\approx H^{(t + 1)} s^{(t)}<br>$$</p>\n<p>由于牛顿法中 Hessian 矩阵的逆难以计算，因此在拟牛顿法中，令 $B$ 表示 $H$ 的近似，$D$ 表示 $H^{-1}$ 的近似，代入上式即可得到 <font color=EB6D39>拟牛顿法的条件</font> 为：</p>\n<font color=EB6D39>\n<center>\n\n<p>$$<br>y^{(t)} = B^{(t + 1)} s^{(t)}<br>$$</p>\n<p>或</p>\n<p>$$<br>s^{(t)} = D^{(t + 1)} y^{(t)}<br>$$</p>\n</center>\n\n<p>实际上，拟牛顿法的条件给出了 Hessian 矩阵的近似需要满足的条件。</p>\n</font>\n\n<h2 id=\"2-1-BFGS\"><a href=\"#2-1-BFGS\" class=\"headerlink\" title=\"2.1 BFGS\"></a>2.1 BFGS</h2><p>BFGS（Broyden, Fletcher, Glodfarb, Shanno）被认为是数值效果最好的拟牛顿法，且具有全局收敛性和超线性收敛速度。</p>\n<p>BFGS 算法采用迭代法逼近 Hessian 矩阵：$B^{(t + 1)} = B^{(t)} + \\Delta B^{(t)}$，初始值 $B^{(0)} = I$ 为单位矩阵，因此关键在于如何构造 $\\Delta B^{(t)}$。</p>\n<p>为保证矩阵 $B$ 的正定性，令 $\\Delta B^{(t)} = \\alpha u u^T + \\beta v v^T$，代入上述拟牛顿法条件可得：</p>\n<p>$<br>\\begin{aligned}<br>y^{(t)} &amp;= B^{(t + 1)} s^{(t)} = (B^{(t)} + \\Delta B^{(t)}) s^{(t)} = B^{(t)} s^{(t)} + \\Delta B^{(t)} s^{(t)}<br>\\<br>&amp;= B^{(t)} s^{(t)} + \\alpha u u^T s^{(t)} + \\beta v v^T s^{(t)}<br>\\<br>&amp;= B^{(t)} s^{(t)} + u (\\alpha u^T s^{(t)}) + v (\\beta v^T s^{(t)})<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>@注：当 $u^T$ 或 $v^T$ 的维数与 $s^{(t)}$ 的维数一致（由于 $\\Delta B^{(t)}$ 是构造的，因此可以构造为相同维数）时，$u^T s^{(t)}$ 以及 $v^T s^{(t)}$ 均为一个标量数值（向量的转置 x 向量 = 数值）。</p>\n</blockquote>\n<p>令 $\\alpha u^T s^{(t)} = 1$，$\\beta v^T s^{(t)} = -1$，即 $\\alpha = \\dfrac {1} {u^T s^{(t)}}$，$\\beta = - \\dfrac {1} {v^T s^{(t)}}$，得到：</p>\n<p>$<br>u - v = y^{(t)} - B^{(t)} s^{(t)}<br>$</p>\n<p>不妨令 $u = y^{(t)}$，$v = B^{(t)} s^{(t)}$，代入 $\\alpha$ 和 $\\beta$ 的表达式得：</p>\n<p>$<br>\\alpha = \\dfrac {1} {u^T s^{(t)}} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>$<br>\\beta = - \\dfrac {1} {v^T s^{(t)}} = - \\dfrac {1} {(B^{(t)} s^{(t)})^T s^{(t)}} = - \\dfrac {1} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>$</p>\n<p>代入 $\\Delta B^{(t)}$ 的表达式得：</p>\n<font color=EB6D39>\n\n<p>$$<br>\\begin{aligned}<br>\\Delta B^{(t)} &amp;= \\alpha u u^T + \\beta v v^T<br>\\<br>&amp;= \\dfrac {y^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} - \\dfrac {B^{(t)} s^{(t)} (B^{(t)} s^{(t)})^T} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$$</p>\n</font>\n\n<blockquote>\n<p>@注：Sherman-Morrison 公式：若 $A$ 为非奇异方阵，$1 + v^T A^{-1} u \\ne 0$，则有：</p>\n</blockquote>\n<p>$<br>(A + uv^T)^{-1} = A^{-1} - \\dfrac {A^{-1} u v^T A^{-1}} {1 + v^T A^{-1}}<br>$</p>\n<p>由于牛顿法迭代过程需要计算 Hessian 矩阵的逆矩阵，因此根据 Sherman-Morrison 公式可得：</p>\n<font color=EB6D39>\n\n<p>$$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$$</p>\n</font>\n\n<p>综上，对于 $\\Delta B^{(t)}$ 和 $D^{(t + 1)}$，均可使用 $s^{(t)}$（$X$ 的变化量）和 $y^{(t)}$（函数梯度的变化量）表示，而初始化 $B^{(0)} = D^{(0)} = I$ 是一指的，$s^{(t)}$ 和 $y^{(t)}$ 在 $X$ 已知（优化求解的目的是寻找最优的 $X$，而 $X$ 本来就是已知的）时均是可计算的。</p>\n<p>整理得 BFGS 更新参数的流程如下：</p>\n<p>① 从 $t = 0$ 开始，初始化 $D^{(0)} = I$</p>\n<p>② 计算移动方向：$d^{(t)} = D^{(t)} g^{(t)}$</p>\n<blockquote>\n<p>@注：先用 $B^{(t)} = B^{(t - 1)} + \\Delta B^{(t - 1)}$ 迭代解出 $B^{(t)}$，再用 Sherman-Morrison 公式解出 $D^{(t)}$。</p>\n</blockquote>\n<p>③ 更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</p>\n<p>④ $s^{(t)} = d^{(t)}$</p>\n<p>⑤ 若 $||g^{(t + 1)}|| \\le \\varepsilon$，则迭代终止</p>\n<p>⑥ 计算：$y^{(t)} = g^{(t + 1)} - g^{(t)}$</p>\n<p>⑦ $t = t + 1$，跳转第 2 步</p>\n<h2 id=\"2-2-L-BFGS\"><a href=\"#2-2-L-BFGS\" class=\"headerlink\" title=\"2.2 L-BFGS\"></a>2.2 L-BFGS</h2><p>在 BFGS 中，每一轮迭代需要存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），但当 $X$ 维数很高时，矩阵的维度也会很高，需要耗费大量存储空间。</p>\n<p>L-BFGS（Limited memory BFGS）不直接存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），而是存储迭代计算过程中的 $s^{(t)}$ 和 $y^{(t)}$ 来计算，从而减少参数存储所需空间。</p>\n<p>在 BFGS 中，Hessian 矩阵的更新公式为：</p>\n<p>$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>令 $\\rho^{(t)} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}$，$V^{(t)} = \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) = I - \\rho^{(t)} y^{(t)} (s^{(t)})^T$</p>\n<blockquote>\n<p>@注：由于向量 $s^{(t)}$（X的变化量）和向量 $y^{(t)}$（梯度变化量）的维数相同（都与 $X$ 维度相等），因此 $s^{(t)} (y^{(t)})^T$ 和 $s^{(t)} (s^{(t)})^T$ 是矩阵，而 $(y^{(t)})^T s^{(t)}$ 是一个数值，因此 $\\rho^{(t)}$ 是一个常数。</p>\n</blockquote>\n<p>则有：</p>\n<p>$<br>\\begin{aligned}<br>(V^{(t)})^T &amp;= \\left( I - \\rho^{(t)} y^{(t)} (s^{(t)})^T \\right)^T<br>\\<br>&amp;= I - \\rho^{(t)} \\left( y^{(t)} (s^{(t)})^T \\right)^T<br>\\<br>&amp;= I - \\rho^{(t)} s^{(t)} (y^{(t)})^T<br>\\<br>&amp;= I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$</p>\n<p>因此原 Hessian 更新公式变为：</p>\n<font color=EB6D39>\n\n<p>$$<br>D^{(t + 1)} = (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>$$</p>\n</font>\n\n<p>将上述迭代更新公式展开得：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\<br>&amp; \\Downarrow<br>\\<br>D^{(1)} &amp;= (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T<br>\\ \\<br>D^{(2)} &amp;= (V^{(1)})^T D^{(1)} V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\<br>&amp;= (V^{(1)})^T \\left( (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right) V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\<br>&amp;= (V^{(1)})^T (V^{(0)})^T D^{(0)} V^{(0)} V^{(1)} + (V^{(1)})^T \\rho^{(0)} s^{(0)} (s^{(0)})^T V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\<br>&amp; \\ \\ \\vdots<br>\\<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(0)})^T \\right] D^{(0)} \\left[ V^{(0)} V^{(1)} \\dots V^{(t)} \\right]<br>\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(1)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(1)} V^{(2)} \\dots V^{(t)} \\right]<br>\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(2)})^T \\right] \\left[ \\rho^{(1)} s^{(1)} (s^{(1)})^T \\right] \\left[ V^{(2)} V^{(3)} \\dots V^{(t)} \\right]<br>\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>从上述迭代过程可知，计算 $D^{(t + 1)}$ 需要用到 $\\left { s^{(k)} y^{(k)} \\right }^t_{k = 0}$，若存储空间有限，仅能存储 m 组 $\\left { s^{(k)} y^{(k)} \\right }$，当 $t &gt; m$ 时，应当丢弃较早生成的 $\\left { s^{(k)} y^{(k)} \\right }$。当然，由于丢弃了部分信息，此时计算的 $D^{(m + 1)}$ 是 $D^{(t + 1)}$ 的近似，也即 Hessian 矩阵的逆矩阵的进一步近似。</p>\n<p>当 $t &gt; m + 1$ 时，构造近似公式：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 1)})^T \\right] D^{(0)} \\left[ V^{(t - m + 1)} V^{(1)} \\dots V^{(t)} \\right]<br>\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 2)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(t - m + 2)} V^{(2)} \\dots V^{(t)} \\right]<br>\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>$D^{(t)}$ 的迭代计算很繁琐，但计算 $D^{(t)}$ 的目的是为了得到搜索方向 $d^{(t)} = D^{(t)} g^{(t)}$，因此可以设计快速计算 $D^{(t)} g^{(t)}$ 的方法：</p>\n<center>\n\n<p><img data-src=\"./double_circle_direction.png\" alt=\"双向循环快速求解搜索方向\" title=\"@ASSET\"></p>\n</center>\n\n<p>算法中还有部分不太明白，暂时只放上图片，待研究透彻后改为 Python 代码形式。另有几篇关于该双向循环快速求解 $D^{(t)} g^{(t)}$ 算法的参考文章如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://blog.csdn.net/red_stone1/article/details/80821760\" title=\"@LINK\">机器学习中牛顿法凸优化的通俗解释（作者：红色石头Will）</a></li>\n<li><a href=\"https://blog.csdn.net/itplus/article/details/21897715\" title=\"@LINK\">牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法（作者：皮果提）</a></li>\n<li><a href=\"https://blog.csdn.net/snaillup/article/details/53524415\" title=\"@LINK\">spark L-BFGS实现（作者：snaillup）</a></li>\n<li><a href=\"https://github.com/scalanlp/breeze/blob/master/math/src/main/scala/breeze/optimize/LBFGS.scala\" title=\"@LINK\">LBFGS.scala（作者：ScalaNLP）</a></li>\n<li><a href=\"https://liuxiaofei.com.cn/blog/lbfgs%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC/#lbfgs%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC\" title=\"@LINK\">LBFGS方法推导（作者：慢慢的回味）</a></li>\n</ol>\n</blockquote>\n<hr>\n<h1 id=\"3-Logistic优化求解算法\"><a href=\"#3-Logistic优化求解算法\" class=\"headerlink\" title=\"3. Logistic优化求解算法\"></a>3. Logistic优化求解算法</h1><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失：</p>\n<p>$<br>L(y, \\mu (X)) = - y \\log (\\mu (X)) - (1 - y) \\log (1 - \\mu (X))<br>$</p>\n<p>其中 $y$ 为真值， $\\mu (X)$ 为预测值为 1 的概率。</p>\n<p>与其他机器学习一样，Logistic 回归的目标函数也包括两项：训练集上的损失和 + 正则项。</p>\n<p>$<br>J(W; \\lambda) = \\sum^N_{i = 1} L(y_i, \\mu (X_i; W)) + \\lambda R(W)<br>$</p>\n<blockquote>\n<p>@注：由于 L1 正则在零点不可导，因此当正则项中含有 L1 正则时，不能直接使用基于梯度、Hessian 矩阵的优化求解算法，而通常使用坐标轴下降法求解，或也可使用次梯度法。</p>\n</blockquote>\n<p>在给定正则参数 $\\lambda$ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W, \\lambda)$，取得最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W, \\lambda)} {\\partial W} = 0$。</p>\n<p>与线性回归模型不同的是，Logistic 回归模型的参数无法用解析法求解，因此可使用迭代法逼近求解。</p>\n<p>其中一阶近似有与梯度相关的几个算法：</p>\n<ul>\n<li>梯度下降（Logistic 使用梯度下降法收敛速度较慢）</li>\n<li>随机梯度下降（SGD）</li>\n<li>随机平均梯度法（SAG）</li>\n<li>随机平均梯度法改进版（SAGA）</li>\n<li>共轭梯度</li>\n<li>坐标轴下降</li>\n</ul>\n<p>二阶近似有：</p>\n<ul>\n<li>牛顿法</li>\n<li>拟牛顿法（BFGS、L-BFGS）</li>\n</ul>\n<p>观察目标函数的损失和部分：</p>\n<p>$<br>J_1 (W) = \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>$</p>\n<h2 id=\"3-1-梯度\"><a href=\"#3-1-梯度\" class=\"headerlink\" title=\"3.1 梯度\"></a>3.1 梯度</h2><p>最优化问题的求解离不开梯度的计算，由于目标函数中包含了 $\\mu$，即 Sigmoid 变换，记 $\\mu_i = \\mu (X_i; W) = \\sigma (W^T X_i)$，令 $z_i = W^T X_i$，根据复合函数的求导，$\\dfrac {\\partial \\mu_i} {\\partial W}$ 的求解如下：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {\\partial \\sigma (W^T X_i)} {\\partial W} = \\dfrac {\\partial \\sigma {z_i}} {\\partial W}<br>\\<br>&amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\end{aligned}<br>$</p>\n<p>其中 ① 复合函数外层 $\\sigma (z_i)$ 求导：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {d \\sigma (z_i)} {d z_i} &amp;= \\dfrac {d (\\dfrac {1} {1 + e^{- z_i}})} {d z_i}<br>\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times \\dfrac {d (1 + e^{- z_i})} {d z_i}<br>\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times (- e^{- z_i})<br>\\<br>&amp;= \\dfrac {1} {(1 + e^{- z_i})^2} \\times (e^{- z_i})<br>\\<br>&amp;= \\dfrac {1} {1 + e^{- z_i}} \\times \\dfrac {(1 + e^{- z_i}) - 1} {1 + e^{- z_i}}<br>\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i))<br>\\end{aligned}<br>$</p>\n<p>② 复合函数内层 $z_i$ 求导：</p>\n<p>$<br>\\dfrac {\\partial z_i} {\\partial W} = \\dfrac {\\partial (W^T X_i)} {\\partial W} = X_i<br>$</p>\n<p>综合上述 2 式得：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i)) \\times X_i<br>\\<br>&amp;= \\mu_i \\times (1 - \\mu_i) \\times X_i<br>\\end{aligned}<br>$</p>\n<p>回到目标函数梯度，将上式代入求导得：</p>\n<p>$<br>\\begin{aligned}<br>J_1 (W) &amp;= \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>\\<br>&amp;= \\sum^N_{i = 1} \\left( - y_i \\log \\mu_i - (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\<br>&amp;= - \\sum^N_{i = 1} \\left(y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\end{aligned}<br>$</p>\n<p>$<br>\\begin{aligned}<br>g_1 (W) &amp;= \\nabla J_1 (W) = \\dfrac {d J_1 (W)} {d W}<br>\\<br>&amp;= - d \\left( \\sum^N_{i = 1} \\left( y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right) \\right) / d W<br>\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} \\times \\dfrac {\\partial \\mu_i} {\\partial W} + (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\times - \\dfrac {\\partial \\mu_i} {\\partial W} \\right)<br>\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} - (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\right) \\times \\mu_i (1 - \\mu_i) X_i<br>\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i (1 - \\mu_i) - (1 - y_i) \\mu_i \\right) \\times X_i<br>\\<br>&amp;= - \\sum^N_{i = 1} (y_i - \\mu_i) \\times X_i<br>\\<br>&amp;= (\\mu - y) X<br>\\end{aligned}<br>$</p>\n<p>整理可得 Logistic 回归损失和部分的梯度表达式：</p>\n<font color=EB6D39>\n\n<p>$$<br>g_1 (W) = X^T (\\mu - y)<br>$$</p>\n<blockquote>\n<p>@注：这里直接解出来的结果是 $(\\mu - y) X$，但表达式使用的是 $X^T (\\mu - y)$，对此我有些自己的理解方式如下。</p>\n</blockquote>\n<p>首先要提一下矩阵的形式。在机器学习中有一个很重要的工具包 <code>numpy</code>，这个工具包里其中两个很重要的类：<code>numpy.matrix</code> 和 <code>numpy.array</code>也即矩阵和向量，通常手动创建一个矩阵的时候可以用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>A = np.matrix([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">[[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"> [<span class=\"number\">3</span> <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<p>这就可以视为一个 2 x 2 的矩阵：$\\left[ \\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{matrix} \\right]$，但是当我们如下创建一个向量时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>B = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B.shape)</span><br><span class=\"line\">(<span class=\"number\">2</span>,)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，尽管输出的 B 的形式还是 <code>[1 2]</code>，但这是一个 2 行（也即 1 列）的向量（之所以没有标出 <code>(2, 1)</code> 是因为向量要么只有 1 行要么只有 1 列，防止与矩阵的 n x m 搞混了）。也就是说，默认情况下的向量是列向量，这也符合机器学习中的直觉，例如标签 y，预测值，或单个特征等都是列向量。</p>\n<p>回到原问题的梯度表达式中，假设训练数据共有 D 维特征 N 个样本，则 X 是 N x D 维的矩阵，$\\mu$ 和 y 均为 N 行的列向量，都知道矩阵的乘法 (A x B) 需要满足 A 的列数 = B 的行数时才有意义，而当作为矩阵运算 $(\\mu - y) X$ 时，$(\\mu - y)$ 列数为 1，此时无论 $X$ 是否转置，$(\\mu - y) X$ 都无意义，不能做乘法运算。因此 $\\sum^N_{i = 1} (\\mu_i - y_i) \\times X_i$ 转换为矩阵表达式时，将 $X$ 提到左乘并转置，不仅 $X^T$ 的列数恰好为 N，与 $\\mu$ 和 $y$ 的行数相等，可以做乘法，而且从矩阵的乘法运算规则上符合直观地计算过程（$X$ 转置后，每一列为一个样本，分别与每个 $(\\mu_i - y_i)$ 相乘）。</p>\n<p>因此，梯度的表达式为：$g_1 (W) = X^T (\\mu - y)$。</p>\n</font>\n\n<h2 id=\"3-2-Hessian矩阵\"><a href=\"#3-2-Hessian矩阵\" class=\"headerlink\" title=\"3.2 Hessian矩阵\"></a>3.2 Hessian矩阵</h2><p>Logistic 损失和部分的梯度为 $g_1 (W) = X^T (\\mu - y)$，由此求解 Hessian 矩阵：</p>\n<p>$<br>\\begin{aligned}<br>H_1 (W) &amp;= \\dfrac {\\partial g_1 (W)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} (\\mu_i - y_i) X_i \\right)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} X^T_i (\\mu_i - y_i) \\right)} {\\partial W}<br>\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\dfrac {\\partial (\\mu_i)} {\\partial W}<br>\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\mu_i (1 - \\mu_i) X_i<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>@注：说明：$\\dfrac {\\partial (a^T y)} {\\partial y} = a^T$</p>\n</blockquote>\n<p>令矩阵 $S \\triangleq \\mu_i (1 - \\mu_i)$，即 $S$ 为对角阵，对角元素为 $\\mu_i (1 - \\mu_i)$。可得 Hessian 矩阵表达式：</p>\n<font color=EB6D39>\n\n<p>$$<br>H_1 (W) = X^T S X<br>$$</p>\n</font>\n\n<h2 id=\"3-3-牛顿法求解Logistic损失函数和极小值：IRLS\"><a href=\"#3-3-牛顿法求解Logistic损失函数和极小值：IRLS\" class=\"headerlink\" title=\"3.3 牛顿法求解Logistic损失函数和极小值：IRLS\"></a>3.3 牛顿法求解Logistic损失函数和极小值：IRLS</h2><p>当解得梯度 $g_1 (W) = X^T (\\mu - y)$ 和 Hessian 矩阵 $H_1 (W) = X^T S X$ 后，即可代入牛顿迭代公式中：</p>\n<p>$<br>\\begin{aligned}<br>W^{(t + 1)} &amp;= W^{(t)} - H(W^{(t)})^{-1} g(W)<br>\\<br>&amp;= W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\<br>&amp;= (X^T S^{(t)} X)^{-1} (X^T S^{(t)} X) \\times W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T (\\mu - y) \\right)<br>\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T S^{(t)} {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\<br>&amp;= (X^T S^{(t)} X)^{-1} X^T S^{(t)} \\times \\left( X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\end{aligned}<br>$</p>\n<p>令 $z^{(t)} \\triangleq X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y)$，则得到牛顿法迭代求 Logistic 损失函数和极小值的解：</p>\n<font color=EB6D39>\n\n<p>$$<br>W^{(t + 1)} = (X^T S^{(t)} X)^{-1} X^T S^{(t)} z^{(t)}<br>$$</p>\n</font>\n\n<p>对比线性回归 $X W = y$ 方程中最小二乘的解：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，给每个样本加权（每个样本的权重为 $S_i$）即可得加权最小二乘的解：</p>\n<p>$<br>\\hat{W}_{OLS_weight} = (X^T S X)^{-1} X^T y<br>$</p>\n<p>牛顿迭代法求得的 Logistic 损失函数和极小值的解 与 加权最小二乘的解形式类似，因此也称为 **<font color=EB6D39>迭代加权最小二乘（Iteratively Reweighted Least Squares, IRLS）</font>**，其中每个样本的权重为 $S_i = \\mu_i (1 - \\mu_i)$。而 IRLS 又通过 共轭梯度（Conjugate Gradient）法 求解，因此 Scikit-Learn 中采用牛顿法求解的优化算法为 <code>&#39;newton-cg&#39;</code>。</p>\n<hr>\n<h1 id=\"4-Logistic的优化求解器Solver\"><a href=\"#4-Logistic的优化求解器Solver\" class=\"headerlink\" title=\"4. Logistic的优化求解器Solver\"></a>4. Logistic的优化求解器Solver</h1><p>Logistic 回归有多种优化求解方法。当使用 L2 正则时，可采用所有优化算法，而由于 L1 正则在零点处不可导，因此次不能使用需要计算梯度 / Hessian 矩阵的方法，此时可以类似 Lasso 求解，采用坐标轴下降法。</p>\n<p>Scikit-Learn 中的 Logistic 类已在：<a href=\"/post/machinelearning/ml-logistic/ml-logistic-introduction/ml-logistic-introduction/\" title=\"@LINK\">《ML入门——Logistic回归简介》</a> 文中介绍，此处展开参数 <code>solver</code> 的一些可选项：</p>\n<p>‘liblinear’：<br>线性求解器，适用于小数据集，支持 L1 正则和 L2 正则。<br>内部使用了坐标轴下降法来迭代优化损失函数，如果模型的特征非常多，希望一些不重要的特征系数归零从而让模型系数稀疏的话，可以使用 L1 正则化。在多类 Logistic 回归任务中仅支持 OvR，不支持多项分布损失（MvM），但 MVM 相对精确。</p>\n<p>‘lbfgs’：<br>拟牛顿法，适用于较大数据集，仅支持 L2 正则。<br>支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘newton-cg’：<br>牛顿法，适用于较大数据集，仅支持 L2 正则。<br>每个大迭代中的加权最小二乘回归部分采用共轭梯度算法实现。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘sag’：<br>随机平均梯度下降，适用于很大（如大于 5 万）的数据集，仅支持 L2 正则。<br>梯度下降法的变种，支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>‘saga’：<br>改进的随机平均梯度下降，适用于非常大的数据集，支持 L1 正则。<br>当数据量很大，且选择 L1 正则时，只能采用 ‘saga’ 优化求解器。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>其中，’sag’ 和 ‘saga’ 只有在特征尺度大致相等时才能保证收敛，因此需要对数据做缩放（<code>class sklearn.preprocessing</code> 可以实现如：标准化、MinMaxScaler、MaxAbsScaler 等）。在实际任务中，大部分情况下数据预处理时都最好做标准化。实际上，加正则项本身也要求对每维特征做缩放。</p>\n<p>另外，对于大数据集的训练任务，可以使用 <code>SGDClassifier</code>，并使用 LogLoss 作为损失函数。</p>\n<blockquote>\n<p>@注：若 <code>SGDClassifier</code> 使用 HingeLoss 作为损失函数，则为实现随机梯度下降的 SVM。在回归任务中还有 <code>SDGRegressor</code>。</p>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-交叉验证与模型选择","url":"/post/machinelearning/ml-model/ml-model-selection/","content":"<span id=\"more\"></span>\n\n<h1 id=\"1-模型的交叉验证\"><a href=\"#1-模型的交叉验证\" class=\"headerlink\" title=\"1. 模型的交叉验证\"></a>1. 模型的交叉验证</h1><h2 id=\"1-1-划分校验集\"><a href=\"#1-1-划分校验集\" class=\"headerlink\" title=\"1.1 划分校验集\"></a>1.1 划分校验集</h2><p>模型的评估不能在训练集上进行，而应该在新的测试数据上检验其 推广能力 / 泛化能力。但在实际任务中，测试数据往往是需要用来预测的数据，其标签是未知的，因此可以选择从全体训练数据中分离出一部分作为校验数据，不参与模型的训练：</p>\n<center>\n\n<p><img data-src=\"./check_data.png\" alt=\"校验数据\" title=\"@ASSET\"></p>\n</center>\n\n<p>当训练样本足够多时，划分剩下的训练样本仍足以训练出较好的模型时，即可采用这个方式。Scikit-Learn 中提供了划分校验集的功能：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.train_test_split</span></span><br><span class=\"line\"></span><br><span class=\"line\">X_train, X_test, y_train, y_test = train_test_split(*arrays, **options)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X, y = np.arange(<span class=\"number\">10</span>).reshape((<span class=\"number\">5</span>, <span class=\"number\">2</span>)), <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X</span><br><span class=\"line\">array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(y)</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class=\"line\">         X, y, test_size=<span class=\"number\">0.33</span>, random_state=<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train</span><br><span class=\"line\">array([[<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_train</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_test</span><br><span class=\"line\">array([[<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_test</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>train_test_split(y, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\">[[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<p><code>*arrays</code>：<br>需要划分的数据 (X, y)。sequence of indexables with same length / shape[0].<br>Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.</p>\n<p><code>test_size</code>：<br>校验集大小。float, int or None, optional (default=None)<br>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If train_size is also None, it will be set to 0.25.</p>\n<p><code>train_size</code>：<br>训练集大小。float, int, or None, (default=None)<br>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.</p>\n<p><code>random_state</code>：<br>随机种子。int, RandomState instance or None, optional (default=None)<br>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.</p>\n<p><code>shuffle</code>：<br>划分数据前是否洗牌。boolean, optional (default=True)<br>Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.</p>\n<p><code>stratify</code>：<br>分层抽样。array-like or None (default=None)<br>If not None, data is split in a stratified fashion, using this as the class labels.<br>分层抽样主要用在分类数据类别样本不均衡的时候，如正负样本比例为 1 : 9，假设划 20% 作为校验数据，则分别对正样本和负样本各自划分 20% 作为校验数据再合并。</p>\n<blockquote>\n<p>@注：<code>train_test_split</code> 还能在数据集较大时，用来分隔出小部分数据进行 EDA。</p>\n</blockquote>\n<h2 id=\"1-2-交叉验证\"><a href=\"#1-2-交叉验证\" class=\"headerlink\" title=\"1.2 交叉验证\"></a>1.2 交叉验证</h2><p>当训练数据比较少，或模型训练需要更多数据时（训练样本越多越好），直接分离校验集就不太好了，这时可使用 K 折交叉验证。</p>\n<p>K 折交叉验证即：将全体训练样本等分为 K 份（若无法完全等分，多出来的部分都放进最后一份中），每次用 1 份数据作为校验集，余下 (K - 1) 份作为训练数据，重复 K 次：</p>\n<center>\n\n<p><img data-src=\"./k_fold.png\" alt=\"K 折交叉验证\" title=\"@ASSET\"></p>\n</center>\n\n<blockquote>\n<p>@注：该方法计算代价很高，但不会浪费太多数据，当样本数据集较少时有优势，K 常取 [3, 5, 10]。</p>\n</blockquote>\n<p>Scikit-Learn 中实现了 K 折交叉验证 <code>KFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.KFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">KFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">      shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>n_splits</code>：<br>交叉验证的折数 K，默认为 3。</p>\n<p><code>shuffle</code>：<br>是否在划分数据之前对全体数据进行洗牌（打乱顺序）。</p>\n<p><code>random_state</code>：<br>由随机数产生器产生的随机种子。当参数 <code>shuffle == True</code> 时用到。</p>\n<p>当数据是分类数据时（标签 y 为类别），为保证每折中各个类别样本比例一致，Scikit-Learn 实现了分层（Stratified）的 K 折交叉验证 <code>StratifiedKFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.StratifiedKFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">                shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                random_state=<span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> StratifiedKFold</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf = StratifiedKFold(n_splits=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf.get_n_splits(X, y)  <span class=\"comment\"># 得到划分结果</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf</span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">2</span>, random_state=<span class=\"literal\">None</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> train_index, test_index <span class=\"keyword\">in</span> skf.split(X, y):</span><br><span class=\"line\">    <span class=\"comment\"># split() 取出每折训练和校验数据的索引</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;TRAIN:&quot;</span>, train_index, <span class=\"string\">&quot;TEST:&quot;</span>, test_index)</span><br><span class=\"line\">        X_train, X_test = X[train_index], X[test_index]</span><br><span class=\"line\">        y_train, y_test = y[train_index], y[test_index]</span><br><span class=\"line\"></span><br><span class=\"line\">TRAIN: [<span class=\"number\">1</span> <span class=\"number\">3</span>] TEST: [<span class=\"number\">0</span> <span class=\"number\">2</span>]</span><br><span class=\"line\">TRAIN: [<span class=\"number\">0</span> <span class=\"number\">2</span>] TEST: [<span class=\"number\">1</span> <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>StratifiedKFold</code> 参数含义与 <code>KFold</code> 相同。</p>\n<p>假设有一训练数据集如下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">样本索引</th>\n<th align=\"center\">$x_1$</th>\n<th align=\"center\">$x_2$</th>\n<th align=\"center\">y</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>K 折交叉验证中，校验验证通常用于 模型选择 / 超参数调优（评价不同超参数对应模型的性能）。交叉验证的步骤流程如下图：</p>\n<center>\n\n<p><img data-src=\"./k_fold_detail.png\" alt=\"K 折交叉验证流程\" title=\"@ASSET\"></p>\n</center>\n\n<p>Scikit-Learn 中实现两个了采用 K 折交叉验证评估模型性能的函数：<code>cross_val_score</code> 和 <code>cross_validate</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_val_score</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_val_score(estimator,</span><br><span class=\"line\">                X,</span><br><span class=\"line\">                y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_val_score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(cross_val_score(lasso, X, y, cv=<span class=\"number\">3</span>))</span><br><span class=\"line\">[<span class=\"number\">0.33150734</span> <span class=\"number\">0.08022311</span> <span class=\"number\">0.03531764</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>estimator</code>：<br>要训练的模型</p>\n<p><code>X, y</code>：<br>全体训练数据</p>\n<p><code>groups</code>：<br>数据的分组标识。<br>通常假设数据是独立同分布（Independent Identical Distribution, IID），但在有些应用中如果数据生成过程依赖于样本的 groups，（如从多个患者收集医学数据，从每个患者身上采集多个样本。则每个样本的患者 ID 是其分组标识）。在这种情况下，想知道在一组特定的 groups 上训练的模型是否能很好地适用于未见过的 group 。因此，要确保验证数据的所有样本与对应的训练折中的数据没有相同的组。（Scikit-Learn 中有一整套与 groups 有关的校验验证实现）。</p>\n<p><code>scoring</code>：<br>评价指标。</p>\n<p><code>cv</code>：<br>交叉校验划分策略。可为整数（交叉验证的折数 K）、交叉验证生成器的对象、产生 train / test 划分的迭代器对象。默认为 <code>None</code>，采用3折交叉验证。输入类别数据时，自动采用分层抽样。</p>\n<p><code>n_jobs</code>：<br>使用CPU的数目，-1 表示使用所有的CPU资源（与设置为 CPU 核的数目效果相同）。</p>\n<p><code>verbose</code>：<br>日志冗长度。<br>0：不输出训练过程<br>1：偶尔输出<br>$&gt; 1$：对每个子模型都输出</p>\n<p><code>fit_params</code>：<br>estimator 的 <code>fit()</code> 函数需要的参数。</p>\n<p><code>pre_dispatch</code>：<br>控制并行计算中预派遣的任务数。<br>根据设备条件（内存大小）设置。例如 12 折 CV 任务，且 <code>n_jobs = 3</code>。<br>① 当该参数不设置时，程序一次性将所有并行任务派遣给 CPU，则 3 个 CPU 各获得 4 份 CV 训练数据集和 4 份 测试数据集，并存放在内存中，各个 CPU 则按顺序训练，此时内存占用最高，但由于提前一次性将所有数据分配完毕，开始训练后的等待时间最小。<br>② 当设置 <code>pre_dispatch=&#39;1*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 3</code>，则程序每次只为 3 个 CPU 各分配一份数据，分配后 CPU 立即开始训练，训练完成后再次分配，此时内存占用最低，但由于每次训练完后才分配数据，开始训练后的等待时间最长。<br>③ 当设置 <code>pre_dispatch=&#39;2*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 6</code>，则 3 个 CPU 各获得两份 CV 训练数据（一份即时训练，另一份在队列中等待）并存储在内存中，当某个 CPU 训练完一份 CV 数据后，程序再分配下一份数据，直到所有数据均被分配完毕。通常这种设置的综合效果最佳。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_validate(estimator,</span><br><span class=\"line\">               X,</span><br><span class=\"line\">               y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">               verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">               fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">               return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_validate</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics.scorer <span class=\"keyword\">import</span> make_scorer</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> confusion_matrix</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.svm <span class=\"keyword\">import</span> LinearSVC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Single metric evaluation using cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(cv_results.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;fit_time&#x27;</span>, <span class=\"string\">&#x27;score_time&#x27;</span>, <span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cross_validate 可以得到每折的训练和校验得分，此处仅查看校验得分。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results[<span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\">array([<span class=\"number\">0.33150734</span>, <span class=\"number\">0.08022311</span>, <span class=\"number\">0.03531764</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiple metric evaluation using cross_validate</span></span><br><span class=\"line\"><span class=\"comment\"># (please refer the scoring parameter doc for more information)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scores = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                        scoring=(<span class=\"string\">&#x27;r2&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                                 <span class=\"string\">&#x27;neg_mean_squared_error&#x27;</span>),</span><br><span class=\"line\"><span class=\"meta\">... </span>                        return_train_score=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多种评价指标：&#x27;r2&#x27;, &#x27;neg_mean_squared_error&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;test_neg_mean_squared_error&#x27;</span>])</span><br><span class=\"line\">[-<span class=\"number\">3635.5</span>... -<span class=\"number\">3573.3</span>... -<span class=\"number\">6114.7</span>...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;train_r2&#x27;</span>])</span><br><span class=\"line\">[<span class=\"number\">0.28010158</span> <span class=\"number\">0.39088426</span> <span class=\"number\">0.22784852</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>return_train_score</code>：<br>是否包含训练得分。<br>默认 ‘warn’ 表示真，包含训练得分。计算训练得分可以通过训练得分和校验得分查看模型在过拟合状态还是欠拟合状态。但是训练得分较慢，且不计算也不影响模型 的最佳参数选取（最佳参数只看校验得分），后续版本可能将缺省值设为 <code>False</code>。</p>\n<p>其他参数与 <code>cross_val_score</code> 相同。</p>\n<p>使用 <code>cross_validate</code> 可以输出训练集和校验集上的分数，从而判断是否处于欠拟合或过拟合的状态。</p>\n<h2 id=\"1-3-特殊的交叉验证\"><a href=\"#1-3-特殊的交叉验证\" class=\"headerlink\" title=\"1.3 特殊的交叉验证\"></a>1.3 特殊的交叉验证</h2><h3 id=\"1-3-1-留一交叉验证\"><a href=\"#1-3-1-留一交叉验证\" class=\"headerlink\" title=\"1.3.1 留一交叉验证\"></a>1.3.1 留一交叉验证</h3><p>特别地，当交叉验证的折数与样本数相等时（$K = N$），因为每次仅留出一个样本做校验，因此称为留一交叉验证。由于折数更多，通常进行时间也更长，一般仅在样本数非常少的时候使用。</p>\n<p>但对于线性模型，可以采用广义交叉验证（Generalized Cross Validation, GCV）来近似留一交叉验证，极大降低交叉验证的计算量。Scikit-Learn 中实现了基于 GCV 的线性模型，如：<code>RidgeCV</code>, <code>LassoCV</code>, <code>LogisticRegressionCV</code> 等。其流程大致如下图：</p>\n<center>\n\n<p><img data-src=\"./leave_one_cv.png\" alt=\"留一交叉验证\" title=\"@ASSET\"></p>\n</center>\n\n<h3 id=\"1-3-2-自助法（Bootstrap）\"><a href=\"#1-3-2-自助法（Bootstrap）\" class=\"headerlink\" title=\"1.3.2 自助法（Bootstrap）\"></a>1.3.2 自助法（Bootstrap）</h3><p>交叉验证（包括留一交叉验证）均为无放回采样，一个实例仅能被选择一次。而 Bootstrap 是有放回采样，假设数据集中有 N 个样本，每次有放回地从数据集中抽取一个样本，共采样 N 次。一个 Bootstrap 样本有 N 个样本，其中很可能存在重复数据。由于每个样本被采样的概率为 $\\dfrac {1} {N}$，则不被采样的概率为 $1 - \\dfrac {1} {N}$，因此一个 Bootstrap 的 N 个样本中，某个样本点不被采样的概率为 $(1 - \\dfrac{1} {N})^N \\approx 0.368$，也即一个 Bootstrap 样本中只包含了全体训练集中约 $63.2 %$ 的数据（K 折交叉验证每次包含 $1 - \\dfrac {1} {K}$ 的训练数据），因此也称为“0.632 自助法”。</p>\n<h3 id=\"1-3-3-特殊的校验验证\"><a href=\"#1-3-3-特殊的校验验证\" class=\"headerlink\" title=\"1.3.3 特殊的校验验证\"></a>1.3.3 特殊的校验验证</h3><p>通常，训练数据假设是独立同分布的（Independent Identical Distribution, IID）。</p>\n<p>但在实际任务中，有时样本时使用与时间相关的过程生成的，也即样本间存在时序关系，样本与各自的时序强相关，例如股票的价格等，此时使用 time-series aware cross-validation scheme 更安全。</p>\n<p>同样，如果知道数据生成过程中具有分组结构（group structure），例如从不同 subjects、不同实验、不同测量设备收集的样本等，则使用 group-wise cross-validation 更安全。</p>\n<hr>\n<h1 id=\"2-超参数调优\"><a href=\"#2-超参数调优\" class=\"headerlink\" title=\"2. 超参数调优\"></a>2. 超参数调优</h1><p>Scikit-Learn 中实现了基于交叉验证的模型超参数调优方法 <code>GridSearchCV</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.GridSearchCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">GridSearchCV(estimator,</span><br><span class=\"line\">             param_grid,</span><br><span class=\"line\">             scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">             iid=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             refit=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">             error_score=<span class=\"string\">&#x27;raise&#x27;</span>,</span><br><span class=\"line\">             return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> svm, datasets</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> GridSearchCV</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>iris = datasets.load_iris()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parameters = &#123;<span class=\"string\">&#x27;kernel&#x27;</span>:(<span class=\"string\">&#x27;linear&#x27;</span>, <span class=\"string\">&#x27;rbf&#x27;</span>), <span class=\"string\">&#x27;C&#x27;</span>:[<span class=\"number\">1</span>, <span class=\"number\">10</span>]&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>svc = svm.SVC(gamma=<span class=\"string\">&quot;scale&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf = GridSearchCV(svc, parameters, cv=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fit 过程可能较慢，若有 M 个参数需搜索，采用 K 折交叉验证，则需训练 M x K 次。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf.fit(iris.data, iris.target)</span><br><span class=\"line\">GridSearchCV(cv=<span class=\"number\">5</span>,</span><br><span class=\"line\">             error_score=...,</span><br><span class=\"line\">             estimator=SVC(C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                           cache_size=...,</span><br><span class=\"line\">                           class_weight=...,</span><br><span class=\"line\">                           coef0=...,</span><br><span class=\"line\">                           decision_function_shape=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                           degree=...,</span><br><span class=\"line\">                           gamma=...,</span><br><span class=\"line\">                           kernel=<span class=\"string\">&#x27;rbf&#x27;</span>,</span><br><span class=\"line\">                           max_iter=-<span class=\"number\">1</span>,</span><br><span class=\"line\">                           probability=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                           shrinking=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                           tol=...,</span><br><span class=\"line\">                           verbose=<span class=\"literal\">False</span>),</span><br><span class=\"line\">             iid=...,</span><br><span class=\"line\">             n_jobs=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             param_grid=...,</span><br><span class=\"line\">             pre_dispatch=...,</span><br><span class=\"line\">             refit=...,</span><br><span class=\"line\">             return_train_score=...,</span><br><span class=\"line\">             scoring=...,</span><br><span class=\"line\">             verbose=...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出的结果都保存在字典 cv_results_ 中。</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳超参数：best_params_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳得分：best_score_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳模型：best_estimator_，仅在设置 refit=true 时适用</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(clf.cv_results_.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;mean_fit_time&#x27;</span>, <span class=\"string\">&#x27;mean_score_time&#x27;</span>, <span class=\"string\">&#x27;mean_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;param_C&#x27;</span>, <span class=\"string\">&#x27;param_kernel&#x27;</span>, <span class=\"string\">&#x27;params&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;rank_test_score&#x27;</span>, <span class=\"string\">&#x27;split0_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;split2_test_score&#x27;</span>, ...</span><br><span class=\"line\"> <span class=\"string\">&#x27;std_fit_time&#x27;</span>, <span class=\"string\">&#x27;std_score_time&#x27;</span>, <span class=\"string\">&#x27;std_test_score&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>param_grid</code>：<br>待评价参数（可以多个超参数一起调优：grid）。</p>\n<p><code>X, y</code>：<br>全体训练数据。</p>\n<p><code>iid</code>：<br>样本是否是独立同分布。</p>\n<p><code>refit</code>：<br>评价指标。<br>是否在找到最佳超参数后用全体训练数据再次训练模型参数。</p>\n<p><code>error_score</code>：<br>训练失败的处理</p>\n<p><strong><font color=EB6D39>总结来说，K 折交叉验证可以检验超参数对应的模型的性能，配合网格搜索 <code>GridSearchCV</code> 可以遍历一段取值范围内的超参数 $\\lambda$ 并找到模型效果最好时的超参数 $\\lambda^{\\ast}$，再选定该超参数，使用全体训练数据再次训练模型，得到最佳模型参数 $W$，最终模型为 $f(X;W, \\lambda^{\\ast})$ 。</font></strong></p>\n","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","交叉验证"]},{"title":"Android-ObjectAnimator","url":"/post/android/android-objectanimator/","content":"<span id=\"more\"></span>\n\n<p>前言：之前的项目有一个功能需要对“画布”进行动画变换而不改变 View 本身，在上一篇<a href=\"/post/Android/android-matrix-basic/android-matrix-basic/\" title=\"@LINK\">Android属性——Matrix矩阵</a>中，已经用 <strong>Matrix</strong> 实现了对画布的变换，但只能实现跳跃式变换，还需要加上平缓的动画过渡效果，因此搭配使用 <strong>ObjectAnimator</strong> 实现功能并记录于本文。</p>\n<hr>\n<h1 id=\"1-构思\"><a href=\"#1-构思\" class=\"headerlink\" title=\"1. 构思\"></a>1. 构思</h1><p>在项目中，有一个功能是希望能在介绍页对 App 的功能做一些引导指示，一开始构思这个效果的时候，最简单的也是最容易想到的方式就是预设固定的图片，在需要时设置显示，不需要提示时隐藏：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//需要提示时</span></span><br><span class=\"line\">imageView.setVisibility(View.VISIBLE);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//不需要提示时</span></span><br><span class=\"line\">imageView.setVisibility(View.INVISIBLE);</span><br></pre></td></tr></table></figure>\n\n<p>但是这种方式太过简单和死板界面也相当不优雅，并且也只能完成一些非常非常简单的视图展示效果，在需要动态展示一些过程的时候就很难实现预期效果了。于是想到了 <strong>ValueAnimator</strong> ——数值属性动画这个神奇的东西，ValueAnimator 是一个非常强大的类。但是为什么最后还是没有用 ValueAnimator 呢？接下来本篇就会对 ValueAnimator 做一个简单的介绍，并解释其与 ObjectAnimator 的联系和异同。</p>\n<hr>\n<h1 id=\"2-ValueAnimator与ObjectAnimator\"><a href=\"#2-ValueAnimator与ObjectAnimator\" class=\"headerlink\" title=\"2. ValueAnimator与ObjectAnimator\"></a>2. ValueAnimator与ObjectAnimator</h1><p>提到这两个东西，就必须首先说明：<strong>ValueAnimator</strong> 是 <strong>ObjectAnimator</strong> 它爹（ObjectAnimator：？？？），ObjectAnimator 是继承自 ValueAnimator 的，因此 ObjectAnimator 具有 ValueAnimator 的全部特性，并重写了 ValueAnimator 中的部分方法，定性地总结一句，<font color=#EB6D39>ObjectAnimator 具有更高的灵活性和便捷性</font>。<br>（这两个类名字可还真长啊）</p>\n<h2 id=\"2-1-ValueAnimator的基本介绍\"><a href=\"#2-1-ValueAnimator的基本介绍\" class=\"headerlink\" title=\"2.1 ValueAnimator的基本介绍\"></a>2.1 ValueAnimator的基本介绍</h2><p>虎父无犬子，ObjectAnimator 既然能被广泛使用，其父类 ValueAnimator 作为一个强大的属性动画类当然要放在前面先说说了。ValueAnimator 提供了一系列改变属性的方式，在提供属性动画时，可以选择不同的数值增长方式控制属性值，线性增长、曲线增长等等，例如在缩放显示图像的过程中，如果选择线性增长，图片将匀速缩放，如果选择曲线增长，图片可以以加速或减速的方式缩放，并且还支持在动画执行过程中获取其值的分布和执行的过程监控等，<strong>但是！</strong> ValueAnimator 本身并不会改变控件的属性，也不会直接与动画本身进行联系和控制，常用的创建一个 ValueAnimator 对象的方法是：<code>ValueAnimator valueAnimator = ValueAnimator.ofXXX(xxx...);</code>，其中 <code>XXX</code> 表示不同类型的数据（int、float、args等），<code>xxx...</code> 表示变化范围，是一个可变长参数，例如给定 <code>ofInt(1, 0);</code>，表示从1变为0，给定 <code>ofInt(1, 0, 1);</code> 表示从1变为0再变为1。</p>\n<p>ValueAnimator 实现动画的原理在于使用了：<font color=#EB6D39>Interpolator（插值器）</font> 和  <font color=#EB6D39>TypeEvaluator（数值计算器）</font>，通俗的说，Interpolator 可以根据给出的值来设定数值的变化方式，例如上文中提到的线性和曲线方式。其他 Interpolator 可以参考下面引用博文内的配图（特别简单明了，大赞！）。</p>\n<p>在缩放执行的过程中，动画效果主要就是靠这两个工具来实现的。当我们给出需要缩放的目标大小是从原大小（缩放率为1）放大到2倍（缩放率为2），缩放时间为1秒，并选择线性增长的 Interpolator，那么 TypeEvaluator 就会生成一个时间长度为1秒，且缩放值从1到2的一系列数值，我们无法列举出每一个产生的数值，但是可以知道，当动画刚刚开始第0秒时，TypeEvaluator 计算的缩放率是1；当动画结束的第1秒时，缩放率是2；而在中间第0.5秒时，缩放率是1.5……也就是说，TypeEvaluator 会根据选定的 Interpolator 替我们计算好了某个时刻应该变化的具体值是多少，然后通过快速、连续地设定这个值来产生动画的效果。下面是改变一个 ImageView 的透明度的 Demo，布局很简单，一个 ImageView 一个 Button：</p>\n<center>\n\n<p><img data-src=\"./image_initial.png\" alt=\"初始状态\" title=\"@ASSET\"></p>\n</center>\n\n<p>点击 Button 改变透明度：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化控件</span></span><br><span class=\"line\">ImageView ivImage = findViewById(R.id.ivImage);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建ValueAnimator对象，并给定透明度变化为从完全显示到完全消失</span></span><br><span class=\"line\">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//动画时间为1秒</span></span><br><span class=\"line\">valueAnimator.setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置插值方式为线性插值，即透明度匀速变化</span></span><br><span class=\"line\">valueAnimator.setInterpolator(<span class=\"keyword\">new</span> LinearInterpolator() );</span><br><span class=\"line\"><span class=\"comment\">//开始动画</span></span><br><span class=\"line\">valueAnimator.start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听属性数值的改变并手动做事件处理</span></span><br><span class=\"line\">valueAnimator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取到改变的值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> updateValue = animation.getAnimatedValue();</span><br><span class=\"line\">        <span class=\"comment\">//改变TextView的透明度</span></span><br><span class=\"line\">        ivImage.setAlpha(updateValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>看一下效果：</p>\n<center>\n\n<p><img data-src=\"./click_change_alpha.gif\" alt=\"点击改变透明度\" title=\"@ASSET\"></p>\n</center>\n\n<p>当然这里还要提到一个工具： <font color=#EB6D39>AnimatorUpdateListener</font> ，上文已经提到，ValueAnimator 会自动替我们计算好需要改变的数值，但是对于 Android 系统而言，它怎么知道数值到达几了呢？又该如何做对应的事件反馈呢？这就用到了 AnimatorUpdateListener 了，顾名思义这是一个 Listener，监听的就是 ValueAnimator 中 TypeEvaluator 产生的值，在 ValueAnimator 中，所有产生的值会根据给定的范围划分成比例的形式，例如由原大小缩放到2倍的动画中，缩放率为1.5时的比例就是0.5，AnimatorUpdateListener 可以监听这个数 TypeValue 的变化，我们可以自行给 TypeValue 变化的值做一些事件处理，例如放大到一半的时候顺便改变一下透明度，等等，然而从上面的步骤来看，其实它本身完全没有接触任何一个控件，而是产生一系列的数值，再由我们人为地给控件指定对应的值来实现动画效果。以上就是关于 ValueAnimator 的一些简单介绍了，其实逻辑非常简单，通俗地理解，就是把我们人为 <code>while(true)</code> 的步骤交给Android提供的自带工具来处理。</p>\n<p>总结一下 ValueAnimator 实现动画的步骤：</p>\n<ol>\n<li><strong>指定需要动画变换的值的范围</strong></li>\n<li><strong>指定动画变换的时间</strong></li>\n<li><strong>通过 ValueAnimator 对象指定动画的插值器变换方式 Interpolator</strong></li>\n<li><strong>通过 ValueAnimator 对象的 TypeEvaluator 产生值</strong></li>\n<li><strong>在监听器 AnimatorUpdateListener 中监听数值的变化并指定事件处理</strong></li>\n</ol>\n<h1 id=\"2-2-ObjectAnimator的基本介绍\"><a href=\"#2-2-ObjectAnimator的基本介绍\" class=\"headerlink\" title=\"2.2 ObjectAnimator的基本介绍\"></a>2.2 ObjectAnimator的基本介绍</h1><p>上面介绍完了 ValueAnimator，接下来就要说说其子类 ObjectAnimator 了。既然是子类，当然 ValueAnimator 具有的一切特性 ObjectAnimator 也具有，并且通过重写父类的部分方法，从而提供了更高的易用性。举个例子，在 ValueAnimator 中，由于本身并不接触控件，因此对动画的实现始终需要我们手动去做一些处理，但是 ObjectAnimator 就大大提高了普遍情况下的简易性——它可以直接控制控件的常规属性，例如透明度、 缩放、旋转等等，对于不同的控件，都可以直接指定控件拥有的属性，用同样的方式创建一个 ObjectAnimator 对象：<br><code>ObjectAnimator objectAnimator = ObjectAnimator.ofXXX(Object target, String propertyName, xxx...);</code></p>\n<ol>\n<li><strong>target</strong>：需要应用变化的控件</li>\n<li><strong>propertyName</strong>：需要改变的控件具体要改变的属性名。</li>\n<li>**xxx…**：需要改变的范围，是一个可变长参数，与上文中 ValueAnimator 的一样，就不重述了。</li>\n</ol>\n<p>这里主要讲一下 <strong>propertyName</strong> 的一个注意事项。在源码中，propertyName 最后会被<code>setPropertyName(String propertyName);</code>方法调用，对于这个方法源码的解释有这么一段：</p>\n<center>\n\n<p><img data-src=\"./code_of_setpropertyname.png\" alt=\"setPropertyName 方法源码\" title=\"@ASSET\"></p>\n</center>\n\n<p>意思就是，根据传入的 String 属性名，通过把首字母强制大写，并在前面加上 “set”，然后反射寻找对应的设置方法。例如要改变 ImageView 的透明度，我们可以直接用 <code>tvText.setAlpha(alpha);</code> 来实现，但在 ObjectAnimator 的参数中，属性名要写 <code>&quot;alpha&quot;</code> 或 <code>&quot;Alpha&quot;</code>，如果我们写成 <code>&quot;setAlpha&quot;</code>，最后查找的方法就变成了 <code>setSetAlpha();</code>，这显然是不对的。</p>\n<p>用 ObjectAnimator 同样实现一下设置 ImageView 的透明度1秒内逐渐消失的动画：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ObjectAnimator objectAnimator = ObjectAnimator.ofInt(ivImage, <span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>).setDuration(<span class=\"number\">1000</span>)；</span><br><span class=\"line\">objectAnimator.start();</span><br></pre></td></tr></table></figure>\n\n<p>可以很明显地看到，这个方法指定了控件—— <code>ivImage</code>，以及变化数值作用的属性的 setter 方法—— <code>setAlpha();</code>，只需要一步，就能实现与上文 ValueAnimator 一样的效果，是不是方便的多了？</p>\n<blockquote>\n<p>关于属性动画 ValueAnimator 与 ObjectAnimator 及其他更全面的介绍可以参考附录【2】</p>\n</blockquote>\n<hr>\n<h1 id=\"3-ObjectAnimator配合Matrix\"><a href=\"#3-ObjectAnimator配合Matrix\" class=\"headerlink\" title=\"3. ObjectAnimator配合Matrix\"></a>3. ObjectAnimator配合Matrix</h1><p>了解完 ObjectAnimator 的基本内容后，思考一个问题：<strong>怎么用 ObjectAnimator 实现复杂的变换？</strong><br>在上文讨论的几个属性：透明度 Alpha、缩放 Scale、旋转 Rotate 等，几乎所有的 View 控件都具有直接设置的 setter 方法，可以很方便的直接套用 ObjectAnimator 来实现，但是如果是比较复杂的变化呢？比如，想要做一个由方形变为平行四边形的 <strong>“错切”过程动画</strong> 又或者是想要 <strong>以某个特定的点作为圆心进行缩放</strong>，这些在基本控件的内部并没有这么详细的 setter 方法，那要如何实现呢？</p>\n<p>想要实现上述需求的方法，那就是利用 Matrix 啦！在前一篇博客中介绍了关于 Matrix 的一些基本内容，可以知道 Matrix 是控制控件变换的一个很强大的工具，并且控制的是控件内部的画面而不是控件本身，那么如果能用 ObjectAnimator 不直接控制控件，而是控制一个 Matrix，再由 Matrix 去控制控件，就能达到需求了。这么听起来，其实跟 ValueAnimator 非常像都是通过控制数值间接控制控件，因为毕竟 ValueAnimator 才是爹呀！（ObjectAnimator：？？？？？）</p>\n<p>其实前面讲了过程，小伙伴肯定也已经想到了一个非常简单的实现方式：重写 View！在 View 中写一个接收 Matrix 的方法，通过这个方法把 Matrix 应用到图像中去实现变化效果。在 Demo 中，只是用了简单的 Scale 缩放，其实 ImageView 本身也提供了 <code>setScaleX();</code> 和 <code>setScaleY();</code> 方法，可以通过 PropertyValuesHolder 来一次改变两个属性（下文会讲到），但是我就想一次性同比例缩放，并且这个 Demo 仅仅是提供一种解决思路，例如在使用 Matrix 进行 Skew 错切变换时，重写 View 实现就是一个好方法了，读者可以举一反三多多尝试其他需要间接改变的属性。<br>还是这个 Demo，上代码！</p>\n<p>首先因为我们需要自己的 View 中可以接收到 Matrix，所以先写一个接口，定义接收 Matrix 的方法，然后在自定义的View中实现这个接口并重写接口方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义 接收Matrix方法的接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setScaleToMatrix</span><span class=\"params\">(<span class=\"keyword\">float</span> scaleValue)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以不用接口直接在自定义View中添加方法，但养成良好的编程习惯总没有坏处。接下来自定义 View 继承自 ImageView（根据需求选择继承）并实现接口方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是我自定义的 ScaleImageView，继承自 ImageView</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScaleImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageView</span> <span class=\"keyword\">implements</span> <span class=\"title\">IView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重用的Matrix</span></span><br><span class=\"line\">    Matrix matrix = <span class=\"keyword\">new</span> Matrix();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//直接默认重写所有四个构造方法即可</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleImageView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleImageView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleImageView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleImageView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr, <span class=\"keyword\">int</span> defStyleRes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//实现并重写接口方法</span></span><br><span class=\"line\">    <span class=\"comment\">//我将该方法命名为 setScaleMatrix</span></span><br><span class=\"line\">    <span class=\"comment\">//则 ObjectAnimator 中属性名 String 为 “scaleMatrix”或“ScaleMatrix”</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScaleToMatrix</span><span class=\"params\">(<span class=\"keyword\">float</span> scaleValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//布局中为了初始时视觉美观设置 ScaleType 为 fit_center，需改成 matrix 否则 Matrix 变换不起作用</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setScaleType(ScaleType.MATRIX);</span><br><span class=\"line\">        <span class=\"comment\">//X、Y轴同比例缩放</span></span><br><span class=\"line\">        matrix.setScale(scaleValue, scaleValue);</span><br><span class=\"line\">        <span class=\"comment\">//调用 ImageView 自带的方法应用 Matrix</span></span><br><span class=\"line\">        setImageMatrix(matrix);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//MainActivity 中就简单了，在需要执行动画的地方创建 ObjectAnimator 再指定变化范围即可</span></span><br><span class=\"line\"><span class=\"comment\">//初始化控件，略了</span></span><br><span class=\"line\">ScaleImageView sivImage;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//设置按键监听，略了</span></span><br><span class=\"line\">Button btButton；</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//设置对应的属性和 setter 方法名，缩放范围：1～2，动画时间1秒</span></span><br><span class=\"line\">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br></pre></td></tr></table></figure>\n\n<p>再看一下效果：</p>\n<center>\n\n<p><img data-src=\"./click_scale_up.gif\" alt=\"点击放大\" title=\"@ASSET\"></p>\n</center>\n\n<p>可以看到，动画还是很好的，相比我们手动写成循环的方式，ObjectAnimator 流畅多了，这里给一个小提示，因为 Matrix 如果采用 set 的方式时都会先重置为单位矩阵，因此不需要每次传值缩放时都重新 <code>new Matrix();</code>，直接在自定义的 View 中声明并初始化一个 Matrix，可以减少对象的创建，节约内存。</p>\n<blockquote>\n<p>更多关于 ObjectAnimator 的详细资料可以参考附录【3】【4】</p>\n</blockquote>\n<hr>\n<h1 id=\"4-ObjectAnimator多动画并行\"><a href=\"#4-ObjectAnimator多动画并行\" class=\"headerlink\" title=\"4. ObjectAnimator多动画并行\"></a>4. ObjectAnimator多动画并行</h1><p>现在我们的动画效果出来了，但是假如我又有一个需求，希望在放大的动画结束后再来个缩小的动画，怎么办呢？最直观的方法就是：在放大的动画下面在加一个缩小的动画不就行了吗？实践是检验真理的唯一标准，试一试就知道！在 MainActivity 调用动画的下面再加上缩小的动画：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//放大动画</span></span><br><span class=\"line\">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br><span class=\"line\"><span class=\"comment\">//缩小动画</span></span><br><span class=\"line\">objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleMatrix&quot;</span>, <span class=\"number\">2f</span>, <span class=\"number\">1f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br></pre></td></tr></table></figure>\n\n<p>结果发现最后的效果是：</p>\n<center>\n\n<p><img data-src=\"./android-objectanimator-data/scale_up_and_down.gif\" alt=\"放大接缩小动画\" title=\"@ASSET\"></p>\n</center>\n\n<p>视觉上来看，仿佛放大的动画并没有执行，直接跳过到了缩小的动画，但其实放大动画是执行了的，之所以会突然放大一下，并不是因为放大动画执行完的原因，而是我们设置的缩小动画的起始大小就是2f——两倍，所以动画会先从两倍大小开始缩小，造成这样的原因是因为：ObjectAnimator 在执行一个动画时，是非线程阻塞的 <em>（这也是比我们自己用<code>while()</code>写更好的原因之一）</em> ，在执行一个动画的时候，可以理解为 <code>objectAnimator.start();</code> 开始执行后，具体这个动画怎么变化，变多久，都交给后台处理 <em>（其实这个说法是不严谨的，因为要更新UI只有主线程才能做到，后面整理清楚了会专门再发一个从源码角度的解释）</em> ，然后主线程继续向下执行代码，而下一句代码就是缩小动画，于是放大动画刚刚开始，还没来得及展示，就已经开始执行缩小动画了，于是就变成了图中的效果。我们把第二个缩小的动画用改变透明度来替换一下，就直观多了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//放大动画</span></span><br><span class=\"line\">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br><span class=\"line\"><span class=\"comment\">//改变透明度</span></span><br><span class=\"line\">objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br></pre></td></tr></table></figure>\n\n<center>\n\n<p><img data-src=\"./scale_up_and_alpha.gif\" alt=\"放大接改变透明度\" title=\"@ASSET\"></p>\n</center>\n\n<p>这个效果就很明显了，放大也是执行了的，改变透明度也是执行了的，因为每一次动画开始执行后就会继续向下执行，因此视觉上看起来很就是一起执行了。这也提供给了我们一个同时执行多个动画效果的思路：<strong>硬生生的把多个动画效果顺序提交执行</strong>。但是这也是非常非常不友好的实现方式，在每个动画效果比较简单、设备性能较好等情况下也许没有很严重的问题，但是如果动画复杂、处理量大，就会导致动画严重卡顿。于是这里就引出了 <font color=#EB6D39>PropertyValuesHolder</font> 这个工具，它和数据库中的 Transaction 事务管理非常像——要么不做、要么全做。</p>\n<h2 id=\"4-1-PropertyValuesHolder属性值保存器\"><a href=\"#4-1-PropertyValuesHolder属性值保存器\" class=\"headerlink\" title=\"4.1 PropertyValuesHolder属性值保存器\"></a>4.1 PropertyValuesHolder属性值保存器</h2><p>PropertyValuesHolder 一次性记录多个要执行的动画，然后把自己传给 ObjectAnimator，来实现多个动画同时并行 <em>（事实上从底层上来看，CPU的处理在微观上依然单线程的，并且 PropertyValuesHolder 也有导致卡顿的风险）</em> ，下面是 PropertyValuesHolder 的使用样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过 PropertyValuesHolder 存入需要改变的属性和值</span></span><br><span class=\"line\">PropertyValuesHolder pvhScale = PropertyValuesHolder.ofFloat(<span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">4.2f</span>, <span class=\"number\">8.4f</span>);</span><br><span class=\"line\">PropertyValuesHolder pvhAlpha = PropertyValuesHolder.ofFloat(<span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过 ObjectAnimator 应用到控件中</span></span><br><span class=\"line\">objectAnimator = ObjectAnimator.ofPropertyValuesHolder(sivImage, pvhScale, pvhAlpha);</span><br><span class=\"line\">objectAnimator.setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">objectAnimator.start();</span><br></pre></td></tr></table></figure>\n\n<p>从 PropertyValuesHolder（太长了，简称 PVH）的字面上就可以理解，PVH 是一个属性取值的保持器，也就是说，一个 PVH 对象就存入了一个你需要改变值的属性以及这个属性需要变化的取值，但是 PVH 本身是不接触控件的，从这方面来看，PVH 像极了 ValueAnimator，不同点在于 PVH 依然需要针对具体的属性。动画效果与上面的“放大接改变透明度”一样，就不再重复贴图了。</p>\n<h2 id=\"4-2-AnimatorSet动画集合\"><a href=\"#4-2-AnimatorSet动画集合\" class=\"headerlink\" title=\"4.2 AnimatorSet动画集合\"></a>4.2 AnimatorSet动画集合</h2><p><font color=#EB6D39>AnimatorSet</font> 是一个动画集合，与之类似的还有一个叫 <font color=#EB6D39>AnimationSet</font> 的东西，从功能性来说，AnimatorSet 更为强大，AnimationSet 实现的效果与 PropertyValuesHolder 相似，都是把动画组合在一起执行，而 AnimatorSet 强大的地方在于，不仅能让动画组合执行，还能通过指定顺序让多个动画依次执行，因此本文中仅对 AnimatorSet 进行简单的讲解，篇幅有限，此处就只列出基本的应用方法，细节原理和复杂应用考虑在日后补充。</p>\n<p>先说说其中两个方法：</p>\n<ol>\n<li><code>AnimatorSet.playTogether(property1)</code></li>\n<li><code>playSequentially(property2)</code></li>\n</ol>\n<p>这两个方法从字面上就很好理解了，<code>playTogether()</code> 是同时进行，<code>playSequentially()</code> 是逐一进行。这里 property1 和 property2 不是具体的参数，因为这两种方法都分别各有两种类型的参数。</p>\n<p><code>playTogether()</code> 方法的参数可以是： <em>Collection&lt;Animator&gt;</em> 和 <em>Animator…</em> （注意后者是可变长参数），先看后者很明显可以知道，毕竟这个方法是要实现“同时进行”，所以肯定支持多个动画一起作为可变长参数传入，第一个 Collection&lt;&gt; 就是集合，泛型是 Animator 类，也就是说 Collection 集合内的每一个元素都要是 Animator 的对象，这和可变长的 Animator… 是一样的。之所以是集合还是因为这个方法要同时执行所有动画，所以所有的动画在逻辑上是“一层”的，没有顺序、前后之分，在 Java 中就用集合来表示。</p>\n<p><code>playSequentially()</code> 的方法参数可以是：List<Animator> 和 Animator…（注意后者依然是可变长参数），与上面的大同小异，传进去的都是一个或多个 Animator 的对象，但是这里是 List 列表而不是集合，就是因为这个方法是逐一进行，是有执行的前后顺序之分的，在 Java 中就用 List 来表示。</p>\n<p>从参数来看，无论是哪一种，目的都是传 Animator 对象过去，也就是我们要先定义一个个 Animator 的对象，然后制定出每一个 Animator 需要做的动画效果，再把这些（或一个）Animator 交给 AnimatorSet 替我们完成。在 Demo 中，我们可以这样运用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//放大动画</span></span><br><span class=\"line\">ObjectAnimator zoomInAnim = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>);</span><br><span class=\"line\"><span class=\"comment\">//缩小动画</span></span><br><span class=\"line\">ObjectAnimator zoomOutAnim = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">2f</span>, <span class=\"number\">1f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ObjectAnimator 继承自 ValueAnimator，而后者又继承自 Animator</span></span><br><span class=\"line\">AnimatorSet animatorSet = <span class=\"keyword\">new</span> AnimatorSet();</span><br><span class=\"line\"><span class=\"comment\">//以下四种都是对的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同时进行方式一</span></span><br><span class=\"line\">animatorSet.playTogether(zoomInAnim, zoomOutAnim);</span><br><span class=\"line\"><span class=\"comment\">//同时进行方式二</span></span><br><span class=\"line\">ArrayList&lt;Animator&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">arrayList.add(zoomInAnim);</span><br><span class=\"line\">arrayList.add(zoomOutAnim);</span><br><span class=\"line\"><span class=\"comment\">//关于 Collection 的详情可以参考网上，这里不细展开</span></span><br><span class=\"line\">Collection&lt;Animator&gt; collection = arrayList;</span><br><span class=\"line\">animatorSet.playTogether(collection);</span><br><span class=\"line\">animatorSet.setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">animatorSet.start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//逐一进行方式一</span></span><br><span class=\"line\">animatorSet.playSequentially(zoomInAnim, zoomOutAnim);</span><br><span class=\"line\"><span class=\"comment\">//逐一进行方式二</span></span><br><span class=\"line\">List&lt;Animator&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(zoomInAnim);</span><br><span class=\"line\">list.add(zoomOutAnim);</span><br><span class=\"line\">animatorSet.playSequentially(list);</span><br><span class=\"line\">animatorSet.setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">animatorSet.start();</span><br></pre></td></tr></table></figure>\n\n<p>除了上面两个方法外，还有以下这几个方法：</p>\n<ol>\n<li><code>play(Animator)</code></li>\n<li><code>with(Animator)</code></li>\n<li><code>before(Animator)</code></li>\n<li><code>after(delayTime)</code></li>\n<li><code>after(Animator)</code></li>\n</ol>\n<p>依然从字面上看就很好理解，play() 就是当前需要进行的动画，with(Animator) 就是同时执行的动画，before(Animator) 和 after(Animator) 就是需要在参数中的 Animator 前／后执行，而 after(delayTime) 方法是用来设置动画延迟执行的时间。具体的使用方式直接通过代码解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Animator 集合</span></span><br><span class=\"line\">AnimatorSet animatorSet = <span class=\"keyword\">new</span> AnimatorSet();</span><br><span class=\"line\"><span class=\"comment\">//定义四种动画：透明度减半，放大，缩小，旋转90°</span></span><br><span class=\"line\">ObjectAnimator animAlpha, animZoomIn, animZoomOut, animRotation;</span><br><span class=\"line\"></span><br><span class=\"line\">animAlpha = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">0.5f</span>);</span><br><span class=\"line\">animZoomIn = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>);</span><br><span class=\"line\">animZoomOut = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">2f</span>, <span class=\"number\">1f</span>);</span><br><span class=\"line\">animRotation = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;rotation&quot;</span>, <span class=\"number\">0f</span>, <span class=\"number\">90f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置动画的播放顺序</span></span><br><span class=\"line\">animatorSet.play(animAlpha).with(animZoomIn);</span><br><span class=\"line\">animatorSet.play(animZoomIn).before(animRotation);</span><br><span class=\"line\">animatorSet.play(animZoomOut).after(animRotation);</span><br><span class=\"line\">animatorSet.play(animRotation);</span><br><span class=\"line\"></span><br><span class=\"line\">animatorSet.setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">animatorSet.start();</span><br></pre></td></tr></table></figure>\n\n<p>看一下我们预期的播放顺序，四个play操作从上到下的预期结果是：</p>\n<ol>\n<li>执行透明度减半，同时执行放大</li>\n<li>执行放大，并且放大在旋转前执行</li>\n<li>执行缩小，并且在旋转之后执行（也就是先旋转再缩小）</li>\n<li>执行旋转</li>\n</ol>\n<p>整理一下播放顺序应该是：1（透明度减半，同时放大）→2（旋转）→3（缩小）。<br>可以看到，我们在 play(Anim_1) 动画后定义了 with(anim_2)／before(anim_2)／after(anim_2) 后，还需要在下面正式调用 play(anim_2) 才能完成播放，这是因为 with、before、after 只是制定了播放的顺序，并没有表示开始播放。并且，这三个方法是可以链式调用的，也即：<code>play().before().after().with()...</code> 但是我们应当避免这种写法，以避免出现 <code>play(anim1).before(anim2).after(anim2)</code> 这种矛盾的情况。看一下实际的动画结果：</p>\n<center>\n\n<p><img data-src=\"./animator_continually.gif\" alt=\"连续动画\" title=\"@ASSET\"></p>\n</center>\n\n<p>确实和预期是相符的！AnimatorSet 也确实是一个对动画进行控制非常非常强大的工具。</p>\n<blockquote>\n<p>AnimatorSet的详解可以参考附录【5】<br>AnimatorSet以及AnimationSet的区别可以参考附录【6】</p>\n</blockquote>\n<h2 id=\"4-3-AnimatorListener动画监听\"><a href=\"#4-3-AnimatorListener动画监听\" class=\"headerlink\" title=\"4.3 AnimatorListener动画监听\"></a>4.3 AnimatorListener动画监听</h2><p>在做动画效果的时候，往往我们不会仅仅只是为了展示，而会接一些逻辑上的事情，比如 Splash 页面的动画在执行完后要进入主页、更改信息的动画执行完后要退回上一个界面、Tips 引导动画执行完后要打开对应的操作窗口等等，但是上文我们也提到过，不论是 ValueAnimator 也好，ObjectAnimator 也好，或者 Animation 视图动画也好，其动画的运行过程可以 <strong>理解为</strong> 是在后台执行的，而主线程依然会继续向下执行代码，因此如果我们只是简单地把需要操作的事务代码放在动画执行的后面，会导致事务和动画一起执行，那么我们到底要如何才能做到 <em>“动画执行完之后操作事务”</em> 呢？方法就是：利用 AnimatorListener 监听器。</p>\n<p>同理，既然 AnimatorListener 是一个监听器，那它就需要被绑定到想要监听的动画上，动画监听有四个需要重写的方法：</p>\n<ol>\n<li><code>onAnimationStart(Animator animation)&#123;...&#125;</code> ：动画开始时要做的</li>\n<li><code>onAnimationCancel(Animator animation)&#123;...&#125;</code> ：动画被取消时要做的</li>\n<li><code>onAnimationRepeat(Animator animation)&#123;...&#125;</code> ：动画重复执行时要做的</li>\n<li><code>onAnimationEnd(Animator animation)&#123;...&#125;</code> ：动画结束时要做的</li>\n</ol>\n<p>命名都很直观，第1个方法就是动画一开始要做的事，很简单就不多说了。这里再提一下第2、3个方法。<br><code>onAnimationCancel()</code> 是动画被取消时要做的，和 end 不同的是，cancel 中的事务是我们人为地调用 <code>animator.cancel();</code> 方法时才会触发，而 end 是动画自己执行完后就会执行的。</p>\n<p>至于 <code>onAnimationRepeat();</code> 方法，我们在设置一个动画不论是属性动画也好还是视图动画也好，都可以设置动画重复的次数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">objectAnimator.setRepeatCount(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>onAnimationRepeat();</code> 方法就会在动画每次重复执行时调用，并且第一次执行也算在内，也就是说我们设置的 repeatCount 是几，这个方法就会调用几次。</p>\n<p>这么一看马上就知道了，要在动画结束时执行某些事务，直接重写 <code>onAnimationEnd()</code> 方法即可。如果我们想要 Demo 中的图片无限重复放大再缩小再放大再缩小……最直观的的解决方案当然是利用死循环来做，但是前面也说了，<code>while</code> 会导致主线程阻塞，对于比较简单的动画效果（例如本文的 Demo，或者旋转等等规律步骤比较少的）可以进行如下设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">objectAnimater.setRepeatCount(ValueAnimator.INFINITE);  <span class=\"comment\">// ValueAnimator.INFINITE是int型，值为-1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是 Android 官方给我们的方法，但是如果我们有一个非常非常复杂的动画（虽然基本上是没有这种需求的，Android 的动画大都能通过分解转换成简单动画）比如我非要把：放大，旋转、对称、缩小、错切、平移、旋转……作为单次动画流程然后再无限循环这个流程的话，显然我们很难把这么多操作写在一个方法里完成，这时就可以用一个脑洞大开的方式曲线救国啦—— <font color=#EB6D39>AnimatorListener 的迭代</font>！</p>\n<h3 id=\"4-3-1-AnimatorListener的迭代\"><a href=\"#4-3-1-AnimatorListener的迭代\" class=\"headerlink\" title=\"4.3.1 AnimatorListener的迭代\"></a>4.3.1 AnimatorListener的迭代</h3><p>仔细想一下 <code>AnimatorListener</code>，里面有 <code>onAnimationEnd()</code> 方法，再仔细想一下，只要我们设置的不是无限动画，那就都会在结束时调用监听。利用这个思路，我们可以定义一个动画执行步骤的变量，用来引导动画进行的顺序。在 Demo 中，仅用缩放作为示例，复杂的动画变换可以参考思路进行拓展。</p>\n<p>先写出成员变量和动画监听部分，在按钮的点击事件中有一些处理放在下面讲。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">先让类实现 OnclickListener 和 AnimatorListener 接口，并在类中重写四个方法</span></span><br><span class=\"line\"><span class=\"comment\">具有大量操作时，尽量避免使用下述匿名内部类的形式：</span></span><br><span class=\"line\"><span class=\"comment\">objectAnimator.addListener(new AnimatorListener() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    ......</span></span><br><span class=\"line\"><span class=\"comment\">&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个动画步骤成员变量，用来指导动画执行的顺序</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> animStep = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> ObjectAnimator objectAnimator;</span><br><span class=\"line\"><span class=\"keyword\">private</span> ScaleImageView sivImage;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Button btButton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//仅写出 onAnimationEnd() 部分</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animatior animation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断一下非空的情况，避免在重复点击时出现空指针异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(animation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(animStep) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span> : &#123;</span><br><span class=\"line\">                <span class=\"comment\">//在点击按钮时进行放大，因此在放大动画结束后应该先缩小</span></span><br><span class=\"line\">                objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">2f</span>, <span class=\"number\">1f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"comment\">//自增，指导第二个步骤</span></span><br><span class=\"line\">                animStep++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span> : &#123;</span><br><span class=\"line\">                <span class=\"comment\">//第二步为缩小，在 Demo 中只有两步，因此最后一步应把 animStep 重置</span></span><br><span class=\"line\">                objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"comment\">//有多个步骤时，前面的步骤执行完 animStep 都自增，最后一步执行完后重置</span></span><br><span class=\"line\">                animStep = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            defalut : <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        objectAnimator.start();</span><br><span class=\"line\">        <span class=\"comment\">//再把自己重新注册进监听器内继续监听 onAnimationEnd() 方法</span></span><br><span class=\"line\">        objectAnimator.addListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是点击按钮开始动画的部分了。在具体的应用中，并不一定非要用 Button 来触发动画，这里只是专门做一个提醒来指出在使用手动触发动画时一个容易出错的地方。在 Demo 中，按钮主要用来启动动画的第一次执行，那么我们常常只会想到要这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    objectAnimator = ObjectAnimator.ofFloat(sivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1f</span>, <span class=\"number\">2f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    objectAnimator.start();</span><br><span class=\"line\">    objectAnimator.addListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行一下</p>\n<center>\n\n<p><img data-src=\"./init_click_event.gif\" alt=\"初始点击事件\" title=\"@ASSET\"></p>\n</center>\n\n<p>乍一看确实没什么问题，确实达到预期的效果了，但是如果我们这时多次点击按钮就会“翻车”</p>\n<center>\n\n<p><img data-src=\"./multi_animator_issue.gif\" alt=\"动画并行问题\" title=\"@ASSET\"></p>\n</center>\n\n<p>原因也很简单，因为我们每次点击时都会触发一次重新执行动画，并且也会加入动画监听，也就相当于每次点击都会增加一个动画效果的运行线，每个动画效果又自行监听运行过程，所以就会造成这样的混乱场面，如果是上文中的一系列复杂动画，翻车现场只会更加惨烈～解决的办法也很简单，就是每次点击都让动画步骤初始化从第一步开始，然后取消原先的所有动画，并且取消原先绑定的监听器，然后再重新绑定和设定动画的效果。改进的点击事件代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//依然要进行一个非空判断，否则第一次运行时会报空指针异常</span></span><br><span class=\"line\">    <span class=\"comment\">//非空从逻辑上也表明了是“已经在执行动画的过程中再次点击”</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(objectAnimator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取消当前的动画</span></span><br><span class=\"line\">        objectAnimator.cancel();</span><br><span class=\"line\">        <span class=\"comment\">//移除所有监听器，也可以单独仅移除 AnimatorListener</span></span><br><span class=\"line\">        <span class=\"comment\">//仅移除某个监听器时，需要实例化具体的监听器并绑定动画</span></span><br><span class=\"line\">        objectAnimator.removeAllListeners();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始化动画步骤</span></span><br><span class=\"line\">    animStep = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//重新设置动画和监听</span></span><br><span class=\"line\">    objectAnimator = ObjectAnimator.ofFloat(ivImage, <span class=\"string\">&quot;scaleToMatrix&quot;</span>, <span class=\"number\">1.05f</span>, <span class=\"number\">2.1f</span>).setDuration(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    objectAnimator.start();</span><br><span class=\"line\">    objectAnimator.addListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改进完后再看，也就不会出现翻车现场啦！</p>\n<center>\n\n<p><img data-src=\"./fixed_multi_animator.gif\" alt=\"改进的并行动画\" title=\"@ASSET\"></p>\n</center>\n\n<p>这下这个 “*<del>脑洞大开然鹅好像并没有什么卵用也不知道为什么要写这么多的需求</del>*” 总算是解决了，代码而言是真的很简单也很少，但是思路和解决方案希望可以给同是初学的读者们一些灵感，用以运用在大型、复杂的项目中去。<br>本篇结合前一篇写的 <a href=\"/2018/09/06/Android/android-matrix-basic/\">关于Matrix</a> 的文章，应该可以解决大部分情况下简单的动画场景了，但是这两篇博客的讲解可以说是非常皮毛的，甚至对于我自己的实际应用都远远不够，但还是那句话，本文主要目的是提供一种思维方式，再灵活运用进实际的项目中去。对于深入的 ObjectAnimator、 ValueAnimator、 Matrix内容，还是应该细读官方的文档和源码为好。</p>\n<hr>\n<h1 id=\"5-附录-参考指导\"><a href=\"#5-附录-参考指导\" class=\"headerlink\" title=\"5. 附录[参考指导]\"></a>5. 附录[参考指导]</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/huolongluo/p/6792362.html\" title=\"@LINK\">【1】Android属性动画之ValueAnimator的介绍（作者：火龙裸先生）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/harvic880925/article/details/50525521\" title=\"@LINK\">【2】自定义控件三部曲之动画篇(四)——ValueAnimator基本使用（作者：启舰）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/Leslie_LN/article/details/67639753\" title=\"@LINK\">【3】ObjectAnimator详解（作者：钉某人）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/Leslie_LN/article/details/67639753\" title=\"@LINK\">【4】属性动画之—ObjectAnimator基本使用（作者：Linleslie）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/io_field/article/details/53101295\" title=\"@LINK\">【5】Android 动画之AnimatorSet（作者：行云间）<sup>【注】</sup></a></li>\n<li><a href=\"https://blog.csdn.net/ttml5945/article/details/80324128\" title=\"@LINK\">【6】动画之AnimatorSet和AnimationSet的区别（作者：tml5945）<sup>【注】</sup></a></li>\n</ul>\n</blockquote>\n","categories":["Android"],"tags":["Android","Matrix","动画","ObjectAnimator","属性动画"]},{"title":"Android子线程到底能否更新UI——可能是最全面的解析","url":"/post/android/android-ui_thread/","content":"<span id=\"more\"></span>\n\n<p>前言：相信学过 Android 的朋友大都知道这么一条“铁律”：「一个 App 的主线程就是 UI 线程，子线程不能更新 UI」。绝大部分情况下，我们在需要处理 UI 逻辑时，都会自觉地放在主线程操作，但是为什么会有这么一条“铁律”，其原因是什么，以及这条“铁律”就一定正确吗？带着这些疑问我在度娘和 StackOverFlow 上搜了一遍，绝大部分分析都止于「子线程更新 UI 会抛出异常的逻辑在哪」，所以我决定自己探索一遍，并写下这篇截止到目前，【可能】是最全面的一篇分析。</p>\n<p>当然，这篇文章不会深入到屏幕渲染、线程调度等等这样的层面，其重点在于从源码的角度论证：「子线程到底能不能更新 UI」，本文默认读者已有初级 Android 基础。</p>\n<hr>\n<h1 id=\"1-子线程更新UI异常\"><a href=\"#1-子线程更新UI异常\" class=\"headerlink\" title=\"1. 子线程更新UI异常\"></a>1. 子线程更新UI异常</h1><p>下面这段代码，是很典型的子线程更新 UI 的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码运行会抛出异常：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么子线程不能更新 UI 呢？这就需要从 3 个方面解释。</p>\n<h2 id=\"1-1-设计思想\"><a href=\"#1-1-设计思想\" class=\"headerlink\" title=\"1.1 设计思想\"></a>1.1 设计思想</h2><p>首先不得不提到，子线程更新 UI 会抛出异常肯定是 Android 有意为之，但 Android 为什么要这么设计呢？</p>\n<p>这是因为，人眼感到【流畅】需要满足帧率大于等于 60 Fps，对应的也就是约等于 16 毫秒一帧，Android 为了让交互和显示足够流畅，就需要尽可能保证这个帧率，尤其在现在高刷屏普及的时代，就需要尽可能缩短每一帧的渲染时间。因为频繁的加锁和锁释放会带来很大的内存开销，很可能会延长每一帧的渲染时间，因此对于 UI 更新的操作，是没有加锁的。但如果不加锁，在出现并发问题时，系统如何确保下一帧画面到底应该渲染成什么样呢？</p>\n<p>所以，Android 系统为了避免这个问题，就从源码层限制了其他线程更新 UI，以兼顾 UI 更新的效率和并发安全性。</p>\n<h2 id=\"1-2-异常原因\"><a href=\"#1-2-异常原因\" class=\"headerlink\" title=\"1.2 异常原因\"></a>1.2 异常原因</h2><p>解释完设计思想，就要老生常谈分析一下抛出异常的直接原因了。</p>\n<p>首先有一个基础：View 在更新时，是将自己测量并绘制，但这个绘制并不是一旦 View 完成初始化、或者调用更新时就马上绘制，而是发起一个屏幕同步 Sync 请求，等待下一次屏幕刷新时，再绘制到屏幕上。</p>\n<p>而这个 View 发起绘制请求的命令，就是 UI 更新都离不开的：<code>requestLayout()</code>。</p>\n<p>就以 <code>TextView.setText(...)</code> 为例，顺着 <code>setText(...)</code> 的源码一路点进去，直到下面这个方法（省略其他代码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这个 requestLayout()：</span></span><br><span class=\"line\">        requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再点进 requestLayout() 源码：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 每个 View 都逐级调用上层父 View 的 requestLayout，最上层的父 View 就是 ViewRootImpl</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">            mParent.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，每个 View 都会一层层请求自己的父布局调用 <code>requestLayout()</code>，而最最上层的父布局，就是一个 ViewRootImpl，它也实现了 <code>ViewParent</code> 接口。而在 ViewRootImpl 内，<code>requestLayout()</code> 的实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// 注意这个方法是关键</span></span><br><span class=\"line\">            checkThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 看看源码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 就是在这里判断了线程</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这一步就清晰明了了，因为 <code>Thread.currentThread()</code> 是子线程，而 <code>mThread</code> 是主线程，所以在这里抛出了异常。</p>\n<p>【但是！】这个判断有个很大的问题，因为它的判断是 <code>mThread != Thread.currentThread()</code>，而 <code>mThread</code> 是在这个 ViewRootImpl 的构造方法里面存入的，因此这个判断本质上比较的是：当前线程与「ViewRootImpl 初始化时的线程」是否相同，而不是当前线程与「主线程」是否相同，并且这里抛出的异常说明也是「the original thread」而不是「the main thread」，所以我们常说的「子线程不能更新 UI」，实际上是：</p>\n<p>一个线程初始化了 ViewRootImpl 后，其 UI 不能被其他线程更新！而这两个线程，和是不是主线程并没有关系！</p>\n<hr>\n<h1 id=\"2-Activity视图加载流程\"><a href=\"#2-Activity视图加载流程\" class=\"headerlink\" title=\"2. Activity视图加载流程\"></a>2. Activity视图加载流程</h1><p>现在知道了线程能否更新 UI 主要看这个 UI 所处的最上层 ViewRootImpl 是否由同一个线程初始化，那么 ViewRootImpl 是怎么初始化的呢？又是在什么时候初始化的呢？</p>\n<p>既然 ViewRootImpl 是最上层布局，那不妨从 Activity 启动加载开始。但在一切分析之前，首先解释一下 ActivityClientRecord 这个东西：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Activity client record, used for bookkeeping for the real &#123;<span class=\"doctag\">@link</span> Activity&#125; instance. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityClientRecord</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Activity activity;</span><br><span class=\"line\">        Window window;</span><br><span class=\"line\">        Activity parent;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码注释也解释的比较清楚了，ActivityClientRecord 其实是一个容器，它持有了一个 Activity，以及管理这个 Activity 相关的其他资源。可以形象的理解为：「Activity 就像一个主机，Window 就像显示器，同时还有鼠标键盘、电源数据线、维修工具、备用零件、等等，所有这些东西加起来，就能作为完整的计算机提供使用。然后用一个箱子把所有这些都装起来，这个箱子就是 ActivityClientRecord」。ActivityClientRecord 和其持有的 Activity 是一一对应的，系统在调度和管理 Activity 时，大多都是通过 ActivityClientRecord 操作 Activity。</p>\n<h2 id=\"2-1-生命周期onCreate\"><a href=\"#2-1-生命周期onCreate\" class=\"headerlink\" title=\"2.1 生命周期onCreate\"></a>2.1 生命周期onCreate</h2><h3 id=\"2-1-1-onCreate流程分析\"><a href=\"#2-1-1-onCreate流程分析\" class=\"headerlink\" title=\"2.1.1 onCreate流程分析\"></a>2.1.1 onCreate流程分析</h3><p>首先启动一个 Activity 的入口，是通过 <code>ActivityThread.startActivityNow()</code> 开始的，并且创建了一个 ActivityClientRecord，用来持有目标 Activity 以及一些相关的对象，再通过 <code>ActivityThread.performLaunchActivity(...)</code> 创建并启动目标 Activity。这个过程中调用了一个重要方法 <code>Activity.attach()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Activity <span class=\"title\">startActivityNow</span><span class=\"params\">(Activity parent, String id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, ActivityInfo activityInfo, IBinder token, Bundle state,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Activity.NonConfigurationInstances lastNonConfigurationInstances, IBinder assistToken)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">return</span> performLaunchActivity(r, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 ActivityClientRecord 中取出了一个 Window</span></span><br><span class=\"line\">            window = r.mPendingRemoveWindow;</span><br><span class=\"line\">            r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这个方法是重点，并且注意参数中传入了上面从 ActivityClientRecord 中取出的 Window</span></span><br><span class=\"line\">        activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class=\"line\">                r.assistToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先绕个圈子，看到最入口处，出现了一个从 ActivityClientRecord 中取 Window 的操作，那 ActivityClientRecord 中的 Window 又是哪来的呢？查找一下 ActivityClientWindow 中 <code>mPendingRemoveWindow</code> 写入的地方，发现在 <code>handleDestroyActivity(...)</code> 中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class=\"line\">                configChanges, getNonConfigInstance, reason);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            View v = r.activity.mDecor;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Hold off on removing this until the new activity&#x27;s</span></span><br><span class=\"line\">                        <span class=\"comment\">// window is being added.</span></span><br><span class=\"line\">                        <span class=\"comment\">// 核心就是这里：</span></span><br><span class=\"line\">                        r.mPendingRemoveWindow = r.window;</span><br><span class=\"line\">                        r.mPendingRemoveWindowManager = wm;</span><br><span class=\"line\">                        <span class=\"comment\">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class=\"line\">                        <span class=\"comment\">// everything else must be removed, because it might not be able to</span></span><br><span class=\"line\">                        <span class=\"comment\">// behave properly when activity is relaunching.</span></span><br><span class=\"line\">                        r.window.clearContentView();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        wm.removeViewImmediate(v);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码注释就能明白，当一个 Activity 销毁时，会在其 ActivityVlientRecord 中把自己的 Window 保存到 mPendingRemoveWindow 中，然后移除 Window 中所有 View，直到新的 Activity 的 Window 被添加为止，但是在通过 <code>startActivityNow(...)</code> 启动 Activity 时，ActivityClientRecord 都是 <code>new</code> 出来的，调用到 <code>performLaunchActivity(...)</code> 时，<code>r.mPendingRemoveWindow</code> 肯定是 <code>null</code>，那什么场景会用到这个 <code>mPendingRemoveWindow</code> 呢？查找 <code>performLaunchActivity(...)</code> 的调用发现：</p>\n<ul>\n<li>在 <code>handleRelaunchActivityInner(...)</code> 中，先调用了 <code>handleDestroyActivity(...)</code>，这一步就把当前 Activity 的 Window 存进了 <code>mPendingRemoveWindow</code></li>\n<li>接下来调用了 <code>handleLaunchActivity(...)</code></li>\n<li>然后在其内部调用了 <code>performLaunchActivity(...)</code></li>\n</ul>\n<p>这下明白了，当一个 Activity 被系统回收等等场景销毁时，有可能接下来又会回到这个 Activity，这种情况下就可以先把 Window 缓存下来，当自己这个 Activity 再次被激活时，就可以直接复用 Activity 上一次的 Window 而不需要从新分配。当然，由于 <code>r.window.clearContentView();</code>，Window 中的 View 被清空了，所以还是需要重新走一遍视图加载。这样做的好处也许是在效率和内存消耗中的一种折中，或许是因为 View 会占用很大内存，所以需要回收 View，但 Window 本身占用较少，每次都回收再让系统重新分配可能比缓存占用的内存更多、或者可能带来更大的内存抖动风险，所以选择临时缓存。</p>\n<p>从上面的分析知道，而当一个 Activity 被新启动时，<code>performLaunchActivity(...)</code> 传入的 <code>ActivityClientRecord.mPendingRemoveWindow</code> 肯定是 <code>null</code>，跳转到 <code>Activity.attach(...)</code> 中查看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当新启动一个 Activity 时，调用这个 attach 方法的入参中，window 是 null，</span></span><br><span class=\"line\"><span class=\"comment\">     * 因为是 startActivityNow(...) 中 new 出来的 ActivityClientRecord。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果是 performRelaunchActivity 则会把这个 Activity 上一次销毁前的 Window 缓存下来并在这个方法中传入。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个 Window 实例，这里 mWindow 是 Window 类型的接口对象，该接口只有 PhoneWindow 唯一一个实例对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且当新启动一个 Activity 时，这里传入的 window 也是 null</span></span><br><span class=\"line\">        mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>, window, activityConfigCallback);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        mUiThread = Thread.currentThread();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统服务创建一个 WindowManager，并存进 mWindow 中</span></span><br><span class=\"line\">        mWindow.setWindowManager(</span><br><span class=\"line\">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class=\"line\">                mToken, mComponent.flattenToString(),</span><br><span class=\"line\">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mWindow.setContainer(mParent.getWindow());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 同时也把上面创建的 WindowManager 存在 Activity 内</span></span><br><span class=\"line\">        mWindowManager = mWindow.getWindowManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>attach(..)</code> 中 <code>new</code> 了一个 PhoneWindow 对象，再看看 PhoneWindow 的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> <span class=\"keyword\">implements</span> <span class=\"title\">MenuBuilder</span>.<span class=\"title\">Callback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructor for main window of an activity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneWindow</span><span class=\"params\">(Context context, Window preservedWindow,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里的判断条件，是需要 preservedWindow != null 才去初始化 DecorView。</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动一个 Activity，传进来的 preservedWindow == null，是不会走这个逻辑的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preservedWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class=\"line\">            mElevation = preservedWindow.getElevation();</span><br><span class=\"line\">            mLoadElevation = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mForceDecorInstall = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// If we&#x27;re preserving window, carry over the app token from the preserved</span></span><br><span class=\"line\">            <span class=\"comment\">// window, as we&#x27;ll be skipping the addView in handleResumeActivity(), and</span></span><br><span class=\"line\">            <span class=\"comment\">// the token will not be updated as for a new window.</span></span><br><span class=\"line\">            getAttributes().token = preservedWindow.getAttributes().token;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看来如果是新启动一个 Activity，<code>attach(...)</code> 传入的 window 对象其实没有什么用。<code>Activity.attach()</code> 完成后会由 Instrumentation 回调 <code>Activity.onCreate()</code>，表示 Activity 走到了 <code>onCreate()</code> 的生命周期。</p>\n<h3 id=\"2-1-2-onCreate流程总结\"><a href=\"#2-1-2-onCreate流程总结\" class=\"headerlink\" title=\"2.1.2 onCreate流程总结\"></a>2.1.2 onCreate流程总结</h3><p>Activity 在 onCreate 时的流程可以这么总结：</p>\n<ul>\n<li><p>通过 <code>startActivityNow(...)</code> 启动一个 Activity</p>\n</li>\n<li><p><code>startActivityNow(...)</code> 内部调用 <code>performLaunchActivity(...)</code></p>\n</li>\n<li><p><code>performLaunchActivity(...)</code> 判断传入的 ActivityClientRecord.mPendingRemoveWindow 是否为空</p>\n</li>\n<li><p>如果是通过 <code>startActivityNow(...)</code> 触发的 <code>performLaunchActivity(...)</code>，则 <code>ActivityClientRecord.mPendingRemoveWindow == null</code>；否则如果一个 Activity 是被 <code>handleRelaunchActivityInner(...)</code> 的，就会先调用 <code>handleDestroyActivity(...)</code>，这一步将当前 Activity 的 Window 混存在 mPendingRemoveWindow 后再销毁，然后调用 <code>performLaunchActivity(...)</code>，这样重新启动的同一个 Activity 就能拿到上一次销毁时保存的 Window 了。</p>\n</li>\n<li><p><code>performLaunchActivity(...)</code> 中从 ActivityClientRecord 取出对应的 Activity，并调用 <code>Activity.attach(...)</code>，传入了从 ActivityClientRecord 中取出的 mPendingRemoveWindow（可能为空）</p>\n</li>\n<li><p><code>Activity.attach(...)</code> 中直接 <code>new</code> 了一个新的 PhoneWindow，构造方法中传入了 ActivityClientRecord.mPendingRemoveWindow，PhoneWindow 判断 mPendingRemoveWindow 是否为空，为空说明是新启动的 Activity，否则说明是 relaunch 的 Activity</p>\n</li>\n<li><p>如果传入的 mPendingRemoveWindow 不为空，则从 mPendingRemoveWindow 中取出 DecorView，并作为当前 Activity 自己的 DecorView，否则不处理。</p>\n</li>\n<li><p>创建完新的 PhoneWindow 后，再通过系统服务创建一个 WindowManager</p>\n</li>\n<li><p>将这个新建的 WindowManager 绑定到 Activity 新建的 PhoneWindow 中，以及在 Activity 本身中保存。</p>\n</li>\n<li><p>此时 Activity 和对应的 ActivityClientRecord 共用同一个 WindowManager，但注意，Activity 在 <code>attach(...)</code> 中 <code>new</code> 出来的 Window，暂时还没有存入到对应的 ActivityClientRecord 中。</p>\n</li>\n</ul>\n<p>也就是说，走完 <code>onCreate()</code> 的流程后，一个 Activity 就创建好了自己的 Window 并绑定了 WindowManager。并且如果这个 Activity 是 relaunch 的，还会直接复用上一次销毁时缓存的 Window 和 DecorView；但如果是新启动的 Activity，则到当前为止，Activity 已经创建好了 Window，但还不具有 DecorView。</p>\n<h2 id=\"2-2-生命周期onResume\"><a href=\"#2-2-生命周期onResume\" class=\"headerlink\" title=\"2.2 生命周期onResume\"></a>2.2 生命周期onResume</h2><h3 id=\"2-2-1-onResume流程分析\"><a href=\"#2-2-1-onResume流程分析\" class=\"headerlink\" title=\"2.2.1 onResume流程分析\"></a>2.2.1 onResume流程分析</h3><p>接下来是 <code>onResume()</code> 的生命周期，这是通过 <code>ActivityThread.handleResumeActivity()</code> 调用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 通过 token 从所有 ActivityClientRecord 中取出目标</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动的 Activity，可以理解为这里取出来的 ActivityClientRecord 就是上面 startActivityNow(...) 中 new 出来的 ActivityClientRecord</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 因为 onCreate 的时候 Activity 在 attach(...) 中 new 了一个 PhoneWindow，但还没有存入 ActivityClientRecord</span></span><br><span class=\"line\">            <span class=\"comment\">// 这一步就是存入了 ActivityClientRecord，此时 Activity 和对应的 ActivityClientRecord 都持有了同一个 Window 和 WindowManager 对象</span></span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            <span class=\"comment\">// 获取目标 Activity 的 Window 的 DecorView</span></span><br><span class=\"line\">            <span class=\"comment\">// Window#getDecorView() 内部包含两个逻辑，如果持有的 DecorView 已存在（例如 relaunch 的场景）则直接返回，否则（例如 startActivityNow 的场景）就 new 一个再返回</span></span><br><span class=\"line\">            <span class=\"comment\">// 详见下面的源码</span></span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            <span class=\"comment\">// 取出之前 Activity.attach() 中绑定的 WindowManager</span></span><br><span class=\"line\">            <span class=\"comment\">// WindowManager 接口的实例对象是 WindowManagerImpl 对象</span></span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 创建的 DecorView 的窗口属性</span></span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            <span class=\"comment\">// 将创建的的 DecorView 作为目标 Activity 的 DecorView，此时还未创建 ViewRootImpl</span></span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// 判断 Activity 的 Window 是不是从上一次销毁时缓存下来的，如果是则通知 DecorView 的所有子 View 即将重建</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 获取 DecorView 的 ViewRootImpl，如果没有则返回 null</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class=\"line\">                <span class=\"comment\">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class=\"line\">                <span class=\"comment\">// the decor view we have to notify the view root that the</span></span><br><span class=\"line\">                <span class=\"comment\">// callbacks may have changed.</span></span><br><span class=\"line\">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">                <span class=\"comment\">// 当 Activity 是 relaunch 的时候，Window 和其持有的 DecorView 是从上一次缓存下来的，则 DecorView#getViewRootImpl 才不为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通知所有的子 View：「准备重新创建视图」</span></span><br><span class=\"line\">                    impl.notifyChildRebuilt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 注意这个动作</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ......</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 清除掉 Activity 缓存的 Window 等，并重置了 r.mPreserveWindow 标志位</span></span><br><span class=\"line\">        <span class=\"comment\">// Get rid of anything left hanging around.</span></span><br><span class=\"line\">        cleanUpPendingRemoveWindows(r, <span class=\"keyword\">false</span> <span class=\"comment\">/* force */</span>);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应上面 View decor = r.window.getDecorView(); 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    ViewGroup mContentParent;</span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Retrieve the top-level window decor view (containing the standard</span></span><br><span class=\"line\"><span class=\"comment\">     * window frame/decorations and the client&#x27;s content inside of that), which</span></span><br><span class=\"line\"><span class=\"comment\">     * can be added as a window to the window manager.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;&lt;em&gt;Note that calling this function for the first time &quot;locks in&quot;</span></span><br><span class=\"line\"><span class=\"comment\">     * various window characteristics as described in</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> #setContentView(View, android.view.ViewGroup.LayoutParams)&#125;.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Returns the top-level window decor view.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">View <span class=\"title\">getDecorView</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span> || mForceDecorInstall) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 内部逻辑其实就是 new 出来一个 DecorView，并与当前 Window 绑定</span></span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意两个重点：</p>\n<ul>\n<li>如果<code>handleResumeActivity(...)</code> 是因为 startActivityNow 触发的，则ActivityClientRecord 中的 Window 是在 <code>Activity.attach(...)</code> 才 <code>new</code> 出来的，所以并没有缓存下来的 DecorView，因此 <code>View decor = r.window.getDecorView();</code> 这一步会走到 <code>new</code> 一个 DecorView 的逻辑，所以此时这个 DecorView 也还没有 ViewRootImpl，或者说 Activity 还没有 ViewRootImpl。</li>\n<li>而如果 <code>handleResumeActivity(...)</code> 是由于 relaunch 触发的，则会在 relaunch 时将 <code>r.mPreserveWindow</code> 置为 true，表示 Window 和 DecorView 会缓存下来复用，则 Activity 其实已经拥有了 Window、DecorView、以及 ViewRootImpl 了。</li>\n</ul>\n<p>接下来再通过 <code>wm.addView(decor, l)</code> 把新建的 DecorView 按照其窗口属性 <code>WindowManager.LayoutParams</code> 添加到目标 Activity 的 WindowManager 中，这个 WindwoManager 的实现类是 WindowManagerImpl，找到 <code>addView(...)</code> 的实现方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handleResumeActivity(...) 中，调用该方法传入的 View 实际上就是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        <span class=\"comment\">// 这个 mGlobal 是 WindowManagerGlobal 实例对象</span></span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应 mGlobal.addView(...) 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  这里传入的 View 实际上是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// 目标 Activity 的 ViewRootImpl 就是在这里初始化的！</span></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// mRoots 是一个 ArrayList&lt;ViewRootImpl&gt; 类型的集合</span></span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加载 DecorView</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                。。。。。。</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终于找到了 ViewRootImpl 初始化的地方，其构造方法内绑定了初始化时的线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 绑定了初始化时的线程</span></span><br><span class=\"line\">        mThread = Thread.currentThread();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 Instrumentation 会回调 <code>Activity.onResume()</code>，表示 Activity 进入到了 <code>onResume()</code> 的生命周期。到了这一步，Activity 初始化了 PhoneWindow 以及 DecorView，并且在 ViewRootImpl 中加载了 DecorView，这也表示 Activity 已经从视觉上可见。</p>\n<h3 id=\"2-2-2-onResume流程总结\"><a href=\"#2-2-2-onResume流程总结\" class=\"headerlink\" title=\"2.2.2 onResume流程总结\"></a>2.2.2 onResume流程总结</h3><p>Activity 在 onResume 时的流程可以这么总结：</p>\n<ul>\n<li><p>通过 ActivityThread 创建一个 Activity，以及对应的 ActivityClientRecord</p>\n</li>\n<li><p>获取 DecorView，分为两种逻辑：由于 startActivityNow 触发的 handleResumeActivity、以及由于 relaunch 触发的 handleResumeActivity</p>\n</li>\n<li><p>如果是由于 startActivityNow 触发的，则 DecorView 尚未创建，立即创建一个 DecorView，此时 DecorView 或者说 Activity 尚未初始化 ViewRootImpl</p>\n</li>\n<li><p>如果是由于 relaunch 触发的，则 Window、DecorView 均是从上一次销毁时缓存中复用的，此时 DecorView 已经初始化过了 ViewRootImpl，也即 Activity 已经拥有 ViewRootImpl 了，只需要通知所有子 View 即将重建。</p>\n</li>\n<li><p>如果 Activity 还未初始化 ViewRootImpl（对应 startActivityNow 的场景），则调用 <code>WindowManager#addView(...)</code>，其内部初始化了 ViewRootImpl，将初始化 ViewRootImpl 时的所在线程，作为 ViewRootImpl 的初始线程</p>\n</li>\n<li><p>ViewRootImpl 持有 DecorView</p>\n</li>\n</ul>\n<p>也就是说，到了 onResume 这一步，Activity 已经创建了 DecorView 和 ViewRootImpl，并且对 ViewRootImpl 的原始线程做了初始化。此时 Activity 已经完整具有了 Window、DecorView、ViewRootImpl。</p>\n<h2 id=\"2-3-加载布局setContentView\"><a href=\"#2-3-加载布局setContentView\" class=\"headerlink\" title=\"2.3 加载布局setContentView\"></a>2.3 加载布局setContentView</h2><h3 id=\"2-3-1-setContentView流程分析\"><a href=\"#2-3-1-setContentView流程分析\" class=\"headerlink\" title=\"2.3.1 setContentView流程分析\"></a>2.3.1 setContentView流程分析</h3><p>接下来就是 Activity 的另一项重要功能，加载布局文件。通常加载布局文件都是通过 <code>setContentView(...)</code> 实现的，这里其实分为两个版本：</p>\n<p>（1）早期的 Activity 直接继承自 Activity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        getWindow().setContentView(layoutResID);</span><br><span class=\"line\">        initWindowDecorActionBar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是通过之前 <code>Activity.attach(...)</code> 时创建的 PhoneWindow 去直接加载布局。</p>\n<p>（2）新版本的 Activity 继承自 AppCompatActivity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// getDelegate() 返回一个 AppCompatDelegate 接口类型的实例对象</span></span><br><span class=\"line\">        getDelegate().setContentView(layoutResID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AppCompatDelegate <span class=\"title\">getDelegate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDelegate == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实际上内部就是 new 了一个 AppCompatDelegateImpl</span></span><br><span class=\"line\">            mDelegate = AppCompatDelegate.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDelegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看 <code>AppCompatDelegateImpl.setContentView()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class=\"line\">        ensureSubDecor();</span><br><span class=\"line\">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class=\"line\">        contentParent.removeAllViews();</span><br><span class=\"line\">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class=\"line\">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这个 <code>ensureSubDecor()</code> 方法，从命名就能看出，这个方法确保了 <code>subDecor</code> 一定能被创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mSubDecorInstalled) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 真正的创建是这个方法</span></span><br><span class=\"line\">            mSubDecor = createSubDecor();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 可以看到在 setContentView(...) 内部加载了标题和 ActionBar</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么在 Activity 中，对 ActionBar 或 Title 的修改必须放在 setContentView(...) 调用之前</span></span><br><span class=\"line\">            <span class=\"comment\">// If a title was set before we installed the decor, propagate it now</span></span><br><span class=\"line\">            CharSequence title = getTitle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(title)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDecorContentParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mDecorContentParent.setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (peekSupportActionBar() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    peekSupportActionBar().setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mTitleView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mTitleView.setText(title);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            mSubDecorInstalled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接下来看看 createSubDecor() 的源码：</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ViewGroup <span class=\"title\">createSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这下面的一堆 if - else 都只是为了确定这个 Activity 对应 Window 的样式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123;</span><br><span class=\"line\">            a.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;You need to use a Theme.AppCompat theme (or descendant) with this activity.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class=\"line\">            requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        a.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先确保了 Window 已经初始化</span></span><br><span class=\"line\">        <span class=\"comment\">// Now let&#x27;s make sure that the Window has installed its decor by retrieving it</span></span><br><span class=\"line\">        ensureWindow();</span><br><span class=\"line\">        <span class=\"comment\">// 从 Activity 存储的 PhoneWindow 中获取 DecorView，但并不是需要拿到 DecorView 实例，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而是为了像上面 handleResumeActivity(...) 中的 r.activity.getWindow() 一样，确保 DecorView 已被创建</span></span><br><span class=\"line\">        mWindow.getDecorView();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这个就是目标 subDecor</span></span><br><span class=\"line\">        ViewGroup subDecor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mWindowNoTitle) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 Activity 含有 WindowTitle：</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mIsFloating) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加载悬浮窗样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) inflater.inflate(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mHasActionBar) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 加载有 ActionBar 样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) LayoutInflater.from(themedContext).inflate(...);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 这个 mDecorContentParent 是 ActionBarOverlayLayout 类型的，用于管理 ActionBar</span></span><br><span class=\"line\">                mDecorContentParent = (DecorContentParent) subDecor.findViewById(R.id.decor_content_parent);</span><br><span class=\"line\">                mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Propagate features to DecorContentParent</span></span><br><span class=\"line\"><span class=\"comment\">                 * 给 DecorContentParent 应用特性</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                ......</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里同样是加载某个样式的 subDecor，省略</span></span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然无法加载出 subDecor，就抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;AppCompat does not support the current theme features: &#123; &quot;</span> + ...... + <span class=\"string\">&quot; &#125;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">21</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 针对 API &gt;= 21 做适配</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (subDecor <span class=\"keyword\">instanceof</span> FitWindowsViewGroup) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 针对 FitWindowsViewGroup 做适配</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将 subDecor 加载到 PhoneWindow 中</span></span><br><span class=\"line\">        mWindow.setContentView(subDecor);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回头看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class=\"line\">        ensureSubDecor();</span><br><span class=\"line\">        <span class=\"comment\">// 这个临时变量 contentParent 是 subDecor 的一个子元素</span></span><br><span class=\"line\">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class=\"line\">        contentParent.removeAllViews();</span><br><span class=\"line\">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class=\"line\">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 contentParent，它是从 subDecor 加载后的布局中，通过 <code>findViewById(...)</code> 的方式获取到的一个 ViewGroup，也就是说，实际上在 Activity 中调用的 <code>setContentView(int resId)</code> 传入的布局文件，是加载在 subDecor 的一个子 View 中。</p>\n<p>在 <code>createSubDecor()</code> 中，先确保 Window 和 DecorView 已创建，然后根据 Title 和 ActionBar 的样式不同，通过 <code>inflate</code> 的方式加载对应的模板 subDecor。</p>\n<blockquote>\n<p>@注：如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，从类名也能看出这个 View 就是专门负责 ActionBar 的。</p>\n</blockquote>\n<p>当 subDecor 被成功创建后，通过 <code>mWindow.setContentView(subDecor);</code> 把 subDecor 加载到 Activity 的 Window 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里也可以看出，默认情况下是全屏的</span></span><br><span class=\"line\">        setContentView(view, <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class=\"line\">        <span class=\"comment\">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class=\"line\">        <span class=\"comment\">// before this happens.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            mContentParent.removeAllViews();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            view.setLayoutParams(params);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Scene newScene = <span class=\"keyword\">new</span> Scene(mContentParent, view);</span><br><span class=\"line\">            transitionTo(newScene);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">            mContentParent.addView(view, params);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParent.requestApplyInsets();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">            cb.onContentChanged();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>又看到上文中在初始化 DecorView 时的 <code>PhoneWindow#installDecor()</code> 了，通过 <code>mContentParent.addView(view, params);</code> 这行可以看出实际上是把 subDecor 加载到了 <code>mContentParent</code> 中，而这个 <code>mContentParent</code> 就是 DecorView 加载出来的布局容器实例 ViewGroup，所以本质就是把 subDecor 加载到了 DecorView 中！</p>\n<p>注意两个细节：</p>\n<ul>\n<li><p><code>PhoneWindow#getDecorView() - installDecor()</code> 中，DecorView 被加载到了 <code>PhoneWindow#mContentParent</code> 这个 ViewGroup 中</p>\n</li>\n<li><p>然后在 <code>AppCompatDelegateImpl#setContentView(int resId)</code> 中，当 subDecor 被按照模板创建后，使用其中一个叫 <code>contentParent</code> 的子元素 <code>inflate</code> 了传入的布局文件</p>\n</li>\n</ul>\n<h3 id=\"2-3-2-setContentView流程总结\"><a href=\"#2-3-2-setContentView流程总结\" class=\"headerlink\" title=\"2.3.2 setContentView流程总结\"></a>2.3.2 setContentView流程总结</h3><p>至此，可以对 Activty 中调用 <code>setContentView(int resId)</code> 后的流程做一个总结：</p>\n<ul>\n<li><p>如果是老版本直接继承自 Activity，则调用 <code>setContentView(int resId)</code> 后会直接把布局 <code>inflate</code> 到 Activity 对应的 Window 中。</p>\n</li>\n<li><p>如果是新版本继承自 AppCompatActivity，则先确保 subDecor 已创建。</p>\n</li>\n<li><p>在创建 subDecor 前，先确保 Window 和 DecorView 已创建。</p>\n</li>\n<li><p>首先判断 PhoneWindow 是否创建，如果未创建则先创建 Window。</p>\n</li>\n<li><p>然后通过 <code>PhoneWindow#getDecorView() - installDecor()</code> 确保了 DecorView 已被创建、以及根据 DecorView 生成了 <code>PhoneWindow#mContentParent</code> 这个实例 ViewGroup，也即：PhoneWindow 加载了 DecorView 并持有了 DecorView 加载后的 ViewGroup。</p>\n</li>\n<li><p>创建 subDecor 时，根据 Activity 及其 Window 的属性加载预置的 subDecor 模板，如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，专门用于管理 ActionBar 相关的视图。</p>\n</li>\n<li><p>根据模板创建了 subDecor 后，通过 <code>Window#setContentView(View)</code> 将 subDecor 传入，并把传入的 subDecor 作为子 View 添加到 <code>PhoneWindow#mContentParent</code> 中，本质上就是把 subDecor 添加到 DecorView 中。</p>\n</li>\n<li><p>subDecor 创建好后，从 subDecor 中通过 <code>findViewById(int)</code> 获取一个 ID 为 <code>android.R.id.content</code> 的布局 <code>contentParent</code>，接着 <code>contentParent</code> 先 remove 掉所有子 View，再 <code>inflate</code> 传入的布局文件。这一步才真正加载 Activity 布局。</p>\n</li>\n</ul>\n<p>也就是说，在 setContentView 的时候，Activity 实际上是在确保 Window 和 DecorView 均已创建的基础上，把 subDecor 根据模板创建出来并 add 进 <code>mContentParent</code> 这个 ViewGroup 中（<code>mContentParent</code> 是从 DecorView 加载出来的），然后从 subDecor 的模板布局中获取一个子元素 <code>contentParent</code>，最后把实际的 Activity 布局 <code>inflate</code> 进 <code>contentParent</code>。</p>\n<p>虽然顺序上是先把 subDecor 添加到 DecorView 中，再将 Activity 布局 <code>inflate</code> 进 subDecor 的子元素 <code>contentParent</code> 中，但因为 JVM 对象引用的缘故，所以实际上的关系链依然是：</p>\n<p>Window 持有 DecorView - DecorView 持有 subDecor - subDecor 加载 Activity 的布局。</p>\n<hr>\n<h1 id=\"3-ViewRootImpl线程的定义\"><a href=\"#3-ViewRootImpl线程的定义\" class=\"headerlink\" title=\"3. ViewRootImpl线程的定义\"></a>3. ViewRootImpl线程的定义</h1><ul>\n<li><p>通过上文 2.2.2 的总结，可以知道 ViewRootImpl 判断线程时依据的 <code>mThread</code> 就是创建并初始化 ViewRootImpl 时的所在线程。</p>\n</li>\n<li><p>通过上文 2.3.2 的总结，可以知道 <code>setContentView(...)</code> 之后 Activity 视图的加载流程，主要包括对 DecorView、subDecor、以及 mContentParent 的加载和持有逻辑。</p>\n</li>\n</ul>\n<p>但是！结合上面这两条来看，就会发现两个结论：</p>\n<ul>\n<li><p>在 <code>setContentView(...)</code> 中，虽然也有判断 Window、DecorView、subDecor 等是否创建以及立即创建的逻辑，但并没有对 ViewRootImpl 的操作逻辑！！！也就是说，调用 <code>setContentView(...)</code> 时所处的线程并不能决定 ViewRootImpl 的初始线程，也就无法决定哪个线程可以更新 UI！</p>\n</li>\n<li><p>从 Activity 的加载流程 2.2.1 部分来看，决定 ViewRootImpl 初始线程的，似乎只有 <code>handleResumeActivity(...)</code>，而不论 startActivity 是否在子线程中调用，一个 Activity 都是通过 AMS 管理的，<code>handleResumeActivity(...)</code> 的调用都会发生在 ActivityThread 中，ActivityThread 又处在主线程中。</p>\n</li>\n</ul>\n<p><font color=#FF0000, size=5>这两个结论说明：不论 startActivity 是否在子线程中调用，也不论一个 Activity 的 <code>setContentView(...)</code> 是否在子线程中调用，都无法影响到 Activity 是在 ActivityThread 这个主线程中加载的，所以尽管 ViewRootImpl 比较的线程是【初始线程】与当前线程，但在 Activity 常规加载流程中，ViewRootImpl 总是在主线程初始化的，所以在大部分情况下，子线程的确无法更新 UI。</font></p>\n<hr>\n<h1 id=\"4-子线程绝对不能更新UI吗？\"><a href=\"#4-子线程绝对不能更新UI吗？\" class=\"headerlink\" title=\"4. 子线程绝对不能更新UI吗？\"></a>4. 子线程绝对不能更新UI吗？</h1><p>在上面第 3 部分，我做了一个结论，表明「大部分情况下，子线程的确无法更新 UI」，但请注意原画中的「常规加载流程」，以及「大部分情况下」这两个关键词。</p>\n<p>先写结论：<font color=#FF0000, size=5>实际上，子线程可以更新 UI。</font></p>\n<p>在这里我又再一次推倒了前面的结论，因为我们已经知道，只要能让 ViewRootImpl 在子线程中初始化，就能在该子线程中更新 UI。虽然通常初始化 ViewRootImpl 的动作会被 ActivityThread 自动完成，但实际上仍有方法手动创建。</p>\n<h2 id=\"4-1-手动触发ViewRootImpl的初始化\"><a href=\"#4-1-手动触发ViewRootImpl的初始化\" class=\"headerlink\" title=\"4.1 手动触发ViewRootImpl的初始化\"></a>4.1 手动触发ViewRootImpl的初始化</h2><p>从前文可以知道，ViewRootImpl 的初始化发生在 <code>ActivityThread.handleResumeActivity(...)</code> 中，并且发生在初始化 Window 和 DecorView 之后调用 <code>mWindow.addView(DecorView, LayoutParams)</code> 时。那就可以想个办法，在 onCreate 阶段就手动初始化 PhoneWindow，手动触发 <code>mWindow.addView(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">    HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">    newThread.start();</span><br><span class=\"line\">    Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadText = <span class=\"keyword\">new</span> TextView(DemoActivity.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            WindowManager.LayoutParams windowLP = <span class=\"keyword\">new</span> WindowManager.LayoutParams(</span><br><span class=\"line\">                    <span class=\"number\">200</span>,  <span class=\"comment\">// width</span></span><br><span class=\"line\">                    <span class=\"number\">50</span>,   <span class=\"comment\">// height</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// x position</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// y position</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.FIRST_SUB_WINDOW,  <span class=\"comment\">// type</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.TYPE_TOAST,        <span class=\"comment\">// flag</span></span><br><span class=\"line\">                    PixelFormat.OPAQUE                            <span class=\"comment\">// format</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            WindowManager windowManager = MainActivity.<span class=\"keyword\">this</span>.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 实际上就是把这个 TextView 作为 DecorView 传递给 WindowManager 加载</span></span><br><span class=\"line\">            windowManager.addView(tvNewThreadText, windowLP);</span><br><span class=\"line\">            tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过手动初始化 Window 并添加 View，的确可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h2 id=\"4-2-避开ViewRootImpl的检查\"><a href=\"#4-2-避开ViewRootImpl的检查\" class=\"headerlink\" title=\"4.2 避开ViewRootImpl的检查\"></a>4.2 避开ViewRootImpl的检查</h2><p>从文章最开始对 <code>TextView#setText(...)</code> 的源码分析可知，子线程中更新 UI 会抛出异常在于更新 UI 时，View 会逐级向上层父 View 调用 <code>requestLayout()</code>，直到最上层的 <code>ViewRootImpl#requestLayout()</code> 判断了线程。但在后面 Activity 加载流程的分析中又发现，ViewRootImpl 是在 <code>handleResumeActivity()</code> 时初始化的，也就是说，在 Activity 处于 onCreate 生命周期时，ViewRootImpl 根本都还没有初始化，此时如果 TextView 更新 UI，则在逐级向上层调用父 View 的 <code>requestLayout()</code> 时，到了 ViewRootImpl 就会因为 <code>mParent == null</code> 而跳过了。</p>\n<p>Show me the code: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_demo);</span><br><span class=\"line\"></span><br><span class=\"line\">    tvNewThreadTitle = findViewById(R.id.tvNewThreadTitle);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程修改后的 Text&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过避开 ViewRootImpl 的检查，的确也可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h2 id=\"4-3-针对TextView避开重绘\"><a href=\"#4-3-针对TextView避开重绘\" class=\"headerlink\" title=\"4.3 针对TextView避开重绘\"></a>4.3 针对TextView避开重绘</h2><p>4.1 和 4.2 中的两个方法，是对所有 View 更新 UI 都适用的，但对于 TextView，还有一种方式，就是避开重绘。</p>\n<p>首先看下这样一个布局（省略部分）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/btUpdate&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;100dp&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;在子线程更新 UI&quot;</span></span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过 Activity 加载（省略部分）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击 Button 时，会开启一个子线程并在子线程中更新 TextView。</p>\n<p>毫无疑问这段代码 Crash 了，原因和文首说明的一样，因为 ViewRootImpl 在主线程中初始化，因此子线程无法更新 UI。</p>\n<p>但！如果把布局中 TextView 的宽度改为精确值或 <code>match_parent</code>，Activity 中的代码不变：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度改为精确值或 match_parent--&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;200dp&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Activity 中的代码逻辑不变，仍然是在点击时开启子线程并在子线程中更新 TextView</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次运行发现居然没有 Crash，子线程成功更新了 UI！这难道又要再次推翻之前的结论吗？</p>\n<p>再重新翻一下 <code>TextView#setText(...)</code> 的源码，这一次仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we have a fixed width, we can just swap in a new text layout</span></span><br><span class=\"line\">        <span class=\"comment\">// if the text height stays the same or if the view height is fixed.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))</span><br><span class=\"line\">                &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Static width, so try making a new text layout.</span></span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// In a fixed-height view, so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                        &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Dynamic height, but height has stayed the same,</span></span><br><span class=\"line\">                <span class=\"comment\">// so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayout.getHeight() == oldht</span><br><span class=\"line\">                        &amp;&amp; (mHintLayout == <span class=\"keyword\">null</span> || mHintLayout.getHeight() == oldht)) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We lose: the height has changed and we have a dynamic height.</span></span><br><span class=\"line\">            <span class=\"comment\">// Request a new view layout using our new text layout.</span></span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Dynamic width, so we have no choice but to request a new</span></span><br><span class=\"line\">            <span class=\"comment\">// view layout with a new text layout.</span></span><br><span class=\"line\">            nullLayouts();</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码可以发现，在 <code>checkForRelayout()</code> 之前，先通过 <code>setTextInternal(text);</code> 把 text 存入了成员变量，然后才会调用 <code>checkForRelayout()</code> 检查线程。</p>\n<p>通过上文已经知道，如果调用了 <code>requestLayout()</code>，就会导致 ViewRootImpl 判断线程。而 <code>TextView#checkForRelayout()</code> 中，<code>requestLayout()</code> 之前有两个 <code>return</code> 的机会（已在代码注释中标出），接下来就是看看如何才能触发这两个 <code>return</code>！</p>\n<p>（1）首先是最外层的 <code>if</code> 判断必须要满足的条件，否则 <code>else</code> 中一定会走到 <code>requestLayout</code>。这个最外层的 <code>if</code> 条件是（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (</span><br><span class=\"line\">        mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">        || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，这三个条件均满足就表示 TextView 的宽度是固定值且大于 0，也就是宽度是不需要重新测绘的。这也是为什么当 TextView 的宽度设置为 <code>wrap_content</code> 时，子线程更新 TextView 会抛出异常的原因，因为这个最外层的 <code>if</code> 不满足而走到了 <code>else</code> 中。</p>\n<p>（2）接着是第二层的 <code>if</code> 判断也必须要满足条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE)</span><br></pre></td></tr></table></figure>\n\n<p>这个判断满足时表示 TextView 不是跑马灯效果的状态。这个很好理解，因为跑马灯效果是需要一直刷新 UI 的。</p>\n<p>（3）然后是第一个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">    &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n\n<p>代码很好懂，如果高度既不是 <code>wrap_content</code> 又不是 <code>match_parent</code>，那就只能是精确高度了，这也就表示高度也不需要重新测绘。</p>\n<p>（4）最后是第二个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayout.getHeight() == oldht</span><br><span class=\"line\">    &amp;&amp; (</span><br><span class=\"line\">        mHintLayout == <span class=\"keyword\">null</span></span><br><span class=\"line\">        || mHintLayout.getHeight() == oldht</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>代码依然很好懂，如果新的高度和久的高度一致，也表示高度不需要重新测绘。</p>\n<p>综合上述的（1）、（2）、（3）、（4）可以得出结论：如果一个 TextView 的内容被改变了，但是新 TextView 的高度和宽度都不会发生变化，并且也不是跑马灯效果模式，也即 TextView 不需要重新测绘，则不需要调用 requestLayout，也就不会走到 ViewRootImpl 判断线程的地方！</p>\n<p>这里需要注意的是：宽度和高度必须同时都是固定值（精确值或 <code>match_parent</code>）才不会发生重绘。上面测试代码中，TextView 的高度为 <code>wrap_content</code> 却没问题的原因，是更新内容时能在一行内显示完全，因此高度没有发生变化，走进了条件（4）中的 <code>return</code>。如果把 TextView 改成宽度为很小的值、高度为自适应，然后子线程中 set 一个很长的文本，使得 TextView 会因为换行导致高度发生变化，则也是会抛出异常的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度设为很小的值，高度为自适应，然后子线程中 set 一个很长的文本使其换行导致高度变化，会抛出异常--&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    android:layout_width=<span class=\"string\">&quot;10dp&quot;</span></span><br><span class=\"line\">    android:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    android:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">&lt;Button</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>因此 TextView 的 UI 更新方式可以总结为两种：</p>\n<ul>\n<li><p>如果更新后宽度或高度会发生变化，或者是跑马灯效果模式，则立即逐级向父 View 请求重绘一次，并在绘制时绘制出新的文本。</p>\n</li>\n<li><p>否则就把把需要更新的文本存在 TextView 内，等下一次屏幕刷新的时候顺便就绘制成新的文本。</p>\n</li>\n</ul>\n<p>实践证明：针对 TextView，通过避免重绘，的确可以实现子线程更新 UI，但仅针对 TextView 或类似有跳过重绘逻辑的 View。</p>\n<h2 id=\"4-4-使用SurfaceView-TextureView\"><a href=\"#4-4-使用SurfaceView-TextureView\" class=\"headerlink\" title=\"4.4 使用SurfaceView/TextureView\"></a>4.4 使用SurfaceView/TextureView</h2><p>SurfaceView 算是正儿八经使用子线程更新 UI 的例子了，也是其最大的优点。SurfaceView 的画面渲染主要是通过其持有的一个 <code>Surface</code> 类型的 <code>mSurface</code> 对象实现的，这个 <code>Surface</code> 并不是一个 View 的子类，因此其更新并不收到 View 更新中 <code>checkThread()</code> 的限制。简单来说，SurfaceView 可以在子线程中更新 UI 的原理是因为其渲染的目标并不是一个 View。</p>\n<p>当然，实际上 SurfaceView / TextureView 的原理远不止这么简单，本文主要聚焦于子线程更新 UI 的可行性，所以不对 SurfaceView / TextureView 的原理深入解析，相关解析也在计划中，感兴趣的读者可以关注后续更新。</p>\n<h2 id=\"4-5-特例Toast\"><a href=\"#4-5-特例Toast\" class=\"headerlink\" title=\"4.5 特例Toast\"></a>4.5 特例Toast</h2><p>Toast 作为 Android 系统级别的 UI 组件，甚至与 Activity 生命周期都无关，常见的例子就是如果一个 App 正在弹 Toast 的时候出现 Crash 或者手动杀掉了，Toast 还是能正常显示的。</p>\n<h3 id=\"4-5-1-Toast可以跨线程显示\"><a href=\"#4-5-1-Toast可以跨线程显示\" class=\"headerlink\" title=\"4.5.1 Toast可以跨线程显示\"></a>4.5.1 Toast可以跨线程显示</h3><p>实际上 Toast 的显示除了和 Activity 无关之外，也和线程无关，下面这段代码执行不会抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中的Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同时抛出一个注意事项：如果需要在子线程中 Toast，则该子线程必须初始化 Looper，因此需要使用 HandlerThread 或者在子线程中手动调用 Looper 的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在未初始化 Looper 的子线程中 Toast 会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">// RuntimeException: Can&#x27;t toast on a thread that has not called Looper.prepare()</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;未初始化Looper的子线程Toast会报错&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以使用 HandlerThread，或者手动初始化 Looper</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;已初始化Looper的子线程可以正确Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>Toast 本质上也是一种 View，因此是可以通过 <code>toast.setView(View)</code> 来自定义 Toast 样式的，那既然 Toast 是 View，为什么可以在子线程显示呢？老办法，看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(Context context, CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> makeText(context, <span class=\"keyword\">null</span>, text, duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Make a standard toast to display using the specified looper.</span></span><br><span class=\"line\"><span class=\"comment\">     * If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty Toast object.  If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Toast</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mTN = <span class=\"keyword\">new</span> TN(context.getPackageName(), looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TN</span> <span class=\"keyword\">extends</span> <span class=\"title\">ITransientNotification</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        TN(String packageName, <span class=\"meta\">@Nullable</span> Looper looper) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Use Looper.myLooper() if looper is not specified.</span></span><br><span class=\"line\">                looper = Looper.myLooper();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                            <span class=\"string\">&quot;Can&#x27;t toast on a thread that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：</p>\n<ul>\n<li><p>默认情况下三参数的 <code>Toast.makeText(...)</code> 会调用四参数的重载方法，并且传入的 looper 参数是 <code>null</code></p>\n</li>\n<li><p>四参数的方法中，<code>new</code> 了一个 Toast 实例</p>\n</li>\n<li><p>查看对应的 Toast 构造方法发现，又用传入的 looper 作为构造函数参数 <code>new</code> 了一个 <code>TN</code> 类的实例</p>\n</li>\n<li><p>再查看 TN 的构造方法发现，如果传入的 looper 为 <code>null</code>，就直接用当前调用线程的 Looper</p>\n</li>\n</ul>\n<p>简言之，<code>Toast.makeText(...)</code> 是直接使用调用的线程作为显示线程的，这就可以直接验证上文说的 Toast 的两个特性：</p>\n<ul>\n<li><p>Toast 可以在子线程显示，因为 <code>Toast.makeText(...)</code> 内部在调用时每次都使用当前线程作为显示线程，因此实际上不存在跨线程的问题。</p>\n</li>\n<li><p>Toast 要求线程初始化 Looper 否则在 <code>new TN(...)</code> 的时候就会因为拿不到 looper 抛出异常。</p>\n</li>\n</ul>\n<h3 id=\"4-5-2-Toast不能跨线程更新\"><a href=\"#4-5-2-Toast不能跨线程更新\" class=\"headerlink\" title=\"4.5.2 Toast不能跨线程更新\"></a>4.5.2 Toast不能跨线程更新</h3><p>看到这个小标题别慌，Toast 可以在子线程中显示是毫无疑问的，但是有一种情况下，Toast 也会抛出 <code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code> 异常，就是更新内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Toast generalToast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在子线程中弹一个 Toast，并把这个 Toast 持久化到成员变量</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        generalToast = Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中创建并显示的Toast&quot;</span>, Toast.LENGTH_LONG);</span><br><span class=\"line\">        generalToast.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确保子线程已经弹了 Toast 之后，也就是 generalToast 已经初始化，再在主线程更新 generalToast 的内容</span></span><br><span class=\"line\">btUpdateInMainThread.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generalToast != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            generalToast.setText(<span class=\"string\">&quot;在主线程更新子线程创建的Toast的内容&quot;</span>);</span><br><span class=\"line\">            generalToast.show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>运行发现报错了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么 <code>Toast.makeText(...)</code> 不限制线程，但 <code>toast.setText(...)</code> 又限制线程呢？再仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\"></span><br><span class=\"line\">        LayoutInflater inflate = (LayoutInflater)</span><br><span class=\"line\">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">        View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        tv.setText(text);</span><br><span class=\"line\"></span><br><span class=\"line\">        result.mNextView = v;</span><br><span class=\"line\">        result.mDuration = duration;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mNextView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TextView tv = mNextView.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tv == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tv.setText(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来在 <code>Toast.makeText(...)</code> 时，Toast 会使用当前线程作为该 Toast 的消息处理 Looper，然后使用系统的 Inflater 服务去加载一个 <code>com.android.internal.R.layout.transient_notification</code> 的布局作为 Toast 的根布局，其中具有一个 TextView 元素，使用该 TextView 元素承载需要显示的文字。</p>\n<p>当调用 <code>toast.setText(...)</code>  时，TextView 就会像文首提到的方式，一层层向上通知更新，因此如果线程与 toast 在初始化时的线程不一致，自然会抛出异常。</p>\n<h2 id=\"4-6-捕获异常\"><a href=\"#4-6-捕获异常\" class=\"headerlink\" title=\"4.6 捕获异常\"></a>4.6 捕获异常</h2><p>上述的在子线程更新 UI 的方式，都是通过避开已知会抛出异常的情况（SurfaceView 相当于直接不检查）实现的。还有一种更新 UI 的方式最为简单粗暴，就是捕获异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程中更新UI并捕获异常&quot;</span>);</span><br><span class=\"line\">            ivImage.setImageResource(R.drawable.ic_launcher_foreground);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ignore)&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码当然不会抛出异常，并且 TextView 也确实能更新文本内容，但是 ImageView 却没有任何反应。对比一下 <code>TextView#setText(...)</code> 和 <code>ImageView#setImageResource(...)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"meta\">@DrawableRes</span> <span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过看源码发现：</p>\n<ul>\n<li><p><code>TextView#setText(...)</code> 是先通过 <code>setTextInternal(...)</code> 把 text 存入到成员变量，然后再调用 <code>checkForRelayout()</code> 检查是否需要重绘，如果需要的话才调用 <code>requestLayout()</code>，检查线程也就发生在 <code>ViewRootImpl#requestLayout()</code> 中。所以即使 <code>ViewRootImpl#requestLayout()</code> 抛出了异常，也不会影响到 <code>setTextInternal(...)</code> 已经把 text 存下来了，那只需要等待下一次屏幕刷新即可把文本刷新上去。</p>\n</li>\n<li><p><code>ImageView#setImageResource(...)</code> 是先通过 <code>requestLayout()</code> 请求更新，并在 <code>ViewRootImpl#requestLayout()</code> 中检查了线程，只有未抛出异常时，才会走到 <code>invalidate()</code> 并重绘，否则抛出异常则会中断跳出方法。</p>\n</li>\n</ul>\n<p>所以，通过捕获异常的方式，只能针对类似于 TextView 这种，可以在检查线程前先做更新 / 缓存的 View，其他 View 则尽管不会抛出异常，也无法更新 UI，所以捕获异常属于一种“骚操作”，是极为不建议使用的。</p>\n<hr>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>概括一下本文内容：</p>\n<ul>\n<li><p>Android 中视图的顶点都是 Window，显示视图的根基就是需要有一个可用的 Window</p>\n</li>\n<li><p>Window 持有 DecorView</p>\n</li>\n<li><p>Window 在创建并持有 DecorView 时会初始化 ViewRootImpl 时的当前线程会作为 ViewRootImpl 持有的初始化线程</p>\n</li>\n<li><p>DecorView 加载 subDecor</p>\n</li>\n<li><p>用 subDecor 承载 Activity 的 layout</p>\n</li>\n<li><p>更新 View 时，如果需要重绘，会逐级调用父 View 的 <code>requestLayout()</code>，最上层的父 View 就是 ViewRootImpl，在 <code>ViewRootImpl#requestLayout()</code> 中判断了当前线程与初始化线程是否相同，如果不相同则抛出异常</p>\n</li>\n<li><p>有几种方式是可以在子线程更新 UI 的：</p>\n<ul>\n<li><p>手动触发 ViewRootImpl 初始化：也就是手动创建 Window 并添加 DecorView。</p>\n</li>\n<li><p>避开 ViewRootImpl 的检查：针对 TextView 这类先缓存再判断的 View 可以通过避开重绘等待下一次屏幕刷新时显示已缓存的内容来刷新 UI。</p>\n</li>\n<li><p>使用 SurfaceView / TextureView。</p>\n</li>\n<li><p>显示 Toast：Toast 的创建每次都会使用当前线程初始化，因此显示 Toast 不受跨线程的影响。但不能对其他线程的 Toast 实例对象调用 <code>Toast#setText(...)</code>，否则就相当于子线程更新 UI。</p>\n</li>\n<li><p>捕获异常：针对 TextView 这类先缓存再判断的 View，可以更新 UI。但其他 View 通常会先检查线程再重绘，就会导致检查的那一步抛出异常，虽然捕获了不会 Crash，但也会中断重绘逻辑导致无法刷新。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>以上就是本篇关于「子线程到底能不能更新 UI」的全部内容了，相信看完后应当可以对 Android 到底能不能在子线程中更新 UI 有了全面了解。如果觉得写得不错的，欢迎留个言鼓励一下～</p>\n","categories":["Android"],"tags":["Android","子线程","UI线程"]}]