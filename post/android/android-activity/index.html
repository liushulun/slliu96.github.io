<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;blog.luis.ltd&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#EB6D39&quot;,&quot;save&quot;:&quot;manual&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:true,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:true,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeInDown&quot;,&quot;post_header&quot;:null,&quot;post_body&quot;:null,&quot;coll_header&quot;:&quot;none&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;},&quot;path&quot;:&quot;&#x2F;search.json&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="（1）Activity 简介（Activity 的生命周期、Activity 的启动与退出）；（2）Activity 的启动模式（Standard、SingleTop、SingleTask、SingleInstance）；（3）Activity 启动流程（Application 启动流程、onCreate、onStart、onResume）；（4）Activity 布局加载流程（setConten">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-Activity深入理解">
<meta property="og:url" content="https://blog.luis.ltd/post/android/android-activity/index.html">
<meta property="og:site_name" content="Luis&#39;s Blogs">
<meta property="og:description" content="（1）Activity 简介（Activity 的生命周期、Activity 的启动与退出）；（2）Activity 的启动模式（Standard、SingleTop、SingleTask、SingleInstance）；（3）Activity 启动流程（Application 启动流程、onCreate、onStart、onResume）；（4）Activity 布局加载流程（setConten">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-01T13:42:31.000Z">
<meta property="article:author" content="Luis">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="四大组件">
<meta property="article:tag" content="Activty">
<meta property="article:tag" content="taskAffinity">
<meta property="article:tag" content="启动模式">
<meta property="article:tag" content="生命周期">
<meta property="article:tag" content="启动流程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.luis.ltd/post/android/android-activity/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;blog.luis.ltd&#x2F;post&#x2F;android&#x2F;android-activity&#x2F;&quot;,&quot;path&quot;:&quot;post&#x2F;android&#x2F;android-activity&#x2F;&quot;,&quot;title&quot;:&quot;Android-Activity深入理解&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android-Activity深入理解 | Luis's Blogs</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle Navigation" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Luis's Blogs</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">V 1.3.3</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">48</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">11</span></a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">91</span></a></li>
        
            
  <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-comments fa-fw"></i>About</a></li>


      
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>


</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Catalogue
        </li>
        <li class="sidebar-nav-overview">
          SiteInfo
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-Activity%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-text">Android-Activity深入理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Activity%E7%AE%80%E4%BB%8B"><span class="nav-text">1. Activity简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.1 Activity生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%90%AF%E5%8A%A8Activity"><span class="nav-text">1.2 启动Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%80%80%E5%87%BAActivity"><span class="nav-text">1.3 退出Activity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">2. Activity启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Standard"><span class="nav-text">2.1 Standard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-SingleTop"><span class="nav-text">2.2 SingleTop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-SingleTask"><span class="nav-text">2.3 SingleTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-SingleInstance"><span class="nav-text">2.4 SingleInstance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">3. Activity启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Application%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3.1 Application初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-AMS%E5%88%9D%E5%A7%8B%E5%8C%96Application"><span class="nav-text">3.1.1 AMS初始化Application</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%91%E5%AE%9AApplication"><span class="nav-text">3.1.2 创建和绑定Application</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BF%9B%E5%85%A5Activity%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-text">3.2 进入Activity启动事务流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96Activity%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.2.1 初始化Activity启动事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E6%8F%90%E4%BA%A4Activity%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.2.2 提交Activity启动事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E6%89%A7%E8%A1%8CActviity%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.2.3 执行Actviity启动事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Activity%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93"><span class="nav-text">3.3 Activity启动事务总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Activity-onCreate"><span class="nav-text">3.4 Activity-onCreate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-handleLaunchActivity-%E2%80%A6"><span class="nav-text">3.4.1 handleLaunchActivity(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-performLaunchActivity-%E2%80%A6"><span class="nav-text">3.4.2 performLaunchActivity(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-onCreate-%E6%80%BB%E7%BB%93"><span class="nav-text">3.4.3 onCreate()总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Activity-onStart"><span class="nav-text">3.5 Activity-onStart</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-handleStartActivity-%E2%80%A6"><span class="nav-text">3.5.1 handleStartActivity(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-performStart-%E2%80%A6"><span class="nav-text">3.5.2 performStart(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-onStart-%E6%80%BB%E7%BB%93"><span class="nav-text">3.5.3 onStart()总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Activity-onResume"><span class="nav-text">3.6 Activity-onResume</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-handleResumeActivity-%E2%80%A6"><span class="nav-text">3.6.1 handleResumeActivity(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-performResumeActivity-%E2%80%A6"><span class="nav-text">3.6.2 performResumeActivity(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-onResume-%E6%80%BB%E7%BB%93"><span class="nav-text">3.6.3 onResume()总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-text">4. Activity布局加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-setContentView%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">4.1 setContentView流程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-setContentView%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-text">4.2 setContentView流程总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Luis"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Luis</p>
  <div class="site-description" itemprop="description">Keep Learning</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">Posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">Categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">Tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liushulun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liushulun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:luis96@foxmail.com" title="E-Mail → mailto:luis96@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/about/" title="Chats → &#x2F;about&#x2F;"><i class="fa fa-comments fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/" title="Home → &#x2F;"><i class="fa fa-home fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-users fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://renxingkai.github.io/" title="https:&#x2F;&#x2F;renxingkai.github.io" rel="noopener" target="_blank">CinKate</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.juanertu.com/" title="https:&#x2F;&#x2F;blog.juanertu.com" rel="noopener" target="_blank">ConstOwn</a>
        </li>
    </ul>
  </div>


        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liushulun" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.luis.ltd/post/android/android-activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Luis">
      <meta itemprop="description" content="Keep Learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luis's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android-Activity深入理解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted:</span>

      <time title="Created::2020-11-01 21:42:31" itemprop="dateCreated datePublished" datetime="2020-11-01T21:42:31+08:00">2020-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">Categories:</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  






<!-- 注释开始 #############################################

  <script>
    function post_nav(post) {
      const theme = hexo.theme.config;
      if (theme.post_navigation === false || (!post.prev && !post.next)) return '';
      const prev = theme.post_navigation === 'right' ? post.prev : post.next;
      const next = theme.post_navigation === 'right' ? post.next : post.prev;
      const left = prev ? `
        <a href="${this.url_for(prev.path)}" rel="prev" title="${prev.title}">
          <i class="fa fa-chevron-left"></i> ${prev.title}
        </a>` : '';
      const right = next ? `
        <a href="${this.url_for(next.path)}" rel="next" title="${next.title}">
          ${next.title} <i class="fa fa-chevron-right"></i>
        </a>` : '';
      return `
        <div class="post-nav">
          <div class="post-nav-item">${left}</div>
          <div class="post-nav-item">${right}</div>
        </div>`;
    }
  </script>
  
  <div style="position: absolute; top: -20px;">post_nav(post)</div>

############################################# 注释结束 -->



<!-- 注释开始 #############################################
  
  <div style="position: fixed; width: 100%;">
    
      
      <div class="post-tags">
          <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
          <a href="/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" rel="tag"><i class="fa fa-tag"></i> 四大组件</a>
          <a href="/tags/Activty/" rel="tag"><i class="fa fa-tag"></i> Activty</a>
          <a href="/tags/taskAffinity/" rel="tag"><i class="fa fa-tag"></i> taskAffinity</a>
          <a href="/tags/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 启动模式</a>
          <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag"><i class="fa fa-tag"></i> 生命周期</a>
          <a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 启动流程</a>
      </div>
  </div>
############################################# 注释结束 -->

    <span class="post-meta-item" title="Post Symbols">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Post Symbols:</span>
      <span>52k</span>
    </span>
    <span class="post-meta-item" title="Read Time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Read Time &asymp;</span>
      <span>58 Min</span>
    </span>
</div>

            <div class="post-description">（1）Activity 简介（Activity 的生命周期、Activity 的启动与退出）；（2）Activity 的启动模式（Standard、SingleTop、SingleTask、SingleInstance）；（3）Activity 启动流程（Application 启动流程、onCreate、onStart、onResume）；（4）Activity 布局加载流程（setContentView）。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h1 id="Android-Activity深入理解"><a href="#Android-Activity深入理解" class="headerlink" title="Android-Activity深入理解"></a>Android-Activity深入理解</h1><h2 id="1-Activity简介"><a href="#1-Activity简介" class="headerlink" title="1. Activity简介"></a>1. Activity简介</h2><h3 id="1-1-Activity生命周期"><a href="#1-1-Activity生命周期" class="headerlink" title="1.1 Activity生命周期"></a>1.1 Activity生命周期</h3><p>Activity 即一个用户界面，可以理解成一个视图容器，容器内可以包裹和展示各类控件。全部 Activity 都需要在 Manifest 内声明。Activity 的生命周期为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onCreate()</span><br><span class="line">onStart()</span><br><span class="line">onResume()</span><br><span class="line">onPause()</span><br><span class="line">onStop()</span><br><span class="line">onDestroy() 或 onRestart() - onStart()</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<code>onStop()</code> 在 Activity 不可见时才调用，例如 AActivity 启动 BActivity，若 BActivity 是透明或弹窗形式（<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>），则 AActiivty 不会调用 <code>onStop()</code>。</p>
<p>Activity 的 <code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code> 并不是生命周期方法。当用户按 Home 键返回桌面、从多任务切换应用、锁屏、屏幕方向变化、启动新的 Activity时，或者当应用遇到意外情况（如内存不足）且 Activity 由系统销毁时，则 <code>onSaveInstanceState()</code> 会被调用。但是当用户主动销毁一个 Activity（例如在应用中按返回键）时，<code>onSaveInstanceState()</code> 就不会被调用。通常 <code>onSaveInstanceState()</code> 只适合用于保存一些临时性的状态，而 <code>onPause()</code> 适合用于数据的持久化保存。</p>
<p>如果一个 Activity 被打开过，然后被置入任务栈顶端（例如切换到另一个 Activity 且没有再次切换新 Activity），且此时处于 <code>onPause()</code>、<code>onStop</code> 状态，则当有一个 Intent 启动该 Activity，会先调用 <code>onNewIntent()</code>，然后才调用 <code>onRestart()</code> - <code>onStart()</code> - <code>onResume()</code>。</p>
<h3 id="1-2-启动Activity"><a href="#1-2-启动Activity" class="headerlink" title="1.2 启动Activity"></a>1.2 启动Activity</h3><p>假设有一个 DemoActivity 注册信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;demo.DemoActivity&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:excludeFromRecents=&quot;false&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;demo.customActionName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（1）显式启动 Actiivty：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, DemoActivity.class);</span><br><span class="line"><span class="comment">// 直接插入数据</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, value)</span><br><span class="line"><span class="comment">// 通过 Bundle</span></span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putXXX(String key, XXX value);</span><br><span class="line">intent.putExtra(bundle);</span><br><span class="line"></span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>（2）隐式启动 Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">&quot;demo.customActionName&quot;</span>);</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（@注）默认情况下，隐式启动 Activity 时搜索 ActionName 的范围是当前 App 内，如果需要被其他 App 启动，则需要添加 <code>exported = true</code> 属性，该属性默认为 false。</p>
<p>（@注）如果添加了 <code>excludeFromRecents = true</code> 属性，则该 Activity 一旦进入后台，就会从「最近任务」中删除其记录，不论该 Activity 是否是最后一个或唯一一个活跃的 Activity。</p>
</blockquote>
<p>（3）<code>startActivity()</code> 是 Context 中的方法，因此 Activity 或 Application 都可以调用。但如果使用 <code>Application.startActivity()</code> 则需要给 Intent 添加一个 Flag <code>FLAG_ACTIVITY_NEW_TASK</code>，否则会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（@注）Activity、Application 都是 Context 抽象类的子类，而 ContextImpl 是 Context 的实现。ActivityThread 在 <code>main()</code> 方法中实例化一个 ComtextImpl 并与 Activity 绑定。</p>
</blockquote>
<h3 id="1-3-退出Activity"><a href="#1-3-退出Activity" class="headerlink" title="1.3 退出Activity"></a>1.3 退出Activity</h3><p>Activity 可以通过调用 <code>finish()</code> 退出。当 App 正在退出时，<code>isFinishing() == true</code>，可用于在 <code>onPause()</code> 或 <code>onStop()</code> 中判断该 Activity 是正在退出或只是进入后台。</p>
<p>同时退出多个 Activity 的方法：</p>
<ul>
<li>在所有被开启的 Activity 中注册特定的广播监听，收到该广播时退出自己，并在需要统一退出时发送广播。</li>
<li>启动新的 Activity 时，使用 <code>startActivityForResult()</code> 替代 <code>startActivity()</code>，并在 <code>onActivityResult()</code> 中将自己 <code>finish()</code>。</li>
<li>用 List 等记录每个启动的 Activity，并在需要时分别关闭。需要注意的是，使用 List 存放 Activity 有内存泄露的风险，当 Activity 关闭后，要及时清掉对应 List 中的引用。</li>
<li>启动一个 <code>singleTask</code> 模式的 Activity，或是给 Intent 添加 Flag：<code>FLAG_ACTIVITY_CLEAR_TOP</code>，则系统会在新 Activity 启动后将其上的所有 Activity 销毁。</li>
</ul>
<hr>
<h2 id="2-Activity启动模式"><a href="#2-Activity启动模式" class="headerlink" title="2. Activity启动模式"></a>2. Activity启动模式</h2><p>Activity 有 4 种启动模式：</p>
<ul>
<li><code>standard</code></li>
<li><code>singleTop</code></li>
<li><code>singleTask</code></li>
<li><code>singleInstance</code></li>
</ul>
<p>需要先了解到，Android 中 Activity 是存在任务栈 Task 中的，启动一个 Activity 时会将其压栈，销毁时弹出，不同启动模式会导致 Activity 任务栈产生不同的行为，且一个 App 进程可以拥有多个 Activity 任务栈。</p>
<p>Activity 可以通过在 Manifest 中指定 <code>taskAffinity</code> 来指定其 <strong>倾向</strong> 加入的任务栈，但只有在满足条件时才会添加到该指定任务栈中。</p>
<blockquote>
<p>（@注）<code>taskAffinity</code> 属性代表了一种「倾向」，表示一个 Activity <strong>「倾向于」</strong> 放在哪个栈中。Activity 启动时会先查找是否存在指定的栈，假如存在则会 <strong>「优先尝试」</strong> 压入对应栈，否则才会新建一个栈并启动。如果 Activity 没有指定，则默认等同于 Application 的 taskAffinity，如果 Application 也没有指定，则默认等同于包名。</p>
<p>但 taskAffinity 并非 100% 生效。singleInstance 模式启动 Activity 时，其栈内仅允许存在该 Activity；即使其他 Activity 指定同一个 taskAffinity，依然会启动到新的栈中，但这两个栈的 taskAffinity 名称相同；所以判断栈是否相同仍然只能通过 TaskID，而不是 taskAffinity。</p>
</blockquote>
<h3 id="2-1-Standard"><a href="#2-1-Standard" class="headerlink" title="2.1 Standard"></a>2.1 Standard</h3><p>（1）Standard 即标准默认模式。启动一个 Activity 时，不论 Activity 在任务栈中是否已经有实例，都新建一个实例并压入任务栈。当前 Activity 在当前任务栈可以有多个实例，每个实例也可以在不同任务栈。</p>
<p>Standard 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>
<table>
<thead>
<tr>
<th align="left">当前任务栈</th>
<th align="left">如果返回</th>
<th align="center">执行任务</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/A&gt;</td>
<td align="left">退出</td>
<td align="center">Standard Start B</td>
</tr>
<tr>
<td align="left">/AB&gt;</td>
<td align="left">/A&gt;</td>
<td align="center">Standard Start B</td>
</tr>
<tr>
<td align="left">/ABB&gt;</td>
<td align="left">/AB&gt;</td>
<td align="center">Standard Start A</td>
</tr>
<tr>
<td align="left">/ABBA&gt;</td>
<td align="left">/ABB&gt;</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>（2）Standard 模式通常用于允许一个页面同时创建多个，或者从逻辑上可以保证不会触发多个的情况下。</p>
<h3 id="2-2-SingleTop"><a href="#2-2-SingleTop" class="headerlink" title="2.2 SingleTop"></a>2.2 SingleTop</h3><p>（1）SingleTop 即栈顶唯一模式，启动一个 Activity 时，如果该 Activity 已在栈顶则不会新建一个 Activity 实例而是复用它，否则其行为和 Standard 模式一致。</p>
<p>SingleTop 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">当前任务栈</th>
<th align="left">如果返回</th>
<th align="center">执行任务</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">/A&gt;</td>
<td align="left">退出</td>
<td align="center">SingleTop Start B</td>
</tr>
<tr>
<td>2</td>
<td align="left">/AB&gt;</td>
<td align="left">/A&gt;</td>
<td align="center">SingleTop Start B</td>
</tr>
<tr>
<td>3</td>
<td align="left">/AB&gt;</td>
<td align="left">/A&gt;</td>
<td align="center">SingleTop Start A</td>
</tr>
<tr>
<td>4</td>
<td align="left">/ABA&gt;</td>
<td align="left">/AB&gt;</td>
<td align="center">SingleTop Start B</td>
</tr>
<tr>
<td>5</td>
<td align="left">/ABAB&gt;</td>
<td align="left">/ABA&gt;</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>（2）SingleTop 模式通常用于可能多次弹出的页面。实际上，我认为除非某个 Activity 有明确的需求要打开多个实例，否则都应该使用 SingleTop。因为大多数页面跳转都有可能被误触发多次，但绝大多数情况下都是不希望同时存在多个实例的。</p>
<h3 id="2-3-SingleTask"><a href="#2-3-SingleTask" class="headerlink" title="2.3 SingleTask"></a>2.3 SingleTask</h3><p>（1）SingleTask 即任务栈唯一模式，启动一个 Activity 时，如果任务栈中存在该 Activity 实例，则复用它，否则才创建一个新的 Activity 实例。SingleTask 和 SingleTop 的区别在于，SingleTop 只在栈顶 Activity 和要启动的 Activity 相同时才复用，而 SingleTask 是每个 Activity 在当前整个任务栈中都只有一个实例。</p>
<p>SingleTask 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>）：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">当前任务栈</th>
<th align="left">如果返回</th>
<th align="center">执行任务</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">/A&gt;</td>
<td align="left">退出</td>
<td align="center">SingleTask Start B</td>
</tr>
<tr>
<td>2</td>
<td align="left">/AB&gt;</td>
<td align="left">/A&gt;</td>
<td align="center">SingleTask Start B</td>
</tr>
<tr>
<td>3</td>
<td align="left">/AB&gt;</td>
<td align="left">/A&gt;</td>
<td align="center">SingleTask Start A</td>
</tr>
<tr>
<td>4</td>
<td align="left">/BA&gt;</td>
<td align="left">/B&gt;</td>
<td align="center">Standard Start B</td>
</tr>
<tr>
<td>5</td>
<td align="left">/BAB&gt;</td>
<td align="left">/BA&gt;</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>（2）SingleTask 模式常用在 App 的 MainActivity 中，因为大多数情况下 App 在主页面上返回时都应该返回到桌面或退出，而不是返回到其他页面中。</p>
<h3 id="2-4-SingleInstance"><a href="#2-4-SingleInstance" class="headerlink" title="2.4 SingleInstance"></a>2.4 SingleInstance</h3><p>（1）SingleInstance 即唯一实例模式，启动一个 Activity 时，寻找所有的任务栈，如果某个任务栈中存在该 Activity 实例，则切换到该任务栈，否则新建一个任务栈并创建该 Activity 实例。</p>
<p>假如有三个 Activity 按照以下关系启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(Standard) -&gt; B(SingleInstance) -&gt; C(Standard)</span><br></pre></td></tr></table></figure>

<ul>
<li>因为 B 是 SingleInstance，所以会创建一个新的栈，并在新的栈中启动 B。</li>
<li>而 B 启动 C 时，同样由于 B 设置了 SingleInstance 属性，因此会先判断 C 的启动模式，以及 Manifest 中 C 对应的 <code>taskAffinity</code>，如果没有指定，则会把 C 启动在默认栈中，也就是和 A 同一个栈。</li>
<li>因此如果在 C 中按下返回键，由于 A 和 C 在同一个栈，所以会回到 A，而不是 B。</li>
</ul>
<p>重点在于：任务栈不是唯一的，一个 App 可以有多个任务栈，就像 Android 系统的后台应用列表一样，里面包括了多个应用，而每个应用又管理自己的多个任务栈（可以理解为 <strong>任务栈的总栈</strong>），每个任务栈又分别管理包含的 Activity。</p>
<p>SingleInstance 启动方式任务栈的行为实例如下（其中 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>，任务栈之间用 <code>-</code> 连接，右侧的任务栈为最新任务栈，M 为最开始以 Standard 启动的 Activity）：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">当前任务栈</th>
<th align="left">如果返回</th>
<th align="center">执行任务</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">/M&gt;</td>
<td align="left">退出</td>
<td align="center">SingleInstance Start A</td>
</tr>
<tr>
<td>2</td>
<td align="left">/M&gt; - /A&gt;</td>
<td align="left">/M&gt;</td>
<td align="center">SingleInstance Start B</td>
</tr>
<tr>
<td>3</td>
<td align="left">/M&gt; - /A&gt; - /B&gt;</td>
<td align="left">/M&gt; - /A&gt;</td>
<td align="center">SingleInstance Start A</td>
</tr>
<tr>
<td>4</td>
<td align="left">/M&gt; - /B&gt; - /A&gt;</td>
<td align="left">/M&gt; - /B&gt;</td>
<td align="center">Standard Start C</td>
</tr>
<tr>
<td>5</td>
<td align="left">/B&gt; - /A&gt; - /MC&gt;</td>
<td align="left">/B&gt; - /A&gt; - /M&gt;</td>
<td align="center">返回</td>
</tr>
<tr>
<td>6</td>
<td align="left">/B&gt; - /A&gt; - /M&gt;</td>
<td align="left">/B&gt; - /A&gt;</td>
<td align="center">返回</td>
</tr>
<tr>
<td>7</td>
<td align="left">/B&gt; - /A&gt;</td>
<td align="left">/B&gt;</td>
<td align="center">返回</td>
</tr>
<tr>
<td>8</td>
<td align="left">/B&gt;</td>
<td align="left">退出</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>前 3 步都比较好理解，反正就是整个 App 所有任务栈都只允许有一个实例。重点在从第 4 步开始，由于最开始的 M 是 Standard 模式启动的，而第 4 步中 C 也是 Standard 模式，也就导致本来在最底下的任务栈 <code>/M&gt;</code> 被移到了 “任务栈的总栈” 的栈顶，并将 C 压入了 <code>/M&gt;</code> 所在的这个栈顶，因此从 C 返回的时候会先返回到 M，然后才是按顺序下来的 A → B。</p>
<p>（2）SingleInstance 通常用于某些可被共享唤起的 App，但这些 App 仅有部分页面需要被共享唤起。</p>
<p>例如：</p>
<ul>
<li>电话：其包括了拨号页和来电提醒页，而来电提醒页（通话页）则需要设置为 SingleInstance。</li>
<li>闹铃：其包括了设置闹钟的页面和响铃提醒的页面，而响铃提醒页面则需要设置为 SingleInstance。</li>
</ul>
<p>以电话的来电提醒页为例：</p>
<ul>
<li>首先 standard 和 singleTop 是一定不能满足的，否则如果通话期间切到其他 App 后再切回来，就会再次创建一个新的「通话页」。</li>
<li>而 singleTask 同样存在问题：假如用户通过「拨号页」拨打电话，进入「通话页」后，由于设置了 singleTask，「拨号页」就会被销毁，通话结束后用户就无法再次返回到「拨号页」了。收到来电提醒也是类似的场景。</li>
<li>如果电话 App 的「拨号页」是启动的但被置到后台，假如用户正在某个 App「Demo」中，此时收到来电进入「通话页」，电话结束后用户当然是期望能返回到原先的「Demo」页面，因此「通话页」必须处于独立的栈中，否则「通话页」结束后返回时，就会回到「拨号页」了。</li>
</ul>
<hr>
<h2 id="3-Activity启动流程"><a href="#3-Activity启动流程" class="headerlink" title="3. Activity启动流程"></a>3. Activity启动流程</h2><p>Java 程序的入口是 <code>main()</code> 方法，Android 基于 Java 开发（Kotlin 也是基于 JVM 的），自然也遵循这个原则。而一个 App（实际上是每个进程）就可以看作一个完整的程序，其入口就在 <code>ActivityThread.main(String[] args)</code> 中。</p>
<p>操作系统启动后，第一个启动的就是 <code>init</code> 进程，<code>init</code> 进程会启动 <code>Zygote</code>、<code>ServiceManager</code> 等基本进程。随后 Zygot 创建并初始化 system_service，system_service 会分裂出 AMS 等各项系统服务。当启动一个 App 时，实际流程是：</p>
<ul>
<li>Launcher 通过 IPC 通知 AMS。</li>
<li>AMS 通知 system_service。</li>
<li>system_service 通知 Zygote。</li>
<li>Zygote 收到通知后 Fork 出子进程。</li>
<li>子进程在 <code>Process#start()</code> 中通过反射调用 <code>ActivityThread.main()</code>。</li>
</ul>
<p>Android 提供了一系列封装和抽象使得 App 无需关注统一的流程。ActivityThread 在 <code>main()</code> 方法中做了一些初始化，包括初始化操作系统、用户环境、进程信息等，以及最重要的启动主线程 Looper。由于每个 App 的启动都复用了 ActivityThread 的逻辑，因此需要一个包装件用于记录当前需要处理的信息，这个包装件就是 ActivityThread 中的内部类 <code>ActivityClientRecord</code>。源码注释也解释的比较清楚了，ActivityClientRecord 其实是一个容器，它持有了一个 Activity，以及管理这个 Activity 相关的其他资源。ActivityClientRecord 和其持有的 Activity 是一一对应的，系统在调度和管理 Activity 时，大多都是通过 ActivityClientRecord 操作 Activity。</p>
<blockquote>
<p>（@注）可以形象的理解为：Activity 就像一个主机，Window 就像显示器，同时还有鼠标、键盘、电源等等，所有这些东西加起来，就能作为完整的计算机使用。然后用一个箱子把所有这些都装起来，这个箱子就是 ActivityClientRecord。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Activity client record, used for bookkeeping for the real &#123;<span class="doctag">@link</span> Activity&#125; instance. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityClientRecord</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        Activity activity;</span><br><span class="line">        Window window;</span><br><span class="line">        Activity parent;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ......</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Application初始化"><a href="#3-1-Application初始化" class="headerlink" title="3.1 Application初始化"></a>3.1 Application初始化</h3><p>启动一个 Activity 的入口，在 API 29 开始与之前版本有不同。在 API 29 之前的版本，ActivityThread 内部持有的一个 Handler 对象 <code>H</code> 监听了 <code>LAUNCH_ACTIVITY</code> 事件，并在收到 <code>LAUNCH_ACTIVITY</code> 请求后会调用 <code>handleLaunchActivity(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// API 29 移除了 LAUNCH_ACTIVITY 这个条件分支，</span></span><br><span class="line">            <span class="comment">// 而是放在 BIND_APPLICATION 中处理。</span></span><br><span class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在 API 29 以上版本已经移除了这个分支，下文将基于 API 29 分析。</p>
<h4 id="3-1-1-AMS初始化Application"><a href="#3-1-1-AMS初始化Application" class="headerlink" title="3.1.1 AMS初始化Application"></a>3.1.1 AMS初始化Application</h4><p>首先在入口方法 <code>ActivityThread#main()</code> 中，有一个关键步骤 <code>thread.attach(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            <span class="comment">// 非系统 Activity</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这里的 mgr 就是 AMS 实例</span></span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 传入的 mAppThread 是内部 AIDL 类 ApplicationThread 对象</span></span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 系统 Activity</span></span><br><span class="line">            <span class="comment">// Don&#x27;t set application object here -- if the system crashes,</span></span><br><span class="line">            <span class="comment">// we can&#x27;t display an alert, we just want to die die die.</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IActivityManager</code> 是一个 AIDL 的远程接口，只有一个实现类 <code>ActivityManagerService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">IActivityManager</span>.<span class="title">Stub</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="comment">// 传入的 thread 是 ActivityThread 的内部 AIDL 类 ApplicationThread 对象</span></span><br><span class="line">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入的 thread 是 ActivityThread 的内部 AIDL 类 ApplicationThread 对象</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这一步是将 ApplicationThread 和 AMS 绑定</span></span><br><span class="line">            <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This is an isolated process which should just call an entry point instead of being bound to an application.</span></span><br><span class="line">                thread.runIsolatedEntryPoint(...);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                thread.bindApplication(...);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                thread.bindApplication(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这一步才是尝试去启动 Activity</span></span><br><span class="line">        <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">        <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// mAtmInternal 是抽象类 ActivityTaskManagerInternal 的实例，</span></span><br><span class="line">                <span class="comment">// 该抽象类只有一个实现类：ActivityTaskManagerService#LocalService</span></span><br><span class="line">                didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">                badApp = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 AMS 调用 <code>attachApplication(...)</code> 后主要分为两个步骤：</p>
<ul>
<li>调用 <code>ActivityThread#ApplicationThread#bindApplication(...)</code></li>
<li>调用 <code>ActivityTaskManagerService#LocalService#attachApplication(...)</code></li>
</ul>
<h4 id="3-1-2-创建和绑定Application"><a href="#3-1-2-创建和绑定Application" class="headerlink" title="3.1.2 创建和绑定Application"></a>3.1.2 创建和绑定Application</h4><p><code>AMS#attachApplication(...)</code> 内部第 1 步执行 <code>ApplicationThread.bindApplication(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">IApplicationThread</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这个 Data 就用于为后续绑定 Application 对象提供信息，</span></span><br><span class="line">            <span class="comment">// 例如 Process, Instrumentation, AppInfo 等。</span></span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这里向 ActivityThread 的 Handler 发送了一条 BIND_APPLICATION 请求</span></span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 ApplicationThread 创建了一个 AppBindData 对象，内部记录了一个 Application 所需的信息，然后向 ActivityThread 的 Handler 发送 <code>BIND_APPLICATION</code> 消息，表示当前 App 绑定了 AMS 分配的 Application：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION: &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// AppBindData 内记录了一个 Application 所需的信息</span></span><br><span class="line">                AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                handleBindApplication(data);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 回调 Application#onCreate()</span></span><br><span class="line">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-进入Activity启动事务流程"><a href="#3-2-进入Activity启动事务流程" class="headerlink" title="3.2 进入Activity启动事务流程"></a>3.2 进入Activity启动事务流程</h3><p><code>AMS#attachApplication(...)</code> 内部第 2 步执行 <code>mAtmInternal.attachApplication(...)</code>，是启动 Activity 的起点。</p>
<p><code>mAtmInternal</code> 是抽象类 ActivityTaskManagerInternal 的实例，该抽象类只有一个实现类：<code>ActivityTaskManagerService#LocalService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityTaskManagerService</span> <span class="keyword">extends</span> <span class="title">IActivityTaskManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">ActivityTaskManagerInternal</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">                <span class="keyword">return</span> mRootActivityContainer.attachApplication(wpc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootActivityContainer</span> <span class="keyword">extends</span> <span class="title">ConfigurationContainer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">DisplayManager</span>.<span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ActivityStackSupervisor mStackSupervisor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 核心部分，准备启动 Activity 的第一步：</span></span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(activity, app,</span><br><span class="line">                top == activity <span class="comment">/* andResume */</span>, <span class="keyword">true</span> <span class="comment">/* checkConfig */</span>)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-初始化Activity启动事务"><a href="#3-2-1-初始化Activity启动事务" class="headerlink" title="3.2.1 初始化Activity启动事务"></a>3.2.1 初始化Activity启动事务</h4><p>到 ActivityStackSupervisor 这一步，就离开了 Application 初始化的周期，进入 Activity 启动流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">RecentTasks</span>.<span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">        <span class="comment">// 传入的 proc.getThread 就是 IApplicationThread</span></span><br><span class="line">        <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                proc.getThread(), r.appToken);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 注意这里入参是 LaunchActivityItem 对象</span></span><br><span class="line">        clientTransaction.addCallback(LaunchActivityItem.obtain(...));</span><br><span class="line">        <span class="comment">// Set desired final state.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">        <span class="comment">// 如果是新启动 Activity，则 andResume == true</span></span><br><span class="line">        <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">            lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Schedule transaction.</span></span><br><span class="line">        <span class="comment">// 获取到的就是 ClientLifecycleManager 对象</span></span><br><span class="line">        mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientLifecycleManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">        transaction.schedule();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityStackSupervisor 生成了一个 ClientTransaction 对象，用于记录客户端要处理的事务（也就是 Activity 启动）：</p>
<ul>
<li>给 ClientTransaction 添加 Callback，传入 LaunchActivityItem 类型的对象。</li>
<li>给 ClientTransaction 设置生命周期状态流转请求，传入 ResumeActivityItem 类型的对象。</li>
</ul>
<h4 id="3-2-2-提交Activity启动事务"><a href="#3-2-2-提交Activity启动事务" class="headerlink" title="3.2.2 提交Activity启动事务"></a>3.2.2 提交Activity启动事务</h4><p>ActivityStackSupervisor 通过 <code>ClientLifecycleManager#scheduleTransaction(ClientTransaction)</code> 提交 ClientTransaction 的事务，其内部调用了 <code>ClientTransaction#schedule()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTransaction</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>, <span class="title">ObjectPoolItem</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Obtain an instance initialized with provided params. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientTransaction <span class="title">obtain</span><span class="params">(IApplicationThread client, IBinder activityToken)</span> </span>&#123;</span><br><span class="line">        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ClientTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入参的 client 就是 ApplicationThread，存到成员变量 mClient 中</span></span><br><span class="line">        instance.mClient = client;</span><br><span class="line">        instance.mActivityToken = activityToken;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// mClient 就是上面 ActivityStackSupervisor#realStartActivityLocked(...) 中</span></span><br><span class="line">        <span class="comment">// ClientTransaction.obtain(...) 第一个参数传入的 ApplicationThread，</span></span><br><span class="line">        <span class="comment">// 最终又回到了 ActivityThread 中：</span></span><br><span class="line">        mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mClient</code> 就是创建 ClientTransaction 时传入的 ApplicationThread，因此提交的事务又回到了 ActivityThread 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">IApplicationThread</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="comment">// 实际是调用父类 ClientTransactionHandler 中的方法</span></span><br><span class="line">            ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，ClientTransaction, ClientLifecycleManager, ActivityThread 都并不直接执行事务：</p>
<ul>
<li>ClientTransaction 只用于记录事务。</li>
<li>ClientLifecycleManager 调用 <code>scheduleTransaction(...)</code> 只是提交事务。</li>
<li>ActivityThread 调用父类方法 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 也只是提交事务。</li>
</ul>
<p>真正用于执行事务的是 ActivityThread 的成员变量：<code>TransactionExecutor mTransactionExecutor</code>。</p>
<h4 id="3-2-3-执行Actviity启动事务"><a href="#3-2-3-执行Actviity启动事务" class="headerlink" title="3.2.3 执行Actviity启动事务"></a>3.2.3 执行Actviity启动事务</h4><p>上文中 ClientTransactionHandler 发送了 <code>EXECUTE_TRANSACTION</code> 消息，ActivityThread 内部 Handler 收到消息后调用 <code>TransactionExecutor#execute(ClientTransaction)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// An executor that performs multi-step transactions.</span></span><br><span class="line">    <span class="comment">// 入参传入了自己，TransactionExecutor 才是真正的事务「执行器」</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionExecutor mTransactionExecutor = <span class="keyword">new</span> TransactionExecutor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> EXECUTE_TRANSACTION: &#123;</span><br><span class="line">                <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                mTransactionExecutor.execute(transaction);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClientTransactionHandler mTransactionHandler;</span><br><span class="line">    <span class="comment">/** Initialize an instance with transaction handler, that will execute all requested actions. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionExecutor</span><span class="params">(ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意 ActivityThread 在成员变量初始化时把自己传进来，</span></span><br><span class="line">        <span class="comment">// 所以 mTransactionHandler 就是 ActivityThread 本身。</span></span><br><span class="line">        mTransactionHandler = clientTransactionHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于执行 onCreate()</span></span><br><span class="line">        executeCallbacks(transaction);</span><br><span class="line">        <span class="comment">// 用于执行 onStart(), onResume()</span></span><br><span class="line">        executeLifecycleState(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cycle through all states requested by callbacks and execute them at proper times. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的 Callback 实际上是 LaunchActivityItem 类型，</span></span><br><span class="line">        <span class="comment">// LaunchActivityItem 继承自 ClientTransactionItem。</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (...) &#123;</span><br><span class="line">            <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">            <span class="comment">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class="line">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Transition to the final state if requested by the transaction. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityThread 在成员变量持有 <code>TransactionExecutor</code> 对象，并在其初始化构造方法时传入了 ActivityThread 自己，所以 <code>TransactionExecutor#mTransactionHandler</code> 就是 ActivityThread 本身。<code>TransactionExecutor#execute(ClientTransaction)</code> 分为两个步骤：</p>
<ul>
<li><code>executedCallbacks(ClientTransaction)</code> 用于使 Activity 进入 onCreate 状态。</li>
<li><code>executeLifecycleState(ClientTransaction)</code> 用于使 Activity 生命周期流转到 onResume 状态。</li>
</ul>
<h3 id="3-3-Activity启动事务总结"><a href="#3-3-Activity启动事务总结" class="headerlink" title="3.3 Activity启动事务总结"></a>3.3 Activity启动事务总结</h3><p>Activity 的启动事务可以分成两大块：Application 的初始化、Activity 启动事务的初始化。</p>
<p>（1）Application 初始化：</p>
<ul>
<li>AMS 调用 ActivityThread 的 <code>main()</code> 方法启动。</li>
<li><code>main()</code> 方法中创建一个 ActivityThread 对象，并调用 <code>ActivityThread#attach(...)</code>，内部获取 AMS 并与自己的内部类对象 ApplicationThread 绑定。</li>
<li>绑定成功后，AMS 向 ActivityThread 发送 <code>BIND_APPLICATION</code> 消息，ActivityThread 回调 Application 的 onCreate 生命周期。</li>
<li>ActivityThread 调用 <code>ActivityTaskManagerService#attachApplication(...)</code>，尝试启动 Activity。</li>
<li>ActivityTaskManagerService 调用 <code>RootActivityContainer#attachApplication(...)</code>。</li>
</ul>
<p>（2）Activity 启动事务初始化：</p>
<ul>
<li>RootActivityContainer 调用 <code>ActivityStackSupervisor#realStartActivityLocked(...)</code>。</li>
<li>ActivityStackSupervisor 创建 ClientTransaction 实例，传入 ApplicationThread，并调用 <code>ClientTransaction#addCallback(LaunchActivityItem)</code> 和 <code>ClientTransaction#setLifecycleStateRequest(ResumeActivityItem)</code></li>
<li>ActivityStackSupervisor 调用 <code>ClientLifecycleManager#scheduleTransaction(...)</code>，并传入之前创建的 ClientTransaction 对象。</li>
<li>ClientLifecycleManager 调用 <code>ClientTransaction#schedule()</code>。</li>
<li>ClientTransaction 调用 <code>ApplicationThread#scheduleTransaction(...)</code>。</li>
<li>ActivityThread 调用父类的 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 发送一条 <code>EXECUTE_TRANSACTION</code> 消息。</li>
<li>ActivityThread 收到消息后调用 <code>TransactionExecutor#execute(ClientTransaction)</code>。</li>
<li>TransactionExecutor 分别调用 <code>executeCallbacks(ClientTransaction)</code>（对应 onCreate）和 <code>executeLifecycleState(ClientTransaction)</code>（对应 onStart 和 onResume）。</li>
</ul>
<p>从 TransactionExecuotr 正式调用 <code>execute(...)</code> 执行事务开始，Activity 才正式进入生命周期流转阶段。</p>
<h3 id="3-4-Activity-onCreate"><a href="#3-4-Activity-onCreate" class="headerlink" title="3.4 Activity-onCreate"></a>3.4 Activity-onCreate</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，先执行 <code>executedCallbacks(ClientTransaction)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Cycle through all states requested by callbacks and execute them at proper times. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的 Callback 实际上是 LaunchActivityItem 类型，</span></span><br><span class="line">        <span class="comment">// LaunchActivityItem 继承自 ClientTransactionItem。</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (...) &#123;</span><br><span class="line">            <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">            <span class="comment">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class="line">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，该方法内通过 <code>transaction.getCallbacks()</code> 拿到的是 ClientTransactionItem 类型，但回顾上文生成 <code>ClientTransaction</code> 对象的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">RecentTasks</span>.<span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">                <span class="comment">// 传入的 proc.getThread 就是 IApplicationThread</span></span><br><span class="line">                <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                        proc.getThread(), r.appToken);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 注意这里入参是 LaunchActivityItem 对象</span></span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(...));</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以实际上 <code>transaction</code> 持有的 callbacks 是 <code>LaunchActivityItem</code> 类型的。查看 <code>LaunchActivityItem#execute(...)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchActivityItem</span> <span class="keyword">extends</span> <span class="title">ClientTransactionItem</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">        ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(...);</span><br><span class="line">        <span class="comment">// 重点就是这个 handleLaunchActivity：</span></span><br><span class="line">        client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 TransactionExecutor 传入的 <code>ClientTransactionHandler client</code> 就是 ActivityThread，所以 <code>client.handleLaunchActivity(...)</code> 就是 <code>ActivityThread#handleLaunchActivity(...)</code>，此时才与 API 29 以下版本的逻辑重合。</p>
<h4 id="3-4-1-handleLaunchActivity-…"><a href="#3-4-1-handleLaunchActivity-…" class="headerlink" title="3.4.1 handleLaunchActivity(…)"></a>3.4.1 handleLaunchActivity(…)</h4><p><code>LaunchActivityItem#execute(...)</code> 创建了一个 ActivityClientRecord 对象用于持有目标 Activity 以及一些相关资源，再通过 <code>ActivityThread.handleLaunchActivity(...)</code> 创建并启动目标 Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extended implementation of activity launch. Used when server requests a launch or relaunch.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 最关键的步骤就是 performLaunchActivity</span></span><br><span class="line">        <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityTaskManager.getService().finishActivity(...);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>handleLaunchActivity(...)</code> 主要是调用 <code>performLaunchActivity(...)</code> 生成一个 Activity 实例对象，并在生成失败时直接通知 ActivityTaskManagerService 结束该 Activity，或是抛出一个异常，中断后续流程。</p>
<h4 id="3-4-2-performLaunchActivity-…"><a href="#3-4-2-performLaunchActivity-…" class="headerlink" title="3.4.2 performLaunchActivity(…)"></a>3.4.2 performLaunchActivity(…)</h4><p><code>performLaunchActivity(...)</code> 是实际创建 Activity 的方法，过程中调用了一个重要方法 <code>Activity.attach()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        Window window = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">            <span class="comment">// 从 ActivityClientRecord 中取出了一个 Window</span></span><br><span class="line">            window = r.mPendingRemoveWindow;</span><br><span class="line">            r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">            r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个方法是重点，并且注意参数中传入了上面从 ActivityClientRecord 中取出的 Window</span></span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                r.assistToken);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知 Instrumentation 回调 Activity 的 onCreate()</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window = r.mPendingRemoveWindow</code> 是从 ActivityClientRecord 中取出 Window 对象，那 ActivityClientRecord 中的 Window 又是哪来的呢？查找一下 ActivityClientWindow 中 <code>mPendingRemoveWindow</code> 写入的地方，发现在 <code>handleDestroyActivity(...)</code> 中有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">                configChanges, getNonConfigInstance, reason);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            View v = r.activity.mDecor;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                        <span class="comment">// Hold off on removing this until the new activity&#x27;s</span></span><br><span class="line">                        <span class="comment">// window is being added.</span></span><br><span class="line">                        <span class="comment">// 核心就是这里：</span></span><br><span class="line">                        r.mPendingRemoveWindow = r.window;</span><br><span class="line">                        r.mPendingRemoveWindowManager = wm;</span><br><span class="line">                        <span class="comment">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class="line">                        <span class="comment">// everything else must be removed, because it might not be able to</span></span><br><span class="line">                        <span class="comment">// behave properly when activity is relaunching.</span></span><br><span class="line">                        r.window.clearContentView();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        wm.removeViewImmediate(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码注释就能明白，当一个 Activity 销毁时，会在其 ActivityVlientRecord 中把自己的 Window 保存到 mPendingRemoveWindow 中，然后移除 Window 中所有 View，直到新的 Activity 的 Window 被添加为止，但是在通过 <code>startActivityNow(...)</code> 启动 Activity 时，ActivityClientRecord 都是 <code>new</code> 出来的，调用到 <code>performLaunchActivity(...)</code> 时，<code>r.mPendingRemoveWindow</code> 肯定是 <code>null</code>，那什么场景会用到这个 <code>mPendingRemoveWindow</code> 呢？查找 <code>performLaunchActivity(...)</code> 的调用发现：</p>
<ul>
<li>在 <code>handleRelaunchActivityInner(...)</code> 中，先调用了 <code>handleDestroyActivity(...)</code>，这一步就把当前 Activity 的 Window 存进了 <code>mPendingRemoveWindow</code></li>
<li>接下来调用了 <code>handleLaunchActivity(...)</code></li>
<li>然后在其内部调用了 <code>performLaunchActivity(...)</code></li>
</ul>
<p>这下明白了，当一个 Activity 被系统回收等等场景销毁时，有可能接下来又会回到这个 Activity，这种情况下就可以先把 Window 缓存下来，当自己这个 Activity 再次被激活时，就可以直接复用 Activity 上一次的 Window 而不需要从新分配。当然，由于 <code>r.window.clearContentView();</code>，Window 中的 View 被清空了，所以还是需要重新走一遍视图加载。这样做的好处也许是在效率和内存消耗中的一种折中，或许是因为 View 会占用很大内存，所以需要回收 View，但 Window 本身占用较少，每次都回收再让系统重新分配可能比缓存占用的内存更多、或者可能带来更大的内存抖动风险，所以选择临时缓存。</p>
<p>从上面的分析知道，而当一个 Activity 被新启动时，<code>performLaunchActivity(...)</code> 传入的 <code>ActivityClientRecord.mPendingRemoveWindow</code> 肯定是 <code>null</code>。继续查看 <code>Activity.attach(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 当新启动一个 Activity 时，调用这个 attach 方法的入参中，window 是 null，</span></span><br><span class="line"><span class="comment">      * 因为是 startActivityNow(...) 中 new 出来的 ActivityClientRecord。</span></span><br><span class="line"><span class="comment">      * 如果是 performRelaunchActivity 则会把这个 Activity 上一次销毁前的 Window 缓存下来并在这个方法中传入。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建一个 Window 实例，这里 mWindow 是 Window 类型的接口对象，该接口只有 PhoneWindow 唯一一个实例对象</span></span><br><span class="line">        <span class="comment">// 并且当新启动一个 Activity 时，这里传入的 window 也是 null</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">        ......</span><br><span class="line">        mUiThread = Thread.currentThread();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 调用系统服务创建一个 WindowManager，并存进 mWindow 中</span></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mWindow.setContainer(mParent.getWindow());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时也把上面创建的 WindowManager 存在 Activity 内</span></span><br><span class="line">        mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attach(..)</code> 中 <code>new</code> 了一个 PhoneWindow 对象，再看看 PhoneWindow 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for main window of an activity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneWindow</span><span class="params">(Context context, Window preservedWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 注意这里的判断条件，是需要 preservedWindow != null 才去初始化 DecorView。</span></span><br><span class="line">        <span class="comment">// 如果是新启动一个 Activity，传进来的 preservedWindow == null，是不会走这个逻辑的。</span></span><br><span class="line">        <span class="keyword">if</span> (preservedWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class="line">            mElevation = preservedWindow.getElevation();</span><br><span class="line">            mLoadElevation = <span class="keyword">false</span>;</span><br><span class="line">            mForceDecorInstall = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// If we&#x27;re preserving window, carry over the app token from the preserved</span></span><br><span class="line">            <span class="comment">// window, as we&#x27;ll be skipping the addView in handleResumeActivity(), and</span></span><br><span class="line">            <span class="comment">// the token will not be updated as for a new window.</span></span><br><span class="line">            getAttributes().token = preservedWindow.getAttributes().token;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此 <code>Activity.attach()</code> 执行完毕，接下来会由 Instrumentation 回调 <code>Activity.onCreate()</code>，表示 Activity 走到了 <code>onCreate()</code> 的生命周期。</p>
<h4 id="3-4-3-onCreate-总结"><a href="#3-4-3-onCreate-总结" class="headerlink" title="3.4.3 onCreate()总结"></a>3.4.3 onCreate()总结</h4><p>Activity 在 onCreate 时的流程可以这么总结：</p>
<ul>
<li>Application 成功启动、初始化、并绑定 AMS 后，调用 <code>TransactionExecutor#execute()</code>，内部先执行 <code>executeCallbacks(ClientTransaction)</code>，调用 <code>LaunchActivityItem#execute(...)</code>，进而调用 <code>handleLaunchActivity(...)</code>，进入启动 Activity 的流程。</li>
<li><code>handleLaunchActivity(...)</code> 内部调用 <code>performLaunchActivity(...)</code>。</li>
<li><code>performLaunchActivity(...)</code> 判断传入的 ActivityClientRecord.mPendingRemoveWindow 是否为空。<ul>
<li>如果是通过 <code>LaunchActivityItem#execute(...)</code> 触发的 <code>performLaunchActivity(...)</code>，则 <code>ActivityClientRecord.mPendingRemoveWindow == null</code>；</li>
<li>否则如果一个 Activity 是已经启动后被 <code>handleRelaunchActivityInner(...)</code> 唤醒的，就会先调用 <code>handleDestroyActivity(...)</code>，这一步将当前 Activity 的 Window 缓存在 mPendingRemoveWindow 后再销毁，然后调用 <code>performLaunchActivity(...)</code>，这样重新启动的同一个 Activity 就能拿到上一次销毁时保存的 Window 了。</li>
</ul>
</li>
<li><code>performLaunchActivity(...)</code> 中从 ActivityClientRecord 取出对应的 Activity，并调用 <code>Activity.attach(...)</code>，传入了从 ActivityClientRecord 中取出的 mPendingRemoveWindow（可能为空）。</li>
<li><code>Activity.attach(...)</code> 中直接 <code>new</code> 了一个新的 PhoneWindow，构造方法中传入了 ActivityClientRecord.mPendingRemoveWindow，PhoneWindow 判断 mPendingRemoveWindow 是否为空，为空说明是新启动的 Activity，否则说明是 relaunch 的 Activity。</li>
<li>如果传入的 mPendingRemoveWindow 不为空，则从 mPendingRemoveWindow 中取出 DecorView，并作为当前 Activity 自己的 DecorView，否则不处理。</li>
<li>创建完新的 PhoneWindow 后，再通过系统服务创建一个 WindowManager。</li>
<li>将这个新建的 WindowManager 绑定到 Activity 新建的 PhoneWindow 中，以及在 Activity 本身中保存。</li>
<li>此时 Activity 和对应的 ActivityClientRecord 共用同一个 WindowManager，但注意，Activity 在 <code>attach(...)</code> 中 <code>new</code> 出来的 Window，暂时还没有存入到对应的 ActivityClientRecord 中。</li>
<li>如果 </li>
</ul>
<p>也就是说，走完 <code>onCreate()</code> 的流程后，一个 Activity 就创建好了自己的 Window 并绑定了 WindowManager。并且如果这个 Activity 是 relaunch 的，还会直接复用上一次销毁时缓存的 Window 和 DecorView；但如果是新启动的 Activity，则到当前为止，Activity 已经创建好了 Window，但还不具有 DecorView。</p>
<h3 id="3-5-Activity-onStart"><a href="#3-5-Activity-onStart" class="headerlink" title="3.5 Activity-onStart"></a>3.5 Activity-onStart</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序以及 <code>handleLaunchActivity(...)</code> 中的逻辑，只有当 <code>performLaunchActivity(...)</code> 成功生成了一个 Activity 实例对象后，才会执行 <code>executeLifecycleState(ClientTransaction)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Transition to the final state if requested by the transaction. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">        cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在方法内部，会先通过 <code>cycleToPath(...)</code> 将 Activity 需要回调的生命周期走一遍。</p>
<p>需要注意的是，该方法内通过 <code>lifecycleItem = transaction.getLifecycleStateRequest()</code> 拿到的是 ActivityLifecycleItem 类型，但回顾上文生成 <code>ClientTransaction</code> 对象的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">RecentTasks</span>.<span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">        <span class="comment">// 如果是新启动 Activity，则 andResume == true</span></span><br><span class="line">        <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">            <span class="comment">// 此时 lifecycleItem 是 ResumeActivityItem 类型</span></span><br><span class="line">            lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以实际上 <code>transaction</code> 持有的 lifecycleItem 是 <code>ResumeActivityItem</code> 类型的，因此 <code>lifecycleItem.getTargetState()</code> 返回的就是 <code>ON_RESUME</code>，查看 <code>cycleToPath(...)</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionExecutorHelper mHelper = <span class="keyword">new</span> TransactionExecutorHelper();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transition the client between states with an option not to perform the last hop in the</span></span><br><span class="line"><span class="comment">     * sequence. This is used when resolving lifecycle state request, when the last transition must</span></span><br><span class="line"><span class="comment">     * be performed with some specific parameters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">        performLifecycleSequence(r, path, transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Transition the client through previously initialized state sequence. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">            state = path.get(i);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                <span class="keyword">case</span> ON_START: &#123;</span><br><span class="line">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutorHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculate the path through main lifecycle states for an activity and fill</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> #mLifecycleSequence&#125; with values starting with the state that follows the initial</span></span><br><span class="line"><span class="comment">     * state.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> The returned value is used internally in this class and is not a copy. It&#x27;s contents</span></span><br><span class="line"><span class="comment">     * may change after calling other methods of this class.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (finish &gt;= start) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class="line">        <span class="keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于此前 Activity 刚完成 onCreate，所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(start = r.getLifecycleState) == ON_CREATE;</span><br><span class="line">lifectcleItem.getTargetState() == ResumeActivityItem.getTargetState() == ON_RESUME;</span><br><span class="line"><span class="comment">// 实际调用为：</span></span><br><span class="line">TransactionExecutorHelper.getLifecyclePath(ON_CREATE, ON_RESUME, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>由于 <code>for(...)</code> 循环中的起始序号是从 <code>start + 1</code> 开始，实际上就是先把 <code>ON_CREATE</code>（不包括）到 <code>ON_RESUME</code>（包括）之间的生命周期都添加到了 <code>mLifecycleSequence</code>，但由于 <code>excludeLastState == true</code>，因此 mLifecycleSequence 又移除了最后一项（也即 <code>ON_RESUME</code>），因此最终 <code>path = mHelper.getLifecyclePath(start, finish, excludeLastState)</code> 返回的 mLifecycleSequence 只包含 <code>ON_START</code>。</p>
<p>由于 mTransactionHandler 就是 ActivityThread，所以 <code>TransactionExecutor#performLifecycleSequence(...)</code> 最终会调用 <code>ActivityThread#handleStartActivity(...)</code>。</p>
<h4 id="3-5-1-handleStartActivity-…"><a href="#3-5-1-handleStartActivity-…" class="headerlink" title="3.5.1 handleStartActivity(…)"></a>3.5.1 handleStartActivity(…)</h4><p><code>ActivityThread#handleStartActivity(...)</code> 主要是调用 <code>performStart(String)</code>，并判断是否需要回调 <code>onRestoreInstanceState()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = r.activity;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Start</span></span><br><span class="line">        activity.performStart(<span class="string">&quot;handleStartActivity&quot;</span>);</span><br><span class="line">        r.setState(ON_START);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Restore instance state</span></span><br><span class="line">        <span class="keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-performStart-…"><a href="#3-5-2-performStart-…" class="headerlink" title="3.5.2 performStart(…)"></a>3.5.2 performStart(…)</h4><p>需要注意的是，<code>performStart(...)</code> 是 Activity 内的方法，而不是 ActivityThread 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Perform calling of an activity&#x27;s &#123;<span class="doctag">@link</span> Activity#onStart&#125;</span></span><br><span class="line"><span class="comment">     * method.  The default implementation simply calls through to that method.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity The activity being started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performStart()</code> 主要就是通知 Instrumentation 来回调 Activity 的 onStart 生命周期。</p>
<h4 id="3-5-3-onStart-总结"><a href="#3-5-3-onStart-总结" class="headerlink" title="3.5.3 onStart()总结"></a>3.5.3 onStart()总结</h4><p>Activity 在 onStart 的流程可以这么总结：</p>
<ul>
<li>如果 ActivityThreade 在 <code>handleLauncherActivity</code> 期间，通过 <code>performLauncherActivity()</code> 未能成功创建一个 Activity 实例对象，则会请求 AMS 直接中断后续流程。</li>
<li>否则 <code>executeCallbacks(ClientTransaction)</code> 执行完 handleLaunchActivity 后，再执行 <code>executeLifecycleState(ClientTransaction)</code>。</li>
<li>executeLifecycleState 内先执行 <code>cycleToPath(...)</code>，回调 Activity 需要经过的生命周期。</li>
<li>cycleToPath 传入 <code>ON_CREATE</code>, <code>ON_START</code>, <code>ONRESUME</code>，但从第二个开始选择，并排除最后一个，因此最终只有 <code>ON_START</code> 被送入 <code>TransactionExecutor#performLifecycleSequence(...)</code>，并由此回调 <code>ActivityThread#handleActivityStart(...)</code>。</li>
<li>ActivityThread 调用 <code>Activity#performStart(...)</code>，Activity 调用 <code>Instrumentation#callActivityOnStart(this);</code>，并由 Instrumentation 回调 Activity 的 onStart 生命周期。</li>
<li>ActivityThread 判断是否需要回调 onRestoreInstanceState 以及 onPostCreate。</li>
</ul>
<h3 id="3-6-Activity-onResume"><a href="#3-6-Activity-onResume" class="headerlink" title="3.6 Activity-onResume"></a>3.6 Activity-onResume</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，当 <code>cycleToPath(...)</code> 执行完毕后，Activity 需要先经过的生命周期均已回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Transition to the final state if requested by the transaction. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">        cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文也提到，此处的 lifecycleItem 实际就是 <code>ResumeActivityItem</code>，因此查看 <code>ResumeActivityItem#execute(...)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request to move an activity to resumed state.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResumeActivityItem</span> <span class="keyword">extends</span> <span class="title">ActivityLifecycleItem</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityResume&quot;</span>);</span><br><span class="line">        <span class="comment">// 重点就是这个 handleResumeActivity</span></span><br><span class="line">        client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">                <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 TransactionExecutor 传入的 <code>ClientTransactionHandler client</code> 就是 ActivityThread，所以 <code>client.handleResumeActivity(...)</code> 就是 <code>ActivityThread#handleResumeActivity(...)</code>。</p>
<h4 id="3-6-1-handleResumeActivity-…"><a href="#3-6-1-handleResumeActivity-…" class="headerlink" title="3.6.1 handleResumeActivity(…)"></a>3.6.1 handleResumeActivity(…)</h4><p><code>ActivityThread.handleResumeActivity(...)</code> 内部通过调用 <code>performResumeActivity(...)</code> 获取包装了各类资源的 ActivityClientRecord，并用该 ActivityClientRecord 为 Activity 初始化与视图相关的资源，例如绑定 Window，初始化 DecorView 等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通过 token 从所有 ActivityClientRecord 中取出目标</span></span><br><span class="line">        <span class="comment">// 如果是新启动的 Activity，可以理解为这里取出来的 ActivityClientRecord 就是上面 startActivityNow(...) 中 new 出来的 ActivityClientRecord</span></span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">// 因为 onCreate 的时候 Activity 在 attach(...) 中 new 了一个 PhoneWindow，但还没有存入 ActivityClientRecord</span></span><br><span class="line">            <span class="comment">// 这一步就是存入了 ActivityClientRecord，此时 Activity 和对应的 ActivityClientRecord 都持有了同一个 Window 和 WindowManager 对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">// 获取目标 Activity 的 Window 的 DecorView</span></span><br><span class="line">            <span class="comment">// Window#getDecorView() 内部包含两个逻辑，如果持有的 DecorView 已存在（例如 relaunch 的场景）则直接返回，否则（例如 startActivityNow 的场景）就 new 一个再返回</span></span><br><span class="line">            <span class="comment">// 详见下面的源码</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">// 取出之前 Activity.attach() 中绑定的 WindowManager</span></span><br><span class="line">            <span class="comment">// WindowManager 接口的实例对象是 WindowManagerImpl 对象</span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">// 创建的 DecorView 的窗口属性</span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">// 将创建的的 DecorView 作为目标 Activity 的 DecorView，此时还未创建 ViewRootImpl</span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 判断 Activity 的 Window 是不是从上一次销毁时缓存下来的，如果是则通知 DecorView 的所有子 View 即将重建</span></span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 获取 DecorView 的 ViewRootImpl，如果没有则返回 null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">                <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">                <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">                <span class="comment">// callbacks may have changed.</span></span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="comment">// 当 Activity 是 relaunch 的时候，Window 和其持有的 DecorView 是从上一次缓存下来的，则 DecorView#getViewRootImpl 才不为空</span></span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通知所有的子 View：「准备重新创建视图」</span></span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 注意这个动作</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除掉 Activity 缓存的 Window 等，并重置了 r.mPreserveWindow 标志位</span></span><br><span class="line">        <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">        cleanUpPendingRemoveWindows(r, <span class="keyword">false</span> <span class="comment">/* force */</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应上面 View decor = r.window.getDecorView(); 的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewGroup mContentParent;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the top-level window decor view (containing the standard</span></span><br><span class="line"><span class="comment">     * window frame/decorations and the client&#x27;s content inside of that), which</span></span><br><span class="line"><span class="comment">     * can be added as a window to the window manager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;em&gt;Note that calling this function for the first time &quot;locks in&quot;</span></span><br><span class="line"><span class="comment">     * various window characteristics as described in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setContentView(View, android.view.ViewGroup.LayoutParams)&#125;.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns the top-level window decor view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> <span class="function">View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span> || mForceDecorInstall) &#123;</span><br><span class="line">            <span class="comment">// 内部逻辑其实就是 new 出来一个 DecorView，并与当前 Window 绑定</span></span><br><span class="line">            installDecor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDecor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class="line">            mContentParent = generateLayout(mDecor);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意两个重点：</p>
<ul>
<li>如果<code>handleResumeActivity(...)</code> 是因为 startActivityNow 触发的，则 ActivityClientRecord 中的 Window 是在 <code>Activity.attach(...)</code> 才 <code>new</code> 出来的，所以并没有缓存下来的 DecorView，因此 <code>View decor = r.window.getDecorView();</code> 这一步会走到 <code>new</code> 一个 DecorView 的逻辑，所以此时这个 DecorView 也还没有 ViewRootImpl，或者说 Activity 还没有 ViewRootImpl。</li>
<li>而如果 <code>handleResumeActivity(...)</code> 是由于 relaunch 触发的，则会在 relaunch 时将 <code>r.mPreserveWindow</code> 置为 true，表示 Window 和 DecorView 会缓存下来复用，则 Activity 其实已经拥有了 Window、DecorView、以及 ViewRootImpl 了。</li>
</ul>
<p>接下来再通过 <code>wm.addView(decor, l)</code> 把新建的 DecorView 按照其窗口属性 <code>WindowManager.LayoutParams</code> 添加到目标 Activity 的 WindowManager 中，这个 WindwoManager 的实现类是 WindowManagerImpl，找到 <code>addView(...)</code> 的实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handleResumeActivity(...) 中，调用该方法传入的 View 实际上就是 DecorView</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        <span class="comment">// 这个 mGlobal 是 WindowManagerGlobal 实例对象</span></span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 mGlobal.addView(...) 的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  这里传入的 View 实际上是 DecorView</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 目标 Activity 的 ViewRootImpl 就是在这里初始化的！</span></span><br><span class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// mRoots 是一个 ArrayList&lt;ViewRootImpl&gt; 类型的集合</span></span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载 DecorView</span></span><br><span class="line">                root.setView(view, wparams, panelParentView);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                。。。。。。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于找到了 ViewRootImpl 初始化的地方，其构造方法内绑定了初始化时的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 绑定了初始化时的线程</span></span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 Instrumentation 会回调 <code>Activity.onResume()</code>，表示 Activity 进入到了 <code>onResume()</code> 的生命周期。到了这一步，Activity 初始化了 PhoneWindow 以及 DecorView，并且在 ViewRootImpl 中加载了 DecorView，这也表示 Activity 已经从视觉上可见。</p>
<h4 id="3-6-2-performResumeActivity-…"><a href="#3-6-2-performResumeActivity-…" class="headerlink" title="3.6.2 performResumeActivity(…)"></a>3.6.2 performResumeActivity(…)</h4><p>ActivityThread 在 Activity 的 onResume 阶段大部分逻辑都在 <code>handlerResumeActivity(...)</code> 内，和视图资源相关。<code>performResumeActivity(...)</code> 则主要是为 <code>handlerResumeActivity(...)</code> 提供了依赖的 ActivityClientRecord 资源，以及通知 Instrumentation 回调 <code>onResume()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line">            r.state = <span class="keyword">null</span>;</span><br><span class="line">            r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">            r.setState(ON_RESUME);</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">(<span class="keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">        dispatchActivityPreResumed();</span><br><span class="line">        performRestart(<span class="keyword">true</span> <span class="comment">/* start */</span>, reason);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// mResumed is set by the instrumentation</span></span><br><span class="line">        mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnResume</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.mResumed = <span class="keyword">true</span>;</span><br><span class="line">        activity.onResume();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-3-onResume-总结"><a href="#3-6-3-onResume-总结" class="headerlink" title="3.6.3 onResume()总结"></a>3.6.3 onResume()总结</h4><p>Activity 在 onResume 时的流程可以这么总结：</p>
<ul>
<li>ActivityThread 已经通过 <code>handleLaunchActivity(...)</code> 成功创建 Activity 实例，并且通过 <code>TransactionExecutor#cycleToPath(...)</code> 回调了 Activity 需要经历的生命周期。</li>
<li>TransactionExecutor 调用 <code>ResumeActivityItem#execute(...)</code>，从而调用了 <code>ActivityThread#handleResumeActivity(...)</code>。</li>
<li>ActivityThread 在 handleResumeActivity 中通过 <code>performResumeActivity(...)</code> 获取对应的 ActivityClientRecord。</li>
<li>获取 DecorView，分为两种逻辑：由于 startActivityNow 触发的 handleResumeActivity、以及由于 relaunch 触发的 handleResumeActivity。<ul>
<li>如果是由于 startActivityNow 触发的，则 DecorView 尚未创建，立即创建一个 DecorView，此时 DecorView 或者说 Activity 尚未初始化 ViewRootImpl。</li>
<li>如果是由于 relaunch 触发的，则 Window、DecorView 均是从上一次销毁时缓存中复用的，此时 DecorView 已经初始化过了 ViewRootImpl，也即 Activity 已经拥有 ViewRootImpl 了，只需要通知所有子 View 即将重建。</li>
</ul>
</li>
<li>如果 Activity 还未初始化 ViewRootImpl（对应 startActivityNow 的场景），则调用 <code>WindowManager#addView(...)</code>，其内部初始化了 ViewRootImpl，将初始化 ViewRootImpl 时的所在线程，作为 ViewRootImpl 的初始线程。</li>
<li>ViewRootImpl 持有 DecorView。</li>
</ul>
<p>也就是说，到了 onResume 这一步，Activity 已经创建了 DecorView 和 ViewRootImpl，并且对 ViewRootImpl 的原始线程做了初始化。此时 Activity 已经完整具有了 Window、DecorView、ViewRootImpl。</p>
<hr>
<h2 id="4-Activity布局加载流程"><a href="#4-Activity布局加载流程" class="headerlink" title="4. Activity布局加载流程"></a>4. Activity布局加载流程</h2><h3 id="4-1-setContentView流程分析"><a href="#4-1-setContentView流程分析" class="headerlink" title="4.1 setContentView流程分析"></a>4.1 setContentView流程分析</h3><p>接下来就是 Activity 的另一项重要功能，加载布局文件。通常加载布局文件都是通过 <code>setContentView(...)</code> 实现的，这里其实分为两个版本：</p>
<p>（1）早期的 Activity 直接继承自 Activity 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是通过之前 <code>Activity.attach(...)</code> 时创建的 PhoneWindow 去直接加载布局。</p>
<p>（2）新版本的 Activity 继承自 AppCompatActivity 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getDelegate() 返回一个 AppCompatDelegate 接口类型的实例对象</span></span><br><span class="line">        getDelegate().setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 实际上内部就是 new 了一个 AppCompatDelegateImpl</span></span><br><span class="line">            mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 <code>AppCompatDelegateImpl.setContentView()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCompatDelegateImpl</span> <span class="keyword">extends</span> <span class="title">AppCompatDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class="line">        ensureSubDecor();</span><br><span class="line">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">        contentParent.removeAllViews();</span><br><span class="line">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个 <code>ensureSubDecor()</code> 方法，从命名就能看出，这个方法确保了 <code>subDecor</code> 一定能被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCompatDelegateImpl</span> <span class="keyword">extends</span> <span class="title">AppCompatDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">            <span class="comment">// 真正的创建是这个方法</span></span><br><span class="line">            mSubDecor = createSubDecor();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可以看到在 setContentView(...) 内部加载了标题和 ActionBar</span></span><br><span class="line">            <span class="comment">// 这也是为什么在 Activity 中，对 ActionBar 或 Title 的修改必须放在 setContentView(...) 调用之前</span></span><br><span class="line">            <span class="comment">// If a title was set before we installed the decor, propagate it now</span></span><br><span class="line">            CharSequence title = getTitle();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(title)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mDecorContentParent.setWindowTitle(title);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peekSupportActionBar() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    peekSupportActionBar().setWindowTitle(title);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mTitleView.setText(title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            mSubDecorInstalled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来看看 createSubDecor() 的源码：</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ViewGroup <span class="title">createSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="comment">// 这下面有一堆 if - else 都只是为了确定这个 Activity 对应 Window 的样式</span></span><br><span class="line">        <span class="keyword">if</span> (...) &#123;......&#125;</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先确保了 Window 已经初始化</span></span><br><span class="line">        <span class="comment">// Now let&#x27;s make sure that the Window has installed its decor by retrieving it</span></span><br><span class="line">        ensureWindow();</span><br><span class="line">        <span class="comment">// 从 Activity 存储的 PhoneWindow 中获取 DecorView，但并不是需要拿到 DecorView 实例，</span></span><br><span class="line">        <span class="comment">// 而是为了像上面 handleResumeActivity(...) 中的 r.activity.getWindow() 一样，确保 DecorView 已被创建</span></span><br><span class="line">        mWindow.getDecorView();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这个就是目标 subDecor</span></span><br><span class="line">        ViewGroup subDecor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mWindowNoTitle) &#123;</span><br><span class="line">            <span class="comment">// 如果 Activity 含有 WindowTitle：</span></span><br><span class="line">            <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">                <span class="comment">// 加载悬浮窗样式的 subDecor</span></span><br><span class="line">                subDecor = (ViewGroup) inflater.inflate(...);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHasActionBar) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 加载有 ActionBar 样式的 subDecor</span></span><br><span class="line">                subDecor = (ViewGroup) LayoutInflater.from(themedContext).inflate(...);</span><br><span class="line">                <span class="comment">// 这个 mDecorContentParent 是 ActionBarOverlayLayout 类型的，用于管理 ActionBar</span></span><br><span class="line">                mDecorContentParent = (DecorContentParent) subDecor.findViewById(R.id.decor_content_parent);</span><br><span class="line">                mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Propagate features to DecorContentParent</span></span><br><span class="line"><span class="comment">                 * 给 DecorContentParent 应用特性</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果仍然无法加载出 subDecor，就抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;AppCompat does not support the current theme features: &#123; &quot;</span> + ...... + <span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将 subDecor 加载到 PhoneWindow 中</span></span><br><span class="line">        mWindow.setContentView(subDecor);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> subDecor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回头看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCompatDelegateImpl</span> <span class="keyword">extends</span> <span class="title">AppCompatDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class="line">        ensureSubDecor();</span><br><span class="line">        <span class="comment">// 这个临时变量 contentParent 是 subDecor 的一个子元素</span></span><br><span class="line">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">        contentParent.removeAllViews();</span><br><span class="line">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 contentParent，它是从 subDecor 加载后的布局中，通过 <code>findViewById(...)</code> 的方式获取到的一个 ViewGroup，也就是说，实际上在 Activity 中调用的 <code>setContentView(int resId)</code> 传入的布局文件，是加载在 subDecor 的一个子 View 中。</p>
<p>在 <code>createSubDecor()</code> 中，先确保 Window 和 DecorView 已创建，然后根据 Title 和 ActionBar 的样式不同，通过 <code>inflate</code> 的方式加载对应的模板 subDecor。</p>
<blockquote>
<p>（@注）如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，从类名也能看出这个 View 就是专门负责 ActionBar 的。</p>
</blockquote>
<p>当 subDecor 被成功创建后，通过 <code>mWindow.setContentView(subDecor);</code> 把 subDecor 加载到 Activity 的 Window 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入的参数 View 就是 subDecor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也可以看出，默认情况下是全屏的</span></span><br><span class="line">        setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的参数 View 就是 subDecor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">        <span class="comment">// before this happens.</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 传入的参数 View 就是 subDecor</span></span><br><span class="line">            mContentParent.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class="line">            mContentParent = generateLayout(mDecor);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又看到上文中在初始化 DecorView 时的 <code>PhoneWindow#installDecor()</code> 了，通过 <code>mContentParent.addView(view, params);</code> 这行可以看出实际上是把 subDecor 加载到了 <code>mContentParent</code> 中，而这个 <code>mContentParent</code> 就是 DecorView 加载出来的布局容器实例 ViewGroup，所以本质就是把 subDecor 加载到了 DecorView 中！</p>
<p>注意两个细节：</p>
<ul>
<li><code>PhoneWindow#getDecorView() - installDecor()</code> 中，DecorView 被加载到了 <code>PhoneWindow#mContentParent</code> 这个 ViewGroup 中</li>
<li>然后在 <code>AppCompatDelegateImpl#setContentView(int resId)</code> 中，当 subDecor 被按照模板创建后，使用其中一个叫 <code>contentParent</code> 的子元素 <code>inflate</code> 了传入的布局文件</li>
</ul>
<h3 id="4-2-setContentView流程总结"><a href="#4-2-setContentView流程总结" class="headerlink" title="4.2 setContentView流程总结"></a>4.2 setContentView流程总结</h3><p>至此，可以对 Activty 中调用 <code>setContentView(int resId)</code> 后的流程做一个总结：</p>
<ul>
<li>如果是老版本直接继承自 Activity，则调用 <code>setContentView(int resId)</code> 后会直接把布局 <code>inflate</code> 到 Activity 对应的 Window 中。</li>
<li>如果是新版本继承自 AppCompatActivity，则先确保 subDecor 已创建。</li>
<li>在创建 subDecor 前，先确保 Window 和 DecorView 已创建。</li>
<li>首先判断 PhoneWindow 是否创建，如果未创建则先创建 Window。</li>
<li>然后通过 <code>PhoneWindow#getDecorView() - installDecor()</code> 确保了 DecorView 已被创建、以及根据 DecorView 生成了 <code>PhoneWindow#mContentParent</code> 这个实例 ViewGroup，也即：PhoneWindow 加载了 DecorView 并持有了 DecorView 加载后的 ViewGroup。</li>
<li>创建 subDecor 时，根据 Activity 及其 Window 的属性加载预置的 subDecor 模板，如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，专门用于管理 ActionBar 相关的视图。</li>
<li>根据模板创建了 subDecor 后，通过 <code>Window#setContentView(View)</code> 将 subDecor 传入，并把传入的 subDecor 作为子 View 添加到 <code>PhoneWindow#mContentParent</code> 中，本质上就是把 subDecor 添加到 DecorView 中。</li>
<li>subDecor 创建好后，从 subDecor 中通过 <code>findViewById(int)</code> 获取一个 ID 为 <code>android.R.id.content</code> 的布局 <code>contentParent</code>，接着 <code>contentParent</code> 先 remove 掉所有子 View，再 <code>inflate</code> 传入的布局文件。这一步才真正加载 Activity 布局。</li>
</ul>
<p>也就是说，在 setContentView 的时候，Activity 实际上是在确保 Window 和 DecorView 均已创建的基础上，把 subDecor 根据模板创建出来并 add 进 <code>mContentParent</code> 这个 ViewGroup 中（<code>mContentParent</code> 是从 DecorView 加载出来的），然后从 subDecor 的模板布局中获取一个子元素 <code>contentParent</code>，最后把实际的 Activity 布局 <code>inflate</code> 进 <code>contentParent</code>。</p>
<p>虽然顺序上是先把 subDecor 添加到 DecorView 中，再将 Activity 布局 <code>inflate</code> 进 subDecor 的子元素 <code>contentParent</code> 中，但因为 JVM 对象引用的缘故，所以实际上的关系链依然是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Window 持有 DecorView</span><br><span class="line">    -&gt; DecorView 持有 subDecor</span><br><span class="line">        -&gt; subDecor 加载 Activity 的布局。</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else{
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
    })();
</script>






<script>
    <!--动态浏览器标签-->
    var OriginTitle = document.title;
    var titleTime;
    var titleTime2;
    var titleTime3;
    var blankTitle = "\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000"
    blankTitle = blankTitle + blankTitle + blankTitle;
    document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
            $('[rel="icon"]').attr('href', "/images/favicon-32x32-next.png");
            // 失去焦点时不切换标题
            // document.title = "Waiting...";
            document.title = OriginTitle;
            clearTimeout(titleTime);
            clearTimeout(titleTime2);
            clearTimeout(titleTime3);
        }
        else {
            document.title = "Welcome";
            titleTime = setTimeout(function () {
                document.title = "Back";
                titleTime2 = setTimeout(function () {
                    document.title = "Welcome Back !";
                    titleTime3 = setTimeout(function () {
                        document.title = OriginTitle;
                    }, 500);
                }, 300);
            }, 300);
        }
    });
</script>






    
    
    <style type="text/css">
        .postEndContainer {
            border-radius: 10px;
            margin-top: 50px;
            margin-bottom: 10px;
        }
        .toAbout {
            font-size: 18px;
            text-align: center;
            color: #EB6D39;
            cursor: pointer;
            border-bottom: none;
        }
        .toAbout:hover {
            background: #EB6D39;
            color: #FFFFFF;
            cursor: pointer;
            border-bottom: none;
        }

        .postEndText {
            animation: slideHorizontal 4.0s ease infinite;
        }
        
        @keyframes slideHorizontal {
            0% {
                transform: rotateX(0deg);
            }
            25% {
                transform: rotateX(360deg);
            }
            50% {
                transform: rotateX(720deg);
            }
            100% {
                transform: rotateX(720deg);
            }
        }
    </style>
    
        
        <div class="pagination postEndContainer toAbout" onClick="window.open('/about/','_self')">
            <div class="postEndText">全 文 结 束&ensp;&ensp;<i class="fab fa-leanpub"></i>&ensp;&ensp;点 击 留 言</div>
        </div>
    

    
    <img src="/images/reward.png" style="width: 300px; max-width: 100%;">


          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者: </strong>Luis
  </li>
  <li class="post-copyright-link">
      <strong>本文链接:</strong>
      <a href="https://blog.luis.ltd/post/android/android-activity/" title="Android-Activity深入理解">https://blog.luis.ltd/post/android/android-activity/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明: </strong>所有文章均由 Luis 原创，采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议，引用前请务必联系授权。
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
              <a href="/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" rel="tag"><i class="fa fa-tag"></i> 四大组件</a>
              <a href="/tags/Activty/" rel="tag"><i class="fa fa-tag"></i> Activty</a>
              <a href="/tags/taskAffinity/" rel="tag"><i class="fa fa-tag"></i> taskAffinity</a>
              <a href="/tags/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 启动模式</a>
              <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag"><i class="fa fa-tag"></i> 生命周期</a>
              <a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 启动流程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/android/android-ui_thread/" rel="prev" title="Android子线程到底能否更新UI——可能是最全面的解析">
                  <i class="fa fa-chevron-left"></i> Android子线程到底能否更新UI——可能是最全面的解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/java/java-finally/" rel="next" title="Java-finally关键字">
                  Java-finally关键字 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuShulun</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Site Symbols:</span>
    <span title="Site Symbols">316k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Site Read Time &asymp;</span>
    <span title="Site Read Time">5:51</span>
  </span>
</div>


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




<style type="text/css">
    .toBottom {
        color: #EEEEEE;
        border-bottom: none;
    }
    .toBottom:hover {
        color: #EB6D39;
        border-bottom: none;
    }
</style>
<div class="scrollToBottom back-to-top back-to-top-on" role="button" style="bottom: 30px;" onClick="window.open('#postBottom','_self')">
    <span class="fa fa-arrow-down"> Down</span>
</div>

<script>
    $(function() {
        $('.scrollToBottom').click(function(){
            
            $('html,body').animate({scrollTop:$('.bottom').offset().top}, 800);
        });
    })
</script>

<a id='postBottom'></a>
</body>
</html>
